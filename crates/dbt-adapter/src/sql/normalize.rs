use regex::Regex;
use std::sync::LazyLock;

/// Replaces dbt temporary table UUIDs generated by
/// `adapter.generate_unique_temporary_table_suffix`.
///
/// Example: `"dbt_tmp_800c2fb4_a0ba_4708_a0b1_813316032bfb"` -> `"dbt_tmp_"`
pub(crate) fn normalize_dbt_tmp_name(sql: &str) -> String {
    static DBT_TMP_UUID_PATTERN: LazyLock<Regex> = LazyLock::new(|| {
        Regex::new(r"dbt_tmp_[0-9a-f]{8}_[0-9a-f]{4}_[0-9a-f]{4}_[0-9a-f]{4}_[0-9a-f]{12}").unwrap()
    });

    DBT_TMP_UUID_PATTERN
        .replace_all(sql, "dbt_tmp_")
        .to_string()
}

pub(crate) fn strip_sql_comments(sql: &str) -> String {
    let mut result = String::with_capacity(sql.len());
    let mut chars = sql.chars().peekable();
    let mut in_single = false;
    let mut in_double = false;
    let mut in_line_comment = false;
    let mut in_block_comment = false;
    let mut last_output_whitespace = true;
    let mut pending_space = false;

    while let Some(ch) = chars.next() {
        if in_line_comment {
            if ch == '\n' {
                in_line_comment = false;
                result.push('\n');
                last_output_whitespace = true;
                pending_space = false;
            }
            continue;
        }
        if in_block_comment {
            if ch == '*' && chars.peek().is_some_and(|next| *next == '/') {
                let _ = chars.next();
                in_block_comment = false;
            }
            continue;
        }

        if pending_space {
            if ch == '\n' || ch.is_whitespace() {
                pending_space = false;
            } else if !result.is_empty() {
                result.push(' ');
                last_output_whitespace = true;
                pending_space = false;
            }
        }

        if in_single {
            result.push(ch);
            if ch == '\'' {
                if chars.peek().is_some_and(|next| *next == '\'') {
                    result.push('\'');
                    let _ = chars.next();
                } else {
                    in_single = false;
                }
            }
            last_output_whitespace = false;
            continue;
        }

        if in_double {
            result.push(ch);
            if ch == '"' {
                if chars.peek().is_some_and(|next| *next == '"') {
                    result.push('"');
                    let _ = chars.next();
                } else {
                    in_double = false;
                }
            }
            last_output_whitespace = false;
            continue;
        }

        match ch {
            '-' if chars.peek().is_some_and(|next| *next == '-') => {
                let _ = chars.next();
                in_line_comment = true;
                if !last_output_whitespace && !result.is_empty() {
                    pending_space = true;
                }
            }
            '/' if chars.peek().is_some_and(|next| *next == '*') => {
                let _ = chars.next();
                in_block_comment = true;
                if !last_output_whitespace && !result.is_empty() {
                    pending_space = true;
                }
            }
            '\'' => {
                in_single = true;
                result.push('\'');
                last_output_whitespace = false;
            }
            '"' => {
                in_double = true;
                result.push('"');
                last_output_whitespace = false;
            }
            '\n' => {
                result.push('\n');
                last_output_whitespace = true;
                pending_space = false;
            }
            _ if ch.is_whitespace() => {
                if !last_output_whitespace {
                    result.push(' ');
                    last_output_whitespace = true;
                }
            }
            _ => {
                result.push(ch);
                last_output_whitespace = false;
            }
        }
    }

    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_normalize_dbt_tmp_name_basic() {
        let input = "SELECT * FROM dbt_tmp_800c2fb4_a0ba_4708_a0b1_813316032bfb";
        assert_eq!(normalize_dbt_tmp_name(input), "SELECT * FROM dbt_tmp_");
    }

    #[test]
    fn test_normalize_dbt_tmp_name_multiple_uuids() {
        let input = "INSERT INTO dbt_tmp_aaaaaaaa_bbbb_cccc_dddd_eeeeeeeeeeee \
                      SELECT * FROM dbt_tmp_11111111_2222_3333_4444_555555555555";
        assert_eq!(
            normalize_dbt_tmp_name(input),
            "INSERT INTO dbt_tmp_ SELECT * FROM dbt_tmp_"
        );
    }

    #[test]
    fn test_normalize_dbt_tmp_name_no_uuid() {
        let input = "SELECT 1";
        assert_eq!(normalize_dbt_tmp_name(input), "SELECT 1");
    }

    #[test]
    fn test_normalize_dbt_tmp_name_partial_uuid_unchanged() {
        let input = "SELECT * FROM dbt_tmp_800c2fb4";
        assert_eq!(normalize_dbt_tmp_name(input), input);
    }

    #[test]
    fn test_strip_sql_comments_line_comment() {
        assert_eq!(
            strip_sql_comments("SELECT 1 -- comment\nFROM t"),
            "SELECT 1 \nFROM t"
        );
    }

    #[test]
    fn test_strip_sql_comments_block_comment() {
        assert_eq!(strip_sql_comments("SELECT /* inline */ 1"), "SELECT 1");
    }

    #[test]
    fn test_strip_sql_comments_preserves_string_literals() {
        assert_eq!(
            strip_sql_comments("SELECT '-- not a comment'"),
            "SELECT '-- not a comment'"
        );
    }
}

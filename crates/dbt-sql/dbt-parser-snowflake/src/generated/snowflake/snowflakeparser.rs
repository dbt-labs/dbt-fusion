// Generated from Snowflake.g4 by ANTLR 4.8
#![allow(dead_code)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(nonstandard_style)]
#![allow(unused_imports)]
#![allow(unused_mut)]
#![allow(unused_braces)]
use antlr_rust::PredictionContextCache;
use antlr_rust::error_listener::ErrorListener;
use antlr_rust::parser::{Parser, BaseParser, ParserRecog, ParserNodeType};
use antlr_rust::token_stream::TokenStream;
use antlr_rust::TokenSource;
use antlr_rust::parser_atn_simulator::ParserATNSimulator;
use antlr_rust::errors::*;
use antlr_rust::rule_context::{BaseRuleContext, CustomRuleContext, RuleContext};
use antlr_rust::recognizer::{Recognizer,Actions};
use antlr_rust::atn_deserializer::ATNDeserializer;
use antlr_rust::dfa::DFA;
use antlr_rust::atn::{ATN, INVALID_ALT};
use antlr_rust::error_strategy::{ErrorStrategy, DefaultErrorStrategy};
use antlr_rust::parser_rule_context::{BaseParserRuleContext, ParserRuleContext,cast,cast_mut};
use antlr_rust::tree::*;
use antlr_rust::token::{TOKEN_EOF,OwningToken,Token};
use antlr_rust::int_stream::EOF;
use antlr_rust::vocabulary::{Vocabulary,VocabularyImpl};
use antlr_rust::token_factory::{CommonTokenFactory,TokenFactory, TokenAware};
use super::snowflakelistener::*;
use super::snowflakevisitor::*;

use antlr_rust::{TidAble,TidExt};

use std::marker::PhantomData;
use std::rc::Rc;
use std::convert::TryFrom;
use std::cell::RefCell;
use std::ops::{DerefMut, Deref};
use std::borrow::{Borrow,BorrowMut};
use std::any::{Any,TypeId};

		pub const T__0:isize=1; 
		pub const T__1:isize=2; 
		pub const T__2:isize=3; 
		pub const T__3:isize=4; 
		pub const T__4:isize=5; 
		pub const T__5:isize=6; 
		pub const T__6:isize=7; 
		pub const T__7:isize=8; 
		pub const T__8:isize=9; 
		pub const T__9:isize=10; 
		pub const T__10:isize=11; 
		pub const ABORT:isize=12; 
		pub const ABSENT:isize=13; 
		pub const ACCESS:isize=14; 
		pub const ADD:isize=15; 
		pub const ADMIN:isize=16; 
		pub const AFTER:isize=17; 
		pub const ALL:isize=18; 
		pub const ALTER:isize=19; 
		pub const ANALYZE:isize=20; 
		pub const AND:isize=21; 
		pub const ANTI:isize=22; 
		pub const ANY:isize=23; 
		pub const APPEND_ONLY:isize=24; 
		pub const ARRAY:isize=25; 
		pub const ARRAYAGG:isize=26; 
		pub const ARRAY_AGG:isize=27; 
		pub const AS:isize=28; 
		pub const ASC:isize=29; 
		pub const ASOF:isize=30; 
		pub const AT:isize=31; 
		pub const ATTACH:isize=32; 
		pub const AUTHORIZATION:isize=33; 
		pub const AUTO:isize=34; 
		pub const AUTOINCREMENT:isize=35; 
		pub const BACKUP:isize=36; 
		pub const BEFORE:isize=37; 
		pub const BEGIN:isize=38; 
		pub const BERNOULLI:isize=39; 
		pub const BETWEEN:isize=40; 
		pub const BLOCK:isize=41; 
		pub const BOTH:isize=42; 
		pub const BY:isize=43; 
		pub const BZIP2:isize=44; 
		pub const CALL:isize=45; 
		pub const CALLED:isize=46; 
		pub const CALLER:isize=47; 
		pub const CANCEL:isize=48; 
		pub const CASCADE:isize=49; 
		pub const CASE:isize=50; 
		pub const CASE_SENSITIVE:isize=51; 
		pub const CASE_INSENSITIVE:isize=52; 
		pub const CAST:isize=53; 
		pub const CATALOGS:isize=54; 
		pub const CHANGES:isize=55; 
		pub const CHAR:isize=56; 
		pub const CHARACTER:isize=57; 
		pub const CLONE:isize=58; 
		pub const CLOSE:isize=59; 
		pub const CLUSTER:isize=60; 
		pub const COLLATE:isize=61; 
		pub const COLUMN:isize=62; 
		pub const COLUMNS:isize=63; 
		pub const COMMA:isize=64; 
		pub const COMMENT:isize=65; 
		pub const COMMIT:isize=66; 
		pub const COMMITTED:isize=67; 
		pub const COMPOUND:isize=68; 
		pub const COMPRESSION:isize=69; 
		pub const CONDITIONAL:isize=70; 
		pub const CONNECT:isize=71; 
		pub const CONNECTION:isize=72; 
		pub const CONNECT_BY_ROOT:isize=73; 
		pub const CONSTRAINT:isize=74; 
		pub const COPARTITION:isize=75; 
		pub const COPY:isize=76; 
		pub const COUNT:isize=77; 
		pub const CREATE:isize=78; 
		pub const CROSS:isize=79; 
		pub const CUBE:isize=80; 
		pub const CURRENT:isize=81; 
		pub const CURRENT_ROLE:isize=82; 
		pub const DATA:isize=83; 
		pub const DATABASE:isize=84; 
		pub const DATASHARE:isize=85; 
		pub const DAY:isize=86; 
		pub const DEALLOCATE:isize=87; 
		pub const DECLARE:isize=88; 
		pub const DECODE:isize=89; 
		pub const DEFAULT:isize=90; 
		pub const DEFAULTS:isize=91; 
		pub const DEFINE:isize=92; 
		pub const DEFINER:isize=93; 
		pub const DELETE:isize=94; 
		pub const DELIMITED:isize=95; 
		pub const DELIMITER:isize=96; 
		pub const DENY:isize=97; 
		pub const DEFERRABLE:isize=98; 
		pub const DEFERRED:isize=99; 
		pub const DESC:isize=100; 
		pub const DESCRIBE:isize=101; 
		pub const DESCRIPTOR:isize=102; 
		pub const DIRECTORY:isize=103; 
		pub const DISABLE:isize=104; 
		pub const DISTINCT:isize=105; 
		pub const DISTKEY:isize=106; 
		pub const DISTRIBUTED:isize=107; 
		pub const DISTSTYLE:isize=108; 
		pub const DETACH:isize=109; 
		pub const DOWNSTREAM:isize=110; 
		pub const DOUBLE:isize=111; 
		pub const DROP:isize=112; 
		pub const DYNAMIC:isize=113; 
		pub const ELSE:isize=114; 
		pub const EMPTY:isize=115; 
		pub const ENABLE:isize=116; 
		pub const ENCODE:isize=117; 
		pub const ENCODING:isize=118; 
		pub const END:isize=119; 
		pub const ENFORCED:isize=120; 
		pub const ERROR:isize=121; 
		pub const ESCAPE:isize=122; 
		pub const EVEN:isize=123; 
		pub const EVENT:isize=124; 
		pub const EXCEPT:isize=125; 
		pub const EXCLUDE:isize=126; 
		pub const EXCLUDING:isize=127; 
		pub const EXECUTE:isize=128; 
		pub const EXISTS:isize=129; 
		pub const EXPLAIN:isize=130; 
		pub const EXTERNAL:isize=131; 
		pub const EXTRACT:isize=132; 
		pub const FALSE:isize=133; 
		pub const FETCH:isize=134; 
		pub const FIELDS:isize=135; 
		pub const FILE_FORMAT:isize=136; 
		pub const FILES:isize=137; 
		pub const FILTER:isize=138; 
		pub const FINAL:isize=139; 
		pub const FIRST:isize=140; 
		pub const FIRST_VALUE:isize=141; 
		pub const FLOAT:isize=142; 
		pub const FOLLOWING:isize=143; 
		pub const FOR:isize=144; 
		pub const FOREIGN:isize=145; 
		pub const FORMAT:isize=146; 
		pub const FORMAT_NAME:isize=147; 
		pub const FROM:isize=148; 
		pub const FULL:isize=149; 
		pub const FUNCTION:isize=150; 
		pub const FUNCTIONS:isize=151; 
		pub const GENERATED:isize=152; 
		pub const GLOBAL:isize=153; 
		pub const GRACE:isize=154; 
		pub const GRANT:isize=155; 
		pub const GRANTED:isize=156; 
		pub const GRANTS:isize=157; 
		pub const GRAPHVIZ:isize=158; 
		pub const GROUP:isize=159; 
		pub const GROUPING:isize=160; 
		pub const GROUPS:isize=161; 
		pub const GZIP:isize=162; 
		pub const HAVING:isize=163; 
		pub const HEADER:isize=164; 
		pub const HOUR:isize=165; 
		pub const ICEBERG:isize=166; 
		pub const IDENTIFIER_KW:isize=167; 
		pub const IDENTITY:isize=168; 
		pub const IF:isize=169; 
		pub const IGNORE:isize=170; 
		pub const IMMEDIATE:isize=171; 
		pub const IMMUTABLE:isize=172; 
		pub const IN:isize=173; 
		pub const INCLUDE:isize=174; 
		pub const INCLUDING:isize=175; 
		pub const INCREMENT:isize=176; 
		pub const INFORMATION:isize=177; 
		pub const INITIAL:isize=178; 
		pub const INITIALLY:isize=179; 
		pub const INNER:isize=180; 
		pub const INPUT:isize=181; 
		pub const INPUTFORMAT:isize=182; 
		pub const INTERLEAVED:isize=183; 
		pub const INSERT:isize=184; 
		pub const INTERSECT:isize=185; 
		pub const INTERVAL:isize=186; 
		pub const INTO:isize=187; 
		pub const INVOKER:isize=188; 
		pub const IO:isize=189; 
		pub const IS:isize=190; 
		pub const ISOLATION:isize=191; 
		pub const ILIKE:isize=192; 
		pub const JAVA:isize=193; 
		pub const JAVASCRIPT:isize=194; 
		pub const JOIN:isize=195; 
		pub const JSON:isize=196; 
		pub const JSON_ARRAY:isize=197; 
		pub const JSON_EXISTS:isize=198; 
		pub const JSON_OBJECT:isize=199; 
		pub const JSON_QUERY:isize=200; 
		pub const JSON_VALUE:isize=201; 
		pub const KEEP:isize=202; 
		pub const KEY:isize=203; 
		pub const KEYS:isize=204; 
		pub const LAG:isize=205; 
		pub const LAMBDA:isize=206; 
		pub const LANGUAGE:isize=207; 
		pub const LAST:isize=208; 
		pub const LAST_VALUE:isize=209; 
		pub const LATERAL:isize=210; 
		pub const LEADING:isize=211; 
		pub const LEFT:isize=212; 
		pub const LEVEL:isize=213; 
		pub const LIBRARY:isize=214; 
		pub const LIKE:isize=215; 
		pub const LIMIT:isize=216; 
		pub const LINES:isize=217; 
		pub const LISTAGG:isize=218; 
		pub const LOCAL:isize=219; 
		pub const LOCATION:isize=220; 
		pub const LOCK:isize=221; 
		pub const LOGICAL:isize=222; 
		pub const MAP:isize=223; 
		pub const MASKING:isize=224; 
		pub const MATCH:isize=225; 
		pub const MATCHED:isize=226; 
		pub const MATCHES:isize=227; 
		pub const MATCH_CONDITION:isize=228; 
		pub const MATCH_RECOGNIZE:isize=229; 
		pub const MATERIALIZED:isize=230; 
		pub const MAX:isize=231; 
		pub const MEASURES:isize=232; 
		pub const MEMORIZABLE:isize=233; 
		pub const MERGE:isize=234; 
		pub const MINHASH:isize=235; 
		pub const MINUS_KW:isize=236; 
		pub const MINUTE:isize=237; 
		pub const MOD:isize=238; 
		pub const MODEL:isize=239; 
		pub const MONTH:isize=240; 
		pub const NAME:isize=241; 
		pub const NATURAL:isize=242; 
		pub const NCHAR:isize=243; 
		pub const NEXT:isize=244; 
		pub const NFC:isize=245; 
		pub const NFD:isize=246; 
		pub const NFKC:isize=247; 
		pub const NFKD:isize=248; 
		pub const NO:isize=249; 
		pub const NONE:isize=250; 
		pub const NOORDER:isize=251; 
		pub const NORELY:isize=252; 
		pub const NORMALIZE:isize=253; 
		pub const NOT:isize=254; 
		pub const NOVALIDATE:isize=255; 
		pub const NULL:isize=256; 
		pub const NULLS:isize=257; 
		pub const OBJECT:isize=258; 
		pub const OF:isize=259; 
		pub const OFFSET:isize=260; 
		pub const OMIT:isize=261; 
		pub const ON:isize=262; 
		pub const ONE:isize=263; 
		pub const ONLY:isize=264; 
		pub const OPTION:isize=265; 
		pub const OPTIONS:isize=266; 
		pub const OR:isize=267; 
		pub const ORDER:isize=268; 
		pub const ORDINALITY:isize=269; 
		pub const OUTER:isize=270; 
		pub const OUTPUT:isize=271; 
		pub const OUTPUTFORMAT:isize=272; 
		pub const OVER:isize=273; 
		pub const OVERFLOW:isize=274; 
		pub const OWNER:isize=275; 
		pub const PARTITION:isize=276; 
		pub const PARTITIONED:isize=277; 
		pub const PARTITIONS:isize=278; 
		pub const PASSING:isize=279; 
		pub const PAST:isize=280; 
		pub const PATH:isize=281; 
		pub const PATTERN:isize=282; 
		pub const PER:isize=283; 
		pub const PERCENTILE_CONT:isize=284; 
		pub const PERCENTILE_DISC:isize=285; 
		pub const PERIOD:isize=286; 
		pub const PERMUTE:isize=287; 
		pub const PIVOT:isize=288; 
		pub const PLACING:isize=289; 
		pub const POLICY:isize=290; 
		pub const POSITION:isize=291; 
		pub const PRECEDING:isize=292; 
		pub const PRECISION:isize=293; 
		pub const PREPARE:isize=294; 
		pub const PRIOR:isize=295; 
		pub const PROCEDURE:isize=296; 
		pub const PRIMARY:isize=297; 
		pub const PRIVILEGES:isize=298; 
		pub const PROPERTIES:isize=299; 
		pub const PRUNE:isize=300; 
		pub const PYTHON:isize=301; 
		pub const QUALIFY:isize=302; 
		pub const QUOTES:isize=303; 
		pub const RANGE:isize=304; 
		pub const READ:isize=305; 
		pub const RECURSIVE:isize=306; 
		pub const REGEXP:isize=307; 
		pub const REFERENCE:isize=308; 
		pub const REFERENCES:isize=309; 
		pub const REFRESH:isize=310; 
		pub const RELY:isize=311; 
		pub const RENAME:isize=312; 
		pub const REPEATABLE:isize=313; 
		pub const REPLACE:isize=314; 
		pub const RESET:isize=315; 
		pub const RESPECT:isize=316; 
		pub const RESTRICT:isize=317; 
		pub const RESTRICTED:isize=318; 
		pub const RETURN:isize=319; 
		pub const RETURNING:isize=320; 
		pub const RETURNS:isize=321; 
		pub const REVOKE:isize=322; 
		pub const RIGHT:isize=323; 
		pub const RLIKE:isize=324; 
		pub const RLS:isize=325; 
		pub const ROLE:isize=326; 
		pub const ROLES:isize=327; 
		pub const ROLLBACK:isize=328; 
		pub const ROLLUP:isize=329; 
		pub const ROW:isize=330; 
		pub const ROWS:isize=331; 
		pub const RUNNING:isize=332; 
		pub const SAMPLE:isize=333; 
		pub const SCALA:isize=334; 
		pub const SCALAR:isize=335; 
		pub const SECOND:isize=336; 
		pub const SCHEMA:isize=337; 
		pub const SCHEMAS:isize=338; 
		pub const SECURE:isize=339; 
		pub const SECURITY:isize=340; 
		pub const SEED:isize=341; 
		pub const SEEK:isize=342; 
		pub const SELECT:isize=343; 
		pub const SEMI:isize=344; 
		pub const SEQUENCE:isize=345; 
		pub const SERDE:isize=346; 
		pub const SERDEPROPERTIES:isize=347; 
		pub const SERIALIZABLE:isize=348; 
		pub const SESSION:isize=349; 
		pub const SET:isize=350; 
		pub const SETS:isize=351; 
		pub const SHOW:isize=352; 
		pub const SIMILAR:isize=353; 
		pub const SKIP_KW:isize=354; 
		pub const SNAPSHOT:isize=355; 
		pub const SOME:isize=356; 
		pub const SORTKEY:isize=357; 
		pub const SQL:isize=358; 
		pub const STAGE:isize=359; 
		pub const START:isize=360; 
		pub const STATEMENT:isize=361; 
		pub const STATS:isize=362; 
		pub const STORED:isize=363; 
		pub const STREAM:isize=364; 
		pub const STRICT:isize=365; 
		pub const STRUCT:isize=366; 
		pub const SUBSET:isize=367; 
		pub const SUBSTRING:isize=368; 
		pub const SYSTEM:isize=369; 
		pub const SYSTEM_TIME:isize=370; 
		pub const TABLE:isize=371; 
		pub const TABLES:isize=372; 
		pub const TABLESAMPLE:isize=373; 
		pub const TAG:isize=374; 
		pub const TEMP:isize=375; 
		pub const TEMPLATE:isize=376; 
		pub const TEMPORARY:isize=377; 
		pub const TERMINATED:isize=378; 
		pub const TEXT:isize=379; 
		pub const STRING_KW:isize=380; 
		pub const THEN:isize=381; 
		pub const TIES:isize=382; 
		pub const TIME:isize=383; 
		pub const TIMESTAMP:isize=384; 
		pub const TO:isize=385; 
		pub const TOP:isize=386; 
		pub const TRAILING:isize=387; 
		pub const TARGET_LAG:isize=388; 
		pub const TRANSACTION:isize=389; 
		pub const TRANSIENT:isize=390; 
		pub const TRIM:isize=391; 
		pub const TRUE:isize=392; 
		pub const TRUNCATE:isize=393; 
		pub const TRY_CAST:isize=394; 
		pub const TUPLE:isize=395; 
		pub const TYPE:isize=396; 
		pub const UESCAPE:isize=397; 
		pub const UNBOUNDED:isize=398; 
		pub const UNCOMMITTED:isize=399; 
		pub const UNCONDITIONAL:isize=400; 
		pub const UNION:isize=401; 
		pub const UNIQUE:isize=402; 
		pub const UNKNOWN:isize=403; 
		pub const UNLOAD:isize=404; 
		pub const UNMATCHED:isize=405; 
		pub const UNNEST:isize=406; 
		pub const UNPIVOT:isize=407; 
		pub const UNSET:isize=408; 
		pub const UNSIGNED:isize=409; 
		pub const UPDATE:isize=410; 
		pub const USE:isize=411; 
		pub const USER:isize=412; 
		pub const USING:isize=413; 
		pub const UTF16:isize=414; 
		pub const UTF32:isize=415; 
		pub const UTF8:isize=416; 
		pub const VACUUM:isize=417; 
		pub const VALIDATE:isize=418; 
		pub const VALUE:isize=419; 
		pub const VALUES:isize=420; 
		pub const VARYING:isize=421; 
		pub const VECTOR:isize=422; 
		pub const VERBOSE:isize=423; 
		pub const VERSION:isize=424; 
		pub const VIEW:isize=425; 
		pub const VOLATILE:isize=426; 
		pub const WAREHOUSE:isize=427; 
		pub const WHEN:isize=428; 
		pub const WHERE:isize=429; 
		pub const WINDOW:isize=430; 
		pub const WITH:isize=431; 
		pub const WITHIN:isize=432; 
		pub const WITHOUT:isize=433; 
		pub const WORK:isize=434; 
		pub const WRAPPER:isize=435; 
		pub const WRITE:isize=436; 
		pub const XZ:isize=437; 
		pub const YEAR:isize=438; 
		pub const YES:isize=439; 
		pub const ZONE:isize=440; 
		pub const ZSTD:isize=441; 
		pub const LPAREN:isize=442; 
		pub const RPAREN:isize=443; 
		pub const LBRACKET:isize=444; 
		pub const RBRACKET:isize=445; 
		pub const DOT:isize=446; 
		pub const EQ:isize=447; 
		pub const NEQ:isize=448; 
		pub const LT:isize=449; 
		pub const LTE:isize=450; 
		pub const GT:isize=451; 
		pub const GTE:isize=452; 
		pub const PLUS:isize=453; 
		pub const MINUS:isize=454; 
		pub const ASTERISK:isize=455; 
		pub const SLASH:isize=456; 
		pub const PERCENT:isize=457; 
		pub const CONCAT:isize=458; 
		pub const QUESTION_MARK:isize=459; 
		pub const SEMI_COLON:isize=460; 
		pub const COLON:isize=461; 
		pub const DOLLAR:isize=462; 
		pub const BITWISE_SHIFT_LEFT:isize=463; 
		pub const POSIX:isize=464; 
		pub const ESCAPE_SEQUENCE:isize=465; 
		pub const STRING:isize=466; 
		pub const UNICODE_STRING:isize=467; 
		pub const DOLLAR_QUOTED_STRING:isize=468; 
		pub const BINARY_LITERAL:isize=469; 
		pub const INTEGER_VALUE:isize=470; 
		pub const DECIMAL_VALUE:isize=471; 
		pub const DOUBLE_VALUE:isize=472; 
		pub const IDENTIFIER:isize=473; 
		pub const QUOTED_IDENTIFIER:isize=474; 
		pub const BACKQUOTED_IDENTIFIER:isize=475; 
		pub const STAGE_NAME:isize=476; 
		pub const VARIABLE:isize=477; 
		pub const SIMPLE_COMMENT:isize=478; 
		pub const SLASH_SLASH_COMMENT:isize=479; 
		pub const BRACKETED_COMMENT:isize=480; 
		pub const WS:isize=481; 
		pub const UNPAIRED_TOKEN:isize=482; 
		pub const UNRECOGNIZED:isize=483;
	pub const RULE_multipleStatement:usize = 0; 
	pub const RULE_singleStatement:usize = 1; 
	pub const RULE_standaloneExpression:usize = 2; 
	pub const RULE_standaloneQualifiedName:usize = 3; 
	pub const RULE_standaloneType:usize = 4; 
	pub const RULE_statement:usize = 5; 
	pub const RULE_tableElements:usize = 6; 
	pub const RULE_unpivotNullClause:usize = 7; 
	pub const RULE_snowflakeCreateTableClauses:usize = 8; 
	pub const RULE_tableConstraint:usize = 9; 
	pub const RULE_constraintProperties:usize = 10; 
	pub const RULE_snowflakeValueRow:usize = 11; 
	pub const RULE_snowflakeValueItem:usize = 12; 
	pub const RULE_snowflakeCreateExternalTableClauses:usize = 13; 
	pub const RULE_locationSpec:usize = 14; 
	pub const RULE_partitionedByNameSpec:usize = 15; 
	pub const RULE_createFileFormat:usize = 16; 
	pub const RULE_compressionSpec:usize = 17; 
	pub const RULE_headerRowSpec:usize = 18; 
	pub const RULE_delimiterSpec:usize = 19; 
	pub const RULE_query:usize = 20; 
	pub const RULE_with:usize = 21; 
	pub const RULE_tableElement:usize = 22; 
	pub const RULE_columnDefinition:usize = 23; 
	pub const RULE_inlineConstraint:usize = 24; 
	pub const RULE_columnDefinitionForView:usize = 25; 
	pub const RULE_externalColumnDefinition:usize = 26; 
	pub const RULE_fieldDefinition:usize = 27; 
	pub const RULE_columnName:usize = 28; 
	pub const RULE_columnNameComponent:usize = 29; 
	pub const RULE_columnSchemaWithMetadata:usize = 30; 
	pub const RULE_columnOptionList:usize = 31; 
	pub const RULE_columnOption:usize = 32; 
	pub const RULE_columnSchema:usize = 33; 
	pub const RULE_properties:usize = 34; 
	pub const RULE_propertyAssignments:usize = 35; 
	pub const RULE_property:usize = 36; 
	pub const RULE_propertyKey:usize = 37; 
	pub const RULE_propertyValue:usize = 38; 
	pub const RULE_queryNoWith:usize = 39; 
	pub const RULE_queryLimit:usize = 40; 
	pub const RULE_queryLimitTarget:usize = 41; 
	pub const RULE_rowOrRows:usize = 42; 
	pub const RULE_limitRowCount:usize = 43; 
	pub const RULE_rowCount:usize = 44; 
	pub const RULE_queryTerm:usize = 45; 
	pub const RULE_setOperation:usize = 46; 
	pub const RULE_setOperator:usize = 47; 
	pub const RULE_setOperationIntersect:usize = 48; 
	pub const RULE_setIntersectOperator:usize = 49; 
	pub const RULE_setQuantifier:usize = 50; 
	pub const RULE_inlineTable:usize = 51; 
	pub const RULE_queryPrimary:usize = 52; 
	pub const RULE_sortItem:usize = 53; 
	pub const RULE_connectByItem:usize = 54; 
	pub const RULE_querySpecification:usize = 55; 
	pub const RULE_connectBy:usize = 56; 
	pub const RULE_replaceDefinition:usize = 57; 
	pub const RULE_querySelectItems:usize = 58; 
	pub const RULE_aggregationClause:usize = 59; 
	pub const RULE_groupBy:usize = 60; 
	pub const RULE_groupingElement:usize = 61; 
	pub const RULE_groupingSet:usize = 62; 
	pub const RULE_windowDefinition:usize = 63; 
	pub const RULE_windowSpecification:usize = 64; 
	pub const RULE_windowSpecificationPartitionBy:usize = 65; 
	pub const RULE_orderBy:usize = 66; 
	pub const RULE_namedQuery:usize = 67; 
	pub const RULE_selectItemAlias:usize = 68; 
	pub const RULE_selectItem:usize = 69; 
	pub const RULE_multiSelect:usize = 70; 
	pub const RULE_selectStar:usize = 71; 
	pub const RULE_relation:usize = 72; 
	pub const RULE_joinedRelation:usize = 73; 
	pub const RULE_joinType:usize = 74; 
	pub const RULE_joinCriteria:usize = 75; 
	pub const RULE_noJoinRelation:usize = 76; 
	pub const RULE_sampledRelationTarget:usize = 77; 
	pub const RULE_sampledRelation:usize = 78; 
	pub const RULE_sampleOperator:usize = 79; 
	pub const RULE_sampleMethod:usize = 80; 
	pub const RULE_samplePercentage:usize = 81; 
	pub const RULE_sampleCount:usize = 82; 
	pub const RULE_sampleSeed:usize = 83; 
	pub const RULE_trimsSpecification:usize = 84; 
	pub const RULE_listAggOverflowBehavior:usize = 85; 
	pub const RULE_listaggCountIndication:usize = 86; 
	pub const RULE_patternRecognitionTarget:usize = 87; 
	pub const RULE_patternRecognition:usize = 88; 
	pub const RULE_measureDefinition:usize = 89; 
	pub const RULE_rowsPerMatch:usize = 90; 
	pub const RULE_emptyMatchHandling:usize = 91; 
	pub const RULE_skipTo:usize = 92; 
	pub const RULE_subsetDefinition:usize = 93; 
	pub const RULE_variableDefinition:usize = 94; 
	pub const RULE_atBefore:usize = 95; 
	pub const RULE_changeRelationTarget:usize = 96; 
	pub const RULE_changesRelation:usize = 97; 
	pub const RULE_pivotedRelationTarget:usize = 98; 
	pub const RULE_pivotedRelation:usize = 99; 
	pub const RULE_aliasedRelation2:usize = 100; 
	pub const RULE_pivotAggregates:usize = 101; 
	pub const RULE_pivotFrom:usize = 102; 
	pub const RULE_pivotInto:usize = 103; 
	pub const RULE_pivotAsAlias:usize = 104; 
	pub const RULE_singleColumnUnpivot:usize = 105; 
	pub const RULE_columnsToUnpivot:usize = 106; 
	pub const RULE_columnUnpivot:usize = 107; 
	pub const RULE_pivotIntos:usize = 108; 
	pub const RULE_pivotOperator:usize = 109; 
	pub const RULE_aliasedRelationTarget:usize = 110; 
	pub const RULE_aliasedRelation:usize = 111; 
	pub const RULE_columnAliases:usize = 112; 
	pub const RULE_relationPrimary:usize = 113; 
	pub const RULE_tableFunctionCall:usize = 114; 
	pub const RULE_tableFunctionArgumentCopartition:usize = 115; 
	pub const RULE_tableFunctionArgumentName:usize = 116; 
	pub const RULE_tableFunctionArgument:usize = 117; 
	pub const RULE_tableArgument:usize = 118; 
	pub const RULE_tableArgumentRelation:usize = 119; 
	pub const RULE_descriptorArgument:usize = 120; 
	pub const RULE_descriptorField:usize = 121; 
	pub const RULE_copartitionTables:usize = 122; 
	pub const RULE_expression:usize = 123; 
	pub const RULE_booleanExpression:usize = 124; 
	pub const RULE_comparisonPredicate:usize = 125; 
	pub const RULE_nonComparisonExpression:usize = 126; 
	pub const RULE_predicate:usize = 127; 
	pub const RULE_valueExpression:usize = 128; 
	pub const RULE_primaryExpression:usize = 129; 
	pub const RULE_functionCallHead:usize = 130; 
	pub const RULE_functionCallTail:usize = 131; 
	pub const RULE_callArgument:usize = 132; 
	pub const RULE_functionExtraArguments:usize = 133; 
	pub const RULE_constant:usize = 134; 
	pub const RULE_dereferenceKey:usize = 135; 
	pub const RULE_dereferenceKeyElement:usize = 136; 
	pub const RULE_dereferenceKeyText:usize = 137; 
	pub const RULE_functionName:usize = 138; 
	pub const RULE_namedParameter:usize = 139; 
	pub const RULE_stageFileSpec:usize = 140; 
	pub const RULE_field:usize = 141; 
	pub const RULE_processingMode:usize = 142; 
	pub const RULE_nullTreatment:usize = 143; 
	pub const RULE_string:usize = 144; 
	pub const RULE_timeZoneSpecifier:usize = 145; 
	pub const RULE_comparisonOperator:usize = 146; 
	pub const RULE_comparisonQuantifier:usize = 147; 
	pub const RULE_booleanValue:usize = 148; 
	pub const RULE_interval:usize = 149; 
	pub const RULE_intervalField:usize = 150; 
	pub const RULE_normalForm:usize = 151; 
	pub const RULE_typeIdentifier:usize = 152; 
	pub const RULE_type_:usize = 153; 
	pub const RULE_nonnullableType:usize = 154; 
	pub const RULE_rowField:usize = 155; 
	pub const RULE_typeParameter:usize = 156; 
	pub const RULE_whenClause:usize = 157; 
	pub const RULE_filter:usize = 158; 
	pub const RULE_over:usize = 159; 
	pub const RULE_windowFrame:usize = 160; 
	pub const RULE_frameExtent:usize = 161; 
	pub const RULE_frameBound:usize = 162; 
	pub const RULE_rowPattern:usize = 163; 
	pub const RULE_patternPrimary:usize = 164; 
	pub const RULE_patternQuantifier:usize = 165; 
	pub const RULE_transactionMode:usize = 166; 
	pub const RULE_levelOfIsolation:usize = 167; 
	pub const RULE_privilege:usize = 168; 
	pub const RULE_qualifiedName:usize = 169; 
	pub const RULE_pathExpression:usize = 170; 
	pub const RULE_nonquotedIdentifier:usize = 171; 
	pub const RULE_dashedIdentifier:usize = 172; 
	pub const RULE_maybeDashedIdentifier:usize = 173; 
	pub const RULE_queryPeriod:usize = 174; 
	pub const RULE_rangeType:usize = 175; 
	pub const RULE_principal:usize = 176; 
	pub const RULE_identifier:usize = 177; 
	pub const RULE_strictIdentifier:usize = 178; 
	pub const RULE_quotedIdentifier:usize = 179; 
	pub const RULE_pathComponent:usize = 180; 
	pub const RULE_standaloneIdentifier:usize = 181; 
	pub const RULE_identifierList:usize = 182; 
	pub const RULE_identifierSeq:usize = 183; 
	pub const RULE_number:usize = 184; 
	pub const RULE_snowflakeShowFunctionType:usize = 185; 
	pub const RULE_snowflakeShowFunctionArguments:usize = 186; 
	pub const RULE_snowflakeShowFunctionArgumentsList:usize = 187; 
	pub const RULE_strictNonReserved:usize = 188; 
	pub const RULE_nonReserved:usize = 189;
	pub const ruleNames: [&'static str; 190] =  [
		"multipleStatement", "singleStatement", "standaloneExpression", "standaloneQualifiedName", 
		"standaloneType", "statement", "tableElements", "unpivotNullClause", "snowflakeCreateTableClauses", 
		"tableConstraint", "constraintProperties", "snowflakeValueRow", "snowflakeValueItem", 
		"snowflakeCreateExternalTableClauses", "locationSpec", "partitionedByNameSpec", 
		"createFileFormat", "compressionSpec", "headerRowSpec", "delimiterSpec", 
		"query", "with", "tableElement", "columnDefinition", "inlineConstraint", 
		"columnDefinitionForView", "externalColumnDefinition", "fieldDefinition", 
		"columnName", "columnNameComponent", "columnSchemaWithMetadata", "columnOptionList", 
		"columnOption", "columnSchema", "properties", "propertyAssignments", "property", 
		"propertyKey", "propertyValue", "queryNoWith", "queryLimit", "queryLimitTarget", 
		"rowOrRows", "limitRowCount", "rowCount", "queryTerm", "setOperation", 
		"setOperator", "setOperationIntersect", "setIntersectOperator", "setQuantifier", 
		"inlineTable", "queryPrimary", "sortItem", "connectByItem", "querySpecification", 
		"connectBy", "replaceDefinition", "querySelectItems", "aggregationClause", 
		"groupBy", "groupingElement", "groupingSet", "windowDefinition", "windowSpecification", 
		"windowSpecificationPartitionBy", "orderBy", "namedQuery", "selectItemAlias", 
		"selectItem", "multiSelect", "selectStar", "relation", "joinedRelation", 
		"joinType", "joinCriteria", "noJoinRelation", "sampledRelationTarget", 
		"sampledRelation", "sampleOperator", "sampleMethod", "samplePercentage", 
		"sampleCount", "sampleSeed", "trimsSpecification", "listAggOverflowBehavior", 
		"listaggCountIndication", "patternRecognitionTarget", "patternRecognition", 
		"measureDefinition", "rowsPerMatch", "emptyMatchHandling", "skipTo", "subsetDefinition", 
		"variableDefinition", "atBefore", "changeRelationTarget", "changesRelation", 
		"pivotedRelationTarget", "pivotedRelation", "aliasedRelation2", "pivotAggregates", 
		"pivotFrom", "pivotInto", "pivotAsAlias", "singleColumnUnpivot", "columnsToUnpivot", 
		"columnUnpivot", "pivotIntos", "pivotOperator", "aliasedRelationTarget", 
		"aliasedRelation", "columnAliases", "relationPrimary", "tableFunctionCall", 
		"tableFunctionArgumentCopartition", "tableFunctionArgumentName", "tableFunctionArgument", 
		"tableArgument", "tableArgumentRelation", "descriptorArgument", "descriptorField", 
		"copartitionTables", "expression", "booleanExpression", "comparisonPredicate", 
		"nonComparisonExpression", "predicate", "valueExpression", "primaryExpression", 
		"functionCallHead", "functionCallTail", "callArgument", "functionExtraArguments", 
		"constant", "dereferenceKey", "dereferenceKeyElement", "dereferenceKeyText", 
		"functionName", "namedParameter", "stageFileSpec", "field", "processingMode", 
		"nullTreatment", "string", "timeZoneSpecifier", "comparisonOperator", 
		"comparisonQuantifier", "booleanValue", "interval", "intervalField", "normalForm", 
		"typeIdentifier", "type_", "nonnullableType", "rowField", "typeParameter", 
		"whenClause", "filter", "over", "windowFrame", "frameExtent", "frameBound", 
		"rowPattern", "patternPrimary", "patternQuantifier", "transactionMode", 
		"levelOfIsolation", "privilege", "qualifiedName", "pathExpression", "nonquotedIdentifier", 
		"dashedIdentifier", "maybeDashedIdentifier", "queryPeriod", "rangeType", 
		"principal", "identifier", "strictIdentifier", "quotedIdentifier", "pathComponent", 
		"standaloneIdentifier", "identifierList", "identifierSeq", "number", "snowflakeShowFunctionType", 
		"snowflakeShowFunctionArguments", "snowflakeShowFunctionArgumentsList", 
		"strictNonReserved", "nonReserved"
	];


	pub const _LITERAL_NAMES: [Option<&'static str>;465] = [
		None, Some("'=>'"), Some("'(+)'"), Some("'{'"), Some("'}'"), Some("'->'"), 
		Some("'::'"), Some("'|'"), Some("'^'"), Some("'{-'"), Some("'-}'"), Some("'[,'"), 
		Some("'ABORT'"), Some("'ABSENT'"), Some("'ACCESS'"), Some("'ADD'"), Some("'ADMIN'"), 
		Some("'AFTER'"), Some("'ALL'"), Some("'ALTER'"), Some("'ANALYZE'"), Some("'AND'"), 
		Some("'ANTI'"), Some("'ANY'"), Some("'APPEND_ONLY'"), Some("'ARRAY'"), 
		Some("'ARRAYAGG'"), Some("'ARRAY_AGG'"), Some("'AS'"), Some("'ASC'"), 
		Some("'ASOF'"), Some("'AT'"), Some("'ATTACH'"), Some("'AUTHORIZATION'"), 
		Some("'AUTO'"), Some("'AUTOINCREMENT'"), Some("'BACKUP'"), Some("'BEFORE'"), 
		Some("'BEGIN'"), Some("'BERNOULLI'"), Some("'BETWEEN'"), Some("'BLOCK'"), 
		Some("'BOTH'"), Some("'BY'"), Some("'BZIP2'"), Some("'CALL'"), Some("'CALLED'"), 
		Some("'CALLER'"), Some("'CANCEL'"), Some("'CASCADE'"), Some("'CASE'"), 
		Some("'CASE_SENSITIVE'"), Some("'CASE_INSENSITIVE'"), Some("'CAST'"), 
		Some("'CATALOGS'"), Some("'CHANGES'"), Some("'CHAR'"), Some("'CHARACTER'"), 
		Some("'CLONE'"), Some("'CLOSE'"), Some("'CLUSTER'"), Some("'COLLATE'"), 
		Some("'COLUMN'"), Some("'COLUMNS'"), Some("','"), Some("'COMMENT'"), Some("'COMMIT'"), 
		Some("'COMMITTED'"), Some("'COMPOUND'"), Some("'COMPRESSION'"), Some("'CONDITIONAL'"), 
		Some("'CONNECT'"), Some("'CONNECTION'"), Some("'CONNECT_BY_ROOT'"), Some("'CONSTRAINT'"), 
		Some("'COPARTITION'"), Some("'COPY'"), Some("'COUNT'"), Some("'CREATE'"), 
		Some("'CROSS'"), Some("'CUBE'"), Some("'CURRENT'"), Some("'CURRENT_ROLE'"), 
		Some("'DATA'"), Some("'DATABASE'"), Some("'DATASHARE'"), Some("'DAY'"), 
		Some("'DEALLOCATE'"), Some("'DECLARE'"), Some("'DECODE'"), Some("'DEFAULT'"), 
		Some("'DEFAULTS'"), Some("'DEFINE'"), Some("'DEFINER'"), Some("'DELETE'"), 
		Some("'DELIMITED'"), Some("'DELIMITER'"), Some("'DENY'"), Some("'DEFERRABLE'"), 
		Some("'DEFERRED'"), Some("'DESC'"), Some("'DESCRIBE'"), Some("'DESCRIPTOR'"), 
		Some("'DIRECTORY'"), Some("'DISABLE'"), Some("'DISTINCT'"), Some("'DISTKEY'"), 
		Some("'DISTRIBUTED'"), Some("'DISTSTYLE'"), Some("'DETACH'"), Some("'DOWNSTREAM'"), 
		Some("'DOUBLE'"), Some("'DROP'"), Some("'DYNAMIC'"), Some("'ELSE'"), Some("'EMPTY'"), 
		Some("'ENABLE'"), Some("'ENCODE'"), Some("'ENCODING'"), Some("'END'"), 
		Some("'ENFORCED'"), Some("'ERROR'"), Some("'ESCAPE'"), Some("'EVEN'"), 
		Some("'EVENT'"), Some("'EXCEPT'"), Some("'EXCLUDE'"), Some("'EXCLUDING'"), 
		Some("'EXECUTE'"), Some("'EXISTS'"), Some("'EXPLAIN'"), Some("'EXTERNAL'"), 
		Some("'EXTRACT'"), Some("'FALSE'"), Some("'FETCH'"), Some("'FIELDS'"), 
		Some("'FILE_FORMAT'"), Some("'FILES'"), Some("'FILTER'"), Some("'FINAL'"), 
		Some("'FIRST'"), Some("'FIRST_VALUE'"), Some("'FLOAT'"), Some("'FOLLOWING'"), 
		Some("'FOR'"), Some("'FOREIGN'"), Some("'FORMAT'"), Some("'FORMAT_NAME'"), 
		Some("'FROM'"), Some("'FULL'"), Some("'FUNCTION'"), Some("'FUNCTIONS'"), 
		Some("'GENERATED'"), Some("'GLOBAL'"), Some("'GRACE'"), Some("'GRANT'"), 
		Some("'GRANTED'"), Some("'GRANTS'"), Some("'GRAPHVIZ'"), Some("'GROUP'"), 
		Some("'GROUPING'"), Some("'GROUPS'"), Some("'GZIP'"), Some("'HAVING'"), 
		Some("'HEADER'"), Some("'HOUR'"), Some("'ICEBERG'"), Some("'IDENTIFIER'"), 
		Some("'IDENTITY'"), Some("'IF'"), Some("'IGNORE'"), Some("'IMMEDIATE'"), 
		Some("'IMMUTABLE'"), Some("'IN'"), Some("'INCLUDE'"), Some("'INCLUDING'"), 
		Some("'INCREMENT'"), Some("'INFORMATION'"), Some("'INITIAL'"), Some("'INITIALLY'"), 
		Some("'INNER'"), Some("'INPUT'"), Some("'INPUTFORMAT'"), Some("'INTERLEAVED'"), 
		Some("'INSERT'"), Some("'INTERSECT'"), Some("'INTERVAL'"), Some("'INTO'"), 
		Some("'INVOKER'"), Some("'IO'"), Some("'IS'"), Some("'ISOLATION'"), Some("'ILIKE'"), 
		Some("'JAVA'"), Some("'JAVASCRIPT'"), Some("'JOIN'"), Some("'JSON'"), 
		Some("'JSON_ARRAY'"), Some("'JSON_EXISTS'"), Some("'JSON_OBJECT'"), Some("'JSON_QUERY'"), 
		Some("'JSON_VALUE'"), Some("'KEEP'"), Some("'KEY'"), Some("'KEYS'"), Some("'LAG'"), 
		Some("'LAMBDA'"), Some("'LANGUAGE'"), Some("'LAST'"), Some("'LAST_VALUE'"), 
		Some("'LATERAL'"), Some("'LEADING'"), Some("'LEFT'"), Some("'LEVEL'"), 
		Some("'LIBRARY'"), Some("'LIKE'"), Some("'LIMIT'"), Some("'LINES'"), Some("'LISTAGG'"), 
		Some("'LOCAL'"), Some("'LOCATION'"), Some("'LOCK'"), Some("'LOGICAL'"), 
		Some("'MAP'"), Some("'MASKING'"), Some("'MATCH'"), Some("'MATCHED'"), 
		Some("'MATCHES'"), Some("'MATCH_CONDITION'"), Some("'MATCH_RECOGNIZE'"), 
		Some("'MATERIALIZED'"), Some("'MAX'"), Some("'MEASURES'"), Some("'MEMORIZABLE'"), 
		Some("'MERGE'"), Some("'MINHASH'"), Some("'MINUS'"), Some("'MINUTE'"), 
		Some("'MOD'"), Some("'MODEL'"), Some("'MONTH'"), Some("'NAME'"), Some("'NATURAL'"), 
		Some("'NCHAR'"), Some("'NEXT'"), Some("'NFC'"), Some("'NFD'"), Some("'NFKC'"), 
		Some("'NFKD'"), Some("'NO'"), Some("'NONE'"), Some("'NOORDER'"), Some("'NORELY'"), 
		Some("'NORMALIZE'"), Some("'NOT'"), Some("'NOVALIDATE'"), Some("'NULL'"), 
		Some("'NULLS'"), Some("'OBJECT'"), Some("'OF'"), Some("'OFFSET'"), Some("'OMIT'"), 
		Some("'ON'"), Some("'ONE'"), Some("'ONLY'"), Some("'OPTION'"), Some("'OPTIONS'"), 
		Some("'OR'"), Some("'ORDER'"), Some("'ORDINALITY'"), Some("'OUTER'"), 
		Some("'OUTPUT'"), Some("'OUTPUTFORMAT'"), Some("'OVER'"), Some("'OVERFLOW'"), 
		Some("'OWNER'"), Some("'PARTITION'"), Some("'PARTITIONED'"), Some("'PARTITIONS'"), 
		Some("'PASSING'"), Some("'PAST'"), Some("'PATH'"), Some("'PATTERN'"), 
		Some("'PER'"), Some("'PERCENTILE_CONT'"), Some("'PERCENTILE_DISC'"), Some("'PERIOD'"), 
		Some("'PERMUTE'"), Some("'PIVOT'"), Some("'PLACING'"), Some("'POLICY'"), 
		Some("'POSITION'"), Some("'PRECEDING'"), Some("'PRECISION'"), Some("'PREPARE'"), 
		Some("'PRIOR'"), Some("'PROCEDURE'"), Some("'PRIMARY'"), Some("'PRIVILEGES'"), 
		Some("'PROPERTIES'"), Some("'PRUNE'"), Some("'PYTHON'"), Some("'QUALIFY'"), 
		Some("'QUOTES'"), Some("'RANGE'"), Some("'READ'"), Some("'RECURSIVE'"), 
		Some("'REGEXP'"), Some("'REFERENCE'"), Some("'REFERENCES'"), Some("'REFRESH'"), 
		Some("'RELY'"), Some("'RENAME'"), Some("'REPEATABLE'"), Some("'REPLACE'"), 
		Some("'RESET'"), Some("'RESPECT'"), Some("'RESTRICT'"), Some("'RESTRICTED'"), 
		Some("'RETURN'"), Some("'RETURNING'"), Some("'RETURNS'"), Some("'REVOKE'"), 
		Some("'RIGHT'"), Some("'RLIKE'"), Some("'RLS'"), Some("'ROLE'"), Some("'ROLES'"), 
		Some("'ROLLBACK'"), Some("'ROLLUP'"), Some("'ROW'"), Some("'ROWS'"), Some("'RUNNING'"), 
		Some("'SAMPLE'"), Some("'SCALA'"), Some("'SCALAR'"), Some("'SECOND'"), 
		Some("'SCHEMA'"), Some("'SCHEMAS'"), Some("'SECURE'"), Some("'SECURITY'"), 
		Some("'SEED'"), Some("'SEEK'"), Some("'SELECT'"), Some("'SEMI'"), Some("'SEQUENCE'"), 
		Some("'SERDE'"), Some("'SERDEPROPERTIES'"), Some("'SERIALIZABLE'"), Some("'SESSION'"), 
		Some("'SET'"), Some("'SETS'"), Some("'SHOW'"), Some("'SIMILAR'"), Some("'SKIP'"), 
		Some("'SNAPSHOT'"), Some("'SOME'"), Some("'SORTKEY'"), Some("'SQL'"), 
		Some("'STAGE'"), Some("'START'"), Some("'STATEMENT'"), Some("'STATS'"), 
		Some("'STORED'"), Some("'STREAM'"), Some("'STRICT'"), Some("'STRUCT'"), 
		Some("'SUBSET'"), Some("'SUBSTRING'"), Some("'SYSTEM'"), Some("'SYSTEM_TIME'"), 
		Some("'TABLE'"), Some("'TABLES'"), Some("'TABLESAMPLE'"), Some("'TAG'"), 
		Some("'TEMP'"), Some("'TEMPLATE'"), Some("'TEMPORARY'"), Some("'TERMINATED'"), 
		Some("'TEXT'"), Some("'STRING'"), Some("'THEN'"), Some("'TIES'"), Some("'TIME'"), 
		Some("'TIMESTAMP'"), Some("'TO'"), Some("'TOP'"), Some("'TRAILING'"), 
		Some("'TARGET_LAG'"), Some("'TRANSACTION'"), Some("'TRANSIENT'"), Some("'TRIM'"), 
		Some("'TRUE'"), Some("'TRUNCATE'"), Some("'TRY_CAST'"), Some("'TUPLE'"), 
		Some("'TYPE'"), Some("'UESCAPE'"), Some("'UNBOUNDED'"), Some("'UNCOMMITTED'"), 
		Some("'UNCONDITIONAL'"), Some("'UNION'"), Some("'UNIQUE'"), Some("'UNKNOWN'"), 
		Some("'UNLOAD'"), Some("'UNMATCHED'"), Some("'UNNEST'"), Some("'UNPIVOT'"), 
		Some("'UNSET'"), Some("'UNSIGNED'"), Some("'UPDATE'"), Some("'USE'"), 
		Some("'USER'"), Some("'USING'"), Some("'UTF16'"), Some("'UTF32'"), Some("'UTF8'"), 
		Some("'VACUUM'"), Some("'VALIDATE'"), Some("'VALUE'"), Some("'VALUES'"), 
		Some("'VARYING'"), Some("'VECTOR'"), Some("'VERBOSE'"), Some("'VERSION'"), 
		Some("'VIEW'"), Some("'VOLATILE'"), Some("'WAREHOUSE'"), Some("'WHEN'"), 
		Some("'WHERE'"), Some("'WINDOW'"), Some("'WITH'"), Some("'WITHIN'"), Some("'WITHOUT'"), 
		Some("'WORK'"), Some("'WRAPPER'"), Some("'WRITE'"), Some("'XZ'"), Some("'YEAR'"), 
		Some("'YES'"), Some("'ZONE'"), Some("'ZSTD'"), Some("'('"), Some("')'"), 
		Some("'['"), Some("']'"), Some("'.'"), Some("'='"), None, Some("'<'"), 
		Some("'<='"), Some("'>'"), Some("'>='"), Some("'+'"), Some("'-'"), Some("'*'"), 
		Some("'/'"), Some("'%'"), Some("'||'"), Some("'?'"), Some("';'"), Some("':'"), 
		Some("'$'"), Some("'<<'"), Some("'~'")
	];
	pub const _SYMBOLIC_NAMES: [Option<&'static str>;484]  = [
		None, None, None, None, None, None, None, None, None, None, None, None, 
		Some("ABORT"), Some("ABSENT"), Some("ACCESS"), Some("ADD"), Some("ADMIN"), 
		Some("AFTER"), Some("ALL"), Some("ALTER"), Some("ANALYZE"), Some("AND"), 
		Some("ANTI"), Some("ANY"), Some("APPEND_ONLY"), Some("ARRAY"), Some("ARRAYAGG"), 
		Some("ARRAY_AGG"), Some("AS"), Some("ASC"), Some("ASOF"), Some("AT"), 
		Some("ATTACH"), Some("AUTHORIZATION"), Some("AUTO"), Some("AUTOINCREMENT"), 
		Some("BACKUP"), Some("BEFORE"), Some("BEGIN"), Some("BERNOULLI"), Some("BETWEEN"), 
		Some("BLOCK"), Some("BOTH"), Some("BY"), Some("BZIP2"), Some("CALL"), 
		Some("CALLED"), Some("CALLER"), Some("CANCEL"), Some("CASCADE"), Some("CASE"), 
		Some("CASE_SENSITIVE"), Some("CASE_INSENSITIVE"), Some("CAST"), Some("CATALOGS"), 
		Some("CHANGES"), Some("CHAR"), Some("CHARACTER"), Some("CLONE"), Some("CLOSE"), 
		Some("CLUSTER"), Some("COLLATE"), Some("COLUMN"), Some("COLUMNS"), Some("COMMA"), 
		Some("COMMENT"), Some("COMMIT"), Some("COMMITTED"), Some("COMPOUND"), 
		Some("COMPRESSION"), Some("CONDITIONAL"), Some("CONNECT"), Some("CONNECTION"), 
		Some("CONNECT_BY_ROOT"), Some("CONSTRAINT"), Some("COPARTITION"), Some("COPY"), 
		Some("COUNT"), Some("CREATE"), Some("CROSS"), Some("CUBE"), Some("CURRENT"), 
		Some("CURRENT_ROLE"), Some("DATA"), Some("DATABASE"), Some("DATASHARE"), 
		Some("DAY"), Some("DEALLOCATE"), Some("DECLARE"), Some("DECODE"), Some("DEFAULT"), 
		Some("DEFAULTS"), Some("DEFINE"), Some("DEFINER"), Some("DELETE"), Some("DELIMITED"), 
		Some("DELIMITER"), Some("DENY"), Some("DEFERRABLE"), Some("DEFERRED"), 
		Some("DESC"), Some("DESCRIBE"), Some("DESCRIPTOR"), Some("DIRECTORY"), 
		Some("DISABLE"), Some("DISTINCT"), Some("DISTKEY"), Some("DISTRIBUTED"), 
		Some("DISTSTYLE"), Some("DETACH"), Some("DOWNSTREAM"), Some("DOUBLE"), 
		Some("DROP"), Some("DYNAMIC"), Some("ELSE"), Some("EMPTY"), Some("ENABLE"), 
		Some("ENCODE"), Some("ENCODING"), Some("END"), Some("ENFORCED"), Some("ERROR"), 
		Some("ESCAPE"), Some("EVEN"), Some("EVENT"), Some("EXCEPT"), Some("EXCLUDE"), 
		Some("EXCLUDING"), Some("EXECUTE"), Some("EXISTS"), Some("EXPLAIN"), Some("EXTERNAL"), 
		Some("EXTRACT"), Some("FALSE"), Some("FETCH"), Some("FIELDS"), Some("FILE_FORMAT"), 
		Some("FILES"), Some("FILTER"), Some("FINAL"), Some("FIRST"), Some("FIRST_VALUE"), 
		Some("FLOAT"), Some("FOLLOWING"), Some("FOR"), Some("FOREIGN"), Some("FORMAT"), 
		Some("FORMAT_NAME"), Some("FROM"), Some("FULL"), Some("FUNCTION"), Some("FUNCTIONS"), 
		Some("GENERATED"), Some("GLOBAL"), Some("GRACE"), Some("GRANT"), Some("GRANTED"), 
		Some("GRANTS"), Some("GRAPHVIZ"), Some("GROUP"), Some("GROUPING"), Some("GROUPS"), 
		Some("GZIP"), Some("HAVING"), Some("HEADER"), Some("HOUR"), Some("ICEBERG"), 
		Some("IDENTIFIER_KW"), Some("IDENTITY"), Some("IF"), Some("IGNORE"), Some("IMMEDIATE"), 
		Some("IMMUTABLE"), Some("IN"), Some("INCLUDE"), Some("INCLUDING"), Some("INCREMENT"), 
		Some("INFORMATION"), Some("INITIAL"), Some("INITIALLY"), Some("INNER"), 
		Some("INPUT"), Some("INPUTFORMAT"), Some("INTERLEAVED"), Some("INSERT"), 
		Some("INTERSECT"), Some("INTERVAL"), Some("INTO"), Some("INVOKER"), Some("IO"), 
		Some("IS"), Some("ISOLATION"), Some("ILIKE"), Some("JAVA"), Some("JAVASCRIPT"), 
		Some("JOIN"), Some("JSON"), Some("JSON_ARRAY"), Some("JSON_EXISTS"), Some("JSON_OBJECT"), 
		Some("JSON_QUERY"), Some("JSON_VALUE"), Some("KEEP"), Some("KEY"), Some("KEYS"), 
		Some("LAG"), Some("LAMBDA"), Some("LANGUAGE"), Some("LAST"), Some("LAST_VALUE"), 
		Some("LATERAL"), Some("LEADING"), Some("LEFT"), Some("LEVEL"), Some("LIBRARY"), 
		Some("LIKE"), Some("LIMIT"), Some("LINES"), Some("LISTAGG"), Some("LOCAL"), 
		Some("LOCATION"), Some("LOCK"), Some("LOGICAL"), Some("MAP"), Some("MASKING"), 
		Some("MATCH"), Some("MATCHED"), Some("MATCHES"), Some("MATCH_CONDITION"), 
		Some("MATCH_RECOGNIZE"), Some("MATERIALIZED"), Some("MAX"), Some("MEASURES"), 
		Some("MEMORIZABLE"), Some("MERGE"), Some("MINHASH"), Some("MINUS_KW"), 
		Some("MINUTE"), Some("MOD"), Some("MODEL"), Some("MONTH"), Some("NAME"), 
		Some("NATURAL"), Some("NCHAR"), Some("NEXT"), Some("NFC"), Some("NFD"), 
		Some("NFKC"), Some("NFKD"), Some("NO"), Some("NONE"), Some("NOORDER"), 
		Some("NORELY"), Some("NORMALIZE"), Some("NOT"), Some("NOVALIDATE"), Some("NULL"), 
		Some("NULLS"), Some("OBJECT"), Some("OF"), Some("OFFSET"), Some("OMIT"), 
		Some("ON"), Some("ONE"), Some("ONLY"), Some("OPTION"), Some("OPTIONS"), 
		Some("OR"), Some("ORDER"), Some("ORDINALITY"), Some("OUTER"), Some("OUTPUT"), 
		Some("OUTPUTFORMAT"), Some("OVER"), Some("OVERFLOW"), Some("OWNER"), Some("PARTITION"), 
		Some("PARTITIONED"), Some("PARTITIONS"), Some("PASSING"), Some("PAST"), 
		Some("PATH"), Some("PATTERN"), Some("PER"), Some("PERCENTILE_CONT"), Some("PERCENTILE_DISC"), 
		Some("PERIOD"), Some("PERMUTE"), Some("PIVOT"), Some("PLACING"), Some("POLICY"), 
		Some("POSITION"), Some("PRECEDING"), Some("PRECISION"), Some("PREPARE"), 
		Some("PRIOR"), Some("PROCEDURE"), Some("PRIMARY"), Some("PRIVILEGES"), 
		Some("PROPERTIES"), Some("PRUNE"), Some("PYTHON"), Some("QUALIFY"), Some("QUOTES"), 
		Some("RANGE"), Some("READ"), Some("RECURSIVE"), Some("REGEXP"), Some("REFERENCE"), 
		Some("REFERENCES"), Some("REFRESH"), Some("RELY"), Some("RENAME"), Some("REPEATABLE"), 
		Some("REPLACE"), Some("RESET"), Some("RESPECT"), Some("RESTRICT"), Some("RESTRICTED"), 
		Some("RETURN"), Some("RETURNING"), Some("RETURNS"), Some("REVOKE"), Some("RIGHT"), 
		Some("RLIKE"), Some("RLS"), Some("ROLE"), Some("ROLES"), Some("ROLLBACK"), 
		Some("ROLLUP"), Some("ROW"), Some("ROWS"), Some("RUNNING"), Some("SAMPLE"), 
		Some("SCALA"), Some("SCALAR"), Some("SECOND"), Some("SCHEMA"), Some("SCHEMAS"), 
		Some("SECURE"), Some("SECURITY"), Some("SEED"), Some("SEEK"), Some("SELECT"), 
		Some("SEMI"), Some("SEQUENCE"), Some("SERDE"), Some("SERDEPROPERTIES"), 
		Some("SERIALIZABLE"), Some("SESSION"), Some("SET"), Some("SETS"), Some("SHOW"), 
		Some("SIMILAR"), Some("SKIP_KW"), Some("SNAPSHOT"), Some("SOME"), Some("SORTKEY"), 
		Some("SQL"), Some("STAGE"), Some("START"), Some("STATEMENT"), Some("STATS"), 
		Some("STORED"), Some("STREAM"), Some("STRICT"), Some("STRUCT"), Some("SUBSET"), 
		Some("SUBSTRING"), Some("SYSTEM"), Some("SYSTEM_TIME"), Some("TABLE"), 
		Some("TABLES"), Some("TABLESAMPLE"), Some("TAG"), Some("TEMP"), Some("TEMPLATE"), 
		Some("TEMPORARY"), Some("TERMINATED"), Some("TEXT"), Some("STRING_KW"), 
		Some("THEN"), Some("TIES"), Some("TIME"), Some("TIMESTAMP"), Some("TO"), 
		Some("TOP"), Some("TRAILING"), Some("TARGET_LAG"), Some("TRANSACTION"), 
		Some("TRANSIENT"), Some("TRIM"), Some("TRUE"), Some("TRUNCATE"), Some("TRY_CAST"), 
		Some("TUPLE"), Some("TYPE"), Some("UESCAPE"), Some("UNBOUNDED"), Some("UNCOMMITTED"), 
		Some("UNCONDITIONAL"), Some("UNION"), Some("UNIQUE"), Some("UNKNOWN"), 
		Some("UNLOAD"), Some("UNMATCHED"), Some("UNNEST"), Some("UNPIVOT"), Some("UNSET"), 
		Some("UNSIGNED"), Some("UPDATE"), Some("USE"), Some("USER"), Some("USING"), 
		Some("UTF16"), Some("UTF32"), Some("UTF8"), Some("VACUUM"), Some("VALIDATE"), 
		Some("VALUE"), Some("VALUES"), Some("VARYING"), Some("VECTOR"), Some("VERBOSE"), 
		Some("VERSION"), Some("VIEW"), Some("VOLATILE"), Some("WAREHOUSE"), Some("WHEN"), 
		Some("WHERE"), Some("WINDOW"), Some("WITH"), Some("WITHIN"), Some("WITHOUT"), 
		Some("WORK"), Some("WRAPPER"), Some("WRITE"), Some("XZ"), Some("YEAR"), 
		Some("YES"), Some("ZONE"), Some("ZSTD"), Some("LPAREN"), Some("RPAREN"), 
		Some("LBRACKET"), Some("RBRACKET"), Some("DOT"), Some("EQ"), Some("NEQ"), 
		Some("LT"), Some("LTE"), Some("GT"), Some("GTE"), Some("PLUS"), Some("MINUS"), 
		Some("ASTERISK"), Some("SLASH"), Some("PERCENT"), Some("CONCAT"), Some("QUESTION_MARK"), 
		Some("SEMI_COLON"), Some("COLON"), Some("DOLLAR"), Some("BITWISE_SHIFT_LEFT"), 
		Some("POSIX"), Some("ESCAPE_SEQUENCE"), Some("STRING"), Some("UNICODE_STRING"), 
		Some("DOLLAR_QUOTED_STRING"), Some("BINARY_LITERAL"), Some("INTEGER_VALUE"), 
		Some("DECIMAL_VALUE"), Some("DOUBLE_VALUE"), Some("IDENTIFIER"), Some("QUOTED_IDENTIFIER"), 
		Some("BACKQUOTED_IDENTIFIER"), Some("STAGE_NAME"), Some("VARIABLE"), Some("SIMPLE_COMMENT"), 
		Some("SLASH_SLASH_COMMENT"), Some("BRACKETED_COMMENT"), Some("WS"), Some("UNPAIRED_TOKEN"), 
		Some("UNRECOGNIZED")
	];
	thread_local!{
	    static _shared_context_cache: Rc<PredictionContextCache> = Rc::new(PredictionContextCache::new());
		static VOCABULARY: Box<dyn Vocabulary> = Box::new(VocabularyImpl::new(_LITERAL_NAMES.iter(), _SYMBOLIC_NAMES.iter(), None));
	}


type BaseParserType<'input, I> =
	BaseParser<'input,SnowflakeParserExt<'input>, I, SnowflakeParserContextType , dyn SnowflakeListener<'input> + 'input >;

type TokenType<'input> = <LocalTokenFactory<'input> as TokenFactory<'input>>::Tok;

pub type LocalTokenFactory<'input> = antlr_rust::token_factory::ArenaCommonFactory<'input>;

pub type SnowflakeTreeWalker<'input,'a> =
	ParseTreeWalker<'input, 'a, SnowflakeParserContextType , dyn SnowflakeListener<'input> + 'a>;

/// Parser for Snowflake grammar
pub struct SnowflakeParser<'input,I,H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	base:BaseParserType<'input,I>,
	interpreter:Rc<ParserATNSimulator>,
	_shared_context_cache: Box<PredictionContextCache>,
    pub err_handler: H,
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn get_serialized_atn() -> &'static str { _serializedATN }

    pub fn set_error_strategy(&mut self, strategy: H) {
        self.err_handler = strategy
    }

    pub fn with_strategy(input: I, strategy: H) -> Self {
		antlr_rust::recognizer::check_version("0","3");
        let interpreter = Rc::new(ParserATNSimulator::new(
            _ATN.with(|atn| atn.clone()),
            _decision_to_DFA.with(|decision| decision.clone()),
            _shared_context_cache.with(|ctx| ctx.clone()),
        ));
		Self {
			base: BaseParser::new_base_parser(
				input,
				Rc::clone(&interpreter),
				SnowflakeParserExt{
					_pd: Default::default(),
				}
			),
			interpreter,
            _shared_context_cache: Box::new(PredictionContextCache::new()),
            err_handler: strategy,
        }
    }

    pub fn add_error_listener(&mut self, listener: Box<(dyn ErrorListener<'input, BaseParser<'input, SnowflakeParserExt<'input>, I, SnowflakeParserContextType, (dyn SnowflakeListener<'input> + 'input)>> + 'static)>) {
        self.base.add_error_listener(listener)
    }

	pub fn remove_error_listeners(&mut self) {
        self.base.remove_error_listeners()
    }
}

type DynStrategy<'input,I> = Box<dyn ErrorStrategy<'input,BaseParserType<'input,I>> + 'input>;

impl<'input, I> SnowflakeParser<'input, I, DynStrategy<'input,I>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn with_dyn_strategy(input: I) -> Self{
    	Self::with_strategy(input,Box::new(DefaultErrorStrategy::new()))
    }
}

impl<'input, I> SnowflakeParser<'input, I, DefaultErrorStrategy<'input,SnowflakeParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
    pub fn new(input: I) -> Self{
    	Self::with_strategy(input,DefaultErrorStrategy::new())
    }
}

/// Trait for monomorphized trait object that corresponds to the nodes of parse tree generated for SnowflakeParser
pub trait SnowflakeParserContext<'input>:
	for<'x> Listenable<dyn SnowflakeListener<'input> + 'x > + 
	for<'x> Visitable<dyn SnowflakeVisitor<'input> + 'x > + 
	ParserRuleContext<'input, TF=LocalTokenFactory<'input>, Ctx=SnowflakeParserContextType>
{}

antlr_rust::coerce_from!{ 'input : SnowflakeParserContext<'input> }

impl<'input, 'x, T> VisitableDyn<T> for dyn SnowflakeParserContext<'input> + 'input
where
    T: SnowflakeVisitor<'input> + 'x,
{
    fn accept_dyn(&self, visitor: &mut T) {
        self.accept(visitor as &mut (dyn SnowflakeVisitor<'input> + 'x))
    }
}

impl<'input> SnowflakeParserContext<'input> for TerminalNode<'input,SnowflakeParserContextType> {}
impl<'input> SnowflakeParserContext<'input> for ErrorNode<'input,SnowflakeParserContextType> {}

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn SnowflakeParserContext<'input> + 'input }

antlr_rust::tid! { impl<'input> TidAble<'input> for dyn SnowflakeListener<'input> + 'input }

pub struct SnowflakeParserContextType;
antlr_rust::tid!{SnowflakeParserContextType}

impl<'input> ParserNodeType<'input> for SnowflakeParserContextType{
	type TF = LocalTokenFactory<'input>;
	type Type = dyn SnowflakeParserContext<'input> + 'input;
}

impl<'input, I, H> Deref for SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    type Target = BaseParserType<'input,I>;

    fn deref(&self) -> &Self::Target {
        &self.base
    }
}

impl<'input, I, H> DerefMut for SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.base
    }
}

pub struct SnowflakeParserExt<'input>{
	_pd: PhantomData<&'input str>,
}

impl<'input> SnowflakeParserExt<'input>{
}
antlr_rust::tid! { SnowflakeParserExt<'a> }

impl<'input> TokenAware<'input> for SnowflakeParserExt<'input>{
	type TF = LocalTokenFactory<'input>;
}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> ParserRecog<'input, BaseParserType<'input,I>> for SnowflakeParserExt<'input>{}

impl<'input,I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>> Actions<'input, BaseParserType<'input,I>> for SnowflakeParserExt<'input>{
	fn get_grammar_file_name(&self) -> & str{ "Snowflake.g4"}

   	fn get_rule_names(&self) -> &[& str] {&ruleNames}

   	fn get_vocabulary(&self) -> &dyn Vocabulary { VOCABULARY.with(|v| unsafe { std::mem::transmute(&**v) }) }
	fn sempred(_localctx: Option<&(dyn SnowflakeParserContext<'input> + 'input)>, rule_index: isize, pred_index: isize,
			   recog:&mut BaseParserType<'input,I>
	)->bool{
		match rule_index {
					73 => SnowflakeParser::<'input,I,_>::joinedRelation_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					124 => SnowflakeParser::<'input,I,_>::booleanExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					128 => SnowflakeParser::<'input,I,_>::valueExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					129 => SnowflakeParser::<'input,I,_>::primaryExpression_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					163 => SnowflakeParser::<'input,I,_>::rowPattern_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
					172 => SnowflakeParser::<'input,I,_>::dashedIdentifier_sempred(_localctx.and_then(|x|x.downcast_ref()), pred_index, recog),
			_ => true
		}
	}
}

impl<'input, I> SnowflakeParser<'input, I, DefaultErrorStrategy<'input,SnowflakeParserContextType>>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
{
	fn joinedRelation_sempred(_localctx: Option<&JoinedRelationContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				0=>{
					recog.precpred(None, 3)
				}
				1=>{
					recog.precpred(None, 2)
				}
			_ => true
		}
	}
	fn booleanExpression_sempred(_localctx: Option<&BooleanExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				2=>{
					recog.precpred(None, 2)
				}
				3=>{
					recog.precpred(None, 1)
				}
				4=>{
					recog.precpred(None, 5)
				}
			_ => true
		}
	}
	fn valueExpression_sempred(_localctx: Option<&ValueExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				5=>{
					recog.precpred(None, 4)
				}
				6=>{
					recog.precpred(None, 3)
				}
				7=>{
					recog.precpred(None, 2)
				}
				8=>{
					recog.precpred(None, 1)
				}
				9=>{
					recog.precpred(None, 6)
				}
			_ => true
		}
	}
	fn primaryExpression_sempred(_localctx: Option<&PrimaryExpressionContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				10=>{
					recog.precpred(None, 15)
				}
				11=>{
					recog.precpred(None, 14)
				}
				12=>{
					recog.precpred(None, 13)
				}
				13=>{
					recog.precpred(None, 11)
				}
			_ => true
		}
	}
	fn rowPattern_sempred(_localctx: Option<&RowPatternContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				14=>{
					recog.precpred(None, 2)
				}
				15=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
	fn dashedIdentifier_sempred(_localctx: Option<&DashedIdentifierContext<'input>>, pred_index:isize,
						recog:&mut <Self as Deref>::Target
		) -> bool {
		match pred_index {
				16=>{
					recog.precpred(None, 5)
				}
				17=>{
					recog.precpred(None, 3)
				}
				18=>{
					recog.precpred(None, 1)
				}
			_ => true
		}
	}
}
//------------------- multipleStatement ----------------
pub type MultipleStatementContextAll<'input> = MultipleStatementContext<'input>;


pub type MultipleStatementContext<'input> = BaseParserRuleContext<'input,MultipleStatementContextExt<'input>>;

#[derive(Clone)]
pub struct MultipleStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for MultipleStatementContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for MultipleStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multipleStatement(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_multipleStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for MultipleStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_multipleStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultipleStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multipleStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multipleStatement }
}
antlr_rust::tid!{MultipleStatementContextExt<'a>}

impl<'input> MultipleStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultipleStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultipleStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MultipleStatementContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<MultipleStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}
fn statement_all(&self) ->  Vec<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn statement(&self, i: usize) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEMI_COLON, i)
}

}

impl<'input> MultipleStatementContextAttrs<'input> for MultipleStatementContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multipleStatement(&mut self,)
	-> Result<Rc<MultipleStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultipleStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 0, RULE_multipleStatement);
        let mut _localctx: Rc<MultipleStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(381);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ALTER || _la==ANALYZE || ((((_la - 38)) & !0x3f) == 0 && ((1usize << (_la - 38)) & ((1usize << (BEGIN - 38)) | (1usize << (CALL - 38)) | (1usize << (COMMENT - 38)) | (1usize << (COMMIT - 38)))) != 0) || ((((_la - 78)) & !0x3f) == 0 && ((1usize << (_la - 78)) & ((1usize << (CREATE - 78)) | (1usize << (DEALLOCATE - 78)) | (1usize << (DELETE - 78)) | (1usize << (DENY - 78)) | (1usize << (DESC - 78)) | (1usize << (DESCRIBE - 78)))) != 0) || ((((_la - 112)) & !0x3f) == 0 && ((1usize << (_la - 112)) & ((1usize << (DROP - 112)) | (1usize << (EXECUTE - 112)) | (1usize << (EXPLAIN - 112)))) != 0) || _la==GRANT || _la==INSERT || _la==MERGE || ((((_la - 294)) & !0x3f) == 0 && ((1usize << (_la - 294)) & ((1usize << (PREPARE - 294)) | (1usize << (REFRESH - 294)) | (1usize << (RESET - 294)) | (1usize << (REVOKE - 294)))) != 0) || ((((_la - 328)) & !0x3f) == 0 && ((1usize << (_la - 328)) & ((1usize << (ROLLBACK - 328)) | (1usize << (SELECT - 328)) | (1usize << (SET - 328)) | (1usize << (SHOW - 328)))) != 0) || _la==START || _la==TABLE || ((((_la - 393)) & !0x3f) == 0 && ((1usize << (_la - 393)) & ((1usize << (TRUNCATE - 393)) | (1usize << (UNSET - 393)) | (1usize << (UPDATE - 393)) | (1usize << (USE - 393)))) != 0) || _la==WITH || _la==LPAREN {
				{
				/*InvokeRule statement*/
				recog.base.set_state(380);
				recog.statement()?;

				}
			}

			recog.base.set_state(389);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==SEMI_COLON {
				{
				{
				recog.base.set_state(383);
				recog.base.match_token(SEMI_COLON,&mut recog.err_handler)?;

				recog.base.set_state(385);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==ALTER || _la==ANALYZE || ((((_la - 38)) & !0x3f) == 0 && ((1usize << (_la - 38)) & ((1usize << (BEGIN - 38)) | (1usize << (CALL - 38)) | (1usize << (COMMENT - 38)) | (1usize << (COMMIT - 38)))) != 0) || ((((_la - 78)) & !0x3f) == 0 && ((1usize << (_la - 78)) & ((1usize << (CREATE - 78)) | (1usize << (DEALLOCATE - 78)) | (1usize << (DELETE - 78)) | (1usize << (DENY - 78)) | (1usize << (DESC - 78)) | (1usize << (DESCRIBE - 78)))) != 0) || ((((_la - 112)) & !0x3f) == 0 && ((1usize << (_la - 112)) & ((1usize << (DROP - 112)) | (1usize << (EXECUTE - 112)) | (1usize << (EXPLAIN - 112)))) != 0) || _la==GRANT || _la==INSERT || _la==MERGE || ((((_la - 294)) & !0x3f) == 0 && ((1usize << (_la - 294)) & ((1usize << (PREPARE - 294)) | (1usize << (REFRESH - 294)) | (1usize << (RESET - 294)) | (1usize << (REVOKE - 294)))) != 0) || ((((_la - 328)) & !0x3f) == 0 && ((1usize << (_la - 328)) & ((1usize << (ROLLBACK - 328)) | (1usize << (SELECT - 328)) | (1usize << (SET - 328)) | (1usize << (SHOW - 328)))) != 0) || _la==START || _la==TABLE || ((((_la - 393)) & !0x3f) == 0 && ((1usize << (_la - 393)) & ((1usize << (TRUNCATE - 393)) | (1usize << (UNSET - 393)) | (1usize << (UPDATE - 393)) | (1usize << (USE - 393)))) != 0) || _la==WITH || _la==LPAREN {
					{
					/*InvokeRule statement*/
					recog.base.set_state(384);
					recog.statement()?;

					}
				}

				}
				}
				recog.base.set_state(391);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(392);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleStatement ----------------
pub type SingleStatementContextAll<'input> = SingleStatementContext<'input>;


pub type SingleStatementContext<'input> = BaseParserRuleContext<'input,SingleStatementContextExt<'input>>;

#[derive(Clone)]
pub struct SingleStatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SingleStatementContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SingleStatementContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_singleStatement(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_singleStatement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SingleStatementContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_singleStatement(self);
	}
}

impl<'input> CustomRuleContext<'input> for SingleStatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleStatement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleStatement }
}
antlr_rust::tid!{SingleStatementContextExt<'a>}

impl<'input> SingleStatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleStatementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleStatementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleStatementContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SingleStatementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}
fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SEMI_COLON
/// Returns `None` if there is no child corresponding to token SEMI_COLON
fn SEMI_COLON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEMI_COLON, 0)
}

}

impl<'input> SingleStatementContextAttrs<'input> for SingleStatementContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleStatement(&mut self,)
	-> Result<Rc<SingleStatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleStatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 2, RULE_singleStatement);
        let mut _localctx: Rc<SingleStatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(395);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ALTER || _la==ANALYZE || ((((_la - 38)) & !0x3f) == 0 && ((1usize << (_la - 38)) & ((1usize << (BEGIN - 38)) | (1usize << (CALL - 38)) | (1usize << (COMMENT - 38)) | (1usize << (COMMIT - 38)))) != 0) || ((((_la - 78)) & !0x3f) == 0 && ((1usize << (_la - 78)) & ((1usize << (CREATE - 78)) | (1usize << (DEALLOCATE - 78)) | (1usize << (DELETE - 78)) | (1usize << (DENY - 78)) | (1usize << (DESC - 78)) | (1usize << (DESCRIBE - 78)))) != 0) || ((((_la - 112)) & !0x3f) == 0 && ((1usize << (_la - 112)) & ((1usize << (DROP - 112)) | (1usize << (EXECUTE - 112)) | (1usize << (EXPLAIN - 112)))) != 0) || _la==GRANT || _la==INSERT || _la==MERGE || ((((_la - 294)) & !0x3f) == 0 && ((1usize << (_la - 294)) & ((1usize << (PREPARE - 294)) | (1usize << (REFRESH - 294)) | (1usize << (RESET - 294)) | (1usize << (REVOKE - 294)))) != 0) || ((((_la - 328)) & !0x3f) == 0 && ((1usize << (_la - 328)) & ((1usize << (ROLLBACK - 328)) | (1usize << (SELECT - 328)) | (1usize << (SET - 328)) | (1usize << (SHOW - 328)))) != 0) || _la==START || _la==TABLE || ((((_la - 393)) & !0x3f) == 0 && ((1usize << (_la - 393)) & ((1usize << (TRUNCATE - 393)) | (1usize << (UNSET - 393)) | (1usize << (UPDATE - 393)) | (1usize << (USE - 393)))) != 0) || _la==WITH || _la==LPAREN {
				{
				/*InvokeRule statement*/
				recog.base.set_state(394);
				recog.statement()?;

				}
			}

			recog.base.set_state(398);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==SEMI_COLON {
				{
				recog.base.set_state(397);
				recog.base.match_token(SEMI_COLON,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(400);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- standaloneExpression ----------------
pub type StandaloneExpressionContextAll<'input> = StandaloneExpressionContext<'input>;


pub type StandaloneExpressionContext<'input> = BaseParserRuleContext<'input,StandaloneExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct StandaloneExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for StandaloneExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StandaloneExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_standaloneExpression(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_standaloneExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StandaloneExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_standaloneExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for StandaloneExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_standaloneExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_standaloneExpression }
}
antlr_rust::tid!{StandaloneExpressionContextExt<'a>}

impl<'input> StandaloneExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StandaloneExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StandaloneExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StandaloneExpressionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<StandaloneExpressionContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}

}

impl<'input> StandaloneExpressionContextAttrs<'input> for StandaloneExpressionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn standaloneExpression(&mut self,)
	-> Result<Rc<StandaloneExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StandaloneExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 4, RULE_standaloneExpression);
        let mut _localctx: Rc<StandaloneExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(402);
			recog.expression()?;

			recog.base.set_state(403);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- standaloneQualifiedName ----------------
pub type StandaloneQualifiedNameContextAll<'input> = StandaloneQualifiedNameContext<'input>;


pub type StandaloneQualifiedNameContext<'input> = BaseParserRuleContext<'input,StandaloneQualifiedNameContextExt<'input>>;

#[derive(Clone)]
pub struct StandaloneQualifiedNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for StandaloneQualifiedNameContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StandaloneQualifiedNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_standaloneQualifiedName(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_standaloneQualifiedName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StandaloneQualifiedNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_standaloneQualifiedName(self);
	}
}

impl<'input> CustomRuleContext<'input> for StandaloneQualifiedNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_standaloneQualifiedName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_standaloneQualifiedName }
}
antlr_rust::tid!{StandaloneQualifiedNameContextExt<'a>}

impl<'input> StandaloneQualifiedNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StandaloneQualifiedNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StandaloneQualifiedNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StandaloneQualifiedNameContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<StandaloneQualifiedNameContextExt<'input>>{

fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}

}

impl<'input> StandaloneQualifiedNameContextAttrs<'input> for StandaloneQualifiedNameContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn standaloneQualifiedName(&mut self,)
	-> Result<Rc<StandaloneQualifiedNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StandaloneQualifiedNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 6, RULE_standaloneQualifiedName);
        let mut _localctx: Rc<StandaloneQualifiedNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule qualifiedName*/
			recog.base.set_state(405);
			recog.qualifiedName()?;

			recog.base.set_state(406);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- standaloneType ----------------
pub type StandaloneTypeContextAll<'input> = StandaloneTypeContext<'input>;


pub type StandaloneTypeContext<'input> = BaseParserRuleContext<'input,StandaloneTypeContextExt<'input>>;

#[derive(Clone)]
pub struct StandaloneTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for StandaloneTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StandaloneTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_standaloneType(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_standaloneType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StandaloneTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_standaloneType(self);
	}
}

impl<'input> CustomRuleContext<'input> for StandaloneTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_standaloneType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_standaloneType }
}
antlr_rust::tid!{StandaloneTypeContextExt<'a>}

impl<'input> StandaloneTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StandaloneTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StandaloneTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StandaloneTypeContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<StandaloneTypeContextExt<'input>>{

fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}

}

impl<'input> StandaloneTypeContextAttrs<'input> for StandaloneTypeContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn standaloneType(&mut self,)
	-> Result<Rc<StandaloneTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StandaloneTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 8, RULE_standaloneType);
        let mut _localctx: Rc<StandaloneTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule type_*/
			recog.base.set_state(408);
			recog.type_()?;

			recog.base.set_state(409);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- statement ----------------
#[derive(Debug)]
pub enum StatementContextAll<'input>{
	CreateFooContext(CreateFooContext<'input>),
	ExplainContext(ExplainContext<'input>),
	PrepareContext(PrepareContext<'input>),
	SnowflakeInsertIntoContext(SnowflakeInsertIntoContext<'input>),
	CreateAnonymousPythonProcedureContext(CreateAnonymousPythonProcedureContext<'input>),
	SetMaterializedViewPropertiesContext(SetMaterializedViewPropertiesContext<'input>),
	UseContext(UseContext<'input>),
	DeallocateContext(DeallocateContext<'input>),
	RenameTableContext(RenameTableContext<'input>),
	CommitContext(CommitContext<'input>),
	CreateStageContext(CreateStageContext<'input>),
	CreateRoleContext(CreateRoleContext<'input>),
	DropViewContext(DropViewContext<'input>),
	DropColumnContext(DropColumnContext<'input>),
	SnowflakeCreateTableContext(SnowflakeCreateTableContext<'input>),
	UnsetContext(UnsetContext<'input>),
	SetViewAuthorizationContext(SetViewAuthorizationContext<'input>),
	MergeContext(MergeContext<'input>),
	RenameColumnContext(RenameColumnContext<'input>),
	ShowColumnsContext(ShowColumnsContext<'input>),
	CreateModuleFunctionContext(CreateModuleFunctionContext<'input>),
	AlterContext(AlterContext<'input>),
	AddColumnContext(AddColumnContext<'input>),
	DenyContext(DenyContext<'input>),
	CreateEventTableContext(CreateEventTableContext<'input>),
	CreateDynamicTableContext(CreateDynamicTableContext<'input>),
	CreateSchemaContext(CreateSchemaContext<'input>),
	ExecuteContext(ExecuteContext<'input>),
	CreateJSFunctionContext(CreateJSFunctionContext<'input>),
	CreateJarFunctionContext(CreateJarFunctionContext<'input>),
	RenameSchemaContext(RenameSchemaContext<'input>),
	CreatePythonProcedureContext(CreatePythonProcedureContext<'input>),
	AnalyzeContext(AnalyzeContext<'input>),
	ResetContext(ResetContext<'input>),
	CreateScalaJarFunctionContext(CreateScalaJarFunctionContext<'input>),
	DropSchemaContext(DropSchemaContext<'input>),
	BeginContext(BeginContext<'input>),
	SetTableAuthorizationContext(SetTableAuthorizationContext<'input>),
	DropContext(DropContext<'input>),
	StartTransactionContext(StartTransactionContext<'input>),
	CreateIcebergTableContext(CreateIcebergTableContext<'input>),
	ShowContext(ShowContext<'input>),
	RevokeContext(RevokeContext<'input>),
	UpdateContext(UpdateContext<'input>),
	CreateRecursiveTableContext(CreateRecursiveTableContext<'input>),
	TableExecuteContext(TableExecuteContext<'input>),
	DeleteContext(DeleteContext<'input>),
	DescribeInputContext(DescribeInputContext<'input>),
	SetColumnTypeContext(SetColumnTypeContext<'input>),
	StatementDefaultContext(StatementDefaultContext<'input>),
	CreateJavaFunctionContext(CreateJavaFunctionContext<'input>),
	SnowflakeCreateTableUsingTemplateContext(SnowflakeCreateTableUsingTemplateContext<'input>),
	CreateScalaFunctionContext(CreateScalaFunctionContext<'input>),
	TruncateTableContext(TruncateTableContext<'input>),
	CreateMaterializedViewContext(CreateMaterializedViewContext<'input>),
	CreateViewContext(CreateViewContext<'input>),
	RenameMaterializedViewContext(RenameMaterializedViewContext<'input>),
	DropTableContext(DropTableContext<'input>),
	CreateTableCloneContext(CreateTableCloneContext<'input>),
	SetSchemaAuthorizationContext(SetSchemaAuthorizationContext<'input>),
	RollbackContext(RollbackContext<'input>),
	SetContext(SetContext<'input>),
	CreateSqlFunctionContext(CreateSqlFunctionContext<'input>),
	CreatePythonFunctionContext(CreatePythonFunctionContext<'input>),
	RenameViewContext(RenameViewContext<'input>),
	SnowflakeCreateTableAsSelectContext(SnowflakeCreateTableAsSelectContext<'input>),
	CallContext(CallContext<'input>),
	RefreshMaterializedViewContext(RefreshMaterializedViewContext<'input>),
	CreateExternalTableContext(CreateExternalTableContext<'input>),
	CommentContext(CommentContext<'input>),
	DescribeOutputContext(DescribeOutputContext<'input>),
	GrantContext(GrantContext<'input>),
	SetTablePropertiesContext(SetTablePropertiesContext<'input>),
Error(StatementContext<'input>)
}
antlr_rust::tid!{StatementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for StatementContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for StatementContextAll<'input>{}

impl<'input> Deref for StatementContextAll<'input>{
	type Target = dyn StatementContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use StatementContextAll::*;
		match self{
			CreateFooContext(inner) => inner,
			ExplainContext(inner) => inner,
			PrepareContext(inner) => inner,
			SnowflakeInsertIntoContext(inner) => inner,
			CreateAnonymousPythonProcedureContext(inner) => inner,
			SetMaterializedViewPropertiesContext(inner) => inner,
			UseContext(inner) => inner,
			DeallocateContext(inner) => inner,
			RenameTableContext(inner) => inner,
			CommitContext(inner) => inner,
			CreateStageContext(inner) => inner,
			CreateRoleContext(inner) => inner,
			DropViewContext(inner) => inner,
			DropColumnContext(inner) => inner,
			SnowflakeCreateTableContext(inner) => inner,
			UnsetContext(inner) => inner,
			SetViewAuthorizationContext(inner) => inner,
			MergeContext(inner) => inner,
			RenameColumnContext(inner) => inner,
			ShowColumnsContext(inner) => inner,
			CreateModuleFunctionContext(inner) => inner,
			AlterContext(inner) => inner,
			AddColumnContext(inner) => inner,
			DenyContext(inner) => inner,
			CreateEventTableContext(inner) => inner,
			CreateDynamicTableContext(inner) => inner,
			CreateSchemaContext(inner) => inner,
			ExecuteContext(inner) => inner,
			CreateJSFunctionContext(inner) => inner,
			CreateJarFunctionContext(inner) => inner,
			RenameSchemaContext(inner) => inner,
			CreatePythonProcedureContext(inner) => inner,
			AnalyzeContext(inner) => inner,
			ResetContext(inner) => inner,
			CreateScalaJarFunctionContext(inner) => inner,
			DropSchemaContext(inner) => inner,
			BeginContext(inner) => inner,
			SetTableAuthorizationContext(inner) => inner,
			DropContext(inner) => inner,
			StartTransactionContext(inner) => inner,
			CreateIcebergTableContext(inner) => inner,
			ShowContext(inner) => inner,
			RevokeContext(inner) => inner,
			UpdateContext(inner) => inner,
			CreateRecursiveTableContext(inner) => inner,
			TableExecuteContext(inner) => inner,
			DeleteContext(inner) => inner,
			DescribeInputContext(inner) => inner,
			SetColumnTypeContext(inner) => inner,
			StatementDefaultContext(inner) => inner,
			CreateJavaFunctionContext(inner) => inner,
			SnowflakeCreateTableUsingTemplateContext(inner) => inner,
			CreateScalaFunctionContext(inner) => inner,
			TruncateTableContext(inner) => inner,
			CreateMaterializedViewContext(inner) => inner,
			CreateViewContext(inner) => inner,
			RenameMaterializedViewContext(inner) => inner,
			DropTableContext(inner) => inner,
			CreateTableCloneContext(inner) => inner,
			SetSchemaAuthorizationContext(inner) => inner,
			RollbackContext(inner) => inner,
			SetContext(inner) => inner,
			CreateSqlFunctionContext(inner) => inner,
			CreatePythonFunctionContext(inner) => inner,
			RenameViewContext(inner) => inner,
			SnowflakeCreateTableAsSelectContext(inner) => inner,
			CallContext(inner) => inner,
			RefreshMaterializedViewContext(inner) => inner,
			CreateExternalTableContext(inner) => inner,
			CommentContext(inner) => inner,
			DescribeOutputContext(inner) => inner,
			GrantContext(inner) => inner,
			SetTablePropertiesContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StatementContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StatementContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type StatementContext<'input> = BaseParserRuleContext<'input,StatementContextExt<'input>>;

#[derive(Clone)]
pub struct StatementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for StatementContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StatementContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StatementContext<'input>{
}

impl<'input> CustomRuleContext<'input> for StatementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}
antlr_rust::tid!{StatementContextExt<'a>}

impl<'input> StatementContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StatementContextAll<'input>> {
		Rc::new(
		StatementContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StatementContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait StatementContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<StatementContextExt<'input>>{


}

impl<'input> StatementContextAttrs<'input> for StatementContext<'input>{}

pub type CreateFooContext<'input> = BaseParserRuleContext<'input,CreateFooContextExt<'input>>;

pub trait CreateFooContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DATABASE
	/// Returns `None` if there is no child corresponding to token DATABASE
	fn DATABASE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DATABASE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
	/// Retrieves first TerminalNode corresponding to token SEQUENCE
	/// Returns `None` if there is no child corresponding to token SEQUENCE
	fn SEQUENCE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEQUENCE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MASKING
	/// Returns `None` if there is no child corresponding to token MASKING
	fn MASKING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MASKING, 0)
	}
	/// Retrieves first TerminalNode corresponding to token POLICY
	/// Returns `None` if there is no child corresponding to token POLICY
	fn POLICY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(POLICY, 0)
	}
}

impl<'input> CreateFooContextAttrs<'input> for CreateFooContext<'input>{}

pub struct CreateFooContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateFooContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateFooContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateFooContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createFoo(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createFoo(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateFooContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createFoo(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateFooContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateFooContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateFooContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateFooContext<'input> {}

impl<'input> CreateFooContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateFooContext(
				BaseParserRuleContext::copy_from(ctx,CreateFooContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ExplainContext<'input> = BaseParserRuleContext<'input,ExplainContextExt<'input>>;

pub trait ExplainContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token EXPLAIN
	/// Returns `None` if there is no child corresponding to token EXPLAIN
	fn EXPLAIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXPLAIN, 0)
	}
	fn statement(&self) -> Option<Rc<StatementContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token USING
	/// Returns `None` if there is no child corresponding to token USING
	fn USING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(USING, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ExplainContextAttrs<'input> for ExplainContext<'input>{}

pub struct ExplainContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ExplainContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ExplainContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ExplainContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_explain(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_explain(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ExplainContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_explain(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExplainContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ExplainContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ExplainContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for ExplainContext<'input> {}

impl<'input> ExplainContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::ExplainContext(
				BaseParserRuleContext::copy_from(ctx,ExplainContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PrepareContext<'input> = BaseParserRuleContext<'input,PrepareContextExt<'input>>;

pub trait PrepareContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token PREPARE
	/// Returns `None` if there is no child corresponding to token PREPARE
	fn PREPARE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PREPARE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> PrepareContextAttrs<'input> for PrepareContext<'input>{}

pub struct PrepareContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PrepareContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PrepareContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PrepareContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_prepare(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_prepare(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PrepareContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_prepare(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrepareContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for PrepareContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for PrepareContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for PrepareContext<'input> {}

impl<'input> PrepareContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::PrepareContext(
				BaseParserRuleContext::copy_from(ctx,PrepareContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeInsertIntoContext<'input> = BaseParserRuleContext<'input,SnowflakeInsertIntoContextExt<'input>>;

pub trait SnowflakeInsertIntoContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token INSERT
	/// Returns `None` if there is no child corresponding to token INSERT
	fn INSERT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INSERT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INTO
	/// Returns `None` if there is no child corresponding to token INTO
	fn INTO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INTO, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token VALUES
	/// Returns `None` if there is no child corresponding to token VALUES
	fn VALUES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VALUES, 0)
	}
	fn snowflakeValueRow_all(&self) ->  Vec<Rc<SnowflakeValueRowContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn snowflakeValueRow(&self, i: usize) -> Option<Rc<SnowflakeValueRowContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> SnowflakeInsertIntoContextAttrs<'input> for SnowflakeInsertIntoContext<'input>{}

pub struct SnowflakeInsertIntoContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeInsertIntoContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeInsertIntoContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeInsertIntoContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeInsertInto(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeInsertInto(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeInsertIntoContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeInsertInto(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeInsertIntoContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SnowflakeInsertIntoContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SnowflakeInsertIntoContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SnowflakeInsertIntoContext<'input> {}

impl<'input> SnowflakeInsertIntoContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SnowflakeInsertIntoContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeInsertIntoContextExt{
					tail:None, 
        			dest:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateAnonymousPythonProcedureContext<'input> = BaseParserRuleContext<'input,CreateAnonymousPythonProcedureContextExt<'input>>;

pub trait CreateAnonymousPythonProcedureContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token WITH
	/// Returns `None` if there is no child corresponding to token WITH
	fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITH, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token AS in current rule
	fn AS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token AS, starting from 0.
	/// Returns `None` if number of children corresponding to token AS is less or equal than `i`.
	fn AS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, i)
	}
	/// Retrieves first TerminalNode corresponding to token PROCEDURE
	/// Returns `None` if there is no child corresponding to token PROCEDURE
	fn PROCEDURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PROCEDURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PYTHON
	/// Returns `None` if there is no child corresponding to token PYTHON
	fn PYTHON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PYTHON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token CALL
	/// Returns `None` if there is no child corresponding to token CALL
	fn CALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALL, 0)
	}
	fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token NULL
	/// Returns `None` if there is no child corresponding to token NULL
	fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token EXECUTE
	/// Returns `None` if there is no child corresponding to token EXECUTE
	fn EXECUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXECUTE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INTO
	/// Returns `None` if there is no child corresponding to token INTO
	fn INTO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INTO, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COLON
	/// Returns `None` if there is no child corresponding to token COLON
	fn COLON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COLON, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	/// Retrieves first TerminalNode corresponding to token OWNER
	/// Returns `None` if there is no child corresponding to token OWNER
	fn OWNER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OWNER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token CALLER
	/// Returns `None` if there is no child corresponding to token CALLER
	fn CALLER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALLER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RESTRICTED
	/// Returns `None` if there is no child corresponding to token RESTRICTED
	fn RESTRICTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RESTRICTED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	fn callArgument_all(&self) ->  Vec<Rc<CallArgumentContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn callArgument(&self, i: usize) -> Option<Rc<CallArgumentContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> CreateAnonymousPythonProcedureContextAttrs<'input> for CreateAnonymousPythonProcedureContext<'input>{}

pub struct CreateAnonymousPythonProcedureContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub tableReturnFieldName:Vec<Rc<IdentifierContextAll<'input>>>,
	pub type_: Option<Rc<Type_ContextAll<'input>>>,
	pub tableReturnFieldType:Vec<Rc<Type_ContextAll<'input>>>,
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateAnonymousPythonProcedureContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateAnonymousPythonProcedureContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateAnonymousPythonProcedureContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createAnonymousPythonProcedure(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createAnonymousPythonProcedure(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateAnonymousPythonProcedureContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createAnonymousPythonProcedure(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateAnonymousPythonProcedureContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateAnonymousPythonProcedureContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateAnonymousPythonProcedureContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateAnonymousPythonProcedureContext<'input> {}

impl<'input> CreateAnonymousPythonProcedureContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateAnonymousPythonProcedureContext(
				BaseParserRuleContext::copy_from(ctx,CreateAnonymousPythonProcedureContextExt{
					tail:None, 
        			name:None, singleReturnType:None, identifier:None, type_:None, body:None, 
        			tableReturnFieldName:Vec::new(), tableReturnFieldType:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SetMaterializedViewPropertiesContext<'input> = BaseParserRuleContext<'input,SetMaterializedViewPropertiesContextExt<'input>>;

pub trait SetMaterializedViewPropertiesContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MATERIALIZED
	/// Returns `None` if there is no child corresponding to token MATERIALIZED
	fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MATERIALIZED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VIEW
	/// Returns `None` if there is no child corresponding to token VIEW
	fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VIEW, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token SET
	/// Returns `None` if there is no child corresponding to token SET
	fn SET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PROPERTIES
	/// Returns `None` if there is no child corresponding to token PROPERTIES
	fn PROPERTIES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PROPERTIES, 0)
	}
	fn propertyAssignments(&self) -> Option<Rc<PropertyAssignmentsContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SetMaterializedViewPropertiesContextAttrs<'input> for SetMaterializedViewPropertiesContext<'input>{}

pub struct SetMaterializedViewPropertiesContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SetMaterializedViewPropertiesContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SetMaterializedViewPropertiesContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetMaterializedViewPropertiesContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_setMaterializedViewProperties(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_setMaterializedViewProperties(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetMaterializedViewPropertiesContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setMaterializedViewProperties(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetMaterializedViewPropertiesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetMaterializedViewPropertiesContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetMaterializedViewPropertiesContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SetMaterializedViewPropertiesContext<'input> {}

impl<'input> SetMaterializedViewPropertiesContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SetMaterializedViewPropertiesContext(
				BaseParserRuleContext::copy_from(ctx,SetMaterializedViewPropertiesContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type UseContext<'input> = BaseParserRuleContext<'input,UseContextExt<'input>>;

pub trait UseContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token USE
	/// Returns `None` if there is no child corresponding to token USE
	fn USE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(USE, 0)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token DOT
	/// Returns `None` if there is no child corresponding to token DOT
	fn DOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOT, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> UseContextAttrs<'input> for UseContext<'input>{}

pub struct UseContextExt<'input>{
	base:StatementContextExt<'input>,
	pub schema: Option<Rc<IdentifierContextAll<'input>>>,
	pub catalog: Option<Rc<IdentifierContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UseContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UseContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UseContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_use(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_use(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UseContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_use(self);
	}
}

impl<'input> CustomRuleContext<'input> for UseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for UseContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for UseContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for UseContext<'input> {}

impl<'input> UseContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::UseContext(
				BaseParserRuleContext::copy_from(ctx,UseContextExt{
        			schema:None, catalog:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DeallocateContext<'input> = BaseParserRuleContext<'input,DeallocateContextExt<'input>>;

pub trait DeallocateContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DEALLOCATE
	/// Returns `None` if there is no child corresponding to token DEALLOCATE
	fn DEALLOCATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DEALLOCATE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> DeallocateContextAttrs<'input> for DeallocateContext<'input>{}

pub struct DeallocateContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DeallocateContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DeallocateContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DeallocateContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_deallocate(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_deallocate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DeallocateContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_deallocate(self);
	}
}

impl<'input> CustomRuleContext<'input> for DeallocateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DeallocateContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DeallocateContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DeallocateContext<'input> {}

impl<'input> DeallocateContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DeallocateContext(
				BaseParserRuleContext::copy_from(ctx,DeallocateContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RenameTableContext<'input> = BaseParserRuleContext<'input,RenameTableContextExt<'input>>;

pub trait RenameTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RENAME
	/// Returns `None` if there is no child corresponding to token RENAME
	fn RENAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RENAME, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TO
	/// Returns `None` if there is no child corresponding to token TO
	fn TO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TO, 0)
	}
	fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token IF
	/// Returns `None` if there is no child corresponding to token IF
	fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
}

impl<'input> RenameTableContextAttrs<'input> for RenameTableContext<'input>{}

pub struct RenameTableContextExt<'input>{
	base:StatementContextExt<'input>,
	pub from: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub to: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RenameTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RenameTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RenameTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_renameTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_renameTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RenameTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_renameTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for RenameTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RenameTableContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RenameTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for RenameTableContext<'input> {}

impl<'input> RenameTableContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::RenameTableContext(
				BaseParserRuleContext::copy_from(ctx,RenameTableContextExt{
        			from:None, to:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CommitContext<'input> = BaseParserRuleContext<'input,CommitContextExt<'input>>;

pub trait CommitContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token COMMIT
	/// Returns `None` if there is no child corresponding to token COMMIT
	fn COMMIT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMIT, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> CommitContextAttrs<'input> for CommitContext<'input>{}

pub struct CommitContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CommitContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CommitContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CommitContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_commit(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_commit(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CommitContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_commit(self);
	}
}

impl<'input> CustomRuleContext<'input> for CommitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CommitContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CommitContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CommitContext<'input> {}

impl<'input> CommitContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CommitContext(
				BaseParserRuleContext::copy_from(ctx,CommitContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateStageContext<'input> = BaseParserRuleContext<'input,CreateStageContextExt<'input>>;

pub trait CreateStageContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STAGE
	/// Returns `None` if there is no child corresponding to token STAGE
	fn STAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STAGE, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TAG
	/// Returns `None` if there is no child corresponding to token TAG
	fn TAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TAG, 0)
	}
	fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token WITH
	/// Returns `None` if there is no child corresponding to token WITH
	fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITH, 0)
	}
}

impl<'input> CreateStageContextAttrs<'input> for CreateStageContext<'input>{}

pub struct CreateStageContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateStageContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateStageContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateStageContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createStage(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createStage(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateStageContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createStage(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateStageContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateStageContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateStageContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateStageContext<'input> {}

impl<'input> CreateStageContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateStageContext(
				BaseParserRuleContext::copy_from(ctx,CreateStageContextExt{
        			dest:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateRoleContext<'input> = BaseParserRuleContext<'input,CreateRoleContextExt<'input>>;

pub trait CreateRoleContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ROLE
	/// Returns `None` if there is no child corresponding to token ROLE
	fn ROLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ROLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> CreateRoleContextAttrs<'input> for CreateRoleContext<'input>{}

pub struct CreateRoleContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateRoleContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateRoleContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateRoleContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createRole(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createRole(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateRoleContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createRole(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateRoleContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateRoleContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateRoleContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateRoleContext<'input> {}

impl<'input> CreateRoleContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateRoleContext(
				BaseParserRuleContext::copy_from(ctx,CreateRoleContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DropViewContext<'input> = BaseParserRuleContext<'input,DropViewContextExt<'input>>;

pub trait DropViewContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DROP
	/// Returns `None` if there is no child corresponding to token DROP
	fn DROP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DROP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VIEW
	/// Returns `None` if there is no child corresponding to token VIEW
	fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VIEW, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> DropViewContextAttrs<'input> for DropViewContext<'input>{}

pub struct DropViewContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DropViewContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DropViewContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DropViewContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropView(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_dropView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DropViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dropView(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropViewContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropViewContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DropViewContext<'input> {}

impl<'input> DropViewContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DropViewContext(
				BaseParserRuleContext::copy_from(ctx,DropViewContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DropColumnContext<'input> = BaseParserRuleContext<'input,DropColumnContextExt<'input>>;

pub trait DropColumnContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DROP
	/// Returns `None` if there is no child corresponding to token DROP
	fn DROP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DROP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COLUMN
	/// Returns `None` if there is no child corresponding to token COLUMN
	fn COLUMN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COLUMN, 0)
	}
	fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
}

impl<'input> DropColumnContextAttrs<'input> for DropColumnContext<'input>{}

pub struct DropColumnContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub column: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DropColumnContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DropColumnContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DropColumnContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropColumn(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_dropColumn(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DropColumnContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dropColumn(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropColumnContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropColumnContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropColumnContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DropColumnContext<'input> {}

impl<'input> DropColumnContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DropColumnContext(
				BaseParserRuleContext::copy_from(ctx,DropColumnContextExt{
        			tableName:None, column:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeCreateTableContext<'input> = BaseParserRuleContext<'input,SnowflakeCreateTableContextExt<'input>>;

pub trait SnowflakeCreateTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	fn snowflakeCreateTableClauses_all(&self) ->  Vec<Rc<SnowflakeCreateTableClausesContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn snowflakeCreateTableClauses(&self, i: usize) -> Option<Rc<SnowflakeCreateTableClausesContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn tableElements(&self) -> Option<Rc<TableElementsContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TRANSIENT
	/// Returns `None` if there is no child corresponding to token TRANSIENT
	fn TRANSIENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TRANSIENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LOCAL
	/// Returns `None` if there is no child corresponding to token LOCAL
	fn LOCAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LOCAL, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GLOBAL
	/// Returns `None` if there is no child corresponding to token GLOBAL
	fn GLOBAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GLOBAL, 0)
	}
}

impl<'input> SnowflakeCreateTableContextAttrs<'input> for SnowflakeCreateTableContext<'input>{}

pub struct SnowflakeCreateTableContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeCreateTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeCreateTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeCreateTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeCreateTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeCreateTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeCreateTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeCreateTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeCreateTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SnowflakeCreateTableContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SnowflakeCreateTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SnowflakeCreateTableContext<'input> {}

impl<'input> SnowflakeCreateTableContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SnowflakeCreateTableContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeCreateTableContextExt{
        			dest:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type UnsetContext<'input> = BaseParserRuleContext<'input,UnsetContextExt<'input>>;

pub trait UnsetContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token UNSET
	/// Returns `None` if there is no child corresponding to token UNSET
	fn UNSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(UNSET, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> UnsetContextAttrs<'input> for UnsetContext<'input>{}

pub struct UnsetContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UnsetContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UnsetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UnsetContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unset(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_unset(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UnsetContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_unset(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnsetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for UnsetContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for UnsetContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for UnsetContext<'input> {}

impl<'input> UnsetContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::UnsetContext(
				BaseParserRuleContext::copy_from(ctx,UnsetContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SetViewAuthorizationContext<'input> = BaseParserRuleContext<'input,SetViewAuthorizationContextExt<'input>>;

pub trait SetViewAuthorizationContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VIEW
	/// Returns `None` if there is no child corresponding to token VIEW
	fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VIEW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SET
	/// Returns `None` if there is no child corresponding to token SET
	fn SET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AUTHORIZATION
	/// Returns `None` if there is no child corresponding to token AUTHORIZATION
	fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AUTHORIZATION, 0)
	}
	fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SetViewAuthorizationContextAttrs<'input> for SetViewAuthorizationContext<'input>{}

pub struct SetViewAuthorizationContextExt<'input>{
	base:StatementContextExt<'input>,
	pub from: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SetViewAuthorizationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SetViewAuthorizationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetViewAuthorizationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_setViewAuthorization(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_setViewAuthorization(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetViewAuthorizationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setViewAuthorization(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetViewAuthorizationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetViewAuthorizationContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetViewAuthorizationContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SetViewAuthorizationContext<'input> {}

impl<'input> SetViewAuthorizationContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SetViewAuthorizationContext(
				BaseParserRuleContext::copy_from(ctx,SetViewAuthorizationContextExt{
        			from:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type MergeContext<'input> = BaseParserRuleContext<'input,MergeContextExt<'input>>;

pub trait MergeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token MERGE
	/// Returns `None` if there is no child corresponding to token MERGE
	fn MERGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MERGE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> MergeContextAttrs<'input> for MergeContext<'input>{}

pub struct MergeContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{MergeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for MergeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for MergeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_merge(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_merge(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for MergeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_merge(self);
	}
}

impl<'input> CustomRuleContext<'input> for MergeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for MergeContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for MergeContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for MergeContext<'input> {}

impl<'input> MergeContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::MergeContext(
				BaseParserRuleContext::copy_from(ctx,MergeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RenameColumnContext<'input> = BaseParserRuleContext<'input,RenameColumnContextExt<'input>>;

pub trait RenameColumnContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RENAME
	/// Returns `None` if there is no child corresponding to token RENAME
	fn RENAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RENAME, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COLUMN
	/// Returns `None` if there is no child corresponding to token COLUMN
	fn COLUMN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COLUMN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TO
	/// Returns `None` if there is no child corresponding to token TO
	fn TO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TO, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
}

impl<'input> RenameColumnContextAttrs<'input> for RenameColumnContext<'input>{}

pub struct RenameColumnContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub from: Option<Rc<IdentifierContextAll<'input>>>,
	pub to: Option<Rc<IdentifierContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RenameColumnContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RenameColumnContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RenameColumnContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_renameColumn(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_renameColumn(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RenameColumnContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_renameColumn(self);
	}
}

impl<'input> CustomRuleContext<'input> for RenameColumnContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RenameColumnContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RenameColumnContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for RenameColumnContext<'input> {}

impl<'input> RenameColumnContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::RenameColumnContext(
				BaseParserRuleContext::copy_from(ctx,RenameColumnContextExt{
        			tableName:None, from:None, to:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ShowColumnsContext<'input> = BaseParserRuleContext<'input,ShowColumnsContextExt<'input>>;

pub trait ShowColumnsContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DESCRIBE
	/// Returns `None` if there is no child corresponding to token DESCRIBE
	fn DESCRIBE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DESCRIBE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DESC
	/// Returns `None` if there is no child corresponding to token DESC
	fn DESC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DESC, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ShowColumnsContextAttrs<'input> for ShowColumnsContext<'input>{}

pub struct ShowColumnsContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ShowColumnsContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ShowColumnsContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ShowColumnsContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_showColumns(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_showColumns(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ShowColumnsContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_showColumns(self);
	}
}

impl<'input> CustomRuleContext<'input> for ShowColumnsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowColumnsContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowColumnsContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for ShowColumnsContext<'input> {}

impl<'input> ShowColumnsContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::ShowColumnsContext(
				BaseParserRuleContext::copy_from(ctx,ShowColumnsContextExt{
        			tableName:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateModuleFunctionContext<'input> = BaseParserRuleContext<'input,CreateModuleFunctionContextExt<'input>>;

pub trait CreateModuleFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FUNCTION
	/// Returns `None` if there is no child corresponding to token FUNCTION
	fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FUNCTION, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PYTHON
	/// Returns `None` if there is no child corresponding to token PYTHON
	fn PYTHON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PYTHON, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NULL in current rule
	fn NULL_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NULL, starting from 0.
	/// Returns `None` if number of children corresponding to token NULL is less or equal than `i`.
	fn NULL(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, i)
	}
	/// Retrieves first TerminalNode corresponding to token CALLED
	/// Returns `None` if there is no child corresponding to token CALLED
	fn CALLED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALLED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INPUT
	/// Returns `None` if there is no child corresponding to token INPUT
	fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INPUT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RETURN
	/// Returns `None` if there is no child corresponding to token RETURN
	fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STRICT
	/// Returns `None` if there is no child corresponding to token STRICT
	fn STRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRICT, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IMMUTABLE
	/// Returns `None` if there is no child corresponding to token IMMUTABLE
	fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IMMUTABLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> CreateModuleFunctionContextAttrs<'input> for CreateModuleFunctionContext<'input>{}

pub struct CreateModuleFunctionContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub tableReturnFieldName:Vec<Rc<IdentifierContextAll<'input>>>,
	pub type_: Option<Rc<Type_ContextAll<'input>>>,
	pub tableReturnFieldType:Vec<Rc<Type_ContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateModuleFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateModuleFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateModuleFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createModuleFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createModuleFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateModuleFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createModuleFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateModuleFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateModuleFunctionContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateModuleFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateModuleFunctionContext<'input> {}

impl<'input> CreateModuleFunctionContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateModuleFunctionContext(
				BaseParserRuleContext::copy_from(ctx,CreateModuleFunctionContextExt{
					tail:None, 
        			name:None, singleReturnType:None, identifier:None, type_:None, 
        			tableReturnFieldName:Vec::new(), tableReturnFieldType:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type AlterContext<'input> = BaseParserRuleContext<'input,AlterContextExt<'input>>;

pub trait AlterContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> AlterContextAttrs<'input> for AlterContext<'input>{}

pub struct AlterContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{AlterContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for AlterContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AlterContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_alter(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_alter(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AlterContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_alter(self);
	}
}

impl<'input> CustomRuleContext<'input> for AlterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for AlterContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for AlterContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for AlterContext<'input> {}

impl<'input> AlterContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::AlterContext(
				BaseParserRuleContext::copy_from(ctx,AlterContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type AddColumnContext<'input> = BaseParserRuleContext<'input,AddColumnContextExt<'input>>;

pub trait AddColumnContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ADD
	/// Returns `None` if there is no child corresponding to token ADD
	fn ADD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ADD, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COLUMN
	/// Returns `None` if there is no child corresponding to token COLUMN
	fn COLUMN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COLUMN, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn columnDefinition(&self) -> Option<Rc<ColumnDefinitionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> AddColumnContextAttrs<'input> for AddColumnContext<'input>{}

pub struct AddColumnContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub column: Option<Rc<ColumnDefinitionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{AddColumnContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for AddColumnContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AddColumnContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_addColumn(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_addColumn(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AddColumnContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_addColumn(self);
	}
}

impl<'input> CustomRuleContext<'input> for AddColumnContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for AddColumnContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for AddColumnContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for AddColumnContext<'input> {}

impl<'input> AddColumnContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::AddColumnContext(
				BaseParserRuleContext::copy_from(ctx,AddColumnContextExt{
        			tableName:None, column:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DenyContext<'input> = BaseParserRuleContext<'input,DenyContextExt<'input>>;

pub trait DenyContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DENY
	/// Returns `None` if there is no child corresponding to token DENY
	fn DENY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DENY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TO
	/// Returns `None` if there is no child corresponding to token TO
	fn TO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TO, 0)
	}
	fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn privilege_all(&self) ->  Vec<Rc<PrivilegeContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn privilege(&self, i: usize) -> Option<Rc<PrivilegeContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token ALL
	/// Returns `None` if there is no child corresponding to token ALL
	fn ALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALL, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PRIVILEGES
	/// Returns `None` if there is no child corresponding to token PRIVILEGES
	fn PRIVILEGES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PRIVILEGES, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SCHEMA
	/// Returns `None` if there is no child corresponding to token SCHEMA
	fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SCHEMA, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> DenyContextAttrs<'input> for DenyContext<'input>{}

pub struct DenyContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	pub grantee: Option<Rc<PrincipalContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DenyContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DenyContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DenyContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_deny(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_deny(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DenyContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_deny(self);
	}
}

impl<'input> CustomRuleContext<'input> for DenyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DenyContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DenyContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DenyContext<'input> {}

impl<'input> DenyContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DenyContext(
				BaseParserRuleContext::copy_from(ctx,DenyContextExt{
					tail:None, 
        			grantee:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateEventTableContext<'input> = BaseParserRuleContext<'input,CreateEventTableContextExt<'input>>;

pub trait CreateEventTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EVENT
	/// Returns `None` if there is no child corresponding to token EVENT
	fn EVENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EVENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token CLONE
	/// Returns `None` if there is no child corresponding to token CLONE
	fn CLONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CLONE, 0)
	}
	fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IF
	/// Returns `None` if there is no child corresponding to token IF
	fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AT
	/// Returns `None` if there is no child corresponding to token AT
	fn AT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token BEFORE
	/// Returns `None` if there is no child corresponding to token BEFORE
	fn BEFORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BEFORE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TIMESTAMP
	/// Returns `None` if there is no child corresponding to token TIMESTAMP
	fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TIMESTAMP, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OFFSET
	/// Returns `None` if there is no child corresponding to token OFFSET
	fn OFFSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OFFSET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STATEMENT
	/// Returns `None` if there is no child corresponding to token STATEMENT
	fn STATEMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STATEMENT, 0)
	}
}

impl<'input> CreateEventTableContextAttrs<'input> for CreateEventTableContext<'input>{}

pub struct CreateEventTableContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub src: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateEventTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateEventTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateEventTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createEventTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createEventTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateEventTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createEventTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateEventTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateEventTableContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateEventTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateEventTableContext<'input> {}

impl<'input> CreateEventTableContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateEventTableContext(
				BaseParserRuleContext::copy_from(ctx,CreateEventTableContextExt{
        			dest:None, src:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateDynamicTableContext<'input> = BaseParserRuleContext<'input,CreateDynamicTableContextExt<'input>>;

pub trait CreateDynamicTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DYNAMIC
	/// Returns `None` if there is no child corresponding to token DYNAMIC
	fn DYNAMIC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DYNAMIC, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token CLONE
	/// Returns `None` if there is no child corresponding to token CLONE
	fn CLONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CLONE, 0)
	}
	fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IF
	/// Returns `None` if there is no child corresponding to token IF
	fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TARGET_LAG
	/// Returns `None` if there is no child corresponding to token TARGET_LAG
	fn TARGET_LAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TARGET_LAG, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EQ in current rule
	fn EQ_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EQ, starting from 0.
	/// Returns `None` if number of children corresponding to token EQ is less or equal than `i`.
	fn EQ(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EQ, i)
	}
	/// Retrieves first TerminalNode corresponding to token WAREHOUSE
	/// Returns `None` if there is no child corresponding to token WAREHOUSE
	fn WAREHOUSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WAREHOUSE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AT
	/// Returns `None` if there is no child corresponding to token AT
	fn AT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token BEFORE
	/// Returns `None` if there is no child corresponding to token BEFORE
	fn BEFORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BEFORE, 0)
	}
	fn string_all(&self) ->  Vec<Rc<StringContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TIMESTAMP
	/// Returns `None` if there is no child corresponding to token TIMESTAMP
	fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TIMESTAMP, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OFFSET
	/// Returns `None` if there is no child corresponding to token OFFSET
	fn OFFSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OFFSET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STATEMENT
	/// Returns `None` if there is no child corresponding to token STATEMENT
	fn STATEMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STATEMENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DOWNSTREAM
	/// Returns `None` if there is no child corresponding to token DOWNSTREAM
	fn DOWNSTREAM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOWNSTREAM, 0)
	}
}

impl<'input> CreateDynamicTableContextAttrs<'input> for CreateDynamicTableContext<'input>{}

pub struct CreateDynamicTableContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub src: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub lag: Option<Rc<StringContextAll<'input>>>,
	pub warehouseName: Option<Rc<StringContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateDynamicTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateDynamicTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateDynamicTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createDynamicTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createDynamicTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateDynamicTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createDynamicTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateDynamicTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateDynamicTableContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateDynamicTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateDynamicTableContext<'input> {}

impl<'input> CreateDynamicTableContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateDynamicTableContext(
				BaseParserRuleContext::copy_from(ctx,CreateDynamicTableContextExt{
        			dest:None, src:None, lag:None, warehouseName:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateSchemaContext<'input> = BaseParserRuleContext<'input,CreateSchemaContextExt<'input>>;

pub trait CreateSchemaContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SCHEMA
	/// Returns `None` if there is no child corresponding to token SCHEMA
	fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SCHEMA, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> CreateSchemaContextAttrs<'input> for CreateSchemaContext<'input>{}

pub struct CreateSchemaContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateSchemaContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateSchemaContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateSchemaContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createSchema(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createSchema(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateSchemaContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createSchema(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateSchemaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateSchemaContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateSchemaContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateSchemaContext<'input> {}

impl<'input> CreateSchemaContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateSchemaContext(
				BaseParserRuleContext::copy_from(ctx,CreateSchemaContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ExecuteContext<'input> = BaseParserRuleContext<'input,ExecuteContextExt<'input>>;

pub trait ExecuteContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token EXECUTE
	/// Returns `None` if there is no child corresponding to token EXECUTE
	fn EXECUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXECUTE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> ExecuteContextAttrs<'input> for ExecuteContext<'input>{}

pub struct ExecuteContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ExecuteContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ExecuteContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ExecuteContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_execute(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_execute(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ExecuteContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_execute(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExecuteContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ExecuteContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ExecuteContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for ExecuteContext<'input> {}

impl<'input> ExecuteContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::ExecuteContext(
				BaseParserRuleContext::copy_from(ctx,ExecuteContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateJSFunctionContext<'input> = BaseParserRuleContext<'input,CreateJSFunctionContextExt<'input>>;

pub trait CreateJSFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FUNCTION
	/// Returns `None` if there is no child corresponding to token FUNCTION
	fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FUNCTION, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token JAVASCRIPT
	/// Returns `None` if there is no child corresponding to token JAVASCRIPT
	fn JAVASCRIPT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(JAVASCRIPT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NULL in current rule
	fn NULL_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NULL, starting from 0.
	/// Returns `None` if number of children corresponding to token NULL is less or equal than `i`.
	fn NULL(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, i)
	}
	/// Retrieves first TerminalNode corresponding to token CALLED
	/// Returns `None` if there is no child corresponding to token CALLED
	fn CALLED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALLED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INPUT
	/// Returns `None` if there is no child corresponding to token INPUT
	fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INPUT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RETURN
	/// Returns `None` if there is no child corresponding to token RETURN
	fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STRICT
	/// Returns `None` if there is no child corresponding to token STRICT
	fn STRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRICT, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IMMUTABLE
	/// Returns `None` if there is no child corresponding to token IMMUTABLE
	fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IMMUTABLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> CreateJSFunctionContextAttrs<'input> for CreateJSFunctionContext<'input>{}

pub struct CreateJSFunctionContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub tableReturnFieldName:Vec<Rc<IdentifierContextAll<'input>>>,
	pub type_: Option<Rc<Type_ContextAll<'input>>>,
	pub tableReturnFieldType:Vec<Rc<Type_ContextAll<'input>>>,
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateJSFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateJSFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateJSFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createJSFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createJSFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateJSFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createJSFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateJSFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateJSFunctionContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateJSFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateJSFunctionContext<'input> {}

impl<'input> CreateJSFunctionContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateJSFunctionContext(
				BaseParserRuleContext::copy_from(ctx,CreateJSFunctionContextExt{
					tail:None, 
        			name:None, singleReturnType:None, identifier:None, type_:None, body:None, 
        			tableReturnFieldName:Vec::new(), tableReturnFieldType:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateJarFunctionContext<'input> = BaseParserRuleContext<'input,CreateJarFunctionContextExt<'input>>;

pub trait CreateJarFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FUNCTION
	/// Returns `None` if there is no child corresponding to token FUNCTION
	fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FUNCTION, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token JAVA
	/// Returns `None` if there is no child corresponding to token JAVA
	fn JAVA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(JAVA, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NULL in current rule
	fn NULL_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NULL, starting from 0.
	/// Returns `None` if number of children corresponding to token NULL is less or equal than `i`.
	fn NULL(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, i)
	}
	/// Retrieves first TerminalNode corresponding to token CALLED
	/// Returns `None` if there is no child corresponding to token CALLED
	fn CALLED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALLED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INPUT
	/// Returns `None` if there is no child corresponding to token INPUT
	fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INPUT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RETURN
	/// Returns `None` if there is no child corresponding to token RETURN
	fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STRICT
	/// Returns `None` if there is no child corresponding to token STRICT
	fn STRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRICT, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IMMUTABLE
	/// Returns `None` if there is no child corresponding to token IMMUTABLE
	fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IMMUTABLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> CreateJarFunctionContextAttrs<'input> for CreateJarFunctionContext<'input>{}

pub struct CreateJarFunctionContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub tableReturnFieldName:Vec<Rc<IdentifierContextAll<'input>>>,
	pub type_: Option<Rc<Type_ContextAll<'input>>>,
	pub tableReturnFieldType:Vec<Rc<Type_ContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateJarFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateJarFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateJarFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createJarFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createJarFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateJarFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createJarFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateJarFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateJarFunctionContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateJarFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateJarFunctionContext<'input> {}

impl<'input> CreateJarFunctionContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateJarFunctionContext(
				BaseParserRuleContext::copy_from(ctx,CreateJarFunctionContextExt{
					tail:None, 
        			name:None, singleReturnType:None, identifier:None, type_:None, 
        			tableReturnFieldName:Vec::new(), tableReturnFieldType:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RenameSchemaContext<'input> = BaseParserRuleContext<'input,RenameSchemaContextExt<'input>>;

pub trait RenameSchemaContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SCHEMA
	/// Returns `None` if there is no child corresponding to token SCHEMA
	fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SCHEMA, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RENAME
	/// Returns `None` if there is no child corresponding to token RENAME
	fn RENAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RENAME, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TO
	/// Returns `None` if there is no child corresponding to token TO
	fn TO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TO, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> RenameSchemaContextAttrs<'input> for RenameSchemaContext<'input>{}

pub struct RenameSchemaContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RenameSchemaContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RenameSchemaContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RenameSchemaContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_renameSchema(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_renameSchema(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RenameSchemaContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_renameSchema(self);
	}
}

impl<'input> CustomRuleContext<'input> for RenameSchemaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RenameSchemaContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RenameSchemaContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for RenameSchemaContext<'input> {}

impl<'input> RenameSchemaContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::RenameSchemaContext(
				BaseParserRuleContext::copy_from(ctx,RenameSchemaContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreatePythonProcedureContext<'input> = BaseParserRuleContext<'input,CreatePythonProcedureContextExt<'input>>;

pub trait CreatePythonProcedureContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PROCEDURE
	/// Returns `None` if there is no child corresponding to token PROCEDURE
	fn PROCEDURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PROCEDURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PYTHON
	/// Returns `None` if there is no child corresponding to token PYTHON
	fn PYTHON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PYTHON, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token NULL
	/// Returns `None` if there is no child corresponding to token NULL
	fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> CreatePythonProcedureContextAttrs<'input> for CreatePythonProcedureContext<'input>{}

pub struct CreatePythonProcedureContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub tableReturnFieldName:Vec<Rc<IdentifierContextAll<'input>>>,
	pub type_: Option<Rc<Type_ContextAll<'input>>>,
	pub tableReturnFieldType:Vec<Rc<Type_ContextAll<'input>>>,
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreatePythonProcedureContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreatePythonProcedureContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreatePythonProcedureContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createPythonProcedure(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createPythonProcedure(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreatePythonProcedureContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createPythonProcedure(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreatePythonProcedureContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreatePythonProcedureContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreatePythonProcedureContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreatePythonProcedureContext<'input> {}

impl<'input> CreatePythonProcedureContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreatePythonProcedureContext(
				BaseParserRuleContext::copy_from(ctx,CreatePythonProcedureContextExt{
					tail:None, 
        			name:None, singleReturnType:None, identifier:None, type_:None, body:None, 
        			tableReturnFieldName:Vec::new(), tableReturnFieldType:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type AnalyzeContext<'input> = BaseParserRuleContext<'input,AnalyzeContextExt<'input>>;

pub trait AnalyzeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ANALYZE
	/// Returns `None` if there is no child corresponding to token ANALYZE
	fn ANALYZE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ANALYZE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> AnalyzeContextAttrs<'input> for AnalyzeContext<'input>{}

pub struct AnalyzeContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{AnalyzeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for AnalyzeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AnalyzeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_analyze(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_analyze(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AnalyzeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_analyze(self);
	}
}

impl<'input> CustomRuleContext<'input> for AnalyzeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for AnalyzeContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for AnalyzeContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for AnalyzeContext<'input> {}

impl<'input> AnalyzeContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::AnalyzeContext(
				BaseParserRuleContext::copy_from(ctx,AnalyzeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ResetContext<'input> = BaseParserRuleContext<'input,ResetContextExt<'input>>;

pub trait ResetContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token RESET
	/// Returns `None` if there is no child corresponding to token RESET
	fn RESET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RESET, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> ResetContextAttrs<'input> for ResetContext<'input>{}

pub struct ResetContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ResetContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ResetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ResetContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_reset(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_reset(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ResetContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_reset(self);
	}
}

impl<'input> CustomRuleContext<'input> for ResetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ResetContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ResetContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for ResetContext<'input> {}

impl<'input> ResetContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::ResetContext(
				BaseParserRuleContext::copy_from(ctx,ResetContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateScalaJarFunctionContext<'input> = BaseParserRuleContext<'input,CreateScalaJarFunctionContextExt<'input>>;

pub trait CreateScalaJarFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FUNCTION
	/// Returns `None` if there is no child corresponding to token FUNCTION
	fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FUNCTION, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SCALA
	/// Returns `None` if there is no child corresponding to token SCALA
	fn SCALA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SCALA, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NULL in current rule
	fn NULL_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NULL, starting from 0.
	/// Returns `None` if number of children corresponding to token NULL is less or equal than `i`.
	fn NULL(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, i)
	}
	/// Retrieves first TerminalNode corresponding to token CALLED
	/// Returns `None` if there is no child corresponding to token CALLED
	fn CALLED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALLED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INPUT
	/// Returns `None` if there is no child corresponding to token INPUT
	fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INPUT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RETURN
	/// Returns `None` if there is no child corresponding to token RETURN
	fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STRICT
	/// Returns `None` if there is no child corresponding to token STRICT
	fn STRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRICT, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IMMUTABLE
	/// Returns `None` if there is no child corresponding to token IMMUTABLE
	fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IMMUTABLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> CreateScalaJarFunctionContextAttrs<'input> for CreateScalaJarFunctionContext<'input>{}

pub struct CreateScalaJarFunctionContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateScalaJarFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateScalaJarFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateScalaJarFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createScalaJarFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createScalaJarFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateScalaJarFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createScalaJarFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateScalaJarFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateScalaJarFunctionContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateScalaJarFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateScalaJarFunctionContext<'input> {}

impl<'input> CreateScalaJarFunctionContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateScalaJarFunctionContext(
				BaseParserRuleContext::copy_from(ctx,CreateScalaJarFunctionContextExt{
					tail:None, 
        			name:None, singleReturnType:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DropSchemaContext<'input> = BaseParserRuleContext<'input,DropSchemaContextExt<'input>>;

pub trait DropSchemaContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DROP
	/// Returns `None` if there is no child corresponding to token DROP
	fn DROP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DROP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SCHEMA
	/// Returns `None` if there is no child corresponding to token SCHEMA
	fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SCHEMA, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token IF
	/// Returns `None` if there is no child corresponding to token IF
	fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> DropSchemaContextAttrs<'input> for DropSchemaContext<'input>{}

pub struct DropSchemaContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DropSchemaContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DropSchemaContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DropSchemaContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropSchema(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_dropSchema(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DropSchemaContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dropSchema(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropSchemaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropSchemaContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropSchemaContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DropSchemaContext<'input> {}

impl<'input> DropSchemaContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DropSchemaContext(
				BaseParserRuleContext::copy_from(ctx,DropSchemaContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type BeginContext<'input> = BaseParserRuleContext<'input,BeginContextExt<'input>>;

pub trait BeginContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token BEGIN
	/// Returns `None` if there is no child corresponding to token BEGIN
	fn BEGIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BEGIN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> BeginContextAttrs<'input> for BeginContext<'input>{}

pub struct BeginContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{BeginContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for BeginContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for BeginContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_begin(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_begin(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for BeginContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_begin(self);
	}
}

impl<'input> CustomRuleContext<'input> for BeginContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for BeginContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for BeginContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for BeginContext<'input> {}

impl<'input> BeginContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::BeginContext(
				BaseParserRuleContext::copy_from(ctx,BeginContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SetTableAuthorizationContext<'input> = BaseParserRuleContext<'input,SetTableAuthorizationContextExt<'input>>;

pub trait SetTableAuthorizationContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SET
	/// Returns `None` if there is no child corresponding to token SET
	fn SET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AUTHORIZATION
	/// Returns `None` if there is no child corresponding to token AUTHORIZATION
	fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AUTHORIZATION, 0)
	}
	fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SetTableAuthorizationContextAttrs<'input> for SetTableAuthorizationContext<'input>{}

pub struct SetTableAuthorizationContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SetTableAuthorizationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SetTableAuthorizationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetTableAuthorizationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_setTableAuthorization(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_setTableAuthorization(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetTableAuthorizationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setTableAuthorization(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetTableAuthorizationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetTableAuthorizationContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetTableAuthorizationContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SetTableAuthorizationContext<'input> {}

impl<'input> SetTableAuthorizationContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SetTableAuthorizationContext(
				BaseParserRuleContext::copy_from(ctx,SetTableAuthorizationContextExt{
        			tableName:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DropContext<'input> = BaseParserRuleContext<'input,DropContextExt<'input>>;

pub trait DropContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DROP
	/// Returns `None` if there is no child corresponding to token DROP
	fn DROP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DROP, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> DropContextAttrs<'input> for DropContext<'input>{}

pub struct DropContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DropContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DropContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DropContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_drop(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_drop(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DropContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_drop(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DropContext<'input> {}

impl<'input> DropContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DropContext(
				BaseParserRuleContext::copy_from(ctx,DropContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type StartTransactionContext<'input> = BaseParserRuleContext<'input,StartTransactionContextExt<'input>>;

pub trait StartTransactionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token START
	/// Returns `None` if there is no child corresponding to token START
	fn START(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(START, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TRANSACTION
	/// Returns `None` if there is no child corresponding to token TRANSACTION
	fn TRANSACTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TRANSACTION, 0)
	}
	fn transactionMode_all(&self) ->  Vec<Rc<TransactionModeContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn transactionMode(&self, i: usize) -> Option<Rc<TransactionModeContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> StartTransactionContextAttrs<'input> for StartTransactionContext<'input>{}

pub struct StartTransactionContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{StartTransactionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for StartTransactionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StartTransactionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_startTransaction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_startTransaction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StartTransactionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_startTransaction(self);
	}
}

impl<'input> CustomRuleContext<'input> for StartTransactionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for StartTransactionContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for StartTransactionContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for StartTransactionContext<'input> {}

impl<'input> StartTransactionContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::StartTransactionContext(
				BaseParserRuleContext::copy_from(ctx,StartTransactionContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateIcebergTableContext<'input> = BaseParserRuleContext<'input,CreateIcebergTableContextExt<'input>>;

pub trait CreateIcebergTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ICEBERG
	/// Returns `None` if there is no child corresponding to token ICEBERG
	fn ICEBERG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ICEBERG, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token CLONE
	/// Returns `None` if there is no child corresponding to token CLONE
	fn CLONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CLONE, 0)
	}
	fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IF
	/// Returns `None` if there is no child corresponding to token IF
	fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AT
	/// Returns `None` if there is no child corresponding to token AT
	fn AT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token BEFORE
	/// Returns `None` if there is no child corresponding to token BEFORE
	fn BEFORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BEFORE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TIMESTAMP
	/// Returns `None` if there is no child corresponding to token TIMESTAMP
	fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TIMESTAMP, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OFFSET
	/// Returns `None` if there is no child corresponding to token OFFSET
	fn OFFSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OFFSET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STATEMENT
	/// Returns `None` if there is no child corresponding to token STATEMENT
	fn STATEMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STATEMENT, 0)
	}
}

impl<'input> CreateIcebergTableContextAttrs<'input> for CreateIcebergTableContext<'input>{}

pub struct CreateIcebergTableContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub src: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateIcebergTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateIcebergTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateIcebergTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createIcebergTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createIcebergTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateIcebergTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createIcebergTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateIcebergTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateIcebergTableContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateIcebergTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateIcebergTableContext<'input> {}

impl<'input> CreateIcebergTableContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateIcebergTableContext(
				BaseParserRuleContext::copy_from(ctx,CreateIcebergTableContextExt{
        			dest:None, src:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ShowContext<'input> = BaseParserRuleContext<'input,ShowContextExt<'input>>;

pub trait ShowContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token SHOW
	/// Returns `None` if there is no child corresponding to token SHOW
	fn SHOW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SHOW, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> ShowContextAttrs<'input> for ShowContext<'input>{}

pub struct ShowContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ShowContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ShowContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ShowContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_show(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_show(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ShowContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_show(self);
	}
}

impl<'input> CustomRuleContext<'input> for ShowContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for ShowContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for ShowContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for ShowContext<'input> {}

impl<'input> ShowContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::ShowContext(
				BaseParserRuleContext::copy_from(ctx,ShowContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RevokeContext<'input> = BaseParserRuleContext<'input,RevokeContextExt<'input>>;

pub trait RevokeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token REVOKE
	/// Returns `None` if there is no child corresponding to token REVOKE
	fn REVOKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REVOKE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> RevokeContextAttrs<'input> for RevokeContext<'input>{}

pub struct RevokeContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RevokeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RevokeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RevokeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_revoke(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_revoke(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RevokeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_revoke(self);
	}
}

impl<'input> CustomRuleContext<'input> for RevokeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RevokeContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RevokeContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for RevokeContext<'input> {}

impl<'input> RevokeContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::RevokeContext(
				BaseParserRuleContext::copy_from(ctx,RevokeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type UpdateContext<'input> = BaseParserRuleContext<'input,UpdateContextExt<'input>>;

pub trait UpdateContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token UPDATE
	/// Returns `None` if there is no child corresponding to token UPDATE
	fn UPDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(UPDATE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> UpdateContextAttrs<'input> for UpdateContext<'input>{}

pub struct UpdateContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UpdateContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UpdateContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UpdateContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_update(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_update(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UpdateContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_update(self);
	}
}

impl<'input> CustomRuleContext<'input> for UpdateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for UpdateContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for UpdateContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for UpdateContext<'input> {}

impl<'input> UpdateContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::UpdateContext(
				BaseParserRuleContext::copy_from(ctx,UpdateContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateRecursiveTableContext<'input> = BaseParserRuleContext<'input,CreateRecursiveTableContextExt<'input>>;

pub trait CreateRecursiveTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RECURSIVE
	/// Returns `None` if there is no child corresponding to token RECURSIVE
	fn RECURSIVE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RECURSIVE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IF
	/// Returns `None` if there is no child corresponding to token IF
	fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
	fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token COMMENT
	/// Returns `None` if there is no child corresponding to token COMMENT
	fn COMMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token WITH
	/// Returns `None` if there is no child corresponding to token WITH
	fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITH, 0)
	}
	fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> CreateRecursiveTableContextAttrs<'input> for CreateRecursiveTableContext<'input>{}

pub struct CreateRecursiveTableContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub comment: Option<Rc<StringContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateRecursiveTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateRecursiveTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateRecursiveTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createRecursiveTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createRecursiveTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateRecursiveTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createRecursiveTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateRecursiveTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateRecursiveTableContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateRecursiveTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateRecursiveTableContext<'input> {}

impl<'input> CreateRecursiveTableContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateRecursiveTableContext(
				BaseParserRuleContext::copy_from(ctx,CreateRecursiveTableContextExt{
        			dest:None, comment:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TableExecuteContext<'input> = BaseParserRuleContext<'input,TableExecuteContextExt<'input>>;

pub trait TableExecuteContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXECUTE
	/// Returns `None` if there is no child corresponding to token EXECUTE
	fn EXECUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXECUTE, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token WHERE
	/// Returns `None` if there is no child corresponding to token WHERE
	fn WHERE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WHERE, 0)
	}
	fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn callArgument_all(&self) ->  Vec<Rc<CallArgumentContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn callArgument(&self, i: usize) -> Option<Rc<CallArgumentContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> TableExecuteContextAttrs<'input> for TableExecuteContext<'input>{}

pub struct TableExecuteContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub procedureName: Option<Rc<IdentifierContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub where_: Option<Rc<BooleanExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TableExecuteContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TableExecuteContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableExecuteContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tableExecute(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_tableExecute(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableExecuteContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableExecute(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableExecuteContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for TableExecuteContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for TableExecuteContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for TableExecuteContext<'input> {}

impl<'input> TableExecuteContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::TableExecuteContext(
				BaseParserRuleContext::copy_from(ctx,TableExecuteContextExt{
					tail:None, 
        			tableName:None, procedureName:None, where_:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DeleteContext<'input> = BaseParserRuleContext<'input,DeleteContextExt<'input>>;

pub trait DeleteContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DELETE
	/// Returns `None` if there is no child corresponding to token DELETE
	fn DELETE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DELETE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> DeleteContextAttrs<'input> for DeleteContext<'input>{}

pub struct DeleteContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DeleteContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DeleteContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DeleteContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_delete(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_delete(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DeleteContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_delete(self);
	}
}

impl<'input> CustomRuleContext<'input> for DeleteContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DeleteContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DeleteContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DeleteContext<'input> {}

impl<'input> DeleteContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DeleteContext(
				BaseParserRuleContext::copy_from(ctx,DeleteContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DescribeInputContext<'input> = BaseParserRuleContext<'input,DescribeInputContextExt<'input>>;

pub trait DescribeInputContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DESCRIBE
	/// Returns `None` if there is no child corresponding to token DESCRIBE
	fn DESCRIBE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DESCRIBE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INPUT
	/// Returns `None` if there is no child corresponding to token INPUT
	fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INPUT, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> DescribeInputContextAttrs<'input> for DescribeInputContext<'input>{}

pub struct DescribeInputContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DescribeInputContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DescribeInputContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DescribeInputContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_describeInput(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_describeInput(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DescribeInputContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_describeInput(self);
	}
}

impl<'input> CustomRuleContext<'input> for DescribeInputContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DescribeInputContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DescribeInputContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DescribeInputContext<'input> {}

impl<'input> DescribeInputContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DescribeInputContext(
				BaseParserRuleContext::copy_from(ctx,DescribeInputContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SetColumnTypeContext<'input> = BaseParserRuleContext<'input,SetColumnTypeContextExt<'input>>;

pub trait SetColumnTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves all `TerminalNode`s corresponding to token ALTER in current rule
	fn ALTER_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token ALTER, starting from 0.
	/// Returns `None` if number of children corresponding to token ALTER is less or equal than `i`.
	fn ALTER(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, i)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COLUMN
	/// Returns `None` if there is no child corresponding to token COLUMN
	fn COLUMN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COLUMN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SET
	/// Returns `None` if there is no child corresponding to token SET
	fn SET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DATA
	/// Returns `None` if there is no child corresponding to token DATA
	fn DATA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DATA, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TYPE
	/// Returns `None` if there is no child corresponding to token TYPE
	fn TYPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TYPE, 0)
	}
	fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token IF
	/// Returns `None` if there is no child corresponding to token IF
	fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
}

impl<'input> SetColumnTypeContextAttrs<'input> for SetColumnTypeContext<'input>{}

pub struct SetColumnTypeContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub setColumnName: Option<Rc<IdentifierContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SetColumnTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SetColumnTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetColumnTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_setColumnType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_setColumnType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetColumnTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setColumnType(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetColumnTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetColumnTypeContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetColumnTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SetColumnTypeContext<'input> {}

impl<'input> SetColumnTypeContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SetColumnTypeContext(
				BaseParserRuleContext::copy_from(ctx,SetColumnTypeContextExt{
        			tableName:None, setColumnName:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type StatementDefaultContext<'input> = BaseParserRuleContext<'input,StatementDefaultContextExt<'input>>;

pub trait StatementDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> StatementDefaultContextAttrs<'input> for StatementDefaultContext<'input>{}

pub struct StatementDefaultContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{StatementDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for StatementDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StatementDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_statementDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_statementDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StatementDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_statementDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for StatementDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for StatementDefaultContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for StatementDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for StatementDefaultContext<'input> {}

impl<'input> StatementDefaultContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::StatementDefaultContext(
				BaseParserRuleContext::copy_from(ctx,StatementDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateJavaFunctionContext<'input> = BaseParserRuleContext<'input,CreateJavaFunctionContextExt<'input>>;

pub trait CreateJavaFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FUNCTION
	/// Returns `None` if there is no child corresponding to token FUNCTION
	fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FUNCTION, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token JAVA
	/// Returns `None` if there is no child corresponding to token JAVA
	fn JAVA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(JAVA, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NULL in current rule
	fn NULL_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NULL, starting from 0.
	/// Returns `None` if number of children corresponding to token NULL is less or equal than `i`.
	fn NULL(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, i)
	}
	/// Retrieves first TerminalNode corresponding to token CALLED
	/// Returns `None` if there is no child corresponding to token CALLED
	fn CALLED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALLED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INPUT
	/// Returns `None` if there is no child corresponding to token INPUT
	fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INPUT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RETURN
	/// Returns `None` if there is no child corresponding to token RETURN
	fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STRICT
	/// Returns `None` if there is no child corresponding to token STRICT
	fn STRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRICT, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IMMUTABLE
	/// Returns `None` if there is no child corresponding to token IMMUTABLE
	fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IMMUTABLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> CreateJavaFunctionContextAttrs<'input> for CreateJavaFunctionContext<'input>{}

pub struct CreateJavaFunctionContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub tableReturnFieldName:Vec<Rc<IdentifierContextAll<'input>>>,
	pub type_: Option<Rc<Type_ContextAll<'input>>>,
	pub tableReturnFieldType:Vec<Rc<Type_ContextAll<'input>>>,
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateJavaFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateJavaFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateJavaFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createJavaFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createJavaFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateJavaFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createJavaFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateJavaFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateJavaFunctionContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateJavaFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateJavaFunctionContext<'input> {}

impl<'input> CreateJavaFunctionContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateJavaFunctionContext(
				BaseParserRuleContext::copy_from(ctx,CreateJavaFunctionContextExt{
					tail:None, 
        			name:None, singleReturnType:None, identifier:None, type_:None, body:None, 
        			tableReturnFieldName:Vec::new(), tableReturnFieldType:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeCreateTableUsingTemplateContext<'input> = BaseParserRuleContext<'input,SnowflakeCreateTableUsingTemplateContextExt<'input>>;

pub trait SnowflakeCreateTableUsingTemplateContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token USING
	/// Returns `None` if there is no child corresponding to token USING
	fn USING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(USING, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPLATE
	/// Returns `None` if there is no child corresponding to token TEMPLATE
	fn TEMPLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPLATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
}

impl<'input> SnowflakeCreateTableUsingTemplateContextAttrs<'input> for SnowflakeCreateTableUsingTemplateContext<'input>{}

pub struct SnowflakeCreateTableUsingTemplateContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeCreateTableUsingTemplateContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeCreateTableUsingTemplateContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeCreateTableUsingTemplateContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeCreateTableUsingTemplate(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeCreateTableUsingTemplate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeCreateTableUsingTemplateContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeCreateTableUsingTemplate(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeCreateTableUsingTemplateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SnowflakeCreateTableUsingTemplateContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SnowflakeCreateTableUsingTemplateContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SnowflakeCreateTableUsingTemplateContext<'input> {}

impl<'input> SnowflakeCreateTableUsingTemplateContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SnowflakeCreateTableUsingTemplateContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeCreateTableUsingTemplateContextExt{
        			dest:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateScalaFunctionContext<'input> = BaseParserRuleContext<'input,CreateScalaFunctionContextExt<'input>>;

pub trait CreateScalaFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FUNCTION
	/// Returns `None` if there is no child corresponding to token FUNCTION
	fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FUNCTION, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SCALA
	/// Returns `None` if there is no child corresponding to token SCALA
	fn SCALA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SCALA, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NULL in current rule
	fn NULL_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NULL, starting from 0.
	/// Returns `None` if number of children corresponding to token NULL is less or equal than `i`.
	fn NULL(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, i)
	}
	/// Retrieves first TerminalNode corresponding to token CALLED
	/// Returns `None` if there is no child corresponding to token CALLED
	fn CALLED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALLED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INPUT
	/// Returns `None` if there is no child corresponding to token INPUT
	fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INPUT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RETURN
	/// Returns `None` if there is no child corresponding to token RETURN
	fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STRICT
	/// Returns `None` if there is no child corresponding to token STRICT
	fn STRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRICT, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IMMUTABLE
	/// Returns `None` if there is no child corresponding to token IMMUTABLE
	fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IMMUTABLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> CreateScalaFunctionContextAttrs<'input> for CreateScalaFunctionContext<'input>{}

pub struct CreateScalaFunctionContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateScalaFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateScalaFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateScalaFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createScalaFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createScalaFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateScalaFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createScalaFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateScalaFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateScalaFunctionContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateScalaFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateScalaFunctionContext<'input> {}

impl<'input> CreateScalaFunctionContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateScalaFunctionContext(
				BaseParserRuleContext::copy_from(ctx,CreateScalaFunctionContextExt{
					tail:None, 
        			name:None, singleReturnType:None, body:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TruncateTableContext<'input> = BaseParserRuleContext<'input,TruncateTableContextExt<'input>>;

pub trait TruncateTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token TRUNCATE
	/// Returns `None` if there is no child corresponding to token TRUNCATE
	fn TRUNCATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TRUNCATE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> TruncateTableContextAttrs<'input> for TruncateTableContext<'input>{}

pub struct TruncateTableContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TruncateTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TruncateTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TruncateTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_truncateTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_truncateTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TruncateTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_truncateTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for TruncateTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for TruncateTableContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for TruncateTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for TruncateTableContext<'input> {}

impl<'input> TruncateTableContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::TruncateTableContext(
				BaseParserRuleContext::copy_from(ctx,TruncateTableContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateMaterializedViewContext<'input> = BaseParserRuleContext<'input,CreateMaterializedViewContextExt<'input>>;

pub trait CreateMaterializedViewContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MATERIALIZED
	/// Returns `None` if there is no child corresponding to token MATERIALIZED
	fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MATERIALIZED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VIEW
	/// Returns `None` if there is no child corresponding to token VIEW
	fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VIEW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANT
	/// Returns `None` if there is no child corresponding to token GRANT
	fn GRANT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANT, 0)
	}
	fn columnDefinitionForView_all(&self) ->  Vec<Rc<ColumnDefinitionForViewContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn columnDefinitionForView(&self, i: usize) -> Option<Rc<ColumnDefinitionForViewContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COMMENT
	/// Returns `None` if there is no child corresponding to token COMMENT
	fn COMMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EQ
	/// Returns `None` if there is no child corresponding to token EQ
	fn EQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EQ, 0)
	}
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token ROW
	/// Returns `None` if there is no child corresponding to token ROW
	fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ROW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ACCESS
	/// Returns `None` if there is no child corresponding to token ACCESS
	fn ACCESS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ACCESS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token POLICY
	/// Returns `None` if there is no child corresponding to token POLICY
	fn POLICY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(POLICY, 0)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TAG
	/// Returns `None` if there is no child corresponding to token TAG
	fn TAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TAG, 0)
	}
	fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token CLUSTER
	/// Returns `None` if there is no child corresponding to token CLUSTER
	fn CLUSTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CLUSTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token BY
	/// Returns `None` if there is no child corresponding to token BY
	fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BY, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token WITH in current rule
	fn WITH_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token WITH, starting from 0.
	/// Returns `None` if number of children corresponding to token WITH is less or equal than `i`.
	fn WITH(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITH, i)
	}
}

impl<'input> CreateMaterializedViewContextAttrs<'input> for CreateMaterializedViewContext<'input>{}

pub struct CreateMaterializedViewContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateMaterializedViewContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateMaterializedViewContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateMaterializedViewContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createMaterializedView(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createMaterializedView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateMaterializedViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createMaterializedView(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateMaterializedViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateMaterializedViewContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateMaterializedViewContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateMaterializedViewContext<'input> {}

impl<'input> CreateMaterializedViewContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateMaterializedViewContext(
				BaseParserRuleContext::copy_from(ctx,CreateMaterializedViewContextExt{
					COMMA:None, 
        			tail:Vec::new(), 
        			dest:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateViewContext<'input> = BaseParserRuleContext<'input,CreateViewContextExt<'input>>;

pub trait CreateViewContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VIEW
	/// Returns `None` if there is no child corresponding to token VIEW
	fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VIEW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RECURSIVE
	/// Returns `None` if there is no child corresponding to token RECURSIVE
	fn RECURSIVE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RECURSIVE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn columnDefinitionForView_all(&self) ->  Vec<Rc<ColumnDefinitionForViewContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn columnDefinitionForView(&self, i: usize) -> Option<Rc<ColumnDefinitionForViewContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token ROW
	/// Returns `None` if there is no child corresponding to token ROW
	fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ROW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ACCESS
	/// Returns `None` if there is no child corresponding to token ACCESS
	fn ACCESS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ACCESS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token POLICY
	/// Returns `None` if there is no child corresponding to token POLICY
	fn POLICY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(POLICY, 0)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TAG
	/// Returns `None` if there is no child corresponding to token TAG
	fn TAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TAG, 0)
	}
	fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANT
	/// Returns `None` if there is no child corresponding to token GRANT
	fn GRANT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COMMENT
	/// Returns `None` if there is no child corresponding to token COMMENT
	fn COMMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EQ
	/// Returns `None` if there is no child corresponding to token EQ
	fn EQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EQ, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token WITH in current rule
	fn WITH_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token WITH, starting from 0.
	/// Returns `None` if number of children corresponding to token WITH is less or equal than `i`.
	fn WITH(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITH, i)
	}
	/// Retrieves first TerminalNode corresponding to token LOCAL
	/// Returns `None` if there is no child corresponding to token LOCAL
	fn LOCAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LOCAL, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GLOBAL
	/// Returns `None` if there is no child corresponding to token GLOBAL
	fn GLOBAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GLOBAL, 0)
	}
}

impl<'input> CreateViewContextAttrs<'input> for CreateViewContext<'input>{}

pub struct CreateViewContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
	pub comment: Option<Rc<StringContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateViewContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateViewContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateViewContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createView(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createView(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateViewContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateViewContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateViewContext<'input> {}

impl<'input> CreateViewContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateViewContext(
				BaseParserRuleContext::copy_from(ctx,CreateViewContextExt{
					COMMA:None, 
        			tail:Vec::new(), 
        			dest:None, comment:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RenameMaterializedViewContext<'input> = BaseParserRuleContext<'input,RenameMaterializedViewContextExt<'input>>;

pub trait RenameMaterializedViewContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MATERIALIZED
	/// Returns `None` if there is no child corresponding to token MATERIALIZED
	fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MATERIALIZED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VIEW
	/// Returns `None` if there is no child corresponding to token VIEW
	fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VIEW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RENAME
	/// Returns `None` if there is no child corresponding to token RENAME
	fn RENAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RENAME, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TO
	/// Returns `None` if there is no child corresponding to token TO
	fn TO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TO, 0)
	}
	fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token IF
	/// Returns `None` if there is no child corresponding to token IF
	fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
}

impl<'input> RenameMaterializedViewContextAttrs<'input> for RenameMaterializedViewContext<'input>{}

pub struct RenameMaterializedViewContextExt<'input>{
	base:StatementContextExt<'input>,
	pub from: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub to: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RenameMaterializedViewContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RenameMaterializedViewContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RenameMaterializedViewContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_renameMaterializedView(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_renameMaterializedView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RenameMaterializedViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_renameMaterializedView(self);
	}
}

impl<'input> CustomRuleContext<'input> for RenameMaterializedViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RenameMaterializedViewContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RenameMaterializedViewContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for RenameMaterializedViewContext<'input> {}

impl<'input> RenameMaterializedViewContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::RenameMaterializedViewContext(
				BaseParserRuleContext::copy_from(ctx,RenameMaterializedViewContextExt{
        			from:None, to:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DropTableContext<'input> = BaseParserRuleContext<'input,DropTableContextExt<'input>>;

pub trait DropTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DROP
	/// Returns `None` if there is no child corresponding to token DROP
	fn DROP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DROP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> DropTableContextAttrs<'input> for DropTableContext<'input>{}

pub struct DropTableContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DropTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DropTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DropTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dropTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_dropTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DropTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dropTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for DropTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DropTableContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DropTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DropTableContext<'input> {}

impl<'input> DropTableContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DropTableContext(
				BaseParserRuleContext::copy_from(ctx,DropTableContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateTableCloneContext<'input> = BaseParserRuleContext<'input,CreateTableCloneContextExt<'input>>;

pub trait CreateTableCloneContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token CLONE
	/// Returns `None` if there is no child corresponding to token CLONE
	fn CLONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CLONE, 0)
	}
	fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IF
	/// Returns `None` if there is no child corresponding to token IF
	fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TRANSIENT
	/// Returns `None` if there is no child corresponding to token TRANSIENT
	fn TRANSIENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TRANSIENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AT
	/// Returns `None` if there is no child corresponding to token AT
	fn AT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token BEFORE
	/// Returns `None` if there is no child corresponding to token BEFORE
	fn BEFORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BEFORE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TIMESTAMP
	/// Returns `None` if there is no child corresponding to token TIMESTAMP
	fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TIMESTAMP, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OFFSET
	/// Returns `None` if there is no child corresponding to token OFFSET
	fn OFFSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OFFSET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STATEMENT
	/// Returns `None` if there is no child corresponding to token STATEMENT
	fn STATEMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STATEMENT, 0)
	}
}

impl<'input> CreateTableCloneContextAttrs<'input> for CreateTableCloneContext<'input>{}

pub struct CreateTableCloneContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub src: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateTableCloneContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateTableCloneContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateTableCloneContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createTableClone(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createTableClone(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateTableCloneContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createTableClone(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateTableCloneContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateTableCloneContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateTableCloneContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateTableCloneContext<'input> {}

impl<'input> CreateTableCloneContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateTableCloneContext(
				BaseParserRuleContext::copy_from(ctx,CreateTableCloneContextExt{
        			dest:None, src:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SetSchemaAuthorizationContext<'input> = BaseParserRuleContext<'input,SetSchemaAuthorizationContextExt<'input>>;

pub trait SetSchemaAuthorizationContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SCHEMA
	/// Returns `None` if there is no child corresponding to token SCHEMA
	fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SCHEMA, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token SET
	/// Returns `None` if there is no child corresponding to token SET
	fn SET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AUTHORIZATION
	/// Returns `None` if there is no child corresponding to token AUTHORIZATION
	fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AUTHORIZATION, 0)
	}
	fn principal(&self) -> Option<Rc<PrincipalContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SetSchemaAuthorizationContextAttrs<'input> for SetSchemaAuthorizationContext<'input>{}

pub struct SetSchemaAuthorizationContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SetSchemaAuthorizationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SetSchemaAuthorizationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetSchemaAuthorizationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_setSchemaAuthorization(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_setSchemaAuthorization(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetSchemaAuthorizationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setSchemaAuthorization(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetSchemaAuthorizationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetSchemaAuthorizationContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetSchemaAuthorizationContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SetSchemaAuthorizationContext<'input> {}

impl<'input> SetSchemaAuthorizationContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SetSchemaAuthorizationContext(
				BaseParserRuleContext::copy_from(ctx,SetSchemaAuthorizationContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RollbackContext<'input> = BaseParserRuleContext<'input,RollbackContextExt<'input>>;

pub trait RollbackContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ROLLBACK
	/// Returns `None` if there is no child corresponding to token ROLLBACK
	fn ROLLBACK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ROLLBACK, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> RollbackContextAttrs<'input> for RollbackContext<'input>{}

pub struct RollbackContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RollbackContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RollbackContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RollbackContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rollback(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_rollback(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RollbackContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rollback(self);
	}
}

impl<'input> CustomRuleContext<'input> for RollbackContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RollbackContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RollbackContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for RollbackContext<'input> {}

impl<'input> RollbackContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::RollbackContext(
				BaseParserRuleContext::copy_from(ctx,RollbackContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SetContext<'input> = BaseParserRuleContext<'input,SetContextExt<'input>>;

pub trait SetContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token SET
	/// Returns `None` if there is no child corresponding to token SET
	fn SET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SET, 0)
	}
	fn property(&self) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token EQ
	/// Returns `None` if there is no child corresponding to token EQ
	fn EQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EQ, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> SetContextAttrs<'input> for SetContext<'input>{}

pub struct SetContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SetContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_set(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_set(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_set(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SetContext<'input> {}

impl<'input> SetContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SetContext(
				BaseParserRuleContext::copy_from(ctx,SetContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateSqlFunctionContext<'input> = BaseParserRuleContext<'input,CreateSqlFunctionContextExt<'input>>;

pub trait CreateSqlFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FUNCTION
	/// Returns `None` if there is no child corresponding to token FUNCTION
	fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FUNCTION, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token NULL
	/// Returns `None` if there is no child corresponding to token NULL
	fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SQL
	/// Returns `None` if there is no child corresponding to token SQL
	fn SQL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SQL, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MEMORIZABLE
	/// Returns `None` if there is no child corresponding to token MEMORIZABLE
	fn MEMORIZABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MEMORIZABLE, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IMMUTABLE
	/// Returns `None` if there is no child corresponding to token IMMUTABLE
	fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IMMUTABLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> CreateSqlFunctionContextAttrs<'input> for CreateSqlFunctionContext<'input>{}

pub struct CreateSqlFunctionContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub tableReturnFieldName:Vec<Rc<IdentifierContextAll<'input>>>,
	pub type_: Option<Rc<Type_ContextAll<'input>>>,
	pub tableReturnFieldType:Vec<Rc<Type_ContextAll<'input>>>,
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateSqlFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateSqlFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateSqlFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createSqlFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createSqlFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateSqlFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createSqlFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateSqlFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateSqlFunctionContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateSqlFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateSqlFunctionContext<'input> {}

impl<'input> CreateSqlFunctionContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateSqlFunctionContext(
				BaseParserRuleContext::copy_from(ctx,CreateSqlFunctionContextExt{
					tail:None, 
        			name:None, singleReturnType:None, identifier:None, type_:None, body:None, 
        			tableReturnFieldName:Vec::new(), tableReturnFieldType:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreatePythonFunctionContext<'input> = BaseParserRuleContext<'input,CreatePythonFunctionContextExt<'input>>;

pub trait CreatePythonFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FUNCTION
	/// Returns `None` if there is no child corresponding to token FUNCTION
	fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FUNCTION, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token RETURNS
	/// Returns `None` if there is no child corresponding to token RETURNS
	fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURNS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LANGUAGE
	/// Returns `None` if there is no child corresponding to token LANGUAGE
	fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LANGUAGE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PYTHON
	/// Returns `None` if there is no child corresponding to token PYTHON
	fn PYTHON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PYTHON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SECURE
	/// Returns `None` if there is no child corresponding to token SECURE
	fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SECURE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn namedParameter_all(&self) ->  Vec<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn namedParameter(&self, i: usize) -> Option<Rc<NamedParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COPY
	/// Returns `None` if there is no child corresponding to token COPY
	fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COPY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GRANTS
	/// Returns `None` if there is no child corresponding to token GRANTS
	fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANTS, 0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NULL in current rule
	fn NULL_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NULL, starting from 0.
	/// Returns `None` if number of children corresponding to token NULL is less or equal than `i`.
	fn NULL(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, i)
	}
	/// Retrieves first TerminalNode corresponding to token CALLED
	/// Returns `None` if there is no child corresponding to token CALLED
	fn CALLED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALLED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ON
	/// Returns `None` if there is no child corresponding to token ON
	fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ON, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INPUT
	/// Returns `None` if there is no child corresponding to token INPUT
	fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INPUT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RETURN
	/// Returns `None` if there is no child corresponding to token RETURN
	fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RETURN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STRICT
	/// Returns `None` if there is no child corresponding to token STRICT
	fn STRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRICT, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IMMUTABLE
	/// Returns `None` if there is no child corresponding to token IMMUTABLE
	fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IMMUTABLE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> CreatePythonFunctionContextAttrs<'input> for CreatePythonFunctionContext<'input>{}

pub struct CreatePythonFunctionContextExt<'input>{
	base:StatementContextExt<'input>,
	pub name: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	pub singleReturnType: Option<Rc<Type_ContextAll<'input>>>,
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub tableReturnFieldName:Vec<Rc<IdentifierContextAll<'input>>>,
	pub type_: Option<Rc<Type_ContextAll<'input>>>,
	pub tableReturnFieldType:Vec<Rc<Type_ContextAll<'input>>>,
	pub body: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreatePythonFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreatePythonFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreatePythonFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createPythonFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createPythonFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreatePythonFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createPythonFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreatePythonFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreatePythonFunctionContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreatePythonFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreatePythonFunctionContext<'input> {}

impl<'input> CreatePythonFunctionContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreatePythonFunctionContext(
				BaseParserRuleContext::copy_from(ctx,CreatePythonFunctionContextExt{
					tail:None, 
        			name:None, singleReturnType:None, identifier:None, type_:None, body:None, 
        			tableReturnFieldName:Vec::new(), tableReturnFieldType:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RenameViewContext<'input> = BaseParserRuleContext<'input,RenameViewContextExt<'input>>;

pub trait RenameViewContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VIEW
	/// Returns `None` if there is no child corresponding to token VIEW
	fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VIEW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RENAME
	/// Returns `None` if there is no child corresponding to token RENAME
	fn RENAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RENAME, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TO
	/// Returns `None` if there is no child corresponding to token TO
	fn TO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TO, 0)
	}
	fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> RenameViewContextAttrs<'input> for RenameViewContext<'input>{}

pub struct RenameViewContextExt<'input>{
	base:StatementContextExt<'input>,
	pub from: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub to: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RenameViewContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RenameViewContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RenameViewContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_renameView(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_renameView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RenameViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_renameView(self);
	}
}

impl<'input> CustomRuleContext<'input> for RenameViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RenameViewContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RenameViewContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for RenameViewContext<'input> {}

impl<'input> RenameViewContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::RenameViewContext(
				BaseParserRuleContext::copy_from(ctx,RenameViewContextExt{
        			from:None, to:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeCreateTableAsSelectContext<'input> = BaseParserRuleContext<'input,SnowflakeCreateTableAsSelectContextExt<'input>>;

pub trait SnowflakeCreateTableAsSelectContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	fn snowflakeCreateTableClauses_all(&self) ->  Vec<Rc<SnowflakeCreateTableClausesContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn snowflakeCreateTableClauses(&self, i: usize) -> Option<Rc<SnowflakeCreateTableClausesContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMP
	/// Returns `None` if there is no child corresponding to token TEMP
	fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TEMPORARY
	/// Returns `None` if there is no child corresponding to token TEMPORARY
	fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TEMPORARY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VOLATILE
	/// Returns `None` if there is no child corresponding to token VOLATILE
	fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VOLATILE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TRANSIENT
	/// Returns `None` if there is no child corresponding to token TRANSIENT
	fn TRANSIENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TRANSIENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LOCAL
	/// Returns `None` if there is no child corresponding to token LOCAL
	fn LOCAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LOCAL, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GLOBAL
	/// Returns `None` if there is no child corresponding to token GLOBAL
	fn GLOBAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GLOBAL, 0)
	}
}

impl<'input> SnowflakeCreateTableAsSelectContextAttrs<'input> for SnowflakeCreateTableAsSelectContext<'input>{}

pub struct SnowflakeCreateTableAsSelectContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeCreateTableAsSelectContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeCreateTableAsSelectContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeCreateTableAsSelectContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeCreateTableAsSelect(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeCreateTableAsSelect(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeCreateTableAsSelectContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeCreateTableAsSelect(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeCreateTableAsSelectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SnowflakeCreateTableAsSelectContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SnowflakeCreateTableAsSelectContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SnowflakeCreateTableAsSelectContext<'input> {}

impl<'input> SnowflakeCreateTableAsSelectContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SnowflakeCreateTableAsSelectContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeCreateTableAsSelectContextExt{
        			dest:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CallContext<'input> = BaseParserRuleContext<'input,CallContextExt<'input>>;

pub trait CallContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CALL
	/// Returns `None` if there is no child corresponding to token CALL
	fn CALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CALL, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> CallContextAttrs<'input> for CallContext<'input>{}

pub struct CallContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CallContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CallContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CallContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_call(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_call(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CallContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_call(self);
	}
}

impl<'input> CustomRuleContext<'input> for CallContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CallContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CallContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CallContext<'input> {}

impl<'input> CallContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CallContext(
				BaseParserRuleContext::copy_from(ctx,CallContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RefreshMaterializedViewContext<'input> = BaseParserRuleContext<'input,RefreshMaterializedViewContextExt<'input>>;

pub trait RefreshMaterializedViewContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token REFRESH
	/// Returns `None` if there is no child corresponding to token REFRESH
	fn REFRESH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REFRESH, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MATERIALIZED
	/// Returns `None` if there is no child corresponding to token MATERIALIZED
	fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MATERIALIZED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VIEW
	/// Returns `None` if there is no child corresponding to token VIEW
	fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VIEW, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> RefreshMaterializedViewContextAttrs<'input> for RefreshMaterializedViewContext<'input>{}

pub struct RefreshMaterializedViewContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RefreshMaterializedViewContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RefreshMaterializedViewContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RefreshMaterializedViewContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_refreshMaterializedView(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_refreshMaterializedView(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RefreshMaterializedViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_refreshMaterializedView(self);
	}
}

impl<'input> CustomRuleContext<'input> for RefreshMaterializedViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for RefreshMaterializedViewContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for RefreshMaterializedViewContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for RefreshMaterializedViewContext<'input> {}

impl<'input> RefreshMaterializedViewContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::RefreshMaterializedViewContext(
				BaseParserRuleContext::copy_from(ctx,RefreshMaterializedViewContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CreateExternalTableContext<'input> = BaseParserRuleContext<'input,CreateExternalTableContextExt<'input>>;

pub trait CreateExternalTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CREATE
	/// Returns `None` if there is no child corresponding to token CREATE
	fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CREATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token EXTERNAL
	/// Returns `None` if there is no child corresponding to token EXTERNAL
	fn EXTERNAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXTERNAL, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	fn snowflakeCreateExternalTableClauses(&self) -> Option<Rc<SnowflakeCreateExternalTableClausesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token REPLACE
	/// Returns `None` if there is no child corresponding to token REPLACE
	fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPLACE, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token IF in current rule
	fn IF_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token IF, starting from 0.
	/// Returns `None` if number of children corresponding to token IF is less or equal than `i`.
	fn IF(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IF, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
	fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
	/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
	fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token EXISTS in current rule
	fn EXISTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token EXISTS, starting from 0.
	/// Returns `None` if number of children corresponding to token EXISTS is less or equal than `i`.
	fn EXISTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, i)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn externalColumnDefinition_all(&self) ->  Vec<Rc<ExternalColumnDefinitionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn externalColumnDefinition(&self, i: usize) -> Option<Rc<ExternalColumnDefinitionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> CreateExternalTableContextAttrs<'input> for CreateExternalTableContext<'input>{}

pub struct CreateExternalTableContextExt<'input>{
	base:StatementContextExt<'input>,
	pub dest: Option<Rc<QualifiedNameContextAll<'input>>>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CreateExternalTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CreateExternalTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateExternalTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_createExternalTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_createExternalTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateExternalTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createExternalTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateExternalTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CreateExternalTableContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CreateExternalTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CreateExternalTableContext<'input> {}

impl<'input> CreateExternalTableContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CreateExternalTableContext(
				BaseParserRuleContext::copy_from(ctx,CreateExternalTableContextExt{
					COMMA:None, 
        			tail:Vec::new(), 
        			dest:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CommentContext<'input> = BaseParserRuleContext<'input,CommentContextExt<'input>>;

pub trait CommentContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token COMMENT
	/// Returns `None` if there is no child corresponding to token COMMENT
	fn COMMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMENT, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> CommentContextAttrs<'input> for CommentContext<'input>{}

pub struct CommentContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CommentContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CommentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CommentContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_comment(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_comment(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CommentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_comment(self);
	}
}

impl<'input> CustomRuleContext<'input> for CommentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for CommentContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for CommentContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for CommentContext<'input> {}

impl<'input> CommentContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::CommentContext(
				BaseParserRuleContext::copy_from(ctx,CommentContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DescribeOutputContext<'input> = BaseParserRuleContext<'input,DescribeOutputContextExt<'input>>;

pub trait DescribeOutputContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DESCRIBE
	/// Returns `None` if there is no child corresponding to token DESCRIBE
	fn DESCRIBE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DESCRIBE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token OUTPUT
	/// Returns `None` if there is no child corresponding to token OUTPUT
	fn OUTPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OUTPUT, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> DescribeOutputContextAttrs<'input> for DescribeOutputContext<'input>{}

pub struct DescribeOutputContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DescribeOutputContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DescribeOutputContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DescribeOutputContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_describeOutput(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_describeOutput(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DescribeOutputContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_describeOutput(self);
	}
}

impl<'input> CustomRuleContext<'input> for DescribeOutputContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for DescribeOutputContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for DescribeOutputContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for DescribeOutputContext<'input> {}

impl<'input> DescribeOutputContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::DescribeOutputContext(
				BaseParserRuleContext::copy_from(ctx,DescribeOutputContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type GrantContext<'input> = BaseParserRuleContext<'input,GrantContextExt<'input>>;

pub trait GrantContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token GRANT
	/// Returns `None` if there is no child corresponding to token GRANT
	fn GRANT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GRANT, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token SEMI_COLON in current rule
	fn SEMI_COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token SEMI_COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token SEMI_COLON is less or equal than `i`.
	fn SEMI_COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SEMI_COLON, i)
	}
}

impl<'input> GrantContextAttrs<'input> for GrantContext<'input>{}

pub struct GrantContextExt<'input>{
	base:StatementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{GrantContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for GrantContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for GrantContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_grant(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_grant(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for GrantContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_grant(self);
	}
}

impl<'input> CustomRuleContext<'input> for GrantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for GrantContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for GrantContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for GrantContext<'input> {}

impl<'input> GrantContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::GrantContext(
				BaseParserRuleContext::copy_from(ctx,GrantContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SetTablePropertiesContext<'input> = BaseParserRuleContext<'input,SetTablePropertiesContextExt<'input>>;

pub trait SetTablePropertiesContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALTER
	/// Returns `None` if there is no child corresponding to token ALTER
	fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SET
	/// Returns `None` if there is no child corresponding to token SET
	fn SET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PROPERTIES
	/// Returns `None` if there is no child corresponding to token PROPERTIES
	fn PROPERTIES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PROPERTIES, 0)
	}
	fn propertyAssignments(&self) -> Option<Rc<PropertyAssignmentsContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SetTablePropertiesContextAttrs<'input> for SetTablePropertiesContext<'input>{}

pub struct SetTablePropertiesContextExt<'input>{
	base:StatementContextExt<'input>,
	pub tableName: Option<Rc<QualifiedNameContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SetTablePropertiesContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SetTablePropertiesContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetTablePropertiesContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_setTableProperties(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_setTableProperties(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetTablePropertiesContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setTableProperties(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetTablePropertiesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_statement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_statement }
}

impl<'input> Borrow<StatementContextExt<'input>> for SetTablePropertiesContext<'input>{
	fn borrow(&self) -> &StatementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StatementContextExt<'input>> for SetTablePropertiesContext<'input>{
	fn borrow_mut(&mut self) -> &mut StatementContextExt<'input> { &mut self.base }
}

impl<'input> StatementContextAttrs<'input> for SetTablePropertiesContext<'input> {}

impl<'input> SetTablePropertiesContextExt<'input>{
	fn new(ctx: &dyn StatementContextAttrs<'input>) -> Rc<StatementContextAll<'input>>  {
		Rc::new(
			StatementContextAll::SetTablePropertiesContext(
				BaseParserRuleContext::copy_from(ctx,SetTablePropertiesContextExt{
        			tableName:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn statement(&mut self,)
	-> Result<Rc<StatementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StatementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 10, RULE_statement);
        let mut _localctx: Rc<StatementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(2274);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(309,&mut recog.base)? {
				1 =>{
					let tmp = StatementDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule query*/
					recog.base.set_state(411);
					recog.query()?;

					}
				}
			,
				2 =>{
					let tmp = UseContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(412);
					recog.base.match_token(USE,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(413);
					let tmp = recog.identifier()?;
					if let StatementContextAll::UseContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.schema = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				3 =>{
					let tmp = UseContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(414);
					recog.base.match_token(USE,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(415);
					let tmp = recog.identifier()?;
					if let StatementContextAll::UseContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.catalog = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(416);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(417);
					let tmp = recog.identifier()?;
					if let StatementContextAll::UseContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.schema = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				4 =>{
					let tmp = DropSchemaContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					recog.base.set_state(419);
					recog.base.match_token(DROP,&mut recog.err_handler)?;

					recog.base.set_state(420);
					recog.base.match_token(SCHEMA,&mut recog.err_handler)?;

					recog.base.set_state(423);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(5,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(421);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(422);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(425);
					recog.qualifiedName()?;

					recog.base.set_state(429);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(426);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(431);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				5 =>{
					let tmp = RenameSchemaContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 5);
					_localctx = tmp;
					{
					recog.base.set_state(432);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(433);
					recog.base.match_token(SCHEMA,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(434);
					recog.qualifiedName()?;

					recog.base.set_state(435);
					recog.base.match_token(RENAME,&mut recog.err_handler)?;

					recog.base.set_state(436);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(437);
					recog.identifier()?;

					}
				}
			,
				6 =>{
					let tmp = SetSchemaAuthorizationContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 6);
					_localctx = tmp;
					{
					recog.base.set_state(439);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(440);
					recog.base.match_token(SCHEMA,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(441);
					recog.qualifiedName()?;

					recog.base.set_state(442);
					recog.base.match_token(SET,&mut recog.err_handler)?;

					recog.base.set_state(443);
					recog.base.match_token(AUTHORIZATION,&mut recog.err_handler)?;

					/*InvokeRule principal*/
					recog.base.set_state(444);
					recog.principal()?;

					}
				}
			,
				7 =>{
					let tmp = DropTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 7);
					_localctx = tmp;
					{
					recog.base.set_state(446);
					recog.base.match_token(DROP,&mut recog.err_handler)?;

					recog.base.set_state(447);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(448);
					recog.qualifiedName()?;

					}
				}
			,
				8 =>{
					let tmp = DropViewContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 8);
					_localctx = tmp;
					{
					recog.base.set_state(449);
					recog.base.match_token(DROP,&mut recog.err_handler)?;

					recog.base.set_state(450);
					recog.base.match_token(VIEW,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(451);
					recog.qualifiedName()?;

					}
				}
			,
				9 =>{
					let tmp = CreateExternalTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 9);
					_localctx = tmp;
					{
					recog.base.set_state(452);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(455);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(453);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(454);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(457);
					recog.base.match_token(EXTERNAL,&mut recog.err_handler)?;

					recog.base.set_state(458);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(462);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(8,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(459);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(460);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(461);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(464);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateExternalTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(468);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(9,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(465);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(466);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(467);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(484);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						recog.base.set_state(470);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule externalColumnDefinition*/
						recog.base.set_state(471);
						recog.externalColumnDefinition()?;

						recog.base.set_state(476);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(10,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(472);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule externalColumnDefinition*/
								recog.base.set_state(473);
								recog.externalColumnDefinition()?;

								}
								} 
							}
							recog.base.set_state(478);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(10,&mut recog.base)?;
						}
						recog.base.set_state(480);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(479);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateExternalTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateExternalTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateExternalTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail.push(temp); } else {unreachable!("cant cast");}  
							}
						}

						recog.base.set_state(482);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(487);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(486);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let StatementContextAll::CreateExternalTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
						ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

						let temp = if let StatementContextAll::CreateExternalTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
						ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
						if let StatementContextAll::CreateExternalTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
						ctx.tail.push(temp); } else {unreachable!("cant cast");}  
						}
					}

					/*InvokeRule snowflakeCreateExternalTableClauses*/
					recog.base.set_state(489);
					recog.snowflakeCreateExternalTableClauses()?;

					}
				}
			,
				10 =>{
					let tmp = SnowflakeCreateTableAsSelectContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 10);
					_localctx = tmp;
					{
					recog.base.set_state(491);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(494);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(492);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(493);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(500);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==GLOBAL || _la==LOCAL || ((((_la - 375)) & !0x3f) == 0 && ((1usize << (_la - 375)) & ((1usize << (TEMP - 375)) | (1usize << (TEMPORARY - 375)) | (1usize << (TRANSIENT - 375)))) != 0) || _la==VOLATILE {
						{
						recog.base.set_state(497);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==GLOBAL || _la==LOCAL {
							{
							recog.base.set_state(496);
							_la = recog.base.input.la(1);
							if { !(_la==GLOBAL || _la==LOCAL) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						recog.base.set_state(499);
						_la = recog.base.input.la(1);
						if { !(((((_la - 375)) & !0x3f) == 0 && ((1usize << (_la - 375)) & ((1usize << (TEMP - 375)) | (1usize << (TEMPORARY - 375)) | (1usize << (TRANSIENT - 375)))) != 0) || _la==VOLATILE) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(502);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(506);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(17,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(503);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(504);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(505);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(508);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::SnowflakeCreateTableAsSelectContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(512);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(18,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(509);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(510);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(511);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule snowflakeCreateTableClauses*/
					recog.base.set_state(514);
					recog.snowflakeCreateTableClauses()?;

					recog.base.set_state(516);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						/*InvokeRule columnAliases*/
						recog.base.set_state(515);
						recog.columnAliases()?;

						}
					}

					/*InvokeRule snowflakeCreateTableClauses*/
					recog.base.set_state(518);
					recog.snowflakeCreateTableClauses()?;

					recog.base.set_state(519);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(520);
					recog.query()?;

					}
				}
			,
				11 =>{
					let tmp = CreateTableCloneContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 11);
					_localctx = tmp;
					{
					recog.base.set_state(522);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(525);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(523);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(524);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(528);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if ((((_la - 375)) & !0x3f) == 0 && ((1usize << (_la - 375)) & ((1usize << (TEMP - 375)) | (1usize << (TEMPORARY - 375)) | (1usize << (TRANSIENT - 375)))) != 0) || _la==VOLATILE {
						{
						recog.base.set_state(527);
						_la = recog.base.input.la(1);
						if { !(((((_la - 375)) & !0x3f) == 0 && ((1usize << (_la - 375)) & ((1usize << (TEMP - 375)) | (1usize << (TEMPORARY - 375)) | (1usize << (TRANSIENT - 375)))) != 0) || _la==VOLATILE) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(530);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(534);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(22,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(531);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(532);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(533);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(536);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateTableCloneContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(537);
					recog.base.match_token(CLONE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(538);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateTableCloneContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.src = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(554);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==AT || _la==BEFORE {
						{
						recog.base.set_state(539);
						_la = recog.base.input.la(1);
						if { !(_la==AT || _la==BEFORE) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						recog.base.set_state(540);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						recog.base.set_state(550);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 TIMESTAMP 
							=> {
								{
								recog.base.set_state(541);
								recog.base.match_token(TIMESTAMP,&mut recog.err_handler)?;

								recog.base.set_state(542);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(543);
								recog.expression()?;

								}
							}

						 OFFSET 
							=> {
								{
								recog.base.set_state(544);
								recog.base.match_token(OFFSET,&mut recog.err_handler)?;

								recog.base.set_state(545);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(546);
								recog.expression()?;

								}
							}

						 STATEMENT 
							=> {
								{
								recog.base.set_state(547);
								recog.base.match_token(STATEMENT,&mut recog.err_handler)?;

								recog.base.set_state(548);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(549);
								recog.expression()?;

								}
							}

							_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(552);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(558);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(556);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(557);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					}
				}
			,
				12 =>{
					let tmp = CreateDynamicTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 12);
					_localctx = tmp;
					{
					recog.base.set_state(560);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(563);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(561);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(562);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(565);
					recog.base.match_token(DYNAMIC,&mut recog.err_handler)?;

					recog.base.set_state(566);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(570);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(27,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(567);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(568);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(569);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(572);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateDynamicTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(573);
					recog.base.match_token(CLONE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(574);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateDynamicTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.src = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(590);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==AT || _la==BEFORE {
						{
						recog.base.set_state(575);
						_la = recog.base.input.la(1);
						if { !(_la==AT || _la==BEFORE) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						recog.base.set_state(576);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						recog.base.set_state(586);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 TIMESTAMP 
							=> {
								{
								recog.base.set_state(577);
								recog.base.match_token(TIMESTAMP,&mut recog.err_handler)?;

								recog.base.set_state(578);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(579);
								recog.expression()?;

								}
							}

						 OFFSET 
							=> {
								{
								recog.base.set_state(580);
								recog.base.match_token(OFFSET,&mut recog.err_handler)?;

								recog.base.set_state(581);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(582);
								recog.expression()?;

								}
							}

						 STATEMENT 
							=> {
								{
								recog.base.set_state(583);
								recog.base.match_token(STATEMENT,&mut recog.err_handler)?;

								recog.base.set_state(584);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(585);
								recog.expression()?;

								}
							}

							_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(588);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(601);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TARGET_LAG {
						{
						recog.base.set_state(592);
						recog.base.match_token(TARGET_LAG,&mut recog.err_handler)?;

						recog.base.set_state(593);
						recog.base.match_token(EQ,&mut recog.err_handler)?;

						recog.base.set_state(596);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 STRING | UNICODE_STRING | DOLLAR_QUOTED_STRING 
							=> {
								{
								/*InvokeRule string*/
								recog.base.set_state(594);
								let tmp = recog.string()?;
								if let StatementContextAll::CreateDynamicTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.lag = Some(tmp.clone()); } else {unreachable!("cant cast");}  

								}
							}

						 DOWNSTREAM 
							=> {
								{
								recog.base.set_state(595);
								recog.base.match_token(DOWNSTREAM,&mut recog.err_handler)?;

								}
							}

							_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(598);
						recog.base.match_token(WAREHOUSE,&mut recog.err_handler)?;

						recog.base.set_state(599);
						recog.base.match_token(EQ,&mut recog.err_handler)?;

						/*InvokeRule string*/
						recog.base.set_state(600);
						let tmp = recog.string()?;
						if let StatementContextAll::CreateDynamicTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
						ctx.warehouseName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

						}
					}

					}
				}
			,
				13 =>{
					let tmp = CreateEventTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 13);
					_localctx = tmp;
					{
					recog.base.set_state(603);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(606);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(604);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(605);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(608);
					recog.base.match_token(EVENT,&mut recog.err_handler)?;

					recog.base.set_state(609);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(613);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(33,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(610);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(611);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(612);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(615);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateEventTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(616);
					recog.base.match_token(CLONE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(617);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateEventTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.src = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(633);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==AT || _la==BEFORE {
						{
						recog.base.set_state(618);
						_la = recog.base.input.la(1);
						if { !(_la==AT || _la==BEFORE) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						recog.base.set_state(619);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						recog.base.set_state(629);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 TIMESTAMP 
							=> {
								{
								recog.base.set_state(620);
								recog.base.match_token(TIMESTAMP,&mut recog.err_handler)?;

								recog.base.set_state(621);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(622);
								recog.expression()?;

								}
							}

						 OFFSET 
							=> {
								{
								recog.base.set_state(623);
								recog.base.match_token(OFFSET,&mut recog.err_handler)?;

								recog.base.set_state(624);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(625);
								recog.expression()?;

								}
							}

						 STATEMENT 
							=> {
								{
								recog.base.set_state(626);
								recog.base.match_token(STATEMENT,&mut recog.err_handler)?;

								recog.base.set_state(627);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(628);
								recog.expression()?;

								}
							}

							_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(631);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					}
				}
			,
				14 =>{
					let tmp = CreateIcebergTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 14);
					_localctx = tmp;
					{
					recog.base.set_state(635);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(638);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(636);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(637);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(640);
					recog.base.match_token(ICEBERG,&mut recog.err_handler)?;

					recog.base.set_state(641);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(645);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(37,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(642);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(643);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(644);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(647);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateIcebergTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(648);
					recog.base.match_token(CLONE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(649);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateIcebergTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.src = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(665);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==AT || _la==BEFORE {
						{
						recog.base.set_state(650);
						_la = recog.base.input.la(1);
						if { !(_la==AT || _la==BEFORE) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						recog.base.set_state(651);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						recog.base.set_state(661);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 TIMESTAMP 
							=> {
								{
								recog.base.set_state(652);
								recog.base.match_token(TIMESTAMP,&mut recog.err_handler)?;

								recog.base.set_state(653);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(654);
								recog.expression()?;

								}
							}

						 OFFSET 
							=> {
								{
								recog.base.set_state(655);
								recog.base.match_token(OFFSET,&mut recog.err_handler)?;

								recog.base.set_state(656);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(657);
								recog.expression()?;

								}
							}

						 STATEMENT 
							=> {
								{
								recog.base.set_state(658);
								recog.base.match_token(STATEMENT,&mut recog.err_handler)?;

								recog.base.set_state(659);
								recog.base.match_token(T__0,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(660);
								recog.expression()?;

								}
							}

							_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(663);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(669);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(667);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(668);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					}
				}
			,
				15 =>{
					let tmp = CreateRecursiveTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 15);
					_localctx = tmp;
					{
					recog.base.set_state(671);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(672);
					recog.base.match_token(RECURSIVE,&mut recog.err_handler)?;

					recog.base.set_state(673);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(677);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(41,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(674);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(675);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(676);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(679);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateRecursiveTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(681);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						/*InvokeRule columnAliases*/
						recog.base.set_state(680);
						recog.columnAliases()?;

						}
					}

					recog.base.set_state(685);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMENT {
						{
						recog.base.set_state(683);
						recog.base.match_token(COMMENT,&mut recog.err_handler)?;

						/*InvokeRule string*/
						recog.base.set_state(684);
						let tmp = recog.string()?;
						if let StatementContextAll::CreateRecursiveTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
						ctx.comment = Some(tmp.clone()); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(689);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==WITH {
						{
						recog.base.set_state(687);
						recog.base.match_token(WITH,&mut recog.err_handler)?;

						/*InvokeRule properties*/
						recog.base.set_state(688);
						recog.properties()?;

						}
					}

					recog.base.set_state(691);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					recog.base.set_state(697);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(45,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule query*/
							recog.base.set_state(692);
							recog.query()?;

							}
						}
					,
						2 =>{
							{
							recog.base.set_state(693);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule query*/
							recog.base.set_state(694);
							recog.query()?;

							recog.base.set_state(695);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				16 =>{
					let tmp = SnowflakeCreateTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 16);
					_localctx = tmp;
					{
					recog.base.set_state(699);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(702);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(700);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(701);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(708);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==GLOBAL || _la==LOCAL || ((((_la - 375)) & !0x3f) == 0 && ((1usize << (_la - 375)) & ((1usize << (TEMP - 375)) | (1usize << (TEMPORARY - 375)) | (1usize << (TRANSIENT - 375)))) != 0) || _la==VOLATILE {
						{
						recog.base.set_state(705);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==GLOBAL || _la==LOCAL {
							{
							recog.base.set_state(704);
							_la = recog.base.input.la(1);
							if { !(_la==GLOBAL || _la==LOCAL) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						recog.base.set_state(707);
						_la = recog.base.input.la(1);
						if { !(((((_la - 375)) & !0x3f) == 0 && ((1usize << (_la - 375)) & ((1usize << (TEMP - 375)) | (1usize << (TEMPORARY - 375)) | (1usize << (TRANSIENT - 375)))) != 0) || _la==VOLATILE) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(710);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(714);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(49,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(711);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(712);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(713);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(716);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::SnowflakeCreateTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(720);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(50,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(717);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(718);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(719);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule snowflakeCreateTableClauses*/
					recog.base.set_state(722);
					recog.snowflakeCreateTableClauses()?;

					recog.base.set_state(723);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule tableElements*/
					recog.base.set_state(724);
					recog.tableElements()?;

					recog.base.set_state(725);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule snowflakeCreateTableClauses*/
					recog.base.set_state(726);
					recog.snowflakeCreateTableClauses()?;

					}
				}
			,
				17 =>{
					let tmp = SnowflakeCreateTableUsingTemplateContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 17);
					_localctx = tmp;
					{
					recog.base.set_state(728);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(731);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(729);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(730);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(733);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(734);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::SnowflakeCreateTableUsingTemplateContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(735);
					recog.base.match_token(USING,&mut recog.err_handler)?;

					recog.base.set_state(736);
					recog.base.match_token(TEMPLATE,&mut recog.err_handler)?;

					recog.base.set_state(737);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(738);
					recog.query()?;

					recog.base.set_state(739);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				18 =>{
					let tmp = SnowflakeInsertIntoContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 18);
					_localctx = tmp;
					{
					recog.base.set_state(741);
					recog.base.match_token(INSERT,&mut recog.err_handler)?;

					recog.base.set_state(742);
					recog.base.match_token(INTO,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(743);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::SnowflakeInsertIntoContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(745);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(52,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule columnAliases*/
							recog.base.set_state(744);
							recog.columnAliases()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(760);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 SELECT | TABLE | WITH | LPAREN 
						=> {
							{
							/*InvokeRule query*/
							recog.base.set_state(747);
							recog.query()?;

							}
						}

					 VALUES 
						=> {
							{
							recog.base.set_state(748);
							recog.base.match_token(VALUES,&mut recog.err_handler)?;

							/*InvokeRule snowflakeValueRow*/
							recog.base.set_state(749);
							recog.snowflakeValueRow()?;

							recog.base.set_state(754);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(53,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(750);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule snowflakeValueRow*/
									recog.base.set_state(751);
									recog.snowflakeValueRow()?;

									}
									} 
								}
								recog.base.set_state(756);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(53,&mut recog.base)?;
							}
							recog.base.set_state(758);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(757);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::SnowflakeInsertIntoContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}
			,
				19 =>{
					let tmp = CreateMaterializedViewContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 19);
					_localctx = tmp;
					{
					recog.base.set_state(762);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(765);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(763);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(764);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(768);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(767);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(770);
					recog.base.match_token(MATERIALIZED,&mut recog.err_handler)?;

					recog.base.set_state(771);
					recog.base.match_token(VIEW,&mut recog.err_handler)?;

					recog.base.set_state(775);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(58,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(772);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(773);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(774);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(777);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateMaterializedViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(781);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IF {
						{
						recog.base.set_state(778);
						recog.base.match_token(IF,&mut recog.err_handler)?;

						recog.base.set_state(779);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						recog.base.set_state(780);
						recog.base.match_token(EXISTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(785);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(783);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(784);
						recog.base.match_token(GRANT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(801);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						recog.base.set_state(787);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule columnDefinitionForView*/
						recog.base.set_state(788);
						recog.columnDefinitionForView()?;

						recog.base.set_state(793);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(61,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(789);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule columnDefinitionForView*/
								recog.base.set_state(790);
								recog.columnDefinitionForView()?;

								}
								} 
							}
							recog.base.set_state(795);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(61,&mut recog.base)?;
						}
						recog.base.set_state(797);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(796);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateMaterializedViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateMaterializedViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateMaterializedViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail.push(temp); } else {unreachable!("cant cast");}  
							}
						}

						recog.base.set_state(799);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(806);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMENT {
						{
						recog.base.set_state(803);
						recog.base.match_token(COMMENT,&mut recog.err_handler)?;

						recog.base.set_state(804);
						recog.base.match_token(EQ,&mut recog.err_handler)?;

						/*InvokeRule string*/
						recog.base.set_state(805);
						recog.string()?;

						}
					}

					recog.base.set_state(827);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(67,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(809);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==WITH {
								{
								recog.base.set_state(808);
								recog.base.match_token(WITH,&mut recog.err_handler)?;

								}
							}

							recog.base.set_state(811);
							recog.base.match_token(ROW,&mut recog.err_handler)?;

							recog.base.set_state(812);
							recog.base.match_token(ACCESS,&mut recog.err_handler)?;

							recog.base.set_state(813);
							recog.base.match_token(POLICY,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(814);
							recog.identifier()?;

							recog.base.set_state(815);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(816);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(817);
							recog.identifier()?;

							recog.base.set_state(822);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==COMMA {
								{
								{
								recog.base.set_state(818);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule identifier*/
								recog.base.set_state(819);
								recog.identifier()?;

								}
								}
								recog.base.set_state(824);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(825);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(834);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TAG || _la==WITH {
						{
						recog.base.set_state(830);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==WITH {
							{
							recog.base.set_state(829);
							recog.base.match_token(WITH,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(832);
						recog.base.match_token(TAG,&mut recog.err_handler)?;

						/*InvokeRule properties*/
						recog.base.set_state(833);
						recog.properties()?;

						}
					}

					recog.base.set_state(849);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==CLUSTER {
						{
						recog.base.set_state(836);
						recog.base.match_token(CLUSTER,&mut recog.err_handler)?;

						recog.base.set_state(837);
						recog.base.match_token(BY,&mut recog.err_handler)?;

						recog.base.set_state(838);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(839);
						recog.expression()?;

						recog.base.set_state(844);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(840);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(841);
							recog.expression()?;

							}
							}
							recog.base.set_state(846);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(847);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(851);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					recog.base.set_state(852);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(853);
					recog.query()?;

					recog.base.set_state(854);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				20 =>{
					let tmp = CreateViewContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 20);
					_localctx = tmp;
					{
					recog.base.set_state(856);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(859);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(857);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(858);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(862);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(861);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(868);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==GLOBAL || _la==LOCAL || _la==TEMP || _la==TEMPORARY || _la==VOLATILE {
						{
						recog.base.set_state(865);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==GLOBAL || _la==LOCAL {
							{
							recog.base.set_state(864);
							_la = recog.base.input.la(1);
							if { !(_la==GLOBAL || _la==LOCAL) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						recog.base.set_state(867);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY || _la==VOLATILE) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(871);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==RECURSIVE {
						{
						recog.base.set_state(870);
						recog.base.match_token(RECURSIVE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(873);
					recog.base.match_token(VIEW,&mut recog.err_handler)?;

					recog.base.set_state(877);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(77,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(874);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(875);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(876);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(879);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(883);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IF {
						{
						recog.base.set_state(880);
						recog.base.match_token(IF,&mut recog.err_handler)?;

						recog.base.set_state(881);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						recog.base.set_state(882);
						recog.base.match_token(EXISTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(899);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						recog.base.set_state(885);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule columnDefinitionForView*/
						recog.base.set_state(886);
						recog.columnDefinitionForView()?;

						recog.base.set_state(891);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(79,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(887);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule columnDefinitionForView*/
								recog.base.set_state(888);
								recog.columnDefinitionForView()?;

								}
								} 
							}
							recog.base.set_state(893);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(79,&mut recog.base)?;
						}
						recog.base.set_state(895);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(894);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail.push(temp); } else {unreachable!("cant cast");}  
							}
						}

						recog.base.set_state(897);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(920);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(84,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(902);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==WITH {
								{
								recog.base.set_state(901);
								recog.base.match_token(WITH,&mut recog.err_handler)?;

								}
							}

							recog.base.set_state(904);
							recog.base.match_token(ROW,&mut recog.err_handler)?;

							recog.base.set_state(905);
							recog.base.match_token(ACCESS,&mut recog.err_handler)?;

							recog.base.set_state(906);
							recog.base.match_token(POLICY,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(907);
							recog.identifier()?;

							recog.base.set_state(908);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(909);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(910);
							recog.identifier()?;

							recog.base.set_state(915);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==COMMA {
								{
								{
								recog.base.set_state(911);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule identifier*/
								recog.base.set_state(912);
								recog.identifier()?;

								}
								}
								recog.base.set_state(917);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(918);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(927);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TAG || _la==WITH {
						{
						recog.base.set_state(923);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==WITH {
							{
							recog.base.set_state(922);
							recog.base.match_token(WITH,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(925);
						recog.base.match_token(TAG,&mut recog.err_handler)?;

						/*InvokeRule properties*/
						recog.base.set_state(926);
						recog.properties()?;

						}
					}

					recog.base.set_state(931);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(929);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(930);
						recog.base.match_token(GRANT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(936);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMENT {
						{
						recog.base.set_state(933);
						recog.base.match_token(COMMENT,&mut recog.err_handler)?;

						recog.base.set_state(934);
						recog.base.match_token(EQ,&mut recog.err_handler)?;

						/*InvokeRule string*/
						recog.base.set_state(935);
						let tmp = recog.string()?;
						if let StatementContextAll::CreateViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
						ctx.comment = Some(tmp.clone()); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(938);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					recog.base.set_state(944);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(89,&mut recog.base)? {
						1 =>{
							{
							recog.base.set_state(939);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule query*/
							recog.base.set_state(940);
							recog.query()?;

							recog.base.set_state(941);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule query*/
							recog.base.set_state(943);
							recog.query()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				21 =>{
					let tmp = SetContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 21);
					_localctx = tmp;
					{
					recog.base.set_state(946);
					recog.base.match_token(SET,&mut recog.err_handler)?;

					/*InvokeRule property*/
					recog.base.set_state(947);
					recog.property()?;

					}
				}
			,
				22 =>{
					let tmp = SetContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 22);
					_localctx = tmp;
					{
					recog.base.set_state(948);
					recog.base.match_token(SET,&mut recog.err_handler)?;

					recog.base.set_state(949);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(950);
					recog.identifier()?;

					recog.base.set_state(955);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						recog.base.set_state(951);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(952);
						recog.identifier()?;

						}
						}
						recog.base.set_state(957);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(958);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(959);
					recog.base.match_token(EQ,&mut recog.err_handler)?;

					recog.base.set_state(960);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(961);
					recog.expression()?;

					recog.base.set_state(966);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						recog.base.set_state(962);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(963);
						recog.expression()?;

						}
						}
						recog.base.set_state(968);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(969);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				23 =>{
					let tmp = ShowColumnsContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 23);
					_localctx = tmp;
					{
					recog.base.set_state(971);
					_la = recog.base.input.la(1);
					if { !(_la==DESC || _la==DESCRIBE) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(972);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(973);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::ShowColumnsContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.tableName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				24 =>{
					let tmp = CreateStageContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 24);
					_localctx = tmp;
					{
					recog.base.set_state(974);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(977);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(975);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(976);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(980);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(979);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(982);
					recog.base.match_token(STAGE,&mut recog.err_handler)?;

					recog.base.set_state(986);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(94,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(983);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(984);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(985);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(988);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateStageContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.dest = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(992);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(95,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(989);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(990);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(991);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(997);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(96,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							/*InvokeRule property*/
							recog.base.set_state(994);
							recog.property()?;

							}
							} 
						}
						recog.base.set_state(999);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(96,&mut recog.base)?;
					}
					recog.base.set_state(1005);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TAG || _la==WITH {
						{
						recog.base.set_state(1001);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==WITH {
							{
							recog.base.set_state(1000);
							recog.base.match_token(WITH,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1003);
						recog.base.match_token(TAG,&mut recog.err_handler)?;

						/*InvokeRule properties*/
						recog.base.set_state(1004);
						recog.properties()?;

						}
					}

					}
				}
			,
				25 =>{
					let tmp = CreateJavaFunctionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 25);
					_localctx = tmp;
					{
					recog.base.set_state(1007);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1010);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1008);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1009);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1013);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(1012);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(1016);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(1015);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1018);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					recog.base.set_state(1022);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(102,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1019);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(1020);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(1021);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(1024);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1028);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IF {
						{
						recog.base.set_state(1025);
						recog.base.match_token(IF,&mut recog.err_handler)?;

						recog.base.set_state(1026);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						recog.base.set_state(1027);
						recog.base.match_token(EXISTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1030);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1042);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1031);
						recog.namedParameter()?;

						recog.base.set_state(1036);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(104,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1032);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1033);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1038);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(104,&mut recog.base)?;
						}
						recog.base.set_state(1040);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1039);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1044);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1047);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(1045);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(1046);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1049);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					recog.base.set_state(1069);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INTERVAL | INVOKER | IO | ISOLATION | JAVA |
					 JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT |
					 JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE |
					 LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY | LIMIT |
					 LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
					 MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO |
					 NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULL | NULLS | OBJECT |
					 OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER |
					 OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT |
					 RLS | ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR |
					 SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI |
					 SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS |
					 SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT |
					 STATS | STORED | STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM |
					 SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED |
					 TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG |
					 TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE |
					 TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
					 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
					 USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING |
					 VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW |
					 WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE |
					 ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule type_*/
							recog.base.set_state(1050);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

					 TABLE 
						=> {
							{
							recog.base.set_state(1051);
							recog.base.match_token(TABLE,&mut recog.err_handler)?;

							recog.base.set_state(1052);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(1053);
							let tmp = recog.identifier()?;
							if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
							/*InvokeRule type_*/
							recog.base.set_state(1054);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
							recog.base.set_state(1061);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(108,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1055);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule identifier*/
									recog.base.set_state(1056);
									let tmp = recog.identifier()?;
									if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
									/*InvokeRule type_*/
									recog.base.set_state(1057);
									let tmp = recog.type_()?;
									if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
									}
									} 
								}
								recog.base.set_state(1063);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(108,&mut recog.base)?;
							}
							recog.base.set_state(1065);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(1064);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							recog.base.set_state(1067);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1075);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1072);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1071);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1074);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1077);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					recog.base.set_state(1078);
					recog.base.match_token(JAVA,&mut recog.err_handler)?;

					recog.base.set_state(1089);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(113,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1079);
							recog.base.match_token(CALLED,&mut recog.err_handler)?;

							recog.base.set_state(1080);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1081);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1082);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 2=>{
							{
							recog.base.set_state(1083);
							recog.base.match_token(RETURN,&mut recog.err_handler)?;

							recog.base.set_state(1084);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1085);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1086);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1087);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 3=>{
							{
							recog.base.set_state(1088);
							recog.base.match_token(STRICT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1092);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(114,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1091);
							_la = recog.base.input.la(1);
							if { !(_la==IMMUTABLE || _la==VOLATILE) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					recog.base.set_state(1097);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(1094);
						recog.property()?;

						}
						}
						recog.base.set_state(1099);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1100);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1101);
					let tmp = recog.expression()?;
					if let StatementContextAll::CreateJavaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.body = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				26 =>{
					let tmp = CreateJarFunctionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 26);
					_localctx = tmp;
					{
					recog.base.set_state(1103);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1106);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1104);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1105);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1109);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(1108);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(1112);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(1111);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1114);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					recog.base.set_state(1118);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(119,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1115);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(1116);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(1117);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(1120);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1124);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IF {
						{
						recog.base.set_state(1121);
						recog.base.match_token(IF,&mut recog.err_handler)?;

						recog.base.set_state(1122);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						recog.base.set_state(1123);
						recog.base.match_token(EXISTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1126);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1138);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1127);
						recog.namedParameter()?;

						recog.base.set_state(1132);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(121,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1128);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1129);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1134);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(121,&mut recog.base)?;
						}
						recog.base.set_state(1136);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1135);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1140);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1143);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(1141);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(1142);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1145);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					recog.base.set_state(1165);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INTERVAL | INVOKER | IO | ISOLATION | JAVA |
					 JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT |
					 JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE |
					 LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY | LIMIT |
					 LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
					 MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO |
					 NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULL | NULLS | OBJECT |
					 OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER |
					 OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT |
					 RLS | ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR |
					 SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI |
					 SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS |
					 SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT |
					 STATS | STORED | STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM |
					 SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED |
					 TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG |
					 TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE |
					 TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
					 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
					 USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING |
					 VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW |
					 WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE |
					 ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule type_*/
							recog.base.set_state(1146);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

					 TABLE 
						=> {
							{
							recog.base.set_state(1147);
							recog.base.match_token(TABLE,&mut recog.err_handler)?;

							recog.base.set_state(1148);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(1149);
							let tmp = recog.identifier()?;
							if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
							/*InvokeRule type_*/
							recog.base.set_state(1150);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
							recog.base.set_state(1157);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(125,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1151);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule identifier*/
									recog.base.set_state(1152);
									let tmp = recog.identifier()?;
									if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
									/*InvokeRule type_*/
									recog.base.set_state(1153);
									let tmp = recog.type_()?;
									if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
									}
									} 
								}
								recog.base.set_state(1159);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(125,&mut recog.base)?;
							}
							recog.base.set_state(1161);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(1160);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::CreateJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							recog.base.set_state(1163);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1171);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1168);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1167);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1170);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1173);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					recog.base.set_state(1174);
					recog.base.match_token(JAVA,&mut recog.err_handler)?;

					recog.base.set_state(1185);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(130,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1175);
							recog.base.match_token(CALLED,&mut recog.err_handler)?;

							recog.base.set_state(1176);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1177);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1178);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 2=>{
							{
							recog.base.set_state(1179);
							recog.base.match_token(RETURN,&mut recog.err_handler)?;

							recog.base.set_state(1180);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1181);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1182);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1183);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 3=>{
							{
							recog.base.set_state(1184);
							recog.base.match_token(STRICT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1188);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(131,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1187);
							_la = recog.base.input.la(1);
							if { !(_la==IMMUTABLE || _la==VOLATILE) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					recog.base.set_state(1193);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(1190);
						recog.property()?;

						}
						}
						recog.base.set_state(1195);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				27 =>{
					let tmp = CreateJSFunctionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 27);
					_localctx = tmp;
					{
					recog.base.set_state(1196);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1199);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1197);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1198);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1202);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(1201);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(1205);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(1204);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1207);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					recog.base.set_state(1211);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(136,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1208);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(1209);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(1210);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(1213);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1217);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IF {
						{
						recog.base.set_state(1214);
						recog.base.match_token(IF,&mut recog.err_handler)?;

						recog.base.set_state(1215);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						recog.base.set_state(1216);
						recog.base.match_token(EXISTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1219);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1231);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1220);
						recog.namedParameter()?;

						recog.base.set_state(1225);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(138,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1221);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1222);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1227);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(138,&mut recog.base)?;
						}
						recog.base.set_state(1229);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1228);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1233);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1236);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(1234);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(1235);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1238);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					recog.base.set_state(1258);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INTERVAL | INVOKER | IO | ISOLATION | JAVA |
					 JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT |
					 JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE |
					 LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY | LIMIT |
					 LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
					 MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO |
					 NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULL | NULLS | OBJECT |
					 OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER |
					 OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT |
					 RLS | ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR |
					 SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI |
					 SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS |
					 SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT |
					 STATS | STORED | STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM |
					 SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED |
					 TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG |
					 TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE |
					 TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
					 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
					 USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING |
					 VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW |
					 WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE |
					 ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule type_*/
							recog.base.set_state(1239);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

					 TABLE 
						=> {
							{
							recog.base.set_state(1240);
							recog.base.match_token(TABLE,&mut recog.err_handler)?;

							recog.base.set_state(1241);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(1242);
							let tmp = recog.identifier()?;
							if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
							/*InvokeRule type_*/
							recog.base.set_state(1243);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
							recog.base.set_state(1250);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(142,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1244);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule identifier*/
									recog.base.set_state(1245);
									let tmp = recog.identifier()?;
									if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
									/*InvokeRule type_*/
									recog.base.set_state(1246);
									let tmp = recog.type_()?;
									if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
									}
									} 
								}
								recog.base.set_state(1252);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(142,&mut recog.base)?;
							}
							recog.base.set_state(1254);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(1253);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							recog.base.set_state(1256);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1264);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1261);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1260);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1263);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1266);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					recog.base.set_state(1267);
					recog.base.match_token(JAVASCRIPT,&mut recog.err_handler)?;

					recog.base.set_state(1278);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(147,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1268);
							recog.base.match_token(CALLED,&mut recog.err_handler)?;

							recog.base.set_state(1269);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1270);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1271);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 2=>{
							{
							recog.base.set_state(1272);
							recog.base.match_token(RETURN,&mut recog.err_handler)?;

							recog.base.set_state(1273);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1274);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1275);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1276);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 3=>{
							{
							recog.base.set_state(1277);
							recog.base.match_token(STRICT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1281);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(148,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1280);
							_la = recog.base.input.la(1);
							if { !(_la==IMMUTABLE || _la==VOLATILE) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					recog.base.set_state(1286);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(1283);
						recog.property()?;

						}
						}
						recog.base.set_state(1288);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1289);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1290);
					let tmp = recog.expression()?;
					if let StatementContextAll::CreateJSFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.body = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				28 =>{
					let tmp = CreatePythonFunctionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 28);
					_localctx = tmp;
					{
					recog.base.set_state(1292);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1295);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1293);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1294);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1298);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(1297);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(1301);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(1300);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1303);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					recog.base.set_state(1307);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(153,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1304);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(1305);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(1306);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(1309);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1313);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IF {
						{
						recog.base.set_state(1310);
						recog.base.match_token(IF,&mut recog.err_handler)?;

						recog.base.set_state(1311);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						recog.base.set_state(1312);
						recog.base.match_token(EXISTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1315);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1327);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1316);
						recog.namedParameter()?;

						recog.base.set_state(1321);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(155,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1317);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1318);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1323);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(155,&mut recog.base)?;
						}
						recog.base.set_state(1325);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1324);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1329);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1332);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(1330);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(1331);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1334);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					recog.base.set_state(1354);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INTERVAL | INVOKER | IO | ISOLATION | JAVA |
					 JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT |
					 JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE |
					 LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY | LIMIT |
					 LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
					 MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO |
					 NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULL | NULLS | OBJECT |
					 OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER |
					 OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT |
					 RLS | ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR |
					 SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI |
					 SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS |
					 SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT |
					 STATS | STORED | STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM |
					 SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED |
					 TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG |
					 TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE |
					 TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
					 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
					 USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING |
					 VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW |
					 WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE |
					 ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule type_*/
							recog.base.set_state(1335);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

					 TABLE 
						=> {
							{
							recog.base.set_state(1336);
							recog.base.match_token(TABLE,&mut recog.err_handler)?;

							recog.base.set_state(1337);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(1338);
							let tmp = recog.identifier()?;
							if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
							/*InvokeRule type_*/
							recog.base.set_state(1339);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
							recog.base.set_state(1346);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(159,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1340);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule identifier*/
									recog.base.set_state(1341);
									let tmp = recog.identifier()?;
									if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
									/*InvokeRule type_*/
									recog.base.set_state(1342);
									let tmp = recog.type_()?;
									if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
									}
									} 
								}
								recog.base.set_state(1348);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(159,&mut recog.base)?;
							}
							recog.base.set_state(1350);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(1349);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							recog.base.set_state(1352);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1360);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1357);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1356);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1359);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1362);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					recog.base.set_state(1363);
					recog.base.match_token(PYTHON,&mut recog.err_handler)?;

					recog.base.set_state(1374);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(164,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1364);
							recog.base.match_token(CALLED,&mut recog.err_handler)?;

							recog.base.set_state(1365);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1366);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1367);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 2=>{
							{
							recog.base.set_state(1368);
							recog.base.match_token(RETURN,&mut recog.err_handler)?;

							recog.base.set_state(1369);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1370);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1371);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1372);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 3=>{
							{
							recog.base.set_state(1373);
							recog.base.match_token(STRICT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1377);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(165,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1376);
							_la = recog.base.input.la(1);
							if { !(_la==IMMUTABLE || _la==VOLATILE) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					recog.base.set_state(1382);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(1379);
						recog.property()?;

						}
						}
						recog.base.set_state(1384);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1385);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1386);
					let tmp = recog.expression()?;
					if let StatementContextAll::CreatePythonFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.body = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				29 =>{
					let tmp = CreateModuleFunctionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 29);
					_localctx = tmp;
					{
					recog.base.set_state(1388);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1391);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1389);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1390);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1394);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(1393);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(1397);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(1396);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1399);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					recog.base.set_state(1403);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(170,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1400);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(1401);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(1402);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(1405);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1409);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IF {
						{
						recog.base.set_state(1406);
						recog.base.match_token(IF,&mut recog.err_handler)?;

						recog.base.set_state(1407);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						recog.base.set_state(1408);
						recog.base.match_token(EXISTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1411);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1423);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1412);
						recog.namedParameter()?;

						recog.base.set_state(1417);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(172,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1413);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1414);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1419);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(172,&mut recog.base)?;
						}
						recog.base.set_state(1421);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1420);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1425);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1428);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(1426);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(1427);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1430);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					recog.base.set_state(1450);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INTERVAL | INVOKER | IO | ISOLATION | JAVA |
					 JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT |
					 JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE |
					 LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY | LIMIT |
					 LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
					 MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO |
					 NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULL | NULLS | OBJECT |
					 OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER |
					 OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT |
					 RLS | ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR |
					 SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI |
					 SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS |
					 SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT |
					 STATS | STORED | STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM |
					 SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED |
					 TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG |
					 TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE |
					 TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
					 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
					 USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING |
					 VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW |
					 WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE |
					 ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule type_*/
							recog.base.set_state(1431);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

					 TABLE 
						=> {
							{
							recog.base.set_state(1432);
							recog.base.match_token(TABLE,&mut recog.err_handler)?;

							recog.base.set_state(1433);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(1434);
							let tmp = recog.identifier()?;
							if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
							/*InvokeRule type_*/
							recog.base.set_state(1435);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
							recog.base.set_state(1442);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(176,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1436);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule identifier*/
									recog.base.set_state(1437);
									let tmp = recog.identifier()?;
									if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
									/*InvokeRule type_*/
									recog.base.set_state(1438);
									let tmp = recog.type_()?;
									if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
									}
									} 
								}
								recog.base.set_state(1444);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(176,&mut recog.base)?;
							}
							recog.base.set_state(1446);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(1445);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::CreateModuleFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							recog.base.set_state(1448);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1456);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1453);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1452);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1455);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1458);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					recog.base.set_state(1459);
					recog.base.match_token(PYTHON,&mut recog.err_handler)?;

					recog.base.set_state(1470);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(181,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1460);
							recog.base.match_token(CALLED,&mut recog.err_handler)?;

							recog.base.set_state(1461);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1462);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1463);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 2=>{
							{
							recog.base.set_state(1464);
							recog.base.match_token(RETURN,&mut recog.err_handler)?;

							recog.base.set_state(1465);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1466);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1467);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1468);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 3=>{
							{
							recog.base.set_state(1469);
							recog.base.match_token(STRICT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1473);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(182,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1472);
							_la = recog.base.input.la(1);
							if { !(_la==IMMUTABLE || _la==VOLATILE) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					recog.base.set_state(1478);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(1475);
						recog.property()?;

						}
						}
						recog.base.set_state(1480);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				30 =>{
					let tmp = CreateScalaFunctionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 30);
					_localctx = tmp;
					{
					recog.base.set_state(1481);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1484);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1482);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1483);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1487);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(1486);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(1490);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(1489);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1492);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					recog.base.set_state(1496);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(187,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1493);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(1494);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(1495);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(1498);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateScalaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1502);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IF {
						{
						recog.base.set_state(1499);
						recog.base.match_token(IF,&mut recog.err_handler)?;

						recog.base.set_state(1500);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						recog.base.set_state(1501);
						recog.base.match_token(EXISTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1504);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1516);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1505);
						recog.namedParameter()?;

						recog.base.set_state(1510);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(189,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1506);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1507);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1512);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(189,&mut recog.base)?;
						}
						recog.base.set_state(1514);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1513);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateScalaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1518);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1521);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(1519);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(1520);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1523);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					/*InvokeRule type_*/
					recog.base.set_state(1524);
					let tmp = recog.type_()?;
					if let StatementContextAll::CreateScalaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1529);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1526);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1525);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1528);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1531);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					recog.base.set_state(1532);
					recog.base.match_token(SCALA,&mut recog.err_handler)?;

					recog.base.set_state(1543);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(195,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1533);
							recog.base.match_token(CALLED,&mut recog.err_handler)?;

							recog.base.set_state(1534);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1535);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1536);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 2=>{
							{
							recog.base.set_state(1537);
							recog.base.match_token(RETURN,&mut recog.err_handler)?;

							recog.base.set_state(1538);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1539);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1540);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1541);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 3=>{
							{
							recog.base.set_state(1542);
							recog.base.match_token(STRICT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1546);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(196,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1545);
							_la = recog.base.input.la(1);
							if { !(_la==IMMUTABLE || _la==VOLATILE) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					recog.base.set_state(1551);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(1548);
						recog.property()?;

						}
						}
						recog.base.set_state(1553);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1554);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1555);
					let tmp = recog.expression()?;
					if let StatementContextAll::CreateScalaFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.body = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				31 =>{
					let tmp = CreateScalaJarFunctionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 31);
					_localctx = tmp;
					{
					recog.base.set_state(1557);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1560);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1558);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1559);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1563);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(1562);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(1566);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(1565);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1568);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					recog.base.set_state(1572);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(201,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1569);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(1570);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(1571);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(1574);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateScalaJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1578);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IF {
						{
						recog.base.set_state(1575);
						recog.base.match_token(IF,&mut recog.err_handler)?;

						recog.base.set_state(1576);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						recog.base.set_state(1577);
						recog.base.match_token(EXISTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1580);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1592);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1581);
						recog.namedParameter()?;

						recog.base.set_state(1586);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(203,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1582);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1583);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1588);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(203,&mut recog.base)?;
						}
						recog.base.set_state(1590);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1589);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateScalaJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1594);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1597);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(1595);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(1596);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1599);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					/*InvokeRule type_*/
					recog.base.set_state(1600);
					let tmp = recog.type_()?;
					if let StatementContextAll::CreateScalaJarFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1605);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1602);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1601);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1604);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1607);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					recog.base.set_state(1608);
					recog.base.match_token(SCALA,&mut recog.err_handler)?;

					recog.base.set_state(1619);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(209,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1609);
							recog.base.match_token(CALLED,&mut recog.err_handler)?;

							recog.base.set_state(1610);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1611);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1612);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 2=>{
							{
							recog.base.set_state(1613);
							recog.base.match_token(RETURN,&mut recog.err_handler)?;

							recog.base.set_state(1614);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1615);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(1616);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							recog.base.set_state(1617);
							recog.base.match_token(INPUT,&mut recog.err_handler)?;

							}
						}

						x if x == 3=>{
							{
							recog.base.set_state(1618);
							recog.base.match_token(STRICT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1622);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(210,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1621);
							_la = recog.base.input.la(1);
							if { !(_la==IMMUTABLE || _la==VOLATILE) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					recog.base.set_state(1627);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(1624);
						recog.property()?;

						}
						}
						recog.base.set_state(1629);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				32 =>{
					let tmp = CreateSqlFunctionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 32);
					_localctx = tmp;
					{
					recog.base.set_state(1630);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1633);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1631);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1632);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1636);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(1635);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(1639);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(1638);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1641);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(1642);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1643);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1655);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1644);
						recog.namedParameter()?;

						recog.base.set_state(1649);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(215,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1645);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1646);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1651);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(215,&mut recog.base)?;
						}
						recog.base.set_state(1653);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1652);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1657);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1660);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(1658);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(1659);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1662);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					recog.base.set_state(1682);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INTERVAL | INVOKER | IO | ISOLATION | JAVA |
					 JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT |
					 JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE |
					 LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY | LIMIT |
					 LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
					 MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO |
					 NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULL | NULLS | OBJECT |
					 OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER |
					 OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT |
					 RLS | ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR |
					 SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI |
					 SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS |
					 SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT |
					 STATS | STORED | STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM |
					 SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED |
					 TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG |
					 TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE |
					 TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
					 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
					 USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING |
					 VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW |
					 WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE |
					 ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule type_*/
							recog.base.set_state(1663);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

					 TABLE 
						=> {
							{
							recog.base.set_state(1664);
							recog.base.match_token(TABLE,&mut recog.err_handler)?;

							recog.base.set_state(1665);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(1666);
							let tmp = recog.identifier()?;
							if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
							/*InvokeRule type_*/
							recog.base.set_state(1667);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
							recog.base.set_state(1674);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(219,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1668);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule identifier*/
									recog.base.set_state(1669);
									let tmp = recog.identifier()?;
									if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
									/*InvokeRule type_*/
									recog.base.set_state(1670);
									let tmp = recog.type_()?;
									if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
									}
									} 
								}
								recog.base.set_state(1676);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(219,&mut recog.base)?;
							}
							recog.base.set_state(1678);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(1677);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							recog.base.set_state(1680);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1688);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1685);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1684);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1687);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1692);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(224,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1690);
							recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

							recog.base.set_state(1691);
							recog.base.match_token(SQL,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1695);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(225,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1694);
							_la = recog.base.input.la(1);
							if { !(_la==IMMUTABLE || _la==VOLATILE) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					recog.base.set_state(1698);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(226,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1697);
							recog.base.match_token(MEMORIZABLE,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(1703);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(1700);
						recog.property()?;

						}
						}
						recog.base.set_state(1705);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1706);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1707);
					let tmp = recog.expression()?;
					if let StatementContextAll::CreateSqlFunctionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.body = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				33 =>{
					let tmp = CreatePythonProcedureContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 33);
					_localctx = tmp;
					{
					recog.base.set_state(1709);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1712);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1710);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1711);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1715);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==TEMP || _la==TEMPORARY {
						{
						recog.base.set_state(1714);
						_la = recog.base.input.la(1);
						if { !(_la==TEMP || _la==TEMPORARY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(1718);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SECURE {
						{
						recog.base.set_state(1717);
						recog.base.match_token(SECURE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1720);
					recog.base.match_token(PROCEDURE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(1721);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1722);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1734);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1723);
						recog.namedParameter()?;

						recog.base.set_state(1728);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(231,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1724);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1725);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1730);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(231,&mut recog.base)?;
						}
						recog.base.set_state(1732);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1731);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1736);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1739);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPY {
						{
						recog.base.set_state(1737);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(1738);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1741);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					recog.base.set_state(1761);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INTERVAL | INVOKER | IO | ISOLATION | JAVA |
					 JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT |
					 JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE |
					 LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY | LIMIT |
					 LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
					 MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO |
					 NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULL | NULLS | OBJECT |
					 OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER |
					 OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT |
					 RLS | ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR |
					 SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI |
					 SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS |
					 SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT |
					 STATS | STORED | STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM |
					 SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED |
					 TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG |
					 TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE |
					 TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
					 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
					 USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING |
					 VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW |
					 WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE |
					 ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule type_*/
							recog.base.set_state(1742);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

					 TABLE 
						=> {
							{
							recog.base.set_state(1743);
							recog.base.match_token(TABLE,&mut recog.err_handler)?;

							recog.base.set_state(1744);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(1745);
							let tmp = recog.identifier()?;
							if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
							/*InvokeRule type_*/
							recog.base.set_state(1746);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
							recog.base.set_state(1753);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(235,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1747);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule identifier*/
									recog.base.set_state(1748);
									let tmp = recog.identifier()?;
									if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
									/*InvokeRule type_*/
									recog.base.set_state(1749);
									let tmp = recog.type_()?;
									if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
									}
									} 
								}
								recog.base.set_state(1755);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(235,&mut recog.base)?;
							}
							recog.base.set_state(1757);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(1756);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							recog.base.set_state(1759);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1767);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1764);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1763);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1766);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1769);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					recog.base.set_state(1770);
					recog.base.match_token(PYTHON,&mut recog.err_handler)?;

					recog.base.set_state(1774);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(1771);
						recog.property()?;

						}
						}
						recog.base.set_state(1776);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(1779);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==AS {
						{
						recog.base.set_state(1777);
						recog.base.match_token(AS,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(1778);
						let tmp = recog.expression()?;
						if let StatementContextAll::CreatePythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
						ctx.body = Some(tmp.clone()); } else {unreachable!("cant cast");}  

						}
					}

					}
				}
			,
				34 =>{
					let tmp = CreateAnonymousPythonProcedureContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 34);
					_localctx = tmp;
					{
					recog.base.set_state(1781);
					recog.base.match_token(WITH,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(1782);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.name = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1783);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					recog.base.set_state(1784);
					recog.base.match_token(PROCEDURE,&mut recog.err_handler)?;

					recog.base.set_state(1785);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1797);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule namedParameter*/
						recog.base.set_state(1786);
						recog.namedParameter()?;

						recog.base.set_state(1791);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(242,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(1787);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule namedParameter*/
								recog.base.set_state(1788);
								recog.namedParameter()?;

								}
								} 
							}
							recog.base.set_state(1793);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(242,&mut recog.base)?;
						}
						recog.base.set_state(1795);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1794);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(1799);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(1800);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					recog.base.set_state(1820);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INTERVAL | INVOKER | IO | ISOLATION | JAVA |
					 JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT |
					 JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE |
					 LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY | LIMIT |
					 LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
					 MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO |
					 NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULL | NULLS | OBJECT |
					 OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER |
					 OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT |
					 RLS | ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR |
					 SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI |
					 SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS |
					 SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT |
					 STATS | STORED | STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM |
					 SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED |
					 TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG |
					 TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE |
					 TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
					 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
					 USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING |
					 VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW |
					 WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE |
					 ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule type_*/
							recog.base.set_state(1801);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.singleReturnType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

					 TABLE 
						=> {
							{
							recog.base.set_state(1802);
							recog.base.match_token(TABLE,&mut recog.err_handler)?;

							recog.base.set_state(1803);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(1804);
							let tmp = recog.identifier()?;
							if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
							/*InvokeRule type_*/
							recog.base.set_state(1805);
							let tmp = recog.type_()?;
							if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
							recog.base.set_state(1812);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(245,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1806);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule identifier*/
									recog.base.set_state(1807);
									let tmp = recog.identifier()?;
									if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.identifier.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldName.push(temp); } else {unreachable!("cant cast");}  
									/*InvokeRule type_*/
									recog.base.set_state(1808);
									let tmp = recog.type_()?;
									if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									let temp = if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.type_.clone().unwrap() } else {unreachable!("cant cast");} ;
									if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
									ctx.tableReturnFieldType.push(temp); } else {unreachable!("cant cast");}  
									}
									} 
								}
								recog.base.set_state(1814);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(245,&mut recog.base)?;
							}
							recog.base.set_state(1816);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(1815);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							recog.base.set_state(1818);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(1826);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT || _la==NULL {
						{
						recog.base.set_state(1823);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOT {
							{
							recog.base.set_state(1822);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(1825);
						recog.base.match_token(NULL,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1828);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					recog.base.set_state(1829);
					recog.base.match_token(PYTHON,&mut recog.err_handler)?;

					recog.base.set_state(1833);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(250,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							/*InvokeRule property*/
							recog.base.set_state(1830);
							recog.property()?;

							}
							} 
						}
						recog.base.set_state(1835);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(250,&mut recog.base)?;
					}
					recog.base.set_state(1844);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==EXECUTE {
						{
						recog.base.set_state(1836);
						recog.base.match_token(EXECUTE,&mut recog.err_handler)?;

						recog.base.set_state(1837);
						recog.base.match_token(AS,&mut recog.err_handler)?;

						recog.base.set_state(1842);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 OWNER 
							=> {
								{
								recog.base.set_state(1838);
								recog.base.match_token(OWNER,&mut recog.err_handler)?;

								}
							}

						 CALLER 
							=> {
								{
								recog.base.set_state(1839);
								recog.base.match_token(CALLER,&mut recog.err_handler)?;

								}
							}

						 RESTRICTED 
							=> {
								{
								recog.base.set_state(1840);
								recog.base.match_token(RESTRICTED,&mut recog.err_handler)?;

								recog.base.set_state(1841);
								recog.base.match_token(CALLER,&mut recog.err_handler)?;

								}
							}

							_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						}
					}

					recog.base.set_state(1846);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(1847);
					let tmp = recog.expression()?;
					if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.body = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1848);
					recog.base.match_token(CALL,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(1849);
					recog.qualifiedName()?;

					recog.base.set_state(1865);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						recog.base.set_state(1850);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						recog.base.set_state(1859);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOT - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (ASTERISK - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
							{
							/*InvokeRule callArgument*/
							recog.base.set_state(1851);
							recog.callArgument()?;

							recog.base.set_state(1856);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(253,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(1852);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule callArgument*/
									recog.base.set_state(1853);
									recog.callArgument()?;

									}
									} 
								}
								recog.base.set_state(1858);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(253,&mut recog.base)?;
							}
							}
						}

						recog.base.set_state(1862);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(1861);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::CreateAnonymousPythonProcedureContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						recog.base.set_state(1864);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1870);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==INTO {
						{
						recog.base.set_state(1867);
						recog.base.match_token(INTO,&mut recog.err_handler)?;

						recog.base.set_state(1868);
						recog.base.match_token(COLON,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(1869);
						recog.identifier()?;

						}
					}

					}
				}
			,
				35 =>{
					let tmp = UnsetContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 35);
					_localctx = tmp;
					{
					recog.base.set_state(1872);
					recog.base.match_token(UNSET,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(1873);
					recog.identifier()?;

					}
				}
			,
				36 =>{
					let tmp = MergeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 36);
					_localctx = tmp;
					{
					recog.base.set_state(1874);
					recog.base.match_token(MERGE,&mut recog.err_handler)?;

					recog.base.set_state(1878);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1875);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1880);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				37 =>{
					let tmp = AlterContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 37);
					_localctx = tmp;
					{
					recog.base.set_state(1881);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(1885);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1882);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1887);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				38 =>{
					let tmp = BeginContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 38);
					_localctx = tmp;
					{
					recog.base.set_state(1888);
					recog.base.match_token(BEGIN,&mut recog.err_handler)?;

					recog.base.set_state(1892);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1889);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1894);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				39 =>{
					let tmp = UseContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 39);
					_localctx = tmp;
					{
					recog.base.set_state(1895);
					recog.base.match_token(USE,&mut recog.err_handler)?;

					recog.base.set_state(1899);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1896);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1901);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				40 =>{
					let tmp = CreateFooContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 40);
					_localctx = tmp;
					{
					recog.base.set_state(1902);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1905);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1903);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1904);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1907);
					recog.base.match_token(DATABASE,&mut recog.err_handler)?;

					recog.base.set_state(1911);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1908);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1913);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				41 =>{
					let tmp = CreateFooContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 41);
					_localctx = tmp;
					{
					recog.base.set_state(1914);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1917);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1915);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1916);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1919);
					recog.base.match_token(SEQUENCE,&mut recog.err_handler)?;

					recog.base.set_state(1923);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1920);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1925);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				42 =>{
					let tmp = CreateFooContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 42);
					_localctx = tmp;
					{
					recog.base.set_state(1926);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1929);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1927);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1928);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1931);
					recog.base.match_token(MASKING,&mut recog.err_handler)?;

					recog.base.set_state(1932);
					recog.base.match_token(POLICY,&mut recog.err_handler)?;

					recog.base.set_state(1936);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1933);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1938);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				43 =>{
					let tmp = CreateSchemaContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 43);
					_localctx = tmp;
					{
					recog.base.set_state(1939);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(1942);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OR {
						{
						recog.base.set_state(1940);
						recog.base.match_token(OR,&mut recog.err_handler)?;

						recog.base.set_state(1941);
						recog.base.match_token(REPLACE,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(1944);
					recog.base.match_token(SCHEMA,&mut recog.err_handler)?;

					recog.base.set_state(1948);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1945);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1950);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				44 =>{
					let tmp = DropContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 44);
					_localctx = tmp;
					{
					recog.base.set_state(1951);
					recog.base.match_token(DROP,&mut recog.err_handler)?;

					recog.base.set_state(1955);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1952);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1957);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				45 =>{
					let tmp = DeleteContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 45);
					_localctx = tmp;
					{
					recog.base.set_state(1958);
					recog.base.match_token(DELETE,&mut recog.err_handler)?;

					recog.base.set_state(1962);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1959);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1964);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				46 =>{
					let tmp = TruncateTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 46);
					_localctx = tmp;
					{
					recog.base.set_state(1965);
					recog.base.match_token(TRUNCATE,&mut recog.err_handler)?;

					recog.base.set_state(1969);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1966);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1971);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				47 =>{
					let tmp = CommentContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 47);
					_localctx = tmp;
					{
					recog.base.set_state(1972);
					recog.base.match_token(COMMENT,&mut recog.err_handler)?;

					recog.base.set_state(1976);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(1973);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(1978);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				48 =>{
					let tmp = RenameTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 48);
					_localctx = tmp;
					{
					recog.base.set_state(1979);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(1980);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(1983);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(274,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1981);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(1982);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(1985);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::RenameTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.from = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1986);
					recog.base.match_token(RENAME,&mut recog.err_handler)?;

					recog.base.set_state(1987);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(1988);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::RenameTableContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.to = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				49 =>{
					let tmp = AddColumnContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 49);
					_localctx = tmp;
					{
					recog.base.set_state(1990);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(1991);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(1994);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(275,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1992);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(1993);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(1996);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::AddColumnContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.tableName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(1997);
					recog.base.match_token(ADD,&mut recog.err_handler)?;

					recog.base.set_state(1998);
					recog.base.match_token(COLUMN,&mut recog.err_handler)?;

					recog.base.set_state(2002);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(276,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(1999);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(2000);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(2001);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule columnDefinition*/
					recog.base.set_state(2004);
					let tmp = recog.columnDefinition()?;
					if let StatementContextAll::AddColumnContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.column = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				50 =>{
					let tmp = RenameColumnContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 50);
					_localctx = tmp;
					{
					recog.base.set_state(2006);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2007);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(2010);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(277,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2008);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(2009);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(2012);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::RenameColumnContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.tableName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2013);
					recog.base.match_token(RENAME,&mut recog.err_handler)?;

					recog.base.set_state(2014);
					recog.base.match_token(COLUMN,&mut recog.err_handler)?;

					recog.base.set_state(2017);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(278,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2015);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(2016);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule identifier*/
					recog.base.set_state(2019);
					let tmp = recog.identifier()?;
					if let StatementContextAll::RenameColumnContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.from = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2020);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2021);
					let tmp = recog.identifier()?;
					if let StatementContextAll::RenameColumnContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.to = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				51 =>{
					let tmp = DropColumnContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 51);
					_localctx = tmp;
					{
					recog.base.set_state(2023);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2024);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(2027);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(279,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2025);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(2026);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(2029);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::DropColumnContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.tableName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2030);
					recog.base.match_token(DROP,&mut recog.err_handler)?;

					recog.base.set_state(2031);
					recog.base.match_token(COLUMN,&mut recog.err_handler)?;

					recog.base.set_state(2034);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(280,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2032);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(2033);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(2036);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::DropColumnContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.column = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				52 =>{
					let tmp = SetColumnTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 52);
					_localctx = tmp;
					{
					recog.base.set_state(2038);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2039);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(2042);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(281,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2040);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(2041);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(2044);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::SetColumnTypeContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.tableName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2045);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2046);
					recog.base.match_token(COLUMN,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2047);
					let tmp = recog.identifier()?;
					if let StatementContextAll::SetColumnTypeContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.setColumnName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2048);
					recog.base.match_token(SET,&mut recog.err_handler)?;

					recog.base.set_state(2049);
					recog.base.match_token(DATA,&mut recog.err_handler)?;

					recog.base.set_state(2050);
					recog.base.match_token(TYPE,&mut recog.err_handler)?;

					/*InvokeRule type_*/
					recog.base.set_state(2051);
					recog.type_()?;

					}
				}
			,
				53 =>{
					let tmp = SetTableAuthorizationContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 53);
					_localctx = tmp;
					{
					recog.base.set_state(2053);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2054);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2055);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::SetTableAuthorizationContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.tableName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2056);
					recog.base.match_token(SET,&mut recog.err_handler)?;

					recog.base.set_state(2057);
					recog.base.match_token(AUTHORIZATION,&mut recog.err_handler)?;

					/*InvokeRule principal*/
					recog.base.set_state(2058);
					recog.principal()?;

					}
				}
			,
				54 =>{
					let tmp = SetTablePropertiesContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 54);
					_localctx = tmp;
					{
					recog.base.set_state(2060);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2061);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2062);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::SetTablePropertiesContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.tableName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2063);
					recog.base.match_token(SET,&mut recog.err_handler)?;

					recog.base.set_state(2064);
					recog.base.match_token(PROPERTIES,&mut recog.err_handler)?;

					/*InvokeRule propertyAssignments*/
					recog.base.set_state(2065);
					recog.propertyAssignments()?;

					}
				}
			,
				55 =>{
					let tmp = TableExecuteContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 55);
					_localctx = tmp;
					{
					recog.base.set_state(2067);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2068);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2069);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::TableExecuteContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.tableName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2070);
					recog.base.match_token(EXECUTE,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2071);
					let tmp = recog.identifier()?;
					if let StatementContextAll::TableExecuteContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.procedureName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2087);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						recog.base.set_state(2072);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						recog.base.set_state(2081);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOT - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (ASTERISK - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
							{
							/*InvokeRule callArgument*/
							recog.base.set_state(2073);
							recog.callArgument()?;

							recog.base.set_state(2078);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(282,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(2074);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule callArgument*/
									recog.base.set_state(2075);
									recog.callArgument()?;

									}
									} 
								}
								recog.base.set_state(2080);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(282,&mut recog.base)?;
							}
							}
						}

						recog.base.set_state(2084);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(2083);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::TableExecuteContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						recog.base.set_state(2086);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2091);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==WHERE {
						{
						recog.base.set_state(2089);
						recog.base.match_token(WHERE,&mut recog.err_handler)?;

						/*InvokeRule booleanExpression*/
						recog.base.set_state(2090);
						let tmp = recog.booleanExpression_rec(0)?;
						if let StatementContextAll::TableExecuteContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
						ctx.where_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

						}
					}

					}
				}
			,
				56 =>{
					let tmp = AnalyzeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 56);
					_localctx = tmp;
					{
					recog.base.set_state(2093);
					recog.base.match_token(ANALYZE,&mut recog.err_handler)?;

					recog.base.set_state(2097);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2094);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2099);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				57 =>{
					let tmp = RefreshMaterializedViewContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 57);
					_localctx = tmp;
					{
					recog.base.set_state(2100);
					recog.base.match_token(REFRESH,&mut recog.err_handler)?;

					recog.base.set_state(2101);
					recog.base.match_token(MATERIALIZED,&mut recog.err_handler)?;

					recog.base.set_state(2102);
					recog.base.match_token(VIEW,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2103);
					recog.qualifiedName()?;

					}
				}
			,
				58 =>{
					let tmp = RenameMaterializedViewContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 58);
					_localctx = tmp;
					{
					recog.base.set_state(2104);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2105);
					recog.base.match_token(MATERIALIZED,&mut recog.err_handler)?;

					recog.base.set_state(2106);
					recog.base.match_token(VIEW,&mut recog.err_handler)?;

					recog.base.set_state(2109);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(288,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2107);
							recog.base.match_token(IF,&mut recog.err_handler)?;

							recog.base.set_state(2108);
							recog.base.match_token(EXISTS,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(2111);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::RenameMaterializedViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.from = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2112);
					recog.base.match_token(RENAME,&mut recog.err_handler)?;

					recog.base.set_state(2113);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2114);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::RenameMaterializedViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.to = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				59 =>{
					let tmp = SetMaterializedViewPropertiesContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 59);
					_localctx = tmp;
					{
					recog.base.set_state(2116);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2117);
					recog.base.match_token(MATERIALIZED,&mut recog.err_handler)?;

					recog.base.set_state(2118);
					recog.base.match_token(VIEW,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2119);
					recog.qualifiedName()?;

					recog.base.set_state(2120);
					recog.base.match_token(SET,&mut recog.err_handler)?;

					recog.base.set_state(2121);
					recog.base.match_token(PROPERTIES,&mut recog.err_handler)?;

					/*InvokeRule propertyAssignments*/
					recog.base.set_state(2122);
					recog.propertyAssignments()?;

					}
				}
			,
				60 =>{
					let tmp = RenameViewContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 60);
					_localctx = tmp;
					{
					recog.base.set_state(2124);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2125);
					recog.base.match_token(VIEW,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2126);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::RenameViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.from = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2127);
					recog.base.match_token(RENAME,&mut recog.err_handler)?;

					recog.base.set_state(2128);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2129);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::RenameViewContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.to = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				61 =>{
					let tmp = SetViewAuthorizationContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 61);
					_localctx = tmp;
					{
					recog.base.set_state(2131);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					recog.base.set_state(2132);
					recog.base.match_token(VIEW,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2133);
					let tmp = recog.qualifiedName()?;
					if let StatementContextAll::SetViewAuthorizationContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.from = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2134);
					recog.base.match_token(SET,&mut recog.err_handler)?;

					recog.base.set_state(2135);
					recog.base.match_token(AUTHORIZATION,&mut recog.err_handler)?;

					/*InvokeRule principal*/
					recog.base.set_state(2136);
					recog.principal()?;

					}
				}
			,
				62 =>{
					let tmp = CallContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 62);
					_localctx = tmp;
					{
					recog.base.set_state(2138);
					recog.base.match_token(CALL,&mut recog.err_handler)?;

					recog.base.set_state(2142);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2139);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2144);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				63 =>{
					let tmp = CreateRoleContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 63);
					_localctx = tmp;
					{
					recog.base.set_state(2145);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					recog.base.set_state(2146);
					recog.base.match_token(ROLE,&mut recog.err_handler)?;

					recog.base.set_state(2150);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2147);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2152);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				64 =>{
					let tmp = GrantContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 64);
					_localctx = tmp;
					{
					recog.base.set_state(2153);
					recog.base.match_token(GRANT,&mut recog.err_handler)?;

					recog.base.set_state(2157);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2154);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2159);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				65 =>{
					let tmp = RevokeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 65);
					_localctx = tmp;
					{
					recog.base.set_state(2160);
					recog.base.match_token(REVOKE,&mut recog.err_handler)?;

					recog.base.set_state(2164);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2161);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2166);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				66 =>{
					let tmp = DenyContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 66);
					_localctx = tmp;
					{
					recog.base.set_state(2167);
					recog.base.match_token(DENY,&mut recog.err_handler)?;

					recog.base.set_state(2181);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 CREATE | DELETE | INSERT | SELECT | UPDATE 
						=> {
							{
							/*InvokeRule privilege*/
							recog.base.set_state(2168);
							recog.privilege()?;

							recog.base.set_state(2173);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(293,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(2169);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule privilege*/
									recog.base.set_state(2170);
									recog.privilege()?;

									}
									} 
								}
								recog.base.set_state(2175);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(293,&mut recog.base)?;
							}
							recog.base.set_state(2177);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(2176);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let StatementContextAll::DenyContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							}
						}

					 ALL 
						=> {
							{
							recog.base.set_state(2179);
							recog.base.match_token(ALL,&mut recog.err_handler)?;

							recog.base.set_state(2180);
							recog.base.match_token(PRIVILEGES,&mut recog.err_handler)?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(2183);
					recog.base.match_token(ON,&mut recog.err_handler)?;

					recog.base.set_state(2185);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(296,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2184);
							_la = recog.base.input.la(1);
							if { !(_la==SCHEMA || _la==TABLE) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						_ => {}
					}
					/*InvokeRule qualifiedName*/
					recog.base.set_state(2187);
					recog.qualifiedName()?;

					recog.base.set_state(2188);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					/*InvokeRule principal*/
					recog.base.set_state(2189);
					let tmp = recog.principal()?;
					if let StatementContextAll::DenyContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
					ctx.grantee = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				67 =>{
					let tmp = ExplainContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 67);
					_localctx = tmp;
					{
					recog.base.set_state(2191);
					recog.base.match_token(EXPLAIN,&mut recog.err_handler)?;

					recog.base.set_state(2194);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==USING {
						{
						recog.base.set_state(2192);
						recog.base.match_token(USING,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(2193);
						recog.identifier()?;

						}
					}

					/*InvokeRule statement*/
					recog.base.set_state(2196);
					recog.statement()?;

					}
				}
			,
				68 =>{
					let tmp = ShowContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 68);
					_localctx = tmp;
					{
					recog.base.set_state(2197);
					recog.base.match_token(SHOW,&mut recog.err_handler)?;

					recog.base.set_state(2201);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2198);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2203);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				69 =>{
					let tmp = ResetContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 69);
					_localctx = tmp;
					{
					recog.base.set_state(2204);
					recog.base.match_token(RESET,&mut recog.err_handler)?;

					recog.base.set_state(2208);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2205);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2210);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				70 =>{
					let tmp = StartTransactionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 70);
					_localctx = tmp;
					{
					recog.base.set_state(2211);
					recog.base.match_token(START,&mut recog.err_handler)?;

					recog.base.set_state(2212);
					recog.base.match_token(TRANSACTION,&mut recog.err_handler)?;

					recog.base.set_state(2224);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ISOLATION || _la==READ {
						{
						/*InvokeRule transactionMode*/
						recog.base.set_state(2213);
						recog.transactionMode()?;

						recog.base.set_state(2218);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(300,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(2214);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule transactionMode*/
								recog.base.set_state(2215);
								recog.transactionMode()?;

								}
								} 
							}
							recog.base.set_state(2220);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(300,&mut recog.base)?;
						}
						recog.base.set_state(2222);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(2221);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let StatementContextAll::StartTransactionContext(ctx) = cast_mut::<_,StatementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					}
				}
			,
				71 =>{
					let tmp = CommitContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 71);
					_localctx = tmp;
					{
					recog.base.set_state(2226);
					recog.base.match_token(COMMIT,&mut recog.err_handler)?;

					recog.base.set_state(2230);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2227);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2232);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				72 =>{
					let tmp = RollbackContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 72);
					_localctx = tmp;
					{
					recog.base.set_state(2233);
					recog.base.match_token(ROLLBACK,&mut recog.err_handler)?;

					recog.base.set_state(2237);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2234);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2239);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				73 =>{
					let tmp = PrepareContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 73);
					_localctx = tmp;
					{
					recog.base.set_state(2240);
					recog.base.match_token(PREPARE,&mut recog.err_handler)?;

					recog.base.set_state(2244);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2241);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2246);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				74 =>{
					let tmp = DeallocateContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 74);
					_localctx = tmp;
					{
					recog.base.set_state(2247);
					recog.base.match_token(DEALLOCATE,&mut recog.err_handler)?;

					recog.base.set_state(2251);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2248);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2253);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				75 =>{
					let tmp = ExecuteContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 75);
					_localctx = tmp;
					{
					recog.base.set_state(2254);
					recog.base.match_token(EXECUTE,&mut recog.err_handler)?;

					recog.base.set_state(2258);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2255);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2260);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}
			,
				76 =>{
					let tmp = DescribeInputContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 76);
					_localctx = tmp;
					{
					recog.base.set_state(2261);
					recog.base.match_token(DESCRIBE,&mut recog.err_handler)?;

					recog.base.set_state(2262);
					recog.base.match_token(INPUT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2263);
					recog.identifier()?;

					}
				}
			,
				77 =>{
					let tmp = DescribeOutputContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 77);
					_localctx = tmp;
					{
					recog.base.set_state(2264);
					recog.base.match_token(DESCRIBE,&mut recog.err_handler)?;

					recog.base.set_state(2265);
					recog.base.match_token(OUTPUT,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2266);
					recog.identifier()?;

					}
				}
			,
				78 =>{
					let tmp = UpdateContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 78);
					_localctx = tmp;
					{
					recog.base.set_state(2267);
					recog.base.match_token(UPDATE,&mut recog.err_handler)?;

					recog.base.set_state(2271);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__0) | (1usize << T__1) | (1usize << T__2) | (1usize << T__3) | (1usize << T__4) | (1usize << T__5) | (1usize << T__6) | (1usize << T__7) | (1usize << T__8) | (1usize << T__9) | (1usize << T__10) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ALTER) | (1usize << ANALYZE) | (1usize << AND) | (1usize << ANTI) | (1usize << ANY) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << AS) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BETWEEN - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BY - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMN - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 64)) & !0x3f) == 0 && ((1usize << (_la - 64)) & ((1usize << (COMMA - 64)) | (1usize << (COMMENT - 64)) | (1usize << (COMMIT - 64)) | (1usize << (COMMITTED - 64)) | (1usize << (COMPOUND - 64)) | (1usize << (COMPRESSION - 64)) | (1usize << (CONDITIONAL - 64)) | (1usize << (CONNECT - 64)) | (1usize << (CONNECTION - 64)) | (1usize << (CONNECT_BY_ROOT - 64)) | (1usize << (CONSTRAINT - 64)) | (1usize << (COPARTITION - 64)) | (1usize << (COPY - 64)) | (1usize << (COUNT - 64)) | (1usize << (CREATE - 64)) | (1usize << (CROSS - 64)) | (1usize << (CUBE - 64)) | (1usize << (CURRENT - 64)) | (1usize << (CURRENT_ROLE - 64)) | (1usize << (DATA - 64)) | (1usize << (DATABASE - 64)) | (1usize << (DATASHARE - 64)) | (1usize << (DAY - 64)) | (1usize << (DEALLOCATE - 64)) | (1usize << (DECLARE - 64)) | (1usize << (DECODE - 64)) | (1usize << (DEFAULT - 64)) | (1usize << (DEFAULTS - 64)) | (1usize << (DEFINE - 64)) | (1usize << (DEFINER - 64)) | (1usize << (DELETE - 64)) | (1usize << (DELIMITED - 64)))) != 0) || ((((_la - 96)) & !0x3f) == 0 && ((1usize << (_la - 96)) & ((1usize << (DELIMITER - 96)) | (1usize << (DENY - 96)) | (1usize << (DEFERRABLE - 96)) | (1usize << (DEFERRED - 96)) | (1usize << (DESC - 96)) | (1usize << (DESCRIBE - 96)) | (1usize << (DESCRIPTOR - 96)) | (1usize << (DIRECTORY - 96)) | (1usize << (DISABLE - 96)) | (1usize << (DISTINCT - 96)) | (1usize << (DISTKEY - 96)) | (1usize << (DISTRIBUTED - 96)) | (1usize << (DISTSTYLE - 96)) | (1usize << (DETACH - 96)) | (1usize << (DOWNSTREAM - 96)) | (1usize << (DOUBLE - 96)) | (1usize << (DROP - 96)) | (1usize << (DYNAMIC - 96)) | (1usize << (ELSE - 96)) | (1usize << (EMPTY - 96)) | (1usize << (ENABLE - 96)) | (1usize << (ENCODE - 96)) | (1usize << (ENCODING - 96)) | (1usize << (END - 96)) | (1usize << (ENFORCED - 96)) | (1usize << (ERROR - 96)) | (1usize << (ESCAPE - 96)) | (1usize << (EVEN - 96)) | (1usize << (EVENT - 96)) | (1usize << (EXCEPT - 96)) | (1usize << (EXCLUDE - 96)) | (1usize << (EXCLUDING - 96)))) != 0) || ((((_la - 128)) & !0x3f) == 0 && ((1usize << (_la - 128)) & ((1usize << (EXECUTE - 128)) | (1usize << (EXISTS - 128)) | (1usize << (EXPLAIN - 128)) | (1usize << (EXTERNAL - 128)) | (1usize << (EXTRACT - 128)) | (1usize << (FALSE - 128)) | (1usize << (FETCH - 128)) | (1usize << (FIELDS - 128)) | (1usize << (FILE_FORMAT - 128)) | (1usize << (FILES - 128)) | (1usize << (FILTER - 128)) | (1usize << (FINAL - 128)) | (1usize << (FIRST - 128)) | (1usize << (FIRST_VALUE - 128)) | (1usize << (FLOAT - 128)) | (1usize << (FOLLOWING - 128)) | (1usize << (FOR - 128)) | (1usize << (FOREIGN - 128)) | (1usize << (FORMAT - 128)) | (1usize << (FORMAT_NAME - 128)) | (1usize << (FROM - 128)) | (1usize << (FULL - 128)) | (1usize << (FUNCTION - 128)) | (1usize << (FUNCTIONS - 128)) | (1usize << (GENERATED - 128)) | (1usize << (GLOBAL - 128)) | (1usize << (GRACE - 128)) | (1usize << (GRANT - 128)) | (1usize << (GRANTED - 128)) | (1usize << (GRANTS - 128)) | (1usize << (GRAPHVIZ - 128)) | (1usize << (GROUP - 128)))) != 0) || ((((_la - 160)) & !0x3f) == 0 && ((1usize << (_la - 160)) & ((1usize << (GROUPING - 160)) | (1usize << (GROUPS - 160)) | (1usize << (GZIP - 160)) | (1usize << (HAVING - 160)) | (1usize << (HEADER - 160)) | (1usize << (HOUR - 160)) | (1usize << (ICEBERG - 160)) | (1usize << (IDENTIFIER_KW - 160)) | (1usize << (IDENTITY - 160)) | (1usize << (IF - 160)) | (1usize << (IGNORE - 160)) | (1usize << (IMMEDIATE - 160)) | (1usize << (IMMUTABLE - 160)) | (1usize << (IN - 160)) | (1usize << (INCLUDE - 160)) | (1usize << (INCLUDING - 160)) | (1usize << (INCREMENT - 160)) | (1usize << (INFORMATION - 160)) | (1usize << (INITIAL - 160)) | (1usize << (INITIALLY - 160)) | (1usize << (INNER - 160)) | (1usize << (INPUT - 160)) | (1usize << (INPUTFORMAT - 160)) | (1usize << (INTERLEAVED - 160)) | (1usize << (INSERT - 160)) | (1usize << (INTERSECT - 160)) | (1usize << (INTERVAL - 160)) | (1usize << (INTO - 160)) | (1usize << (INVOKER - 160)) | (1usize << (IO - 160)) | (1usize << (IS - 160)) | (1usize << (ISOLATION - 160)))) != 0) || ((((_la - 192)) & !0x3f) == 0 && ((1usize << (_la - 192)) & ((1usize << (ILIKE - 192)) | (1usize << (JAVA - 192)) | (1usize << (JAVASCRIPT - 192)) | (1usize << (JOIN - 192)) | (1usize << (JSON - 192)) | (1usize << (JSON_ARRAY - 192)) | (1usize << (JSON_EXISTS - 192)) | (1usize << (JSON_OBJECT - 192)) | (1usize << (JSON_QUERY - 192)) | (1usize << (JSON_VALUE - 192)) | (1usize << (KEEP - 192)) | (1usize << (KEY - 192)) | (1usize << (KEYS - 192)) | (1usize << (LAG - 192)) | (1usize << (LAMBDA - 192)) | (1usize << (LANGUAGE - 192)) | (1usize << (LAST - 192)) | (1usize << (LAST_VALUE - 192)) | (1usize << (LATERAL - 192)) | (1usize << (LEADING - 192)) | (1usize << (LEFT - 192)) | (1usize << (LEVEL - 192)) | (1usize << (LIBRARY - 192)) | (1usize << (LIKE - 192)) | (1usize << (LIMIT - 192)) | (1usize << (LINES - 192)) | (1usize << (LISTAGG - 192)) | (1usize << (LOCAL - 192)) | (1usize << (LOCATION - 192)) | (1usize << (LOCK - 192)) | (1usize << (LOGICAL - 192)) | (1usize << (MAP - 192)))) != 0) || ((((_la - 224)) & !0x3f) == 0 && ((1usize << (_la - 224)) & ((1usize << (MASKING - 224)) | (1usize << (MATCH - 224)) | (1usize << (MATCHED - 224)) | (1usize << (MATCHES - 224)) | (1usize << (MATCH_CONDITION - 224)) | (1usize << (MATCH_RECOGNIZE - 224)) | (1usize << (MATERIALIZED - 224)) | (1usize << (MAX - 224)) | (1usize << (MEASURES - 224)) | (1usize << (MEMORIZABLE - 224)) | (1usize << (MERGE - 224)) | (1usize << (MINHASH - 224)) | (1usize << (MINUS_KW - 224)) | (1usize << (MINUTE - 224)) | (1usize << (MOD - 224)) | (1usize << (MODEL - 224)) | (1usize << (MONTH - 224)) | (1usize << (NAME - 224)) | (1usize << (NATURAL - 224)) | (1usize << (NCHAR - 224)) | (1usize << (NEXT - 224)) | (1usize << (NFC - 224)) | (1usize << (NFD - 224)) | (1usize << (NFKC - 224)) | (1usize << (NFKD - 224)) | (1usize << (NO - 224)) | (1usize << (NONE - 224)) | (1usize << (NOORDER - 224)) | (1usize << (NORELY - 224)) | (1usize << (NORMALIZE - 224)) | (1usize << (NOT - 224)) | (1usize << (NOVALIDATE - 224)))) != 0) || ((((_la - 256)) & !0x3f) == 0 && ((1usize << (_la - 256)) & ((1usize << (NULL - 256)) | (1usize << (NULLS - 256)) | (1usize << (OBJECT - 256)) | (1usize << (OF - 256)) | (1usize << (OFFSET - 256)) | (1usize << (OMIT - 256)) | (1usize << (ON - 256)) | (1usize << (ONE - 256)) | (1usize << (ONLY - 256)) | (1usize << (OPTION - 256)) | (1usize << (OPTIONS - 256)) | (1usize << (OR - 256)) | (1usize << (ORDER - 256)) | (1usize << (ORDINALITY - 256)) | (1usize << (OUTER - 256)) | (1usize << (OUTPUT - 256)) | (1usize << (OUTPUTFORMAT - 256)) | (1usize << (OVER - 256)) | (1usize << (OVERFLOW - 256)) | (1usize << (OWNER - 256)) | (1usize << (PARTITION - 256)) | (1usize << (PARTITIONED - 256)) | (1usize << (PARTITIONS - 256)) | (1usize << (PASSING - 256)) | (1usize << (PAST - 256)) | (1usize << (PATH - 256)) | (1usize << (PATTERN - 256)) | (1usize << (PER - 256)) | (1usize << (PERCENTILE_CONT - 256)) | (1usize << (PERCENTILE_DISC - 256)) | (1usize << (PERIOD - 256)) | (1usize << (PERMUTE - 256)))) != 0) || ((((_la - 288)) & !0x3f) == 0 && ((1usize << (_la - 288)) & ((1usize << (PIVOT - 288)) | (1usize << (PLACING - 288)) | (1usize << (POLICY - 288)) | (1usize << (POSITION - 288)) | (1usize << (PRECEDING - 288)) | (1usize << (PRECISION - 288)) | (1usize << (PREPARE - 288)) | (1usize << (PRIOR - 288)) | (1usize << (PROCEDURE - 288)) | (1usize << (PRIMARY - 288)) | (1usize << (PRIVILEGES - 288)) | (1usize << (PROPERTIES - 288)) | (1usize << (PRUNE - 288)) | (1usize << (PYTHON - 288)) | (1usize << (QUALIFY - 288)) | (1usize << (QUOTES - 288)) | (1usize << (RANGE - 288)) | (1usize << (READ - 288)) | (1usize << (RECURSIVE - 288)) | (1usize << (REGEXP - 288)) | (1usize << (REFERENCE - 288)) | (1usize << (REFERENCES - 288)) | (1usize << (REFRESH - 288)) | (1usize << (RELY - 288)) | (1usize << (RENAME - 288)) | (1usize << (REPEATABLE - 288)) | (1usize << (REPLACE - 288)) | (1usize << (RESET - 288)) | (1usize << (RESPECT - 288)) | (1usize << (RESTRICT - 288)) | (1usize << (RESTRICTED - 288)) | (1usize << (RETURN - 288)))) != 0) || ((((_la - 320)) & !0x3f) == 0 && ((1usize << (_la - 320)) & ((1usize << (RETURNING - 320)) | (1usize << (RETURNS - 320)) | (1usize << (REVOKE - 320)) | (1usize << (RIGHT - 320)) | (1usize << (RLIKE - 320)) | (1usize << (RLS - 320)) | (1usize << (ROLE - 320)) | (1usize << (ROLES - 320)) | (1usize << (ROLLBACK - 320)) | (1usize << (ROLLUP - 320)) | (1usize << (ROW - 320)) | (1usize << (ROWS - 320)) | (1usize << (RUNNING - 320)) | (1usize << (SAMPLE - 320)) | (1usize << (SCALA - 320)) | (1usize << (SCALAR - 320)) | (1usize << (SECOND - 320)) | (1usize << (SCHEMA - 320)) | (1usize << (SCHEMAS - 320)) | (1usize << (SECURE - 320)) | (1usize << (SECURITY - 320)) | (1usize << (SEED - 320)) | (1usize << (SEEK - 320)) | (1usize << (SELECT - 320)) | (1usize << (SEMI - 320)) | (1usize << (SEQUENCE - 320)) | (1usize << (SERDE - 320)) | (1usize << (SERDEPROPERTIES - 320)) | (1usize << (SERIALIZABLE - 320)) | (1usize << (SESSION - 320)) | (1usize << (SET - 320)) | (1usize << (SETS - 320)))) != 0) || ((((_la - 352)) & !0x3f) == 0 && ((1usize << (_la - 352)) & ((1usize << (SHOW - 352)) | (1usize << (SIMILAR - 352)) | (1usize << (SKIP_KW - 352)) | (1usize << (SNAPSHOT - 352)) | (1usize << (SOME - 352)) | (1usize << (SORTKEY - 352)) | (1usize << (SQL - 352)) | (1usize << (STAGE - 352)) | (1usize << (START - 352)) | (1usize << (STATEMENT - 352)) | (1usize << (STATS - 352)) | (1usize << (STORED - 352)) | (1usize << (STREAM - 352)) | (1usize << (STRICT - 352)) | (1usize << (STRUCT - 352)) | (1usize << (SUBSET - 352)) | (1usize << (SUBSTRING - 352)) | (1usize << (SYSTEM - 352)) | (1usize << (SYSTEM_TIME - 352)) | (1usize << (TABLE - 352)) | (1usize << (TABLES - 352)) | (1usize << (TABLESAMPLE - 352)) | (1usize << (TAG - 352)) | (1usize << (TEMP - 352)) | (1usize << (TEMPLATE - 352)) | (1usize << (TEMPORARY - 352)) | (1usize << (TERMINATED - 352)) | (1usize << (TEXT - 352)) | (1usize << (STRING_KW - 352)) | (1usize << (THEN - 352)) | (1usize << (TIES - 352)) | (1usize << (TIME - 352)))) != 0) || ((((_la - 384)) & !0x3f) == 0 && ((1usize << (_la - 384)) & ((1usize << (TIMESTAMP - 384)) | (1usize << (TO - 384)) | (1usize << (TOP - 384)) | (1usize << (TRAILING - 384)) | (1usize << (TARGET_LAG - 384)) | (1usize << (TRANSACTION - 384)) | (1usize << (TRANSIENT - 384)) | (1usize << (TRIM - 384)) | (1usize << (TRUE - 384)) | (1usize << (TRUNCATE - 384)) | (1usize << (TRY_CAST - 384)) | (1usize << (TUPLE - 384)) | (1usize << (TYPE - 384)) | (1usize << (UESCAPE - 384)) | (1usize << (UNBOUNDED - 384)) | (1usize << (UNCOMMITTED - 384)) | (1usize << (UNCONDITIONAL - 384)) | (1usize << (UNION - 384)) | (1usize << (UNIQUE - 384)) | (1usize << (UNKNOWN - 384)) | (1usize << (UNLOAD - 384)) | (1usize << (UNMATCHED - 384)) | (1usize << (UNNEST - 384)) | (1usize << (UNPIVOT - 384)) | (1usize << (UNSET - 384)) | (1usize << (UNSIGNED - 384)) | (1usize << (UPDATE - 384)) | (1usize << (USE - 384)) | (1usize << (USER - 384)) | (1usize << (USING - 384)) | (1usize << (UTF16 - 384)) | (1usize << (UTF32 - 384)))) != 0) || ((((_la - 416)) & !0x3f) == 0 && ((1usize << (_la - 416)) & ((1usize << (UTF8 - 416)) | (1usize << (VACUUM - 416)) | (1usize << (VALIDATE - 416)) | (1usize << (VALUE - 416)) | (1usize << (VALUES - 416)) | (1usize << (VARYING - 416)) | (1usize << (VECTOR - 416)) | (1usize << (VERBOSE - 416)) | (1usize << (VERSION - 416)) | (1usize << (VIEW - 416)) | (1usize << (VOLATILE - 416)) | (1usize << (WAREHOUSE - 416)) | (1usize << (WHEN - 416)) | (1usize << (WHERE - 416)) | (1usize << (WINDOW - 416)) | (1usize << (WITH - 416)) | (1usize << (WITHIN - 416)) | (1usize << (WITHOUT - 416)) | (1usize << (WORK - 416)) | (1usize << (WRAPPER - 416)) | (1usize << (WRITE - 416)) | (1usize << (XZ - 416)) | (1usize << (YEAR - 416)) | (1usize << (YES - 416)) | (1usize << (ZONE - 416)) | (1usize << (ZSTD - 416)) | (1usize << (LPAREN - 416)) | (1usize << (RPAREN - 416)) | (1usize << (LBRACKET - 416)) | (1usize << (RBRACKET - 416)) | (1usize << (DOT - 416)) | (1usize << (EQ - 416)))) != 0) || ((((_la - 448)) & !0x3f) == 0 && ((1usize << (_la - 448)) & ((1usize << (NEQ - 448)) | (1usize << (LT - 448)) | (1usize << (LTE - 448)) | (1usize << (GT - 448)) | (1usize << (GTE - 448)) | (1usize << (PLUS - 448)) | (1usize << (MINUS - 448)) | (1usize << (ASTERISK - 448)) | (1usize << (SLASH - 448)) | (1usize << (PERCENT - 448)) | (1usize << (CONCAT - 448)) | (1usize << (QUESTION_MARK - 448)) | (1usize << (COLON - 448)) | (1usize << (DOLLAR - 448)) | (1usize << (BITWISE_SHIFT_LEFT - 448)) | (1usize << (POSIX - 448)) | (1usize << (ESCAPE_SEQUENCE - 448)) | (1usize << (STRING - 448)) | (1usize << (UNICODE_STRING - 448)) | (1usize << (DOLLAR_QUOTED_STRING - 448)) | (1usize << (BINARY_LITERAL - 448)) | (1usize << (INTEGER_VALUE - 448)) | (1usize << (DECIMAL_VALUE - 448)) | (1usize << (DOUBLE_VALUE - 448)) | (1usize << (IDENTIFIER - 448)) | (1usize << (QUOTED_IDENTIFIER - 448)) | (1usize << (BACKQUOTED_IDENTIFIER - 448)) | (1usize << (STAGE_NAME - 448)) | (1usize << (VARIABLE - 448)) | (1usize << (SIMPLE_COMMENT - 448)) | (1usize << (SLASH_SLASH_COMMENT - 448)))) != 0) || ((((_la - 480)) & !0x3f) == 0 && ((1usize << (_la - 480)) & ((1usize << (BRACKETED_COMMENT - 480)) | (1usize << (WS - 480)) | (1usize << (UNPAIRED_TOKEN - 480)) | (1usize << (UNRECOGNIZED - 480)))) != 0) {
						{
						{
						recog.base.set_state(2268);
						_la = recog.base.input.la(1);
						if { _la <= 0 || (_la==SEMI_COLON) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
						}
						recog.base.set_state(2273);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableElements ----------------
pub type TableElementsContextAll<'input> = TableElementsContext<'input>;


pub type TableElementsContext<'input> = BaseParserRuleContext<'input,TableElementsContextExt<'input>>;

#[derive(Clone)]
pub struct TableElementsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TableElementsContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableElementsContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tableElements(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_tableElements(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableElementsContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableElements(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableElementsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableElements }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableElements }
}
antlr_rust::tid!{TableElementsContextExt<'a>}

impl<'input> TableElementsContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableElementsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableElementsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableElementsContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TableElementsContextExt<'input>>{

fn tableElement_all(&self) ->  Vec<Rc<TableElementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn tableElement(&self, i: usize) -> Option<Rc<TableElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TableElementsContextAttrs<'input> for TableElementsContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableElements(&mut self,)
	-> Result<Rc<TableElementsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableElementsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 12, RULE_tableElements);
        let mut _localctx: Rc<TableElementsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule tableElement*/
			recog.base.set_state(2276);
			recog.tableElement()?;

			recog.base.set_state(2281);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(2277);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule tableElement*/
				recog.base.set_state(2278);
				recog.tableElement()?;

				}
				}
				recog.base.set_state(2283);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- unpivotNullClause ----------------
pub type UnpivotNullClauseContextAll<'input> = UnpivotNullClauseContext<'input>;


pub type UnpivotNullClauseContext<'input> = BaseParserRuleContext<'input,UnpivotNullClauseContextExt<'input>>;

#[derive(Clone)]
pub struct UnpivotNullClauseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for UnpivotNullClauseContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UnpivotNullClauseContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_unpivotNullClause(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_unpivotNullClause(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UnpivotNullClauseContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_unpivotNullClause(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnpivotNullClauseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_unpivotNullClause }
	//fn type_rule_index() -> usize where Self: Sized { RULE_unpivotNullClause }
}
antlr_rust::tid!{UnpivotNullClauseContextExt<'a>}

impl<'input> UnpivotNullClauseContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<UnpivotNullClauseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,UnpivotNullClauseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait UnpivotNullClauseContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<UnpivotNullClauseContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token NULLS
/// Returns `None` if there is no child corresponding to token NULLS
fn NULLS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULLS, 0)
}
/// Retrieves first TerminalNode corresponding to token INCLUDE
/// Returns `None` if there is no child corresponding to token INCLUDE
fn INCLUDE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INCLUDE, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCLUDE
/// Returns `None` if there is no child corresponding to token EXCLUDE
fn EXCLUDE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXCLUDE, 0)
}

}

impl<'input> UnpivotNullClauseContextAttrs<'input> for UnpivotNullClauseContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn unpivotNullClause(&mut self,)
	-> Result<Rc<UnpivotNullClauseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = UnpivotNullClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 14, RULE_unpivotNullClause);
        let mut _localctx: Rc<UnpivotNullClauseContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2284);
			_la = recog.base.input.la(1);
			if { !(_la==EXCLUDE || _la==INCLUDE) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(2285);
			recog.base.match_token(NULLS,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- snowflakeCreateTableClauses ----------------
pub type SnowflakeCreateTableClausesContextAll<'input> = SnowflakeCreateTableClausesContext<'input>;


pub type SnowflakeCreateTableClausesContext<'input> = BaseParserRuleContext<'input,SnowflakeCreateTableClausesContextExt<'input>>;

#[derive(Clone)]
pub struct SnowflakeCreateTableClausesContextExt<'input>{
	pub CLUSTER: Option<TokenType<'input>>,
	pub cluster:Vec<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SnowflakeCreateTableClausesContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeCreateTableClausesContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_snowflakeCreateTableClauses(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_snowflakeCreateTableClauses(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeCreateTableClausesContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeCreateTableClauses(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeCreateTableClausesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeCreateTableClauses }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeCreateTableClauses }
}
antlr_rust::tid!{SnowflakeCreateTableClausesContextExt<'a>}

impl<'input> SnowflakeCreateTableClausesContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SnowflakeCreateTableClausesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SnowflakeCreateTableClausesContextExt{
				CLUSTER: None, 
				cluster: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait SnowflakeCreateTableClausesContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SnowflakeCreateTableClausesContextExt<'input>>{

/// Retrieves all `TerminalNode`s corresponding to token BY in current rule
fn BY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token BY, starting from 0.
/// Returns `None` if number of children corresponding to token BY is less or equal than `i`.
fn BY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, i)
}
/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, i)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, i)
}
fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COPY in current rule
fn COPY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COPY, starting from 0.
/// Returns `None` if number of children corresponding to token COPY is less or equal than `i`.
fn COPY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COPY, i)
}
/// Retrieves all `TerminalNode`s corresponding to token GRANTS in current rule
fn GRANTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token GRANTS, starting from 0.
/// Returns `None` if number of children corresponding to token GRANTS is less or equal than `i`.
fn GRANTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRANTS, i)
}
/// Retrieves all `TerminalNode`s corresponding to token ROW in current rule
fn ROW_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token ROW, starting from 0.
/// Returns `None` if number of children corresponding to token ROW is less or equal than `i`.
fn ROW(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROW, i)
}
/// Retrieves all `TerminalNode`s corresponding to token ACCESS in current rule
fn ACCESS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token ACCESS, starting from 0.
/// Returns `None` if number of children corresponding to token ACCESS is less or equal than `i`.
fn ACCESS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ACCESS, i)
}
/// Retrieves all `TerminalNode`s corresponding to token POLICY in current rule
fn POLICY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token POLICY, starting from 0.
/// Returns `None` if number of children corresponding to token POLICY is less or equal than `i`.
fn POLICY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(POLICY, i)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token ON in current rule
fn ON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token ON, starting from 0.
/// Returns `None` if number of children corresponding to token ON is less or equal than `i`.
fn ON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ON, i)
}
/// Retrieves all `TerminalNode`s corresponding to token TAG in current rule
fn TAG_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token TAG, starting from 0.
/// Returns `None` if number of children corresponding to token TAG is less or equal than `i`.
fn TAG(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TAG, i)
}
fn properties_all(&self) ->  Vec<Rc<PropertiesContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn properties(&self, i: usize) -> Option<Rc<PropertiesContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token CLUSTER in current rule
fn CLUSTER_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token CLUSTER, starting from 0.
/// Returns `None` if number of children corresponding to token CLUSTER is less or equal than `i`.
fn CLUSTER(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CLUSTER, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves all `TerminalNode`s corresponding to token WITH in current rule
fn WITH_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token WITH, starting from 0.
/// Returns `None` if number of children corresponding to token WITH is less or equal than `i`.
fn WITH(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, i)
}

}

impl<'input> SnowflakeCreateTableClausesContextAttrs<'input> for SnowflakeCreateTableClausesContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn snowflakeCreateTableClauses(&mut self,)
	-> Result<Rc<SnowflakeCreateTableClausesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SnowflakeCreateTableClausesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 16, RULE_snowflakeCreateTableClauses);
        let mut _localctx: Rc<SnowflakeCreateTableClausesContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2329);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(316,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					recog.base.set_state(2327);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(315,&mut recog.base)? {
						1 =>{
							{
							recog.base.set_state(2287);
							let tmp = recog.base.match_token(CLUSTER,&mut recog.err_handler)?;
							 cast_mut::<_,SnowflakeCreateTableClausesContext >(&mut _localctx).CLUSTER = Some(tmp);
							  

							let temp =  cast_mut::<_,SnowflakeCreateTableClausesContext >(&mut _localctx).CLUSTER.clone().unwrap()
							 ;
							 cast_mut::<_,SnowflakeCreateTableClausesContext >(&mut _localctx).cluster.push(temp);
							  
							recog.base.set_state(2288);
							recog.base.match_token(BY,&mut recog.err_handler)?;

							recog.base.set_state(2289);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(2290);
							recog.expression()?;

							recog.base.set_state(2295);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==COMMA {
								{
								{
								recog.base.set_state(2291);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(2292);
								recog.expression()?;

								}
								}
								recog.base.set_state(2297);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(2298);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule property*/
							recog.base.set_state(2300);
							recog.property()?;

							}
						}
					,
						3 =>{
							{
							recog.base.set_state(2301);
							recog.base.match_token(COPY,&mut recog.err_handler)?;

							recog.base.set_state(2302);
							recog.base.match_token(GRANTS,&mut recog.err_handler)?;

							}
						}
					,
						4 =>{
							{
							recog.base.set_state(2304);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==WITH {
								{
								recog.base.set_state(2303);
								recog.base.match_token(WITH,&mut recog.err_handler)?;

								}
							}

							recog.base.set_state(2306);
							recog.base.match_token(ROW,&mut recog.err_handler)?;

							recog.base.set_state(2307);
							recog.base.match_token(ACCESS,&mut recog.err_handler)?;

							recog.base.set_state(2308);
							recog.base.match_token(POLICY,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(2309);
							recog.identifier()?;

							recog.base.set_state(2310);
							recog.base.match_token(ON,&mut recog.err_handler)?;

							recog.base.set_state(2311);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(2312);
							recog.identifier()?;

							recog.base.set_state(2317);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							while _la==COMMA {
								{
								{
								recog.base.set_state(2313);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule identifier*/
								recog.base.set_state(2314);
								recog.identifier()?;

								}
								}
								recog.base.set_state(2319);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
							}
							recog.base.set_state(2320);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}
					,
						5 =>{
							{
							recog.base.set_state(2323);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==WITH {
								{
								recog.base.set_state(2322);
								recog.base.match_token(WITH,&mut recog.err_handler)?;

								}
							}

							recog.base.set_state(2325);
							recog.base.match_token(TAG,&mut recog.err_handler)?;

							/*InvokeRule properties*/
							recog.base.set_state(2326);
							recog.properties()?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(2331);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(316,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableConstraint ----------------
pub type TableConstraintContextAll<'input> = TableConstraintContext<'input>;


pub type TableConstraintContext<'input> = BaseParserRuleContext<'input,TableConstraintContextExt<'input>>;

#[derive(Clone)]
pub struct TableConstraintContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TableConstraintContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableConstraintContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tableConstraint(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_tableConstraint(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableConstraintContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableConstraint(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableConstraintContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableConstraint }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableConstraint }
}
antlr_rust::tid!{TableConstraintContextExt<'a>}

impl<'input> TableConstraintContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableConstraintContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableConstraintContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableConstraintContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TableConstraintContextExt<'input>>{

fn constraintProperties(&self) -> Option<Rc<ConstraintPropertiesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token UNIQUE
/// Returns `None` if there is no child corresponding to token UNIQUE
fn UNIQUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNIQUE, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIMARY
/// Returns `None` if there is no child corresponding to token PRIMARY
fn PRIMARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRIMARY, 0)
}
/// Retrieves first TerminalNode corresponding to token KEY
/// Returns `None` if there is no child corresponding to token KEY
fn KEY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(KEY, 0)
}
/// Retrieves first TerminalNode corresponding to token REFERENCES
/// Returns `None` if there is no child corresponding to token REFERENCES
fn REFERENCES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REFERENCES, 0)
}
fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CONSTRAINT
/// Returns `None` if there is no child corresponding to token CONSTRAINT
fn CONSTRAINT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONSTRAINT, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnAliases_all(&self) ->  Vec<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn columnAliases(&self, i: usize) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token FOREIGN
/// Returns `None` if there is no child corresponding to token FOREIGN
fn FOREIGN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FOREIGN, 0)
}

}

impl<'input> TableConstraintContextAttrs<'input> for TableConstraintContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableConstraint(&mut self,)
	-> Result<Rc<TableConstraintContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableConstraintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 18, RULE_tableConstraint);
        let mut _localctx: Rc<TableConstraintContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2334);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==CONSTRAINT {
				{
				recog.base.set_state(2332);
				recog.base.match_token(CONSTRAINT,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(2333);
				recog.identifier()?;

				}
			}

			recog.base.set_state(2357);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 UNIQUE 
				=> {
					{
					recog.base.set_state(2336);
					recog.base.match_token(UNIQUE,&mut recog.err_handler)?;

					recog.base.set_state(2338);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						/*InvokeRule columnAliases*/
						recog.base.set_state(2337);
						recog.columnAliases()?;

						}
					}

					}
				}

			 PRIMARY 
				=> {
					{
					recog.base.set_state(2340);
					recog.base.match_token(PRIMARY,&mut recog.err_handler)?;

					recog.base.set_state(2341);
					recog.base.match_token(KEY,&mut recog.err_handler)?;

					recog.base.set_state(2343);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						/*InvokeRule columnAliases*/
						recog.base.set_state(2342);
						recog.columnAliases()?;

						}
					}

					}
				}

			 FOREIGN | REFERENCES | LPAREN 
				=> {
					{
					recog.base.set_state(2347);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==FOREIGN {
						{
						recog.base.set_state(2345);
						recog.base.match_token(FOREIGN,&mut recog.err_handler)?;

						recog.base.set_state(2346);
						recog.base.match_token(KEY,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2350);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						/*InvokeRule columnAliases*/
						recog.base.set_state(2349);
						recog.columnAliases()?;

						}
					}

					recog.base.set_state(2352);
					recog.base.match_token(REFERENCES,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2353);
					recog.qualifiedName()?;

					recog.base.set_state(2355);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						/*InvokeRule columnAliases*/
						recog.base.set_state(2354);
						recog.columnAliases()?;

						}
					}

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			/*InvokeRule constraintProperties*/
			recog.base.set_state(2359);
			recog.constraintProperties()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constraintProperties ----------------
pub type ConstraintPropertiesContextAll<'input> = ConstraintPropertiesContext<'input>;


pub type ConstraintPropertiesContext<'input> = BaseParserRuleContext<'input,ConstraintPropertiesContextExt<'input>>;

#[derive(Clone)]
pub struct ConstraintPropertiesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ConstraintPropertiesContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ConstraintPropertiesContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_constraintProperties(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_constraintProperties(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ConstraintPropertiesContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_constraintProperties(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstraintPropertiesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constraintProperties }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constraintProperties }
}
antlr_rust::tid!{ConstraintPropertiesContextExt<'a>}

impl<'input> ConstraintPropertiesContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstraintPropertiesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstraintPropertiesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConstraintPropertiesContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ConstraintPropertiesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ENFORCED
/// Returns `None` if there is no child corresponding to token ENFORCED
fn ENFORCED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENFORCED, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFERRABLE
/// Returns `None` if there is no child corresponding to token DEFERRABLE
fn DEFERRABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFERRABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token INITIALLY
/// Returns `None` if there is no child corresponding to token INITIALLY
fn INITIALLY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INITIALLY, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFERRED
/// Returns `None` if there is no child corresponding to token DEFERRED
fn DEFERRED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFERRED, 0)
}
/// Retrieves first TerminalNode corresponding to token IMMEDIATE
/// Returns `None` if there is no child corresponding to token IMMEDIATE
fn IMMEDIATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IMMEDIATE, 0)
}
/// Retrieves first TerminalNode corresponding to token ENABLE
/// Returns `None` if there is no child corresponding to token ENABLE
fn ENABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DISABLE
/// Returns `None` if there is no child corresponding to token DISABLE
fn DISABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token VALIDATE
/// Returns `None` if there is no child corresponding to token VALIDATE
fn VALIDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VALIDATE, 0)
}
/// Retrieves first TerminalNode corresponding to token NOVALIDATE
/// Returns `None` if there is no child corresponding to token NOVALIDATE
fn NOVALIDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOVALIDATE, 0)
}
/// Retrieves first TerminalNode corresponding to token RELY
/// Returns `None` if there is no child corresponding to token RELY
fn RELY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RELY, 0)
}
/// Retrieves first TerminalNode corresponding to token NORELY
/// Returns `None` if there is no child corresponding to token NORELY
fn NORELY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NORELY, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token NOT in current rule
fn NOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token NOT, starting from 0.
/// Returns `None` if number of children corresponding to token NOT is less or equal than `i`.
fn NOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOT, i)
}

}

impl<'input> ConstraintPropertiesContextAttrs<'input> for ConstraintPropertiesContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constraintProperties(&mut self,)
	-> Result<Rc<ConstraintPropertiesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstraintPropertiesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 20, RULE_constraintProperties);
        let mut _localctx: Rc<ConstraintPropertiesContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2365);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(325,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2362);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(2361);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2364);
					recog.base.match_token(ENFORCED,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2371);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(327,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2368);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(2367);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2370);
					recog.base.match_token(DEFERRABLE,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2375);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==INITIALLY {
				{
				recog.base.set_state(2373);
				recog.base.match_token(INITIALLY,&mut recog.err_handler)?;

				recog.base.set_state(2374);
				_la = recog.base.input.la(1);
				if { !(_la==DEFERRED || _la==IMMEDIATE) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			recog.base.set_state(2378);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==DISABLE || _la==ENABLE {
				{
				recog.base.set_state(2377);
				_la = recog.base.input.la(1);
				if { !(_la==DISABLE || _la==ENABLE) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			recog.base.set_state(2381);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==NOVALIDATE || _la==VALIDATE {
				{
				recog.base.set_state(2380);
				_la = recog.base.input.la(1);
				if { !(_la==NOVALIDATE || _la==VALIDATE) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			recog.base.set_state(2384);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==NORELY || _la==RELY {
				{
				recog.base.set_state(2383);
				_la = recog.base.input.la(1);
				if { !(_la==NORELY || _la==RELY) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- snowflakeValueRow ----------------
pub type SnowflakeValueRowContextAll<'input> = SnowflakeValueRowContext<'input>;


pub type SnowflakeValueRowContext<'input> = BaseParserRuleContext<'input,SnowflakeValueRowContextExt<'input>>;

#[derive(Clone)]
pub struct SnowflakeValueRowContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SnowflakeValueRowContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeValueRowContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_snowflakeValueRow(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_snowflakeValueRow(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeValueRowContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeValueRow(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeValueRowContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeValueRow }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeValueRow }
}
antlr_rust::tid!{SnowflakeValueRowContextExt<'a>}

impl<'input> SnowflakeValueRowContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SnowflakeValueRowContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SnowflakeValueRowContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait SnowflakeValueRowContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SnowflakeValueRowContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn snowflakeValueItem_all(&self) ->  Vec<Rc<SnowflakeValueItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn snowflakeValueItem(&self, i: usize) -> Option<Rc<SnowflakeValueItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> SnowflakeValueRowContextAttrs<'input> for SnowflakeValueRowContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn snowflakeValueRow(&mut self,)
	-> Result<Rc<SnowflakeValueRowContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SnowflakeValueRowContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 22, RULE_snowflakeValueRow);
        let mut _localctx: Rc<SnowflakeValueRowContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2386);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule snowflakeValueItem*/
			recog.base.set_state(2387);
			recog.snowflakeValueItem()?;

			recog.base.set_state(2392);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(332,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2388);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule snowflakeValueItem*/
					recog.base.set_state(2389);
					recog.snowflakeValueItem()?;

					}
					} 
				}
				recog.base.set_state(2394);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(332,&mut recog.base)?;
			}
			recog.base.set_state(2396);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(2395);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,SnowflakeValueRowContext >(&mut _localctx).tail = Some(tmp);
				  

				}
			}

			recog.base.set_state(2398);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- snowflakeValueItem ----------------
pub type SnowflakeValueItemContextAll<'input> = SnowflakeValueItemContext<'input>;


pub type SnowflakeValueItemContext<'input> = BaseParserRuleContext<'input,SnowflakeValueItemContextExt<'input>>;

#[derive(Clone)]
pub struct SnowflakeValueItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SnowflakeValueItemContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeValueItemContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_snowflakeValueItem(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_snowflakeValueItem(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeValueItemContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeValueItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeValueItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeValueItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeValueItem }
}
antlr_rust::tid!{SnowflakeValueItemContextExt<'a>}

impl<'input> SnowflakeValueItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SnowflakeValueItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SnowflakeValueItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SnowflakeValueItemContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SnowflakeValueItemContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}

}

impl<'input> SnowflakeValueItemContextAttrs<'input> for SnowflakeValueItemContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn snowflakeValueItem(&mut self,)
	-> Result<Rc<SnowflakeValueItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SnowflakeValueItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 24, RULE_snowflakeValueItem);
        let mut _localctx: Rc<SnowflakeValueItemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2402);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(334,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule expression*/
					recog.base.set_state(2400);
					recog.expression()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2401);
					recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- snowflakeCreateExternalTableClauses ----------------
pub type SnowflakeCreateExternalTableClausesContextAll<'input> = SnowflakeCreateExternalTableClausesContext<'input>;


pub type SnowflakeCreateExternalTableClausesContext<'input> = BaseParserRuleContext<'input,SnowflakeCreateExternalTableClausesContextExt<'input>>;

#[derive(Clone)]
pub struct SnowflakeCreateExternalTableClausesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SnowflakeCreateExternalTableClausesContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeCreateExternalTableClausesContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_snowflakeCreateExternalTableClauses(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_snowflakeCreateExternalTableClauses(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeCreateExternalTableClausesContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeCreateExternalTableClauses(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeCreateExternalTableClausesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeCreateExternalTableClauses }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeCreateExternalTableClauses }
}
antlr_rust::tid!{SnowflakeCreateExternalTableClausesContextExt<'a>}

impl<'input> SnowflakeCreateExternalTableClausesContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SnowflakeCreateExternalTableClausesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SnowflakeCreateExternalTableClausesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SnowflakeCreateExternalTableClausesContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SnowflakeCreateExternalTableClausesContextExt<'input>>{

fn locationSpec_all(&self) ->  Vec<Rc<LocationSpecContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn locationSpec(&self, i: usize) -> Option<Rc<LocationSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn partitionedByNameSpec_all(&self) ->  Vec<Rc<PartitionedByNameSpecContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn partitionedByNameSpec(&self, i: usize) -> Option<Rc<PartitionedByNameSpecContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COPY in current rule
fn COPY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COPY, starting from 0.
/// Returns `None` if number of children corresponding to token COPY is less or equal than `i`.
fn COPY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COPY, i)
}
/// Retrieves all `TerminalNode`s corresponding to token GRANTS in current rule
fn GRANTS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token GRANTS, starting from 0.
/// Returns `None` if number of children corresponding to token GRANTS is less or equal than `i`.
fn GRANTS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRANTS, i)
}
/// Retrieves all `TerminalNode`s corresponding to token ROW in current rule
fn ROW_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token ROW, starting from 0.
/// Returns `None` if number of children corresponding to token ROW is less or equal than `i`.
fn ROW(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROW, i)
}
/// Retrieves all `TerminalNode`s corresponding to token ACCESS in current rule
fn ACCESS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token ACCESS, starting from 0.
/// Returns `None` if number of children corresponding to token ACCESS is less or equal than `i`.
fn ACCESS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ACCESS, i)
}
/// Retrieves all `TerminalNode`s corresponding to token POLICY in current rule
fn POLICY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token POLICY, starting from 0.
/// Returns `None` if number of children corresponding to token POLICY is less or equal than `i`.
fn POLICY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(POLICY, i)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token ON in current rule
fn ON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token ON, starting from 0.
/// Returns `None` if number of children corresponding to token ON is less or equal than `i`.
fn ON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ON, i)
}
/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, i)
}
/// Retrieves all `TerminalNode`s corresponding to token TAG in current rule
fn TAG_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token TAG, starting from 0.
/// Returns `None` if number of children corresponding to token TAG is less or equal than `i`.
fn TAG(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TAG, i)
}
fn properties_all(&self) ->  Vec<Rc<PropertiesContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn properties(&self, i: usize) -> Option<Rc<PropertiesContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token WITH in current rule
fn WITH_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token WITH, starting from 0.
/// Returns `None` if number of children corresponding to token WITH is less or equal than `i`.
fn WITH(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, i)
}

}

impl<'input> SnowflakeCreateExternalTableClausesContextAttrs<'input> for SnowflakeCreateExternalTableClausesContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn snowflakeCreateExternalTableClauses(&mut self,)
	-> Result<Rc<SnowflakeCreateExternalTableClausesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SnowflakeCreateExternalTableClausesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 26, RULE_snowflakeCreateExternalTableClauses);
        let mut _localctx: Rc<SnowflakeCreateExternalTableClausesContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2428);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (ROW - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITH - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
				{
				recog.base.set_state(2426);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(337,&mut recog.base)? {
					1 =>{
						{
						/*InvokeRule locationSpec*/
						recog.base.set_state(2404);
						recog.locationSpec()?;

						}
					}
				,
					2 =>{
						{
						/*InvokeRule property*/
						recog.base.set_state(2405);
						recog.property()?;

						}
					}
				,
					3 =>{
						{
						/*InvokeRule partitionedByNameSpec*/
						recog.base.set_state(2406);
						recog.partitionedByNameSpec()?;

						}
					}
				,
					4 =>{
						{
						recog.base.set_state(2407);
						recog.base.match_token(COPY,&mut recog.err_handler)?;

						recog.base.set_state(2408);
						recog.base.match_token(GRANTS,&mut recog.err_handler)?;

						}
					}
				,
					5 =>{
						{
						recog.base.set_state(2410);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==WITH {
							{
							recog.base.set_state(2409);
							recog.base.match_token(WITH,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(2412);
						recog.base.match_token(ROW,&mut recog.err_handler)?;

						recog.base.set_state(2413);
						recog.base.match_token(ACCESS,&mut recog.err_handler)?;

						recog.base.set_state(2414);
						recog.base.match_token(POLICY,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(2415);
						recog.identifier()?;

						recog.base.set_state(2416);
						recog.base.match_token(ON,&mut recog.err_handler)?;

						recog.base.set_state(2417);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(2418);
						recog.identifier()?;

						recog.base.set_state(2419);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}
				,
					6 =>{
						{
						recog.base.set_state(2422);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==WITH {
							{
							recog.base.set_state(2421);
							recog.base.match_token(WITH,&mut recog.err_handler)?;

							}
						}

						recog.base.set_state(2424);
						recog.base.match_token(TAG,&mut recog.err_handler)?;

						/*InvokeRule properties*/
						recog.base.set_state(2425);
						recog.properties()?;

						}
					}

					_ => {}
				}
				}
				recog.base.set_state(2430);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- locationSpec ----------------
pub type LocationSpecContextAll<'input> = LocationSpecContext<'input>;


pub type LocationSpecContext<'input> = BaseParserRuleContext<'input,LocationSpecContextExt<'input>>;

#[derive(Clone)]
pub struct LocationSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for LocationSpecContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LocationSpecContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_locationSpec(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_locationSpec(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LocationSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_locationSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for LocationSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_locationSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_locationSpec }
}
antlr_rust::tid!{LocationSpecContextExt<'a>}

impl<'input> LocationSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LocationSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LocationSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LocationSpecContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<LocationSpecContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LOCATION
/// Returns `None` if there is no child corresponding to token LOCATION
fn LOCATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LOCATION, 0)
}
/// Retrieves first TerminalNode corresponding to token EQ
/// Returns `None` if there is no child corresponding to token EQ
fn EQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EQ, 0)
}
/// Retrieves first TerminalNode corresponding to token STAGE_NAME
/// Returns `None` if there is no child corresponding to token STAGE_NAME
fn STAGE_NAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STAGE_NAME, 0)
}
/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}

}

impl<'input> LocationSpecContextAttrs<'input> for LocationSpecContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn locationSpec(&mut self,)
	-> Result<Rc<LocationSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LocationSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 28, RULE_locationSpec);
        let mut _localctx: Rc<LocationSpecContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2432);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==WITH {
				{
				recog.base.set_state(2431);
				recog.base.match_token(WITH,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2434);
			recog.base.match_token(LOCATION,&mut recog.err_handler)?;

			recog.base.set_state(2435);
			recog.base.match_token(EQ,&mut recog.err_handler)?;

			recog.base.set_state(2436);
			recog.base.match_token(STAGE_NAME,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- partitionedByNameSpec ----------------
pub type PartitionedByNameSpecContextAll<'input> = PartitionedByNameSpecContext<'input>;


pub type PartitionedByNameSpecContext<'input> = BaseParserRuleContext<'input,PartitionedByNameSpecContextExt<'input>>;

#[derive(Clone)]
pub struct PartitionedByNameSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PartitionedByNameSpecContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PartitionedByNameSpecContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_partitionedByNameSpec(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_partitionedByNameSpec(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PartitionedByNameSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_partitionedByNameSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for PartitionedByNameSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_partitionedByNameSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_partitionedByNameSpec }
}
antlr_rust::tid!{PartitionedByNameSpecContextExt<'a>}

impl<'input> PartitionedByNameSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PartitionedByNameSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PartitionedByNameSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PartitionedByNameSpecContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PartitionedByNameSpecContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PARTITION
/// Returns `None` if there is no child corresponding to token PARTITION
fn PARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITION, 0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PartitionedByNameSpecContextAttrs<'input> for PartitionedByNameSpecContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn partitionedByNameSpec(&mut self,)
	-> Result<Rc<PartitionedByNameSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PartitionedByNameSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 30, RULE_partitionedByNameSpec);
        let mut _localctx: Rc<PartitionedByNameSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2438);
			recog.base.match_token(PARTITION,&mut recog.err_handler)?;

			recog.base.set_state(2439);
			recog.base.match_token(BY,&mut recog.err_handler)?;

			/*InvokeRule columnAliases*/
			recog.base.set_state(2440);
			recog.columnAliases()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- createFileFormat ----------------
pub type CreateFileFormatContextAll<'input> = CreateFileFormatContext<'input>;


pub type CreateFileFormatContext<'input> = BaseParserRuleContext<'input,CreateFileFormatContextExt<'input>>;

#[derive(Clone)]
pub struct CreateFileFormatContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for CreateFileFormatContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CreateFileFormatContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_createFileFormat(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_createFileFormat(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CreateFileFormatContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_createFileFormat(self);
	}
}

impl<'input> CustomRuleContext<'input> for CreateFileFormatContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_createFileFormat }
	//fn type_rule_index() -> usize where Self: Sized { RULE_createFileFormat }
}
antlr_rust::tid!{CreateFileFormatContextExt<'a>}

impl<'input> CreateFileFormatContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CreateFileFormatContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CreateFileFormatContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait CreateFileFormatContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<CreateFileFormatContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token STORED
/// Returns `None` if there is no child corresponding to token STORED
fn STORED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STORED, 0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> CreateFileFormatContextAttrs<'input> for CreateFileFormatContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn createFileFormat(&mut self,)
	-> Result<Rc<CreateFileFormatContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CreateFileFormatContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 32, RULE_createFileFormat);
        let mut _localctx: Rc<CreateFileFormatContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2442);
			recog.base.match_token(STORED,&mut recog.err_handler)?;

			recog.base.set_state(2443);
			recog.base.match_token(AS,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(2444);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- compressionSpec ----------------
pub type CompressionSpecContextAll<'input> = CompressionSpecContext<'input>;


pub type CompressionSpecContext<'input> = BaseParserRuleContext<'input,CompressionSpecContextExt<'input>>;

#[derive(Clone)]
pub struct CompressionSpecContextExt<'input>{
	pub compressionType: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for CompressionSpecContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CompressionSpecContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_compressionSpec(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_compressionSpec(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CompressionSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_compressionSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for CompressionSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_compressionSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_compressionSpec }
}
antlr_rust::tid!{CompressionSpecContextExt<'a>}

impl<'input> CompressionSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CompressionSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CompressionSpecContextExt{
				compressionType: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait CompressionSpecContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<CompressionSpecContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COMPRESSION
/// Returns `None` if there is no child corresponding to token COMPRESSION
fn COMPRESSION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMPRESSION, 0)
}
/// Retrieves first TerminalNode corresponding to token TYPE
/// Returns `None` if there is no child corresponding to token TYPE
fn TYPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TYPE, 0)
}
/// Retrieves first TerminalNode corresponding to token GZIP
/// Returns `None` if there is no child corresponding to token GZIP
fn GZIP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GZIP, 0)
}
/// Retrieves first TerminalNode corresponding to token BZIP2
/// Returns `None` if there is no child corresponding to token BZIP2
fn BZIP2(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BZIP2, 0)
}
/// Retrieves first TerminalNode corresponding to token XZ
/// Returns `None` if there is no child corresponding to token XZ
fn XZ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(XZ, 0)
}
/// Retrieves first TerminalNode corresponding to token ZSTD
/// Returns `None` if there is no child corresponding to token ZSTD
fn ZSTD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ZSTD, 0)
}

}

impl<'input> CompressionSpecContextAttrs<'input> for CompressionSpecContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn compressionSpec(&mut self,)
	-> Result<Rc<CompressionSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CompressionSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 34, RULE_compressionSpec);
        let mut _localctx: Rc<CompressionSpecContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2446);
			recog.base.match_token(COMPRESSION,&mut recog.err_handler)?;

			recog.base.set_state(2447);
			recog.base.match_token(TYPE,&mut recog.err_handler)?;

			recog.base.set_state(2448);
			 cast_mut::<_,CompressionSpecContext >(&mut _localctx).compressionType = recog.base.input.lt(1).cloned();
			 
			_la = recog.base.input.la(1);
			if { !(_la==BZIP2 || _la==GZIP || _la==XZ || _la==ZSTD) } {
				let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
				 cast_mut::<_,CompressionSpecContext >(&mut _localctx).compressionType = Some(tmp);
				  

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- headerRowSpec ----------------
pub type HeaderRowSpecContextAll<'input> = HeaderRowSpecContext<'input>;


pub type HeaderRowSpecContext<'input> = BaseParserRuleContext<'input,HeaderRowSpecContextExt<'input>>;

#[derive(Clone)]
pub struct HeaderRowSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for HeaderRowSpecContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for HeaderRowSpecContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_headerRowSpec(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_headerRowSpec(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for HeaderRowSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_headerRowSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for HeaderRowSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_headerRowSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_headerRowSpec }
}
antlr_rust::tid!{HeaderRowSpecContextExt<'a>}

impl<'input> HeaderRowSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<HeaderRowSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,HeaderRowSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait HeaderRowSpecContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<HeaderRowSpecContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}
/// Retrieves first TerminalNode corresponding to token HEADER
/// Returns `None` if there is no child corresponding to token HEADER
fn HEADER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(HEADER, 0)
}
/// Retrieves first TerminalNode corresponding to token ROW
/// Returns `None` if there is no child corresponding to token ROW
fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROW, 0)
}

}

impl<'input> HeaderRowSpecContextAttrs<'input> for HeaderRowSpecContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn headerRowSpec(&mut self,)
	-> Result<Rc<HeaderRowSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = HeaderRowSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 36, RULE_headerRowSpec);
        let mut _localctx: Rc<HeaderRowSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2450);
			recog.base.match_token(WITH,&mut recog.err_handler)?;

			recog.base.set_state(2451);
			recog.base.match_token(HEADER,&mut recog.err_handler)?;

			recog.base.set_state(2452);
			recog.base.match_token(ROW,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- delimiterSpec ----------------
pub type DelimiterSpecContextAll<'input> = DelimiterSpecContext<'input>;


pub type DelimiterSpecContext<'input> = BaseParserRuleContext<'input,DelimiterSpecContextExt<'input>>;

#[derive(Clone)]
pub struct DelimiterSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for DelimiterSpecContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DelimiterSpecContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_delimiterSpec(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_delimiterSpec(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DelimiterSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_delimiterSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for DelimiterSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_delimiterSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_delimiterSpec }
}
antlr_rust::tid!{DelimiterSpecContextExt<'a>}

impl<'input> DelimiterSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DelimiterSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DelimiterSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DelimiterSpecContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<DelimiterSpecContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DELIMITER
/// Returns `None` if there is no child corresponding to token DELIMITER
fn DELIMITER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DELIMITER, 0)
}
fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DelimiterSpecContextAttrs<'input> for DelimiterSpecContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn delimiterSpec(&mut self,)
	-> Result<Rc<DelimiterSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DelimiterSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 38, RULE_delimiterSpec);
        let mut _localctx: Rc<DelimiterSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2454);
			recog.base.match_token(DELIMITER,&mut recog.err_handler)?;

			/*InvokeRule string*/
			recog.base.set_state(2455);
			recog.string()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- query ----------------
pub type QueryContextAll<'input> = QueryContext<'input>;


pub type QueryContext<'input> = BaseParserRuleContext<'input,QueryContextExt<'input>>;

#[derive(Clone)]
pub struct QueryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QueryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_query(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_query(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_query(self);
	}
}

impl<'input> CustomRuleContext<'input> for QueryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_query }
	//fn type_rule_index() -> usize where Self: Sized { RULE_query }
}
antlr_rust::tid!{QueryContextExt<'a>}

impl<'input> QueryContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QueryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QueryContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait QueryContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QueryContextExt<'input>>{

fn queryNoWith(&self) -> Option<Rc<QueryNoWithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn with(&self) -> Option<Rc<WithContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> QueryContextAttrs<'input> for QueryContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn query(&mut self,)
	-> Result<Rc<QueryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QueryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 40, RULE_query);
        let mut _localctx: Rc<QueryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2458);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==WITH {
				{
				/*InvokeRule with*/
				recog.base.set_state(2457);
				recog.with()?;

				}
			}

			/*InvokeRule queryNoWith*/
			recog.base.set_state(2460);
			recog.queryNoWith()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- with ----------------
pub type WithContextAll<'input> = WithContext<'input>;


pub type WithContext<'input> = BaseParserRuleContext<'input,WithContextExt<'input>>;

#[derive(Clone)]
pub struct WithContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for WithContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for WithContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_with(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_with(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for WithContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_with(self);
	}
}

impl<'input> CustomRuleContext<'input> for WithContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_with }
	//fn type_rule_index() -> usize where Self: Sized { RULE_with }
}
antlr_rust::tid!{WithContextExt<'a>}

impl<'input> WithContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WithContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WithContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait WithContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<WithContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}
fn namedQuery_all(&self) ->  Vec<Rc<NamedQueryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn namedQuery(&self, i: usize) -> Option<Rc<NamedQueryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RECURSIVE
/// Returns `None` if there is no child corresponding to token RECURSIVE
fn RECURSIVE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RECURSIVE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> WithContextAttrs<'input> for WithContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn with(&mut self,)
	-> Result<Rc<WithContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WithContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 42, RULE_with);
        let mut _localctx: Rc<WithContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2462);
			recog.base.match_token(WITH,&mut recog.err_handler)?;

			recog.base.set_state(2464);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(341,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2463);
					recog.base.match_token(RECURSIVE,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			/*InvokeRule namedQuery*/
			recog.base.set_state(2466);
			recog.namedQuery()?;

			recog.base.set_state(2471);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(2467);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule namedQuery*/
				recog.base.set_state(2468);
				recog.namedQuery()?;

				}
				}
				recog.base.set_state(2473);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableElement ----------------
pub type TableElementContextAll<'input> = TableElementContext<'input>;


pub type TableElementContext<'input> = BaseParserRuleContext<'input,TableElementContextExt<'input>>;

#[derive(Clone)]
pub struct TableElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TableElementContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableElementContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tableElement(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_tableElement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableElementContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableElement }
}
antlr_rust::tid!{TableElementContextExt<'a>}

impl<'input> TableElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableElementContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableElementContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TableElementContextExt<'input>>{

fn tableConstraint(&self) -> Option<Rc<TableConstraintContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnDefinition(&self) -> Option<Rc<ColumnDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TableElementContextAttrs<'input> for TableElementContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableElement(&mut self,)
	-> Result<Rc<TableElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 44, RULE_tableElement);
        let mut _localctx: Rc<TableElementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2476);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(343,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule tableConstraint*/
					recog.base.set_state(2474);
					recog.tableConstraint()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule columnDefinition*/
					recog.base.set_state(2475);
					recog.columnDefinition()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnDefinition ----------------
pub type ColumnDefinitionContextAll<'input> = ColumnDefinitionContext<'input>;


pub type ColumnDefinitionContext<'input> = BaseParserRuleContext<'input,ColumnDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnDefinitionContextExt<'input>{
	pub comment: Option<Rc<StringContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_columnDefinition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_columnDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnDefinition }
}
antlr_rust::tid!{ColumnDefinitionContextExt<'a>}

impl<'input> ColumnDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnDefinitionContextExt{
				comment: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnDefinitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnDefinitionContextExt<'input>>{

fn fieldDefinition(&self) -> Option<Rc<FieldDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inlineConstraint(&self) -> Option<Rc<InlineConstraintContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token NOT
/// Returns `None` if there is no child corresponding to token NOT
fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOT, 0)
}
/// Retrieves first TerminalNode corresponding to token NULL
/// Returns `None` if there is no child corresponding to token NULL
fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULL, 0)
}
/// Retrieves first TerminalNode corresponding to token COLLATE
/// Returns `None` if there is no child corresponding to token COLLATE
fn COLLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COLLATE, 0)
}
fn string_all(&self) ->  Vec<Rc<StringContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token MASKING
/// Returns `None` if there is no child corresponding to token MASKING
fn MASKING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MASKING, 0)
}
/// Retrieves first TerminalNode corresponding to token POLICY
/// Returns `None` if there is no child corresponding to token POLICY
fn POLICY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(POLICY, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token TAG
/// Returns `None` if there is no child corresponding to token TAG
fn TAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TAG, 0)
}
fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMENT
/// Returns `None` if there is no child corresponding to token COMMENT
fn COMMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AUTOINCREMENT
/// Returns `None` if there is no child corresponding to token AUTOINCREMENT
fn AUTOINCREMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AUTOINCREMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token IDENTITY
/// Returns `None` if there is no child corresponding to token IDENTITY
fn IDENTITY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IDENTITY, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token WITH in current rule
fn WITH_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token WITH, starting from 0.
/// Returns `None` if number of children corresponding to token WITH is less or equal than `i`.
fn WITH(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, i)
}
/// Retrieves first TerminalNode corresponding to token USING
/// Returns `None` if there is no child corresponding to token USING
fn USING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(USING, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn number_all(&self) ->  Vec<Rc<NumberContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn number(&self, i: usize) -> Option<Rc<NumberContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves first TerminalNode corresponding to token START
/// Returns `None` if there is no child corresponding to token START
fn START(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(START, 0)
}
/// Retrieves first TerminalNode corresponding to token INCREMENT
/// Returns `None` if there is no child corresponding to token INCREMENT
fn INCREMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INCREMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token ORDER
/// Returns `None` if there is no child corresponding to token ORDER
fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ORDER, 0)
}
/// Retrieves first TerminalNode corresponding to token NOORDER
/// Returns `None` if there is no child corresponding to token NOORDER
fn NOORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOORDER, 0)
}

}

impl<'input> ColumnDefinitionContextAttrs<'input> for ColumnDefinitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnDefinition(&mut self,)
	-> Result<Rc<ColumnDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 46, RULE_columnDefinition);
        let mut _localctx: Rc<ColumnDefinitionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule fieldDefinition*/
			recog.base.set_state(2478);
			recog.fieldDefinition()?;

			recog.base.set_state(2480);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==CONSTRAINT || _la==FOREIGN || _la==PRIMARY || _la==REFERENCES || _la==UNIQUE {
				{
				/*InvokeRule inlineConstraint*/
				recog.base.set_state(2479);
				recog.inlineConstraint()?;

				}
			}

			recog.base.set_state(2484);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==NOT {
				{
				recog.base.set_state(2482);
				recog.base.match_token(NOT,&mut recog.err_handler)?;

				recog.base.set_state(2483);
				recog.base.match_token(NULL,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2488);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COLLATE {
				{
				recog.base.set_state(2486);
				recog.base.match_token(COLLATE,&mut recog.err_handler)?;

				/*InvokeRule string*/
				recog.base.set_state(2487);
				recog.string()?;

				}
			}

			recog.base.set_state(2509);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AUTOINCREMENT || _la==DEFAULT || _la==IDENTITY {
				{
				recog.base.set_state(2507);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 DEFAULT 
					=> {
						{
						recog.base.set_state(2490);
						recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(2491);
						recog.expression()?;

						}
					}

				 AUTOINCREMENT | IDENTITY 
					=> {
						{
						recog.base.set_state(2492);
						_la = recog.base.input.la(1);
						if { !(_la==AUTOINCREMENT || _la==IDENTITY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						recog.base.set_state(2502);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 MINUS | INTEGER_VALUE | DECIMAL_VALUE | DOUBLE_VALUE 
							=> {
						    	{
						    	/*InvokeRule number*/
						    	recog.base.set_state(2493);
						    	recog.number()?;

						    	recog.base.set_state(2494);
						    	recog.base.match_token(COMMA,&mut recog.err_handler)?;

						    	/*InvokeRule number*/
						    	recog.base.set_state(2495);
						    	recog.number()?;

						    	}
						    }

						 START 
							=> {
						    	{
						    	recog.base.set_state(2497);
						    	recog.base.match_token(START,&mut recog.err_handler)?;

						    	/*InvokeRule number*/
						    	recog.base.set_state(2498);
						    	recog.number()?;

						    	recog.base.set_state(2499);
						    	recog.base.match_token(INCREMENT,&mut recog.err_handler)?;

						    	/*InvokeRule number*/
						    	recog.base.set_state(2500);
						    	recog.number()?;

						    	}
						    }

						 EOF | COMMA | COMMENT | MASKING | NOORDER | ORDER | TAG | WITH | RPAREN |
						 SEMI_COLON 
							=> {
						    }

							_ => {}
						}
						recog.base.set_state(2505);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOORDER || _la==ORDER {
							{
							recog.base.set_state(2504);
							_la = recog.base.input.la(1);
							if { !(_la==NOORDER || _la==ORDER) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
			}

			recog.base.set_state(2531);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(354,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2512);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==WITH {
						{
						recog.base.set_state(2511);
						recog.base.match_token(WITH,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2514);
					recog.base.match_token(MASKING,&mut recog.err_handler)?;

					recog.base.set_state(2515);
					recog.base.match_token(POLICY,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2516);
					recog.identifier()?;

					recog.base.set_state(2529);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==USING {
						{
						recog.base.set_state(2517);
						recog.base.match_token(USING,&mut recog.err_handler)?;

						recog.base.set_state(2518);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(2519);
						recog.identifier()?;

						recog.base.set_state(2524);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(2520);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(2521);
							recog.identifier()?;

							}
							}
							recog.base.set_state(2526);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2527);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					}
				}

				_ => {}
			}
			recog.base.set_state(2538);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==TAG || _la==WITH {
				{
				recog.base.set_state(2534);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==WITH {
					{
					recog.base.set_state(2533);
					recog.base.match_token(WITH,&mut recog.err_handler)?;

					}
				}

				recog.base.set_state(2536);
				recog.base.match_token(TAG,&mut recog.err_handler)?;

				/*InvokeRule properties*/
				recog.base.set_state(2537);
				recog.properties()?;

				}
			}

			recog.base.set_state(2542);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMENT {
				{
				recog.base.set_state(2540);
				recog.base.match_token(COMMENT,&mut recog.err_handler)?;

				/*InvokeRule string*/
				recog.base.set_state(2541);
				let tmp = recog.string()?;
				 cast_mut::<_,ColumnDefinitionContext >(&mut _localctx).comment = Some(tmp.clone());
				  

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inlineConstraint ----------------
pub type InlineConstraintContextAll<'input> = InlineConstraintContext<'input>;


pub type InlineConstraintContext<'input> = BaseParserRuleContext<'input,InlineConstraintContextExt<'input>>;

#[derive(Clone)]
pub struct InlineConstraintContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for InlineConstraintContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for InlineConstraintContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_inlineConstraint(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_inlineConstraint(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for InlineConstraintContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_inlineConstraint(self);
	}
}

impl<'input> CustomRuleContext<'input> for InlineConstraintContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inlineConstraint }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inlineConstraint }
}
antlr_rust::tid!{InlineConstraintContextExt<'a>}

impl<'input> InlineConstraintContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InlineConstraintContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InlineConstraintContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait InlineConstraintContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<InlineConstraintContextExt<'input>>{

fn constraintProperties(&self) -> Option<Rc<ConstraintPropertiesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token UNIQUE
/// Returns `None` if there is no child corresponding to token UNIQUE
fn UNIQUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNIQUE, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIMARY
/// Returns `None` if there is no child corresponding to token PRIMARY
fn PRIMARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRIMARY, 0)
}
/// Retrieves first TerminalNode corresponding to token KEY
/// Returns `None` if there is no child corresponding to token KEY
fn KEY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(KEY, 0)
}
/// Retrieves first TerminalNode corresponding to token REFERENCES
/// Returns `None` if there is no child corresponding to token REFERENCES
fn REFERENCES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REFERENCES, 0)
}
fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token CONSTRAINT
/// Returns `None` if there is no child corresponding to token CONSTRAINT
fn CONSTRAINT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONSTRAINT, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token FOREIGN
/// Returns `None` if there is no child corresponding to token FOREIGN
fn FOREIGN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FOREIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}

}

impl<'input> InlineConstraintContextAttrs<'input> for InlineConstraintContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inlineConstraint(&mut self,)
	-> Result<Rc<InlineConstraintContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InlineConstraintContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 48, RULE_inlineConstraint);
        let mut _localctx: Rc<InlineConstraintContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2546);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==CONSTRAINT {
				{
				recog.base.set_state(2544);
				recog.base.match_token(CONSTRAINT,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(2545);
				recog.identifier()?;

				}
			}

			recog.base.set_state(2563);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 UNIQUE 
				=> {
					{
					recog.base.set_state(2548);
					recog.base.match_token(UNIQUE,&mut recog.err_handler)?;

					}
				}

			 PRIMARY 
				=> {
					{
					recog.base.set_state(2549);
					recog.base.match_token(PRIMARY,&mut recog.err_handler)?;

					recog.base.set_state(2550);
					recog.base.match_token(KEY,&mut recog.err_handler)?;

					}
				}

			 FOREIGN | REFERENCES 
				=> {
					{
					recog.base.set_state(2553);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==FOREIGN {
						{
						recog.base.set_state(2551);
						recog.base.match_token(FOREIGN,&mut recog.err_handler)?;

						recog.base.set_state(2552);
						recog.base.match_token(KEY,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2555);
					recog.base.match_token(REFERENCES,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(2556);
					recog.qualifiedName()?;

					recog.base.set_state(2561);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==LPAREN {
						{
						recog.base.set_state(2557);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(2558);
						recog.identifier()?;

						recog.base.set_state(2559);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			/*InvokeRule constraintProperties*/
			recog.base.set_state(2565);
			recog.constraintProperties()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnDefinitionForView ----------------
pub type ColumnDefinitionForViewContextAll<'input> = ColumnDefinitionForViewContext<'input>;


pub type ColumnDefinitionForViewContext<'input> = BaseParserRuleContext<'input,ColumnDefinitionForViewContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnDefinitionForViewContextExt<'input>{
	pub name: Option<Rc<ColumnNameContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnDefinitionForViewContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnDefinitionForViewContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_columnDefinitionForView(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_columnDefinitionForView(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnDefinitionForViewContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnDefinitionForView(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnDefinitionForViewContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnDefinitionForView }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnDefinitionForView }
}
antlr_rust::tid!{ColumnDefinitionForViewContextExt<'a>}

impl<'input> ColumnDefinitionForViewContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnDefinitionForViewContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnDefinitionForViewContextExt{
				name: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnDefinitionForViewContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnDefinitionForViewContextExt<'input>>{

fn columnName(&self) -> Option<Rc<ColumnNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inlineConstraint(&self) -> Option<Rc<InlineConstraintContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token NOT
/// Returns `None` if there is no child corresponding to token NOT
fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOT, 0)
}
/// Retrieves first TerminalNode corresponding to token NULL
/// Returns `None` if there is no child corresponding to token NULL
fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULL, 0)
}
/// Retrieves first TerminalNode corresponding to token COLLATE
/// Returns `None` if there is no child corresponding to token COLLATE
fn COLLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COLLATE, 0)
}
fn string_all(&self) ->  Vec<Rc<StringContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token MASKING
/// Returns `None` if there is no child corresponding to token MASKING
fn MASKING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MASKING, 0)
}
/// Retrieves first TerminalNode corresponding to token POLICY
/// Returns `None` if there is no child corresponding to token POLICY
fn POLICY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(POLICY, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token TAG
/// Returns `None` if there is no child corresponding to token TAG
fn TAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TAG, 0)
}
fn properties(&self) -> Option<Rc<PropertiesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token COMMENT
/// Returns `None` if there is no child corresponding to token COMMENT
fn COMMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AUTOINCREMENT
/// Returns `None` if there is no child corresponding to token AUTOINCREMENT
fn AUTOINCREMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AUTOINCREMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token IDENTITY
/// Returns `None` if there is no child corresponding to token IDENTITY
fn IDENTITY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IDENTITY, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token WITH in current rule
fn WITH_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token WITH, starting from 0.
/// Returns `None` if number of children corresponding to token WITH is less or equal than `i`.
fn WITH(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, i)
}
/// Retrieves first TerminalNode corresponding to token USING
/// Returns `None` if there is no child corresponding to token USING
fn USING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(USING, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn number_all(&self) ->  Vec<Rc<NumberContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn number(&self, i: usize) -> Option<Rc<NumberContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves first TerminalNode corresponding to token START
/// Returns `None` if there is no child corresponding to token START
fn START(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(START, 0)
}
/// Retrieves first TerminalNode corresponding to token INCREMENT
/// Returns `None` if there is no child corresponding to token INCREMENT
fn INCREMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INCREMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token ORDER
/// Returns `None` if there is no child corresponding to token ORDER
fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ORDER, 0)
}
/// Retrieves first TerminalNode corresponding to token NOORDER
/// Returns `None` if there is no child corresponding to token NOORDER
fn NOORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOORDER, 0)
}

}

impl<'input> ColumnDefinitionForViewContextAttrs<'input> for ColumnDefinitionForViewContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnDefinitionForView(&mut self,)
	-> Result<Rc<ColumnDefinitionForViewContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnDefinitionForViewContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 50, RULE_columnDefinitionForView);
        let mut _localctx: Rc<ColumnDefinitionForViewContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule columnName*/
			recog.base.set_state(2567);
			let tmp = recog.columnName()?;
			 cast_mut::<_,ColumnDefinitionForViewContext >(&mut _localctx).name = Some(tmp.clone());
			  

			recog.base.set_state(2569);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==CONSTRAINT || _la==FOREIGN || _la==PRIMARY || _la==REFERENCES || _la==UNIQUE {
				{
				/*InvokeRule inlineConstraint*/
				recog.base.set_state(2568);
				recog.inlineConstraint()?;

				}
			}

			recog.base.set_state(2573);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==NOT {
				{
				recog.base.set_state(2571);
				recog.base.match_token(NOT,&mut recog.err_handler)?;

				recog.base.set_state(2572);
				recog.base.match_token(NULL,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(2577);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COLLATE {
				{
				recog.base.set_state(2575);
				recog.base.match_token(COLLATE,&mut recog.err_handler)?;

				/*InvokeRule string*/
				recog.base.set_state(2576);
				recog.string()?;

				}
			}

			recog.base.set_state(2598);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AUTOINCREMENT || _la==DEFAULT || _la==IDENTITY {
				{
				recog.base.set_state(2596);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 DEFAULT 
					=> {
						{
						recog.base.set_state(2579);
						recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(2580);
						recog.expression()?;

						}
					}

				 AUTOINCREMENT | IDENTITY 
					=> {
						{
						recog.base.set_state(2581);
						_la = recog.base.input.la(1);
						if { !(_la==AUTOINCREMENT || _la==IDENTITY) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						recog.base.set_state(2591);
						recog.err_handler.sync(&mut recog.base)?;
						match recog.base.input.la(1) {
						 MINUS | INTEGER_VALUE | DECIMAL_VALUE | DOUBLE_VALUE 
							=> {
						    	{
						    	/*InvokeRule number*/
						    	recog.base.set_state(2582);
						    	recog.number()?;

						    	recog.base.set_state(2583);
						    	recog.base.match_token(COMMA,&mut recog.err_handler)?;

						    	/*InvokeRule number*/
						    	recog.base.set_state(2584);
						    	recog.number()?;

						    	}
						    }

						 START 
							=> {
						    	{
						    	recog.base.set_state(2586);
						    	recog.base.match_token(START,&mut recog.err_handler)?;

						    	/*InvokeRule number*/
						    	recog.base.set_state(2587);
						    	recog.number()?;

						    	recog.base.set_state(2588);
						    	recog.base.match_token(INCREMENT,&mut recog.err_handler)?;

						    	/*InvokeRule number*/
						    	recog.base.set_state(2589);
						    	recog.number()?;

						    	}
						    }

						 COMMA | COMMENT | MASKING | NOORDER | ORDER | TAG | WITH | RPAREN 
							=> {
						    }

							_ => {}
						}
						recog.base.set_state(2594);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==NOORDER || _la==ORDER {
							{
							recog.base.set_state(2593);
							_la = recog.base.input.la(1);
							if { !(_la==NOORDER || _la==ORDER) } {
								recog.err_handler.recover_inline(&mut recog.base)?;

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							}
						}

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
			}

			recog.base.set_state(2620);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(372,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2601);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==WITH {
						{
						recog.base.set_state(2600);
						recog.base.match_token(WITH,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2603);
					recog.base.match_token(MASKING,&mut recog.err_handler)?;

					recog.base.set_state(2604);
					recog.base.match_token(POLICY,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(2605);
					recog.identifier()?;

					recog.base.set_state(2618);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==USING {
						{
						recog.base.set_state(2606);
						recog.base.match_token(USING,&mut recog.err_handler)?;

						recog.base.set_state(2607);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(2608);
						recog.identifier()?;

						recog.base.set_state(2613);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(2609);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(2610);
							recog.identifier()?;

							}
							}
							recog.base.set_state(2615);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(2616);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					}
				}

				_ => {}
			}
			recog.base.set_state(2627);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==TAG || _la==WITH {
				{
				recog.base.set_state(2623);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==WITH {
					{
					recog.base.set_state(2622);
					recog.base.match_token(WITH,&mut recog.err_handler)?;

					}
				}

				recog.base.set_state(2625);
				recog.base.match_token(TAG,&mut recog.err_handler)?;

				/*InvokeRule properties*/
				recog.base.set_state(2626);
				recog.properties()?;

				}
			}

			recog.base.set_state(2631);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMENT {
				{
				recog.base.set_state(2629);
				recog.base.match_token(COMMENT,&mut recog.err_handler)?;

				/*InvokeRule string*/
				recog.base.set_state(2630);
				recog.string()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- externalColumnDefinition ----------------
pub type ExternalColumnDefinitionContextAll<'input> = ExternalColumnDefinitionContext<'input>;


pub type ExternalColumnDefinitionContext<'input> = BaseParserRuleContext<'input,ExternalColumnDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct ExternalColumnDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ExternalColumnDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ExternalColumnDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_externalColumnDefinition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_externalColumnDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ExternalColumnDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_externalColumnDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExternalColumnDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_externalColumnDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_externalColumnDefinition }
}
antlr_rust::tid!{ExternalColumnDefinitionContextExt<'a>}

impl<'input> ExternalColumnDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExternalColumnDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExternalColumnDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExternalColumnDefinitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ExternalColumnDefinitionContextExt<'input>>{

fn fieldDefinition(&self) -> Option<Rc<FieldDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn inlineConstraint(&self) -> Option<Rc<InlineConstraintContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExternalColumnDefinitionContextAttrs<'input> for ExternalColumnDefinitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn externalColumnDefinition(&mut self,)
	-> Result<Rc<ExternalColumnDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExternalColumnDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 52, RULE_externalColumnDefinition);
        let mut _localctx: Rc<ExternalColumnDefinitionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule fieldDefinition*/
			recog.base.set_state(2633);
			recog.fieldDefinition()?;

			recog.base.set_state(2634);
			recog.base.match_token(AS,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2635);
			recog.expression()?;

			recog.base.set_state(2637);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==CONSTRAINT || _la==FOREIGN || _la==PRIMARY || _la==REFERENCES || _la==UNIQUE {
				{
				/*InvokeRule inlineConstraint*/
				recog.base.set_state(2636);
				recog.inlineConstraint()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- fieldDefinition ----------------
pub type FieldDefinitionContextAll<'input> = FieldDefinitionContext<'input>;


pub type FieldDefinitionContext<'input> = BaseParserRuleContext<'input,FieldDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct FieldDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for FieldDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FieldDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_fieldDefinition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_fieldDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FieldDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_fieldDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for FieldDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_fieldDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_fieldDefinition }
}
antlr_rust::tid!{FieldDefinitionContextExt<'a>}

impl<'input> FieldDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldDefinitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<FieldDefinitionContextExt<'input>>{

fn columnName(&self) -> Option<Rc<ColumnNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnSchemaWithMetadata(&self) -> Option<Rc<ColumnSchemaWithMetadataContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldDefinitionContextAttrs<'input> for FieldDefinitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn fieldDefinition(&mut self,)
	-> Result<Rc<FieldDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 54, RULE_fieldDefinition);
        let mut _localctx: Rc<FieldDefinitionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule columnName*/
			recog.base.set_state(2639);
			recog.columnName()?;

			/*InvokeRule columnSchemaWithMetadata*/
			recog.base.set_state(2640);
			recog.columnSchemaWithMetadata()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnName ----------------
pub type ColumnNameContextAll<'input> = ColumnNameContext<'input>;


pub type ColumnNameContext<'input> = BaseParserRuleContext<'input,ColumnNameContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnNameContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_columnName(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_columnName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnName(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnName }
}
antlr_rust::tid!{ColumnNameContextExt<'a>}

impl<'input> ColumnNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnNameContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ColumnNameContextAttrs<'input> for ColumnNameContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnName(&mut self,)
	-> Result<Rc<ColumnNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 56, RULE_columnName);
        let mut _localctx: Rc<ColumnNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2642);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnNameComponent ----------------
pub type ColumnNameComponentContextAll<'input> = ColumnNameComponentContext<'input>;


pub type ColumnNameComponentContext<'input> = BaseParserRuleContext<'input,ColumnNameComponentContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnNameComponentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnNameComponentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnNameComponentContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_columnNameComponent(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_columnNameComponent(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnNameComponentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnNameComponent(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnNameComponentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnNameComponent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnNameComponent }
}
antlr_rust::tid!{ColumnNameComponentContextExt<'a>}

impl<'input> ColumnNameComponentContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnNameComponentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnNameComponentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnNameComponentContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnNameComponentContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ColumnNameComponentContextAttrs<'input> for ColumnNameComponentContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnNameComponent(&mut self,)
	-> Result<Rc<ColumnNameComponentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnNameComponentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 58, RULE_columnNameComponent);
        let mut _localctx: Rc<ColumnNameComponentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2644);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnSchemaWithMetadata ----------------
pub type ColumnSchemaWithMetadataContextAll<'input> = ColumnSchemaWithMetadataContext<'input>;


pub type ColumnSchemaWithMetadataContext<'input> = BaseParserRuleContext<'input,ColumnSchemaWithMetadataContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnSchemaWithMetadataContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnSchemaWithMetadataContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnSchemaWithMetadataContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_columnSchemaWithMetadata(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_columnSchemaWithMetadata(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnSchemaWithMetadataContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnSchemaWithMetadata(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnSchemaWithMetadataContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnSchemaWithMetadata }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnSchemaWithMetadata }
}
antlr_rust::tid!{ColumnSchemaWithMetadataContextExt<'a>}

impl<'input> ColumnSchemaWithMetadataContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnSchemaWithMetadataContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnSchemaWithMetadataContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnSchemaWithMetadataContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnSchemaWithMetadataContextExt<'input>>{

fn columnSchema(&self) -> Option<Rc<ColumnSchemaContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token NULL
/// Returns `None` if there is no child corresponding to token NULL
fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULL, 0)
}
/// Retrieves first TerminalNode corresponding to token NOT
/// Returns `None` if there is no child corresponding to token NOT
fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOT, 0)
}

}

impl<'input> ColumnSchemaWithMetadataContextAttrs<'input> for ColumnSchemaWithMetadataContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnSchemaWithMetadata(&mut self,)
	-> Result<Rc<ColumnSchemaWithMetadataContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnSchemaWithMetadataContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 60, RULE_columnSchemaWithMetadata);
        let mut _localctx: Rc<ColumnSchemaWithMetadataContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule columnSchema*/
			recog.base.set_state(2646);
			recog.columnSchema()?;

			recog.base.set_state(2651);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(378,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2648);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(2647);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(2650);
					recog.base.match_token(NULL,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnOptionList ----------------
pub type ColumnOptionListContextAll<'input> = ColumnOptionListContext<'input>;


pub type ColumnOptionListContext<'input> = BaseParserRuleContext<'input,ColumnOptionListContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnOptionListContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnOptionListContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnOptionListContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_columnOptionList(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_columnOptionList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnOptionListContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnOptionList(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnOptionListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnOptionList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnOptionList }
}
antlr_rust::tid!{ColumnOptionListContextExt<'a>}

impl<'input> ColumnOptionListContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnOptionListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnOptionListContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnOptionListContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnOptionListContextExt<'input>>{

fn columnOption_all(&self) ->  Vec<Rc<ColumnOptionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn columnOption(&self, i: usize) -> Option<Rc<ColumnOptionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ColumnOptionListContextAttrs<'input> for ColumnOptionListContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnOptionList(&mut self,)
	-> Result<Rc<ColumnOptionListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnOptionListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 62, RULE_columnOptionList);
        let mut _localctx: Rc<ColumnOptionListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule columnOption*/
			recog.base.set_state(2653);
			recog.columnOption()?;

			recog.base.set_state(2658);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(379,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2654);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule columnOption*/
					recog.base.set_state(2655);
					recog.columnOption()?;

					}
					} 
				}
				recog.base.set_state(2660);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(379,&mut recog.base)?;
			}
			recog.base.set_state(2662);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(2661);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,ColumnOptionListContext >(&mut _localctx).tail = Some(tmp);
				  

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnOption ----------------
pub type ColumnOptionContextAll<'input> = ColumnOptionContext<'input>;


pub type ColumnOptionContext<'input> = BaseParserRuleContext<'input,ColumnOptionContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnOptionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnOptionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnOptionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_columnOption(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_columnOption(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnOptionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnOption(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnOptionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnOption }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnOption }
}
antlr_rust::tid!{ColumnOptionContextExt<'a>}

impl<'input> ColumnOptionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnOptionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnOptionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnOptionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnOptionContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EQ
/// Returns `None` if there is no child corresponding to token EQ
fn EQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EQ, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ColumnOptionContextAttrs<'input> for ColumnOptionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnOption(&mut self,)
	-> Result<Rc<ColumnOptionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnOptionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 64, RULE_columnOption);
        let mut _localctx: Rc<ColumnOptionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2664);
			recog.identifier()?;

			recog.base.set_state(2665);
			recog.base.match_token(EQ,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2666);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnSchema ----------------
#[derive(Debug)]
pub enum ColumnSchemaContextAll<'input>{
	ColumnSchemaSimpleTypeContext(ColumnSchemaSimpleTypeContext<'input>),
Error(ColumnSchemaContext<'input>)
}
antlr_rust::tid!{ColumnSchemaContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ColumnSchemaContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for ColumnSchemaContextAll<'input>{}

impl<'input> Deref for ColumnSchemaContextAll<'input>{
	type Target = dyn ColumnSchemaContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use ColumnSchemaContextAll::*;
		match self{
			ColumnSchemaSimpleTypeContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnSchemaContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnSchemaContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type ColumnSchemaContext<'input> = BaseParserRuleContext<'input,ColumnSchemaContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnSchemaContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnSchemaContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnSchemaContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnSchemaContext<'input>{
}

impl<'input> CustomRuleContext<'input> for ColumnSchemaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnSchema }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnSchema }
}
antlr_rust::tid!{ColumnSchemaContextExt<'a>}

impl<'input> ColumnSchemaContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnSchemaContextAll<'input>> {
		Rc::new(
		ColumnSchemaContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnSchemaContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait ColumnSchemaContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnSchemaContextExt<'input>>{


}

impl<'input> ColumnSchemaContextAttrs<'input> for ColumnSchemaContext<'input>{}

pub type ColumnSchemaSimpleTypeContext<'input> = BaseParserRuleContext<'input,ColumnSchemaSimpleTypeContextExt<'input>>;

pub trait ColumnSchemaSimpleTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ColumnSchemaSimpleTypeContextAttrs<'input> for ColumnSchemaSimpleTypeContext<'input>{}

pub struct ColumnSchemaSimpleTypeContextExt<'input>{
	base:ColumnSchemaContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ColumnSchemaSimpleTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ColumnSchemaSimpleTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnSchemaSimpleTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_columnSchemaSimpleType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_columnSchemaSimpleType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnSchemaSimpleTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnSchemaSimpleType(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnSchemaSimpleTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnSchema }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnSchema }
}

impl<'input> Borrow<ColumnSchemaContextExt<'input>> for ColumnSchemaSimpleTypeContext<'input>{
	fn borrow(&self) -> &ColumnSchemaContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ColumnSchemaContextExt<'input>> for ColumnSchemaSimpleTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut ColumnSchemaContextExt<'input> { &mut self.base }
}

impl<'input> ColumnSchemaContextAttrs<'input> for ColumnSchemaSimpleTypeContext<'input> {}

impl<'input> ColumnSchemaSimpleTypeContextExt<'input>{
	fn new(ctx: &dyn ColumnSchemaContextAttrs<'input>) -> Rc<ColumnSchemaContextAll<'input>>  {
		Rc::new(
			ColumnSchemaContextAll::ColumnSchemaSimpleTypeContext(
				BaseParserRuleContext::copy_from(ctx,ColumnSchemaSimpleTypeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnSchema(&mut self,)
	-> Result<Rc<ColumnSchemaContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnSchemaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 66, RULE_columnSchema);
        let mut _localctx: Rc<ColumnSchemaContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let tmp = ColumnSchemaSimpleTypeContextExt::new(&**_localctx);
			recog.base.enter_outer_alt(Some(tmp.clone()), 1);
			_localctx = tmp;
			{
			/*InvokeRule type_*/
			recog.base.set_state(2668);
			recog.type_()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- properties ----------------
pub type PropertiesContextAll<'input> = PropertiesContext<'input>;


pub type PropertiesContext<'input> = BaseParserRuleContext<'input,PropertiesContextExt<'input>>;

#[derive(Clone)]
pub struct PropertiesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PropertiesContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PropertiesContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_properties(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_properties(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PropertiesContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_properties(self);
	}
}

impl<'input> CustomRuleContext<'input> for PropertiesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_properties }
	//fn type_rule_index() -> usize where Self: Sized { RULE_properties }
}
antlr_rust::tid!{PropertiesContextExt<'a>}

impl<'input> PropertiesContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertiesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertiesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PropertiesContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PropertiesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn propertyAssignments(&self) -> Option<Rc<PropertyAssignmentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PropertiesContextAttrs<'input> for PropertiesContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn properties(&mut self,)
	-> Result<Rc<PropertiesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertiesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 68, RULE_properties);
        let mut _localctx: Rc<PropertiesContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2670);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(2672);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
				{
				/*InvokeRule propertyAssignments*/
				recog.base.set_state(2671);
				recog.propertyAssignments()?;

				}
			}

			recog.base.set_state(2674);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- propertyAssignments ----------------
pub type PropertyAssignmentsContextAll<'input> = PropertyAssignmentsContext<'input>;


pub type PropertyAssignmentsContext<'input> = BaseParserRuleContext<'input,PropertyAssignmentsContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyAssignmentsContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PropertyAssignmentsContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PropertyAssignmentsContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_propertyAssignments(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_propertyAssignments(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PropertyAssignmentsContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_propertyAssignments(self);
	}
}

impl<'input> CustomRuleContext<'input> for PropertyAssignmentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyAssignments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyAssignments }
}
antlr_rust::tid!{PropertyAssignmentsContextExt<'a>}

impl<'input> PropertyAssignmentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyAssignmentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyAssignmentsContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait PropertyAssignmentsContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PropertyAssignmentsContextExt<'input>>{

fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> PropertyAssignmentsContextAttrs<'input> for PropertyAssignmentsContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn propertyAssignments(&mut self,)
	-> Result<Rc<PropertyAssignmentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyAssignmentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 70, RULE_propertyAssignments);
        let mut _localctx: Rc<PropertyAssignmentsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule property*/
			recog.base.set_state(2676);
			recog.property()?;

			recog.base.set_state(2681);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(382,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2677);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule property*/
					recog.base.set_state(2678);
					recog.property()?;

					}
					} 
				}
				recog.base.set_state(2683);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(382,&mut recog.base)?;
			}
			recog.base.set_state(2685);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(2684);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,PropertyAssignmentsContext >(&mut _localctx).tail = Some(tmp);
				  

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- property ----------------
#[derive(Debug)]
pub enum PropertyContextAll<'input>{
	DefaultPropertyContext(DefaultPropertyContext<'input>),
	NestedPropertyContext(NestedPropertyContext<'input>),
Error(PropertyContext<'input>)
}
antlr_rust::tid!{PropertyContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PropertyContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PropertyContextAll<'input>{}

impl<'input> Deref for PropertyContextAll<'input>{
	type Target = dyn PropertyContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PropertyContextAll::*;
		match self{
			DefaultPropertyContext(inner) => inner,
			NestedPropertyContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PropertyContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PropertyContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PropertyContext<'input> = BaseParserRuleContext<'input,PropertyContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PropertyContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PropertyContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PropertyContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PropertyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_property }
	//fn type_rule_index() -> usize where Self: Sized { RULE_property }
}
antlr_rust::tid!{PropertyContextExt<'a>}

impl<'input> PropertyContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyContextAll<'input>> {
		Rc::new(
		PropertyContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PropertyContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PropertyContextExt<'input>>{


}

impl<'input> PropertyContextAttrs<'input> for PropertyContext<'input>{}

pub type DefaultPropertyContext<'input> = BaseParserRuleContext<'input,DefaultPropertyContextExt<'input>>;

pub trait DefaultPropertyContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn propertyKey(&self) -> Option<Rc<PropertyKeyContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token EQ
	/// Returns `None` if there is no child corresponding to token EQ
	fn EQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EQ, 0)
	}
	fn propertyValue(&self) -> Option<Rc<PropertyValueContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> DefaultPropertyContextAttrs<'input> for DefaultPropertyContext<'input>{}

pub struct DefaultPropertyContextExt<'input>{
	base:PropertyContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DefaultPropertyContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DefaultPropertyContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DefaultPropertyContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultProperty(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_defaultProperty(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DefaultPropertyContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_defaultProperty(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultPropertyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_property }
	//fn type_rule_index() -> usize where Self: Sized { RULE_property }
}

impl<'input> Borrow<PropertyContextExt<'input>> for DefaultPropertyContext<'input>{
	fn borrow(&self) -> &PropertyContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PropertyContextExt<'input>> for DefaultPropertyContext<'input>{
	fn borrow_mut(&mut self) -> &mut PropertyContextExt<'input> { &mut self.base }
}

impl<'input> PropertyContextAttrs<'input> for DefaultPropertyContext<'input> {}

impl<'input> DefaultPropertyContextExt<'input>{
	fn new(ctx: &dyn PropertyContextAttrs<'input>) -> Rc<PropertyContextAll<'input>>  {
		Rc::new(
			PropertyContextAll::DefaultPropertyContext(
				BaseParserRuleContext::copy_from(ctx,DefaultPropertyContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type NestedPropertyContext<'input> = BaseParserRuleContext<'input,NestedPropertyContextExt<'input>>;

pub trait NestedPropertyContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn propertyKey(&self) -> Option<Rc<PropertyKeyContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token EQ
	/// Returns `None` if there is no child corresponding to token EQ
	fn EQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EQ, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn property_all(&self) ->  Vec<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn property(&self, i: usize) -> Option<Rc<PropertyContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> NestedPropertyContextAttrs<'input> for NestedPropertyContext<'input>{}

pub struct NestedPropertyContextExt<'input>{
	base:PropertyContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{NestedPropertyContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for NestedPropertyContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NestedPropertyContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_nestedProperty(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_nestedProperty(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NestedPropertyContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_nestedProperty(self);
	}
}

impl<'input> CustomRuleContext<'input> for NestedPropertyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_property }
	//fn type_rule_index() -> usize where Self: Sized { RULE_property }
}

impl<'input> Borrow<PropertyContextExt<'input>> for NestedPropertyContext<'input>{
	fn borrow(&self) -> &PropertyContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PropertyContextExt<'input>> for NestedPropertyContext<'input>{
	fn borrow_mut(&mut self) -> &mut PropertyContextExt<'input> { &mut self.base }
}

impl<'input> PropertyContextAttrs<'input> for NestedPropertyContext<'input> {}

impl<'input> NestedPropertyContextExt<'input>{
	fn new(ctx: &dyn PropertyContextAttrs<'input>) -> Rc<PropertyContextAll<'input>>  {
		Rc::new(
			PropertyContextAll::NestedPropertyContext(
				BaseParserRuleContext::copy_from(ctx,NestedPropertyContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn property(&mut self,)
	-> Result<Rc<PropertyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 72, RULE_property);
        let mut _localctx: Rc<PropertyContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2702);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(385,&mut recog.base)? {
				1 =>{
					let tmp = NestedPropertyContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule propertyKey*/
					recog.base.set_state(2687);
					recog.propertyKey()?;

					recog.base.set_state(2688);
					recog.base.match_token(EQ,&mut recog.err_handler)?;

					recog.base.set_state(2689);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2693);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						{
						/*InvokeRule property*/
						recog.base.set_state(2690);
						recog.property()?;

						}
						}
						recog.base.set_state(2695);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(2696);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = DefaultPropertyContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule propertyKey*/
					recog.base.set_state(2698);
					recog.propertyKey()?;

					recog.base.set_state(2699);
					recog.base.match_token(EQ,&mut recog.err_handler)?;

					/*InvokeRule propertyValue*/
					recog.base.set_state(2700);
					recog.propertyValue()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- propertyKey ----------------
pub type PropertyKeyContextAll<'input> = PropertyKeyContext<'input>;


pub type PropertyKeyContext<'input> = BaseParserRuleContext<'input,PropertyKeyContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyKeyContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PropertyKeyContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PropertyKeyContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_propertyKey(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_propertyKey(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PropertyKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_propertyKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for PropertyKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyKey }
}
antlr_rust::tid!{PropertyKeyContextExt<'a>}

impl<'input> PropertyKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyKeyContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PropertyKeyContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PropertyKeyContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PropertyKeyContextAttrs<'input> for PropertyKeyContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn propertyKey(&mut self,)
	-> Result<Rc<PropertyKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 74, RULE_propertyKey);
        let mut _localctx: Rc<PropertyKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2704);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- propertyValue ----------------
#[derive(Debug)]
pub enum PropertyValueContextAll<'input>{
	ExpressionPropertyValueContext(ExpressionPropertyValueContext<'input>),
	DefaultPropertyValueContext(DefaultPropertyValueContext<'input>),
	IdentifierPropertyValueContext(IdentifierPropertyValueContext<'input>),
Error(PropertyValueContext<'input>)
}
antlr_rust::tid!{PropertyValueContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PropertyValueContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PropertyValueContextAll<'input>{}

impl<'input> Deref for PropertyValueContextAll<'input>{
	type Target = dyn PropertyValueContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PropertyValueContextAll::*;
		match self{
			ExpressionPropertyValueContext(inner) => inner,
			DefaultPropertyValueContext(inner) => inner,
			IdentifierPropertyValueContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PropertyValueContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PropertyValueContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PropertyValueContext<'input> = BaseParserRuleContext<'input,PropertyValueContextExt<'input>>;

#[derive(Clone)]
pub struct PropertyValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PropertyValueContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PropertyValueContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PropertyValueContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PropertyValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyValue }
}
antlr_rust::tid!{PropertyValueContextExt<'a>}

impl<'input> PropertyValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PropertyValueContextAll<'input>> {
		Rc::new(
		PropertyValueContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PropertyValueContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PropertyValueContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PropertyValueContextExt<'input>>{


}

impl<'input> PropertyValueContextAttrs<'input> for PropertyValueContext<'input>{}

pub type ExpressionPropertyValueContext<'input> = BaseParserRuleContext<'input,ExpressionPropertyValueContextExt<'input>>;

pub trait ExpressionPropertyValueContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ExpressionPropertyValueContextAttrs<'input> for ExpressionPropertyValueContext<'input>{}

pub struct ExpressionPropertyValueContextExt<'input>{
	base:PropertyValueContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ExpressionPropertyValueContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ExpressionPropertyValueContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ExpressionPropertyValueContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_expressionPropertyValue(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_expressionPropertyValue(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ExpressionPropertyValueContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_expressionPropertyValue(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionPropertyValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyValue }
}

impl<'input> Borrow<PropertyValueContextExt<'input>> for ExpressionPropertyValueContext<'input>{
	fn borrow(&self) -> &PropertyValueContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PropertyValueContextExt<'input>> for ExpressionPropertyValueContext<'input>{
	fn borrow_mut(&mut self) -> &mut PropertyValueContextExt<'input> { &mut self.base }
}

impl<'input> PropertyValueContextAttrs<'input> for ExpressionPropertyValueContext<'input> {}

impl<'input> ExpressionPropertyValueContextExt<'input>{
	fn new(ctx: &dyn PropertyValueContextAttrs<'input>) -> Rc<PropertyValueContextAll<'input>>  {
		Rc::new(
			PropertyValueContextAll::ExpressionPropertyValueContext(
				BaseParserRuleContext::copy_from(ctx,ExpressionPropertyValueContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DefaultPropertyValueContext<'input> = BaseParserRuleContext<'input,DefaultPropertyValueContextExt<'input>>;

pub trait DefaultPropertyValueContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DEFAULT
	/// Returns `None` if there is no child corresponding to token DEFAULT
	fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DEFAULT, 0)
	}
}

impl<'input> DefaultPropertyValueContextAttrs<'input> for DefaultPropertyValueContext<'input>{}

pub struct DefaultPropertyValueContextExt<'input>{
	base:PropertyValueContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DefaultPropertyValueContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DefaultPropertyValueContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DefaultPropertyValueContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultPropertyValue(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_defaultPropertyValue(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DefaultPropertyValueContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_defaultPropertyValue(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultPropertyValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyValue }
}

impl<'input> Borrow<PropertyValueContextExt<'input>> for DefaultPropertyValueContext<'input>{
	fn borrow(&self) -> &PropertyValueContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PropertyValueContextExt<'input>> for DefaultPropertyValueContext<'input>{
	fn borrow_mut(&mut self) -> &mut PropertyValueContextExt<'input> { &mut self.base }
}

impl<'input> PropertyValueContextAttrs<'input> for DefaultPropertyValueContext<'input> {}

impl<'input> DefaultPropertyValueContextExt<'input>{
	fn new(ctx: &dyn PropertyValueContextAttrs<'input>) -> Rc<PropertyValueContextAll<'input>>  {
		Rc::new(
			PropertyValueContextAll::DefaultPropertyValueContext(
				BaseParserRuleContext::copy_from(ctx,DefaultPropertyValueContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type IdentifierPropertyValueContext<'input> = BaseParserRuleContext<'input,IdentifierPropertyValueContextExt<'input>>;

pub trait IdentifierPropertyValueContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> IdentifierPropertyValueContextAttrs<'input> for IdentifierPropertyValueContext<'input>{}

pub struct IdentifierPropertyValueContextExt<'input>{
	base:PropertyValueContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{IdentifierPropertyValueContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for IdentifierPropertyValueContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IdentifierPropertyValueContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_identifierPropertyValue(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_identifierPropertyValue(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IdentifierPropertyValueContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_identifierPropertyValue(self);
	}
}

impl<'input> CustomRuleContext<'input> for IdentifierPropertyValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_propertyValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_propertyValue }
}

impl<'input> Borrow<PropertyValueContextExt<'input>> for IdentifierPropertyValueContext<'input>{
	fn borrow(&self) -> &PropertyValueContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PropertyValueContextExt<'input>> for IdentifierPropertyValueContext<'input>{
	fn borrow_mut(&mut self) -> &mut PropertyValueContextExt<'input> { &mut self.base }
}

impl<'input> PropertyValueContextAttrs<'input> for IdentifierPropertyValueContext<'input> {}

impl<'input> IdentifierPropertyValueContextExt<'input>{
	fn new(ctx: &dyn PropertyValueContextAttrs<'input>) -> Rc<PropertyValueContextAll<'input>>  {
		Rc::new(
			PropertyValueContextAll::IdentifierPropertyValueContext(
				BaseParserRuleContext::copy_from(ctx,IdentifierPropertyValueContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn propertyValue(&mut self,)
	-> Result<Rc<PropertyValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PropertyValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 76, RULE_propertyValue);
        let mut _localctx: Rc<PropertyValueContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2709);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(386,&mut recog.base)? {
				1 =>{
					let tmp = DefaultPropertyValueContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(2706);
					recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = IdentifierPropertyValueContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule identifier*/
					recog.base.set_state(2707);
					recog.identifier()?;

					}
				}
			,
				3 =>{
					let tmp = ExpressionPropertyValueContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					/*InvokeRule expression*/
					recog.base.set_state(2708);
					recog.expression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- queryNoWith ----------------
pub type QueryNoWithContextAll<'input> = QueryNoWithContext<'input>;


pub type QueryNoWithContext<'input> = BaseParserRuleContext<'input,QueryNoWithContextExt<'input>>;

#[derive(Clone)]
pub struct QueryNoWithContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QueryNoWithContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryNoWithContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_queryNoWith(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_queryNoWith(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryNoWithContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_queryNoWith(self);
	}
}

impl<'input> CustomRuleContext<'input> for QueryNoWithContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryNoWith }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryNoWith }
}
antlr_rust::tid!{QueryNoWithContextExt<'a>}

impl<'input> QueryNoWithContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QueryNoWithContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QueryNoWithContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait QueryNoWithContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QueryNoWithContextExt<'input>>{

fn queryLimit(&self) -> Option<Rc<QueryLimitContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> QueryNoWithContextAttrs<'input> for QueryNoWithContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn queryNoWith(&mut self,)
	-> Result<Rc<QueryNoWithContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QueryNoWithContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 78, RULE_queryNoWith);
        let mut _localctx: Rc<QueryNoWithContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule queryLimit*/
			recog.base.set_state(2711);
			recog.queryLimit()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- queryLimit ----------------
pub type QueryLimitContextAll<'input> = QueryLimitContext<'input>;


pub type QueryLimitContext<'input> = BaseParserRuleContext<'input,QueryLimitContextExt<'input>>;

#[derive(Clone)]
pub struct QueryLimitContextExt<'input>{
	pub limit: Option<Rc<LimitRowCountContextAll<'input>>>,
	pub offset: Option<Rc<RowCountContextAll<'input>>>,
	pub offset2: Option<Rc<RowCountContextAll<'input>>>,
	pub offsetRow: Option<Rc<RowOrRowsContextAll<'input>>>,
	pub fetchCount: Option<Rc<RowCountContextAll<'input>>>,
	pub countRow: Option<Rc<RowOrRowsContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QueryLimitContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryLimitContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_queryLimit(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_queryLimit(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryLimitContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_queryLimit(self);
	}
}

impl<'input> CustomRuleContext<'input> for QueryLimitContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryLimit }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryLimit }
}
antlr_rust::tid!{QueryLimitContextExt<'a>}

impl<'input> QueryLimitContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QueryLimitContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QueryLimitContextExt{
				limit: None, offset: None, offset2: None, offsetRow: None, fetchCount: None, countRow: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait QueryLimitContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QueryLimitContextExt<'input>>{

fn queryLimitTarget(&self) -> Option<Rc<QueryLimitTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LIMIT
/// Returns `None` if there is no child corresponding to token LIMIT
fn LIMIT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LIMIT, 0)
}
/// Retrieves first TerminalNode corresponding to token FETCH
/// Returns `None` if there is no child corresponding to token FETCH
fn FETCH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FETCH, 0)
}
fn limitRowCount(&self) -> Option<Rc<LimitRowCountContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn rowCount_all(&self) ->  Vec<Rc<RowCountContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn rowCount(&self, i: usize) -> Option<Rc<RowCountContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token OFFSET
/// Returns `None` if there is no child corresponding to token OFFSET
fn OFFSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OFFSET, 0)
}
/// Retrieves first TerminalNode corresponding to token ONLY
/// Returns `None` if there is no child corresponding to token ONLY
fn ONLY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ONLY, 0)
}
/// Retrieves first TerminalNode corresponding to token FIRST
/// Returns `None` if there is no child corresponding to token FIRST
fn FIRST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FIRST, 0)
}
/// Retrieves first TerminalNode corresponding to token NEXT
/// Returns `None` if there is no child corresponding to token NEXT
fn NEXT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NEXT, 0)
}
fn rowOrRows_all(&self) ->  Vec<Rc<RowOrRowsContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn rowOrRows(&self, i: usize) -> Option<Rc<RowOrRowsContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> QueryLimitContextAttrs<'input> for QueryLimitContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn queryLimit(&mut self,)
	-> Result<Rc<QueryLimitContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QueryLimitContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 80, RULE_queryLimit);
        let mut _localctx: Rc<QueryLimitContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule queryLimitTarget*/
			recog.base.set_state(2713);
			recog.queryLimitTarget()?;

			recog.base.set_state(2738);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 LIMIT 
				=> {
			    	{
			    	recog.base.set_state(2714);
			    	recog.base.match_token(LIMIT,&mut recog.err_handler)?;

			    	/*InvokeRule limitRowCount*/
			    	recog.base.set_state(2715);
			    	let tmp = recog.limitRowCount()?;
			    	 cast_mut::<_,QueryLimitContext >(&mut _localctx).limit = Some(tmp.clone());
			    	  

			    	recog.base.set_state(2718);
			    	recog.err_handler.sync(&mut recog.base)?;
			    	_la = recog.base.input.la(1);
			    	if _la==OFFSET {
			    		{
			    		recog.base.set_state(2716);
			    		recog.base.match_token(OFFSET,&mut recog.err_handler)?;

			    		/*InvokeRule rowCount*/
			    		recog.base.set_state(2717);
			    		let tmp = recog.rowCount()?;
			    		 cast_mut::<_,QueryLimitContext >(&mut _localctx).offset = Some(tmp.clone());
			    		  

			    		}
			    	}

			    	}
			    }

			 FETCH | OFFSET 
				=> {
			    	{
			    	recog.base.set_state(2725);
			    	recog.err_handler.sync(&mut recog.base)?;
			    	_la = recog.base.input.la(1);
			    	if _la==OFFSET {
			    		{
			    		recog.base.set_state(2720);
			    		recog.base.match_token(OFFSET,&mut recog.err_handler)?;

			    		/*InvokeRule rowCount*/
			    		recog.base.set_state(2721);
			    		let tmp = recog.rowCount()?;
			    		 cast_mut::<_,QueryLimitContext >(&mut _localctx).offset2 = Some(tmp.clone());
			    		  

			    		recog.base.set_state(2723);
			    		recog.err_handler.sync(&mut recog.base)?;
			    		_la = recog.base.input.la(1);
			    		if _la==ROW || _la==ROWS {
			    			{
			    			/*InvokeRule rowOrRows*/
			    			recog.base.set_state(2722);
			    			let tmp = recog.rowOrRows()?;
			    			 cast_mut::<_,QueryLimitContext >(&mut _localctx).offsetRow = Some(tmp.clone());
			    			  

			    			}
			    		}

			    		}
			    	}

			    	recog.base.set_state(2727);
			    	recog.base.match_token(FETCH,&mut recog.err_handler)?;

			    	recog.base.set_state(2729);
			    	recog.err_handler.sync(&mut recog.base)?;
			    	_la = recog.base.input.la(1);
			    	if _la==FIRST || _la==NEXT {
			    		{
			    		recog.base.set_state(2728);
			    		_la = recog.base.input.la(1);
			    		if { !(_la==FIRST || _la==NEXT) } {
			    			recog.err_handler.recover_inline(&mut recog.base)?;

			    		}
			    		else {
			    			if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
			    			recog.err_handler.report_match(&mut recog.base);
			    			recog.base.consume(&mut recog.err_handler);
			    		}
			    		}
			    	}

			    	/*InvokeRule rowCount*/
			    	recog.base.set_state(2731);
			    	let tmp = recog.rowCount()?;
			    	 cast_mut::<_,QueryLimitContext >(&mut _localctx).fetchCount = Some(tmp.clone());
			    	  

			    	recog.base.set_state(2733);
			    	recog.err_handler.sync(&mut recog.base)?;
			    	_la = recog.base.input.la(1);
			    	if _la==ROW || _la==ROWS {
			    		{
			    		/*InvokeRule rowOrRows*/
			    		recog.base.set_state(2732);
			    		let tmp = recog.rowOrRows()?;
			    		 cast_mut::<_,QueryLimitContext >(&mut _localctx).countRow = Some(tmp.clone());
			    		  

			    		}
			    	}

			    	recog.base.set_state(2736);
			    	recog.err_handler.sync(&mut recog.base)?;
			    	_la = recog.base.input.la(1);
			    	if _la==ONLY {
			    		{
			    		recog.base.set_state(2735);
			    		recog.base.match_token(ONLY,&mut recog.err_handler)?;

			    		}
			    	}

			    	}
			    }

			 EOF | COMMA | RPAREN | SEMI_COLON 
				=> {
			    }

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- queryLimitTarget ----------------
#[derive(Debug)]
pub enum QueryLimitTargetContextAll<'input>{
	QueryLimitTargetRedshiftSnowflakeContext(QueryLimitTargetRedshiftSnowflakeContext<'input>),
Error(QueryLimitTargetContext<'input>)
}
antlr_rust::tid!{QueryLimitTargetContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for QueryLimitTargetContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for QueryLimitTargetContextAll<'input>{}

impl<'input> Deref for QueryLimitTargetContextAll<'input>{
	type Target = dyn QueryLimitTargetContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use QueryLimitTargetContextAll::*;
		match self{
			QueryLimitTargetRedshiftSnowflakeContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryLimitTargetContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryLimitTargetContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type QueryLimitTargetContext<'input> = BaseParserRuleContext<'input,QueryLimitTargetContextExt<'input>>;

#[derive(Clone)]
pub struct QueryLimitTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QueryLimitTargetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryLimitTargetContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryLimitTargetContext<'input>{
}

impl<'input> CustomRuleContext<'input> for QueryLimitTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryLimitTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryLimitTarget }
}
antlr_rust::tid!{QueryLimitTargetContextExt<'a>}

impl<'input> QueryLimitTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QueryLimitTargetContextAll<'input>> {
		Rc::new(
		QueryLimitTargetContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QueryLimitTargetContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait QueryLimitTargetContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QueryLimitTargetContextExt<'input>>{


}

impl<'input> QueryLimitTargetContextAttrs<'input> for QueryLimitTargetContext<'input>{}

pub type QueryLimitTargetRedshiftSnowflakeContext<'input> = BaseParserRuleContext<'input,QueryLimitTargetRedshiftSnowflakeContextExt<'input>>;

pub trait QueryLimitTargetRedshiftSnowflakeContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn queryTerm(&self) -> Option<Rc<QueryTermContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn orderBy(&self) -> Option<Rc<OrderByContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> QueryLimitTargetRedshiftSnowflakeContextAttrs<'input> for QueryLimitTargetRedshiftSnowflakeContext<'input>{}

pub struct QueryLimitTargetRedshiftSnowflakeContextExt<'input>{
	base:QueryLimitTargetContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{QueryLimitTargetRedshiftSnowflakeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for QueryLimitTargetRedshiftSnowflakeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryLimitTargetRedshiftSnowflakeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_queryLimitTargetRedshiftSnowflake(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_queryLimitTargetRedshiftSnowflake(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryLimitTargetRedshiftSnowflakeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_queryLimitTargetRedshiftSnowflake(self);
	}
}

impl<'input> CustomRuleContext<'input> for QueryLimitTargetRedshiftSnowflakeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryLimitTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryLimitTarget }
}

impl<'input> Borrow<QueryLimitTargetContextExt<'input>> for QueryLimitTargetRedshiftSnowflakeContext<'input>{
	fn borrow(&self) -> &QueryLimitTargetContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<QueryLimitTargetContextExt<'input>> for QueryLimitTargetRedshiftSnowflakeContext<'input>{
	fn borrow_mut(&mut self) -> &mut QueryLimitTargetContextExt<'input> { &mut self.base }
}

impl<'input> QueryLimitTargetContextAttrs<'input> for QueryLimitTargetRedshiftSnowflakeContext<'input> {}

impl<'input> QueryLimitTargetRedshiftSnowflakeContextExt<'input>{
	fn new(ctx: &dyn QueryLimitTargetContextAttrs<'input>) -> Rc<QueryLimitTargetContextAll<'input>>  {
		Rc::new(
			QueryLimitTargetContextAll::QueryLimitTargetRedshiftSnowflakeContext(
				BaseParserRuleContext::copy_from(ctx,QueryLimitTargetRedshiftSnowflakeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn queryLimitTarget(&mut self,)
	-> Result<Rc<QueryLimitTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QueryLimitTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 82, RULE_queryLimitTarget);
        let mut _localctx: Rc<QueryLimitTargetContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let tmp = QueryLimitTargetRedshiftSnowflakeContextExt::new(&**_localctx);
			recog.base.enter_outer_alt(Some(tmp.clone()), 1);
			_localctx = tmp;
			{
			/*InvokeRule queryTerm*/
			recog.base.set_state(2740);
			recog.queryTerm()?;

			recog.base.set_state(2742);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ORDER {
				{
				/*InvokeRule orderBy*/
				recog.base.set_state(2741);
				recog.orderBy()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rowOrRows ----------------
pub type RowOrRowsContextAll<'input> = RowOrRowsContext<'input>;


pub type RowOrRowsContext<'input> = BaseParserRuleContext<'input,RowOrRowsContextExt<'input>>;

#[derive(Clone)]
pub struct RowOrRowsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for RowOrRowsContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RowOrRowsContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rowOrRows(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_rowOrRows(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RowOrRowsContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rowOrRows(self);
	}
}

impl<'input> CustomRuleContext<'input> for RowOrRowsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rowOrRows }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rowOrRows }
}
antlr_rust::tid!{RowOrRowsContextExt<'a>}

impl<'input> RowOrRowsContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RowOrRowsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RowOrRowsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RowOrRowsContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<RowOrRowsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ROW
/// Returns `None` if there is no child corresponding to token ROW
fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROW, 0)
}
/// Retrieves first TerminalNode corresponding to token ROWS
/// Returns `None` if there is no child corresponding to token ROWS
fn ROWS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROWS, 0)
}

}

impl<'input> RowOrRowsContextAttrs<'input> for RowOrRowsContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rowOrRows(&mut self,)
	-> Result<Rc<RowOrRowsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RowOrRowsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 84, RULE_rowOrRows);
        let mut _localctx: Rc<RowOrRowsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2744);
			_la = recog.base.input.la(1);
			if { !(_la==ROW || _la==ROWS) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- limitRowCount ----------------
pub type LimitRowCountContextAll<'input> = LimitRowCountContext<'input>;


pub type LimitRowCountContext<'input> = BaseParserRuleContext<'input,LimitRowCountContextExt<'input>>;

#[derive(Clone)]
pub struct LimitRowCountContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for LimitRowCountContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LimitRowCountContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_limitRowCount(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_limitRowCount(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LimitRowCountContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_limitRowCount(self);
	}
}

impl<'input> CustomRuleContext<'input> for LimitRowCountContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_limitRowCount }
	//fn type_rule_index() -> usize where Self: Sized { RULE_limitRowCount }
}
antlr_rust::tid!{LimitRowCountContextExt<'a>}

impl<'input> LimitRowCountContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LimitRowCountContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LimitRowCountContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait LimitRowCountContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<LimitRowCountContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ALL
/// Returns `None` if there is no child corresponding to token ALL
fn ALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ALL, 0)
}
/// Retrieves first TerminalNode corresponding to token NULL
/// Returns `None` if there is no child corresponding to token NULL
fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULL, 0)
}
fn rowCount(&self) -> Option<Rc<RowCountContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> LimitRowCountContextAttrs<'input> for LimitRowCountContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn limitRowCount(&mut self,)
	-> Result<Rc<LimitRowCountContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LimitRowCountContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 86, RULE_limitRowCount);
        let mut _localctx: Rc<LimitRowCountContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2749);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ALL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2746);
					recog.base.match_token(ALL,&mut recog.err_handler)?;

					}
				}

			 NULL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2747);
					recog.base.match_token(NULL,&mut recog.err_handler)?;

					}
				}

			 QUESTION_MARK | INTEGER_VALUE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					/*InvokeRule rowCount*/
					recog.base.set_state(2748);
					recog.rowCount()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rowCount ----------------
pub type RowCountContextAll<'input> = RowCountContext<'input>;


pub type RowCountContext<'input> = BaseParserRuleContext<'input,RowCountContextExt<'input>>;

#[derive(Clone)]
pub struct RowCountContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for RowCountContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RowCountContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rowCount(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_rowCount(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RowCountContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rowCount(self);
	}
}

impl<'input> CustomRuleContext<'input> for RowCountContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rowCount }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rowCount }
}
antlr_rust::tid!{RowCountContextExt<'a>}

impl<'input> RowCountContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RowCountContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RowCountContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RowCountContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<RowCountContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTEGER_VALUE, 0)
}
/// Retrieves first TerminalNode corresponding to token QUESTION_MARK
/// Returns `None` if there is no child corresponding to token QUESTION_MARK
fn QUESTION_MARK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(QUESTION_MARK, 0)
}

}

impl<'input> RowCountContextAttrs<'input> for RowCountContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rowCount(&mut self,)
	-> Result<Rc<RowCountContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RowCountContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 88, RULE_rowCount);
        let mut _localctx: Rc<RowCountContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2751);
			_la = recog.base.input.la(1);
			if { !(_la==QUESTION_MARK || _la==INTEGER_VALUE) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- queryTerm ----------------
pub type QueryTermContextAll<'input> = QueryTermContext<'input>;


pub type QueryTermContext<'input> = BaseParserRuleContext<'input,QueryTermContextExt<'input>>;

#[derive(Clone)]
pub struct QueryTermContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QueryTermContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryTermContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_queryTerm(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_queryTerm(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryTermContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_queryTerm(self);
	}
}

impl<'input> CustomRuleContext<'input> for QueryTermContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryTerm }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryTerm }
}
antlr_rust::tid!{QueryTermContextExt<'a>}

impl<'input> QueryTermContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QueryTermContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QueryTermContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait QueryTermContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QueryTermContextExt<'input>>{

fn setOperation(&self) -> Option<Rc<SetOperationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> QueryTermContextAttrs<'input> for QueryTermContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn queryTerm(&mut self,)
	-> Result<Rc<QueryTermContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QueryTermContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 90, RULE_queryTerm);
        let mut _localctx: Rc<QueryTermContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule setOperation*/
			recog.base.set_state(2753);
			recog.setOperation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- setOperation ----------------
pub type SetOperationContextAll<'input> = SetOperationContext<'input>;


pub type SetOperationContext<'input> = BaseParserRuleContext<'input,SetOperationContextExt<'input>>;

#[derive(Clone)]
pub struct SetOperationContextExt<'input>{
	pub left: Option<Rc<SetOperationIntersectContextAll<'input>>>,
	pub setOperationIntersect: Option<Rc<SetOperationIntersectContextAll<'input>>>,
	pub right:Vec<Rc<SetOperationIntersectContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SetOperationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetOperationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_setOperation(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_setOperation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetOperationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setOperation(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetOperationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_setOperation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_setOperation }
}
antlr_rust::tid!{SetOperationContextExt<'a>}

impl<'input> SetOperationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SetOperationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SetOperationContextExt{
				left: None, setOperationIntersect: None, 
				right: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait SetOperationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SetOperationContextExt<'input>>{

fn setOperationIntersect_all(&self) ->  Vec<Rc<SetOperationIntersectContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn setOperationIntersect(&self, i: usize) -> Option<Rc<SetOperationIntersectContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn setOperator_all(&self) ->  Vec<Rc<SetOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn setOperator(&self, i: usize) -> Option<Rc<SetOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SetOperationContextAttrs<'input> for SetOperationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn setOperation(&mut self,)
	-> Result<Rc<SetOperationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SetOperationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 92, RULE_setOperation);
        let mut _localctx: Rc<SetOperationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule setOperationIntersect*/
			recog.base.set_state(2755);
			let tmp = recog.setOperationIntersect()?;
			 cast_mut::<_,SetOperationContext >(&mut _localctx).left = Some(tmp.clone());
			  

			recog.base.set_state(2761);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==EXCEPT || _la==MINUS_KW || _la==UNION {
				{
				{
				/*InvokeRule setOperator*/
				recog.base.set_state(2756);
				recog.setOperator()?;

				/*InvokeRule setOperationIntersect*/
				recog.base.set_state(2757);
				let tmp = recog.setOperationIntersect()?;
				 cast_mut::<_,SetOperationContext >(&mut _localctx).setOperationIntersect = Some(tmp.clone());
				  

				let temp =  cast_mut::<_,SetOperationContext >(&mut _localctx).setOperationIntersect.clone().unwrap()
				 ;
				 cast_mut::<_,SetOperationContext >(&mut _localctx).right.push(temp);
				  
				}
				}
				recog.base.set_state(2763);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- setOperator ----------------
pub type SetOperatorContextAll<'input> = SetOperatorContext<'input>;


pub type SetOperatorContext<'input> = BaseParserRuleContext<'input,SetOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct SetOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SetOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_setOperator(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_setOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_setOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_setOperator }
}
antlr_rust::tid!{SetOperatorContextExt<'a>}

impl<'input> SetOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SetOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SetOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SetOperatorContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SetOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token UNION
/// Returns `None` if there is no child corresponding to token UNION
fn UNION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNION, 0)
}
fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
/// Retrieves first TerminalNode corresponding to token NAME
/// Returns `None` if there is no child corresponding to token NAME
fn NAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NAME, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCEPT
/// Returns `None` if there is no child corresponding to token EXCEPT
fn EXCEPT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXCEPT, 0)
}
/// Retrieves first TerminalNode corresponding to token MINUS_KW
/// Returns `None` if there is no child corresponding to token MINUS_KW
fn MINUS_KW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MINUS_KW, 0)
}

}

impl<'input> SetOperatorContextAttrs<'input> for SetOperatorContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn setOperator(&mut self,)
	-> Result<Rc<SetOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SetOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 94, RULE_setOperator);
        let mut _localctx: Rc<SetOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2776);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 UNION 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2764);
					recog.base.match_token(UNION,&mut recog.err_handler)?;

					recog.base.set_state(2766);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ALL || _la==DISTINCT {
						{
						/*InvokeRule setQuantifier*/
						recog.base.set_state(2765);
						recog.setQuantifier()?;

						}
					}

					recog.base.set_state(2770);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==BY {
						{
						recog.base.set_state(2768);
						recog.base.match_token(BY,&mut recog.err_handler)?;

						recog.base.set_state(2769);
						recog.base.match_token(NAME,&mut recog.err_handler)?;

						}
					}

					}
				}

			 EXCEPT | MINUS_KW 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(2772);
					_la = recog.base.input.la(1);
					if { !(_la==EXCEPT || _la==MINUS_KW) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(2774);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ALL || _la==DISTINCT {
						{
						/*InvokeRule setQuantifier*/
						recog.base.set_state(2773);
						recog.setQuantifier()?;

						}
					}

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- setOperationIntersect ----------------
pub type SetOperationIntersectContextAll<'input> = SetOperationIntersectContext<'input>;


pub type SetOperationIntersectContext<'input> = BaseParserRuleContext<'input,SetOperationIntersectContextExt<'input>>;

#[derive(Clone)]
pub struct SetOperationIntersectContextExt<'input>{
	pub left: Option<Rc<QueryPrimaryContextAll<'input>>>,
	pub queryPrimary: Option<Rc<QueryPrimaryContextAll<'input>>>,
	pub right:Vec<Rc<QueryPrimaryContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SetOperationIntersectContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetOperationIntersectContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_setOperationIntersect(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_setOperationIntersect(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetOperationIntersectContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setOperationIntersect(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetOperationIntersectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_setOperationIntersect }
	//fn type_rule_index() -> usize where Self: Sized { RULE_setOperationIntersect }
}
antlr_rust::tid!{SetOperationIntersectContextExt<'a>}

impl<'input> SetOperationIntersectContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SetOperationIntersectContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SetOperationIntersectContextExt{
				left: None, queryPrimary: None, 
				right: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait SetOperationIntersectContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SetOperationIntersectContextExt<'input>>{

fn queryPrimary_all(&self) ->  Vec<Rc<QueryPrimaryContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn queryPrimary(&self, i: usize) -> Option<Rc<QueryPrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn setIntersectOperator_all(&self) ->  Vec<Rc<SetIntersectOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn setIntersectOperator(&self, i: usize) -> Option<Rc<SetIntersectOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SetOperationIntersectContextAttrs<'input> for SetOperationIntersectContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn setOperationIntersect(&mut self,)
	-> Result<Rc<SetOperationIntersectContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SetOperationIntersectContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 96, RULE_setOperationIntersect);
        let mut _localctx: Rc<SetOperationIntersectContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule queryPrimary*/
			recog.base.set_state(2778);
			let tmp = recog.queryPrimary()?;
			 cast_mut::<_,SetOperationIntersectContext >(&mut _localctx).left = Some(tmp.clone());
			  

			recog.base.set_state(2784);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==INTERSECT {
				{
				{
				/*InvokeRule setIntersectOperator*/
				recog.base.set_state(2779);
				recog.setIntersectOperator()?;

				/*InvokeRule queryPrimary*/
				recog.base.set_state(2780);
				let tmp = recog.queryPrimary()?;
				 cast_mut::<_,SetOperationIntersectContext >(&mut _localctx).queryPrimary = Some(tmp.clone());
				  

				let temp =  cast_mut::<_,SetOperationIntersectContext >(&mut _localctx).queryPrimary.clone().unwrap()
				 ;
				 cast_mut::<_,SetOperationIntersectContext >(&mut _localctx).right.push(temp);
				  
				}
				}
				recog.base.set_state(2786);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- setIntersectOperator ----------------
pub type SetIntersectOperatorContextAll<'input> = SetIntersectOperatorContext<'input>;


pub type SetIntersectOperatorContext<'input> = BaseParserRuleContext<'input,SetIntersectOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct SetIntersectOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SetIntersectOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetIntersectOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_setIntersectOperator(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_setIntersectOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetIntersectOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setIntersectOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetIntersectOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_setIntersectOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_setIntersectOperator }
}
antlr_rust::tid!{SetIntersectOperatorContextExt<'a>}

impl<'input> SetIntersectOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SetIntersectOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SetIntersectOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SetIntersectOperatorContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SetIntersectOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INTERSECT
/// Returns `None` if there is no child corresponding to token INTERSECT
fn INTERSECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTERSECT, 0)
}
fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SetIntersectOperatorContextAttrs<'input> for SetIntersectOperatorContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn setIntersectOperator(&mut self,)
	-> Result<Rc<SetIntersectOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SetIntersectOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 98, RULE_setIntersectOperator);
        let mut _localctx: Rc<SetIntersectOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2787);
			recog.base.match_token(INTERSECT,&mut recog.err_handler)?;

			recog.base.set_state(2789);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ALL || _la==DISTINCT {
				{
				/*InvokeRule setQuantifier*/
				recog.base.set_state(2788);
				recog.setQuantifier()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- setQuantifier ----------------
pub type SetQuantifierContextAll<'input> = SetQuantifierContext<'input>;


pub type SetQuantifierContext<'input> = BaseParserRuleContext<'input,SetQuantifierContextExt<'input>>;

#[derive(Clone)]
pub struct SetQuantifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SetQuantifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SetQuantifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_setQuantifier(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_setQuantifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SetQuantifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_setQuantifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for SetQuantifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_setQuantifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_setQuantifier }
}
antlr_rust::tid!{SetQuantifierContextExt<'a>}

impl<'input> SetQuantifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SetQuantifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SetQuantifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SetQuantifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SetQuantifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DISTINCT
/// Returns `None` if there is no child corresponding to token DISTINCT
fn DISTINCT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISTINCT, 0)
}
/// Retrieves first TerminalNode corresponding to token ALL
/// Returns `None` if there is no child corresponding to token ALL
fn ALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ALL, 0)
}

}

impl<'input> SetQuantifierContextAttrs<'input> for SetQuantifierContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn setQuantifier(&mut self,)
	-> Result<Rc<SetQuantifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SetQuantifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 100, RULE_setQuantifier);
        let mut _localctx: Rc<SetQuantifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2791);
			_la = recog.base.input.la(1);
			if { !(_la==ALL || _la==DISTINCT) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- inlineTable ----------------
pub type InlineTableContextAll<'input> = InlineTableContext<'input>;


pub type InlineTableContext<'input> = BaseParserRuleContext<'input,InlineTableContextExt<'input>>;

#[derive(Clone)]
pub struct InlineTableContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for InlineTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for InlineTableContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_inlineTable(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_inlineTable(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for InlineTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_inlineTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for InlineTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_inlineTable }
	//fn type_rule_index() -> usize where Self: Sized { RULE_inlineTable }
}
antlr_rust::tid!{InlineTableContextExt<'a>}

impl<'input> InlineTableContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<InlineTableContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,InlineTableContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait InlineTableContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<InlineTableContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token VALUES
/// Returns `None` if there is no child corresponding to token VALUES
fn VALUES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VALUES, 0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> InlineTableContextAttrs<'input> for InlineTableContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn inlineTable(&mut self,)
	-> Result<Rc<InlineTableContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = InlineTableContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 102, RULE_inlineTable);
        let mut _localctx: Rc<InlineTableContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2793);
			recog.base.match_token(VALUES,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(2794);
			recog.expression()?;

			recog.base.set_state(2799);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(403,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2795);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(2796);
					recog.expression()?;

					}
					} 
				}
				recog.base.set_state(2801);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(403,&mut recog.base)?;
			}
			recog.base.set_state(2803);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(2802);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,InlineTableContext >(&mut _localctx).tail = Some(tmp);
				  

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- queryPrimary ----------------
#[derive(Debug)]
pub enum QueryPrimaryContextAll<'input>{
	SubqueryContext(SubqueryContext<'input>),
	QueryPrimaryDefaultContext(QueryPrimaryDefaultContext<'input>),
	TableContext(TableContext<'input>),
Error(QueryPrimaryContext<'input>)
}
antlr_rust::tid!{QueryPrimaryContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for QueryPrimaryContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for QueryPrimaryContextAll<'input>{}

impl<'input> Deref for QueryPrimaryContextAll<'input>{
	type Target = dyn QueryPrimaryContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use QueryPrimaryContextAll::*;
		match self{
			SubqueryContext(inner) => inner,
			QueryPrimaryDefaultContext(inner) => inner,
			TableContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryPrimaryContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryPrimaryContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type QueryPrimaryContext<'input> = BaseParserRuleContext<'input,QueryPrimaryContextExt<'input>>;

#[derive(Clone)]
pub struct QueryPrimaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QueryPrimaryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryPrimaryContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryPrimaryContext<'input>{
}

impl<'input> CustomRuleContext<'input> for QueryPrimaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryPrimary }
}
antlr_rust::tid!{QueryPrimaryContextExt<'a>}

impl<'input> QueryPrimaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QueryPrimaryContextAll<'input>> {
		Rc::new(
		QueryPrimaryContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QueryPrimaryContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait QueryPrimaryContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QueryPrimaryContextExt<'input>>{


}

impl<'input> QueryPrimaryContextAttrs<'input> for QueryPrimaryContext<'input>{}

pub type SubqueryContext<'input> = BaseParserRuleContext<'input,SubqueryContextExt<'input>>;

pub trait SubqueryContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SubqueryContextAttrs<'input> for SubqueryContext<'input>{}

pub struct SubqueryContextExt<'input>{
	base:QueryPrimaryContextExt<'input>,
	pub query_: Option<Rc<QueryContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SubqueryContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SubqueryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SubqueryContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_subquery(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_subquery(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SubqueryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_subquery(self);
	}
}

impl<'input> CustomRuleContext<'input> for SubqueryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryPrimary }
}

impl<'input> Borrow<QueryPrimaryContextExt<'input>> for SubqueryContext<'input>{
	fn borrow(&self) -> &QueryPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<QueryPrimaryContextExt<'input>> for SubqueryContext<'input>{
	fn borrow_mut(&mut self) -> &mut QueryPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> QueryPrimaryContextAttrs<'input> for SubqueryContext<'input> {}

impl<'input> SubqueryContextExt<'input>{
	fn new(ctx: &dyn QueryPrimaryContextAttrs<'input>) -> Rc<QueryPrimaryContextAll<'input>>  {
		Rc::new(
			QueryPrimaryContextAll::SubqueryContext(
				BaseParserRuleContext::copy_from(ctx,SubqueryContextExt{
        			query_:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type QueryPrimaryDefaultContext<'input> = BaseParserRuleContext<'input,QueryPrimaryDefaultContextExt<'input>>;

pub trait QueryPrimaryDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn querySpecification(&self) -> Option<Rc<QuerySpecificationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> QueryPrimaryDefaultContextAttrs<'input> for QueryPrimaryDefaultContext<'input>{}

pub struct QueryPrimaryDefaultContextExt<'input>{
	base:QueryPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{QueryPrimaryDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for QueryPrimaryDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryPrimaryDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_queryPrimaryDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_queryPrimaryDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryPrimaryDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_queryPrimaryDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for QueryPrimaryDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryPrimary }
}

impl<'input> Borrow<QueryPrimaryContextExt<'input>> for QueryPrimaryDefaultContext<'input>{
	fn borrow(&self) -> &QueryPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<QueryPrimaryContextExt<'input>> for QueryPrimaryDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut QueryPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> QueryPrimaryContextAttrs<'input> for QueryPrimaryDefaultContext<'input> {}

impl<'input> QueryPrimaryDefaultContextExt<'input>{
	fn new(ctx: &dyn QueryPrimaryContextAttrs<'input>) -> Rc<QueryPrimaryContextAll<'input>>  {
		Rc::new(
			QueryPrimaryContextAll::QueryPrimaryDefaultContext(
				BaseParserRuleContext::copy_from(ctx,QueryPrimaryDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TableContext<'input> = BaseParserRuleContext<'input,TableContextExt<'input>>;

pub trait TableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	fn pathExpression(&self) -> Option<Rc<PathExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> TableContextAttrs<'input> for TableContext<'input>{}

pub struct TableContextExt<'input>{
	base:QueryPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_table(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_table(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_table(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryPrimary }
}

impl<'input> Borrow<QueryPrimaryContextExt<'input>> for TableContext<'input>{
	fn borrow(&self) -> &QueryPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<QueryPrimaryContextExt<'input>> for TableContext<'input>{
	fn borrow_mut(&mut self) -> &mut QueryPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> QueryPrimaryContextAttrs<'input> for TableContext<'input> {}

impl<'input> TableContextExt<'input>{
	fn new(ctx: &dyn QueryPrimaryContextAttrs<'input>) -> Rc<QueryPrimaryContextAll<'input>>  {
		Rc::new(
			QueryPrimaryContextAll::TableContext(
				BaseParserRuleContext::copy_from(ctx,TableContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn queryPrimary(&mut self,)
	-> Result<Rc<QueryPrimaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QueryPrimaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 104, RULE_queryPrimary);
        let mut _localctx: Rc<QueryPrimaryContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(2812);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 SELECT 
				=> {
					let tmp = QueryPrimaryDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule querySpecification*/
					recog.base.set_state(2805);
					recog.querySpecification()?;

					}
				}

			 TABLE 
				=> {
					let tmp = TableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(2806);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					/*InvokeRule pathExpression*/
					recog.base.set_state(2807);
					recog.pathExpression()?;

					}
				}

			 LPAREN 
				=> {
					let tmp = SubqueryContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(2808);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(2809);
					let tmp = recog.query()?;
					if let QueryPrimaryContextAll::SubqueryContext(ctx) = cast_mut::<_,QueryPrimaryContextAll >(&mut _localctx){
					ctx.query_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(2810);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sortItem ----------------
pub type SortItemContextAll<'input> = SortItemContext<'input>;


pub type SortItemContext<'input> = BaseParserRuleContext<'input,SortItemContextExt<'input>>;

#[derive(Clone)]
pub struct SortItemContextExt<'input>{
	pub ordering: Option<TokenType<'input>>,
	pub nullOrdering: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SortItemContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SortItemContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sortItem(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_sortItem(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SortItemContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_sortItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for SortItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sortItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sortItem }
}
antlr_rust::tid!{SortItemContextExt<'a>}

impl<'input> SortItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SortItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SortItemContextExt{
				ordering: None, nullOrdering: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait SortItemContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SortItemContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token NULLS
/// Returns `None` if there is no child corresponding to token NULLS
fn NULLS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULLS, 0)
}
/// Retrieves first TerminalNode corresponding to token ASC
/// Returns `None` if there is no child corresponding to token ASC
fn ASC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ASC, 0)
}
/// Retrieves first TerminalNode corresponding to token DESC
/// Returns `None` if there is no child corresponding to token DESC
fn DESC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DESC, 0)
}
/// Retrieves first TerminalNode corresponding to token FIRST
/// Returns `None` if there is no child corresponding to token FIRST
fn FIRST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FIRST, 0)
}
/// Retrieves first TerminalNode corresponding to token LAST
/// Returns `None` if there is no child corresponding to token LAST
fn LAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LAST, 0)
}

}

impl<'input> SortItemContextAttrs<'input> for SortItemContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sortItem(&mut self,)
	-> Result<Rc<SortItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SortItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 106, RULE_sortItem);
        let mut _localctx: Rc<SortItemContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(2814);
			recog.expression()?;

			recog.base.set_state(2816);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ASC || _la==DESC {
				{
				recog.base.set_state(2815);
				 cast_mut::<_,SortItemContext >(&mut _localctx).ordering = recog.base.input.lt(1).cloned();
				 
				_la = recog.base.input.la(1);
				if { !(_la==ASC || _la==DESC) } {
					let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
					 cast_mut::<_,SortItemContext >(&mut _localctx).ordering = Some(tmp);
					  

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			recog.base.set_state(2820);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==NULLS {
				{
				recog.base.set_state(2818);
				recog.base.match_token(NULLS,&mut recog.err_handler)?;

				recog.base.set_state(2819);
				 cast_mut::<_,SortItemContext >(&mut _localctx).nullOrdering = recog.base.input.lt(1).cloned();
				 
				_la = recog.base.input.la(1);
				if { !(_la==FIRST || _la==LAST) } {
					let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
					 cast_mut::<_,SortItemContext >(&mut _localctx).nullOrdering = Some(tmp);
					  

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- connectByItem ----------------
pub type ConnectByItemContextAll<'input> = ConnectByItemContext<'input>;


pub type ConnectByItemContext<'input> = BaseParserRuleContext<'input,ConnectByItemContextExt<'input>>;

#[derive(Clone)]
pub struct ConnectByItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ConnectByItemContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ConnectByItemContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_connectByItem(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_connectByItem(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ConnectByItemContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_connectByItem(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConnectByItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_connectByItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_connectByItem }
}
antlr_rust::tid!{ConnectByItemContextExt<'a>}

impl<'input> ConnectByItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConnectByItemContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConnectByItemContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConnectByItemContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ConnectByItemContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ConnectByItemContextAttrs<'input> for ConnectByItemContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn connectByItem(&mut self,)
	-> Result<Rc<ConnectByItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConnectByItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 108, RULE_connectByItem);
        let mut _localctx: Rc<ConnectByItemContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(2822);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- querySpecification ----------------
pub type QuerySpecificationContextAll<'input> = QuerySpecificationContext<'input>;


pub type QuerySpecificationContext<'input> = BaseParserRuleContext<'input,QuerySpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct QuerySpecificationContextExt<'input>{
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
	pub where_: Option<Rc<BooleanExpressionContextAll<'input>>>,
	pub having: Option<Rc<BooleanExpressionContextAll<'input>>>,
	pub qualify: Option<Rc<BooleanExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QuerySpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QuerySpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_querySpecification(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_querySpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QuerySpecificationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_querySpecification(self);
	}
}

impl<'input> CustomRuleContext<'input> for QuerySpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_querySpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_querySpecification }
}
antlr_rust::tid!{QuerySpecificationContextExt<'a>}

impl<'input> QuerySpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QuerySpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QuerySpecificationContextExt{
				COMMA: None, 
				tail: Vec::new(), 
				where_: None, having: None, qualify: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait QuerySpecificationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QuerySpecificationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SELECT
/// Returns `None` if there is no child corresponding to token SELECT
fn SELECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SELECT, 0)
}
fn querySelectItems(&self) -> Option<Rc<QuerySelectItemsContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token TOP
/// Returns `None` if there is no child corresponding to token TOP
fn TOP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TOP, 0)
}
fn number(&self) -> Option<Rc<NumberContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token FROM
/// Returns `None` if there is no child corresponding to token FROM
fn FROM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FROM, 0)
}
fn relation_all(&self) ->  Vec<Rc<RelationContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn relation(&self, i: usize) -> Option<Rc<RelationContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token WHERE
/// Returns `None` if there is no child corresponding to token WHERE
fn WHERE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WHERE, 0)
}
fn connectBy(&self) -> Option<Rc<ConnectByContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn aggregationClause(&self) -> Option<Rc<AggregationClauseContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token HAVING
/// Returns `None` if there is no child corresponding to token HAVING
fn HAVING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(HAVING, 0)
}
/// Retrieves first TerminalNode corresponding to token QUALIFY
/// Returns `None` if there is no child corresponding to token QUALIFY
fn QUALIFY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(QUALIFY, 0)
}
fn booleanExpression_all(&self) ->  Vec<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn booleanExpression(&self, i: usize) -> Option<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> QuerySpecificationContextAttrs<'input> for QuerySpecificationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn querySpecification(&mut self,)
	-> Result<Rc<QuerySpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QuerySpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 110, RULE_querySpecification);
        let mut _localctx: Rc<QuerySpecificationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2824);
			recog.base.match_token(SELECT,&mut recog.err_handler)?;

			recog.base.set_state(2827);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(408,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2825);
					recog.base.match_token(TOP,&mut recog.err_handler)?;

					/*InvokeRule number*/
					recog.base.set_state(2826);
					recog.number()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(2830);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ALL || _la==DISTINCT {
				{
				/*InvokeRule setQuantifier*/
				recog.base.set_state(2829);
				recog.setQuantifier()?;

				}
			}

			/*InvokeRule querySelectItems*/
			recog.base.set_state(2832);
			recog.querySelectItems()?;

			recog.base.set_state(2845);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==FROM {
				{
				recog.base.set_state(2833);
				recog.base.match_token(FROM,&mut recog.err_handler)?;

				/*InvokeRule relation*/
				recog.base.set_state(2834);
				recog.relation()?;

				recog.base.set_state(2839);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(410,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(2835);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule relation*/
						recog.base.set_state(2836);
						recog.relation()?;

						}
						} 
					}
					recog.base.set_state(2841);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(410,&mut recog.base)?;
				}
				recog.base.set_state(2843);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(411,&mut recog.base)? {
					x if x == 1=>{
						{
						recog.base.set_state(2842);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						 cast_mut::<_,QuerySpecificationContext >(&mut _localctx).COMMA = Some(tmp);
						  

						let temp =  cast_mut::<_,QuerySpecificationContext >(&mut _localctx).COMMA.clone().unwrap()
						 ;
						 cast_mut::<_,QuerySpecificationContext >(&mut _localctx).tail.push(temp);
						  
						}
					}

					_ => {}
				}
				}
			}

			recog.base.set_state(2849);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==WHERE {
				{
				recog.base.set_state(2847);
				recog.base.match_token(WHERE,&mut recog.err_handler)?;

				/*InvokeRule booleanExpression*/
				recog.base.set_state(2848);
				let tmp = recog.booleanExpression_rec(0)?;
				 cast_mut::<_,QuerySpecificationContext >(&mut _localctx).where_ = Some(tmp.clone());
				  

				}
			}

			recog.base.set_state(2852);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==CONNECT || _la==START {
				{
				/*InvokeRule connectBy*/
				recog.base.set_state(2851);
				recog.connectBy()?;

				}
			}

			recog.base.set_state(2855);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==GROUP {
				{
				/*InvokeRule aggregationClause*/
				recog.base.set_state(2854);
				recog.aggregationClause()?;

				}
			}

			recog.base.set_state(2859);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==HAVING {
				{
				recog.base.set_state(2857);
				recog.base.match_token(HAVING,&mut recog.err_handler)?;

				/*InvokeRule booleanExpression*/
				recog.base.set_state(2858);
				let tmp = recog.booleanExpression_rec(0)?;
				 cast_mut::<_,QuerySpecificationContext >(&mut _localctx).having = Some(tmp.clone());
				  

				}
			}

			recog.base.set_state(2863);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==QUALIFY {
				{
				recog.base.set_state(2861);
				recog.base.match_token(QUALIFY,&mut recog.err_handler)?;

				/*InvokeRule booleanExpression*/
				recog.base.set_state(2862);
				let tmp = recog.booleanExpression_rec(0)?;
				 cast_mut::<_,QuerySpecificationContext >(&mut _localctx).qualify = Some(tmp.clone());
				  

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- connectBy ----------------
pub type ConnectByContextAll<'input> = ConnectByContext<'input>;


pub type ConnectByContext<'input> = BaseParserRuleContext<'input,ConnectByContextExt<'input>>;

#[derive(Clone)]
pub struct ConnectByContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ConnectByContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ConnectByContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_connectBy(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_connectBy(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ConnectByContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_connectBy(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConnectByContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_connectBy }
	//fn type_rule_index() -> usize where Self: Sized { RULE_connectBy }
}
antlr_rust::tid!{ConnectByContextExt<'a>}

impl<'input> ConnectByContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConnectByContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConnectByContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ConnectByContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ConnectByContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CONNECT
/// Returns `None` if there is no child corresponding to token CONNECT
fn CONNECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONNECT, 0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn connectByItem_all(&self) ->  Vec<Rc<ConnectByItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn connectByItem(&self, i: usize) -> Option<Rc<ConnectByItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token START
/// Returns `None` if there is no child corresponding to token START
fn START(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(START, 0)
}
/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token AND in current rule
fn AND_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token AND, starting from 0.
/// Returns `None` if number of children corresponding to token AND is less or equal than `i`.
fn AND(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AND, i)
}

}

impl<'input> ConnectByContextAttrs<'input> for ConnectByContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn connectBy(&mut self,)
	-> Result<Rc<ConnectByContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConnectByContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 112, RULE_connectBy);
        let mut _localctx: Rc<ConnectByContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2868);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==START {
				{
				recog.base.set_state(2865);
				recog.base.match_token(START,&mut recog.err_handler)?;

				recog.base.set_state(2866);
				recog.base.match_token(WITH,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(2867);
				recog.expression()?;

				}
			}

			recog.base.set_state(2870);
			recog.base.match_token(CONNECT,&mut recog.err_handler)?;

			recog.base.set_state(2871);
			recog.base.match_token(BY,&mut recog.err_handler)?;

			/*InvokeRule connectByItem*/
			recog.base.set_state(2872);
			recog.connectByItem()?;

			recog.base.set_state(2877);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==AND {
				{
				{
				recog.base.set_state(2873);
				recog.base.match_token(AND,&mut recog.err_handler)?;

				/*InvokeRule connectByItem*/
				recog.base.set_state(2874);
				recog.connectByItem()?;

				}
				}
				recog.base.set_state(2879);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- replaceDefinition ----------------
pub type ReplaceDefinitionContextAll<'input> = ReplaceDefinitionContext<'input>;


pub type ReplaceDefinitionContext<'input> = BaseParserRuleContext<'input,ReplaceDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct ReplaceDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ReplaceDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ReplaceDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_replaceDefinition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_replaceDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ReplaceDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_replaceDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReplaceDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_replaceDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_replaceDefinition }
}
antlr_rust::tid!{ReplaceDefinitionContextExt<'a>}

impl<'input> ReplaceDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ReplaceDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ReplaceDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ReplaceDefinitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ReplaceDefinitionContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}

}

impl<'input> ReplaceDefinitionContextAttrs<'input> for ReplaceDefinitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn replaceDefinition(&mut self,)
	-> Result<Rc<ReplaceDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ReplaceDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 114, RULE_replaceDefinition);
        let mut _localctx: Rc<ReplaceDefinitionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(2880);
			recog.expression()?;

			recog.base.set_state(2882);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AS {
				{
				recog.base.set_state(2881);
				recog.base.match_token(AS,&mut recog.err_handler)?;

				}
			}

			/*InvokeRule identifier*/
			recog.base.set_state(2884);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- querySelectItems ----------------
pub type QuerySelectItemsContextAll<'input> = QuerySelectItemsContext<'input>;


pub type QuerySelectItemsContext<'input> = BaseParserRuleContext<'input,QuerySelectItemsContextExt<'input>>;

#[derive(Clone)]
pub struct QuerySelectItemsContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QuerySelectItemsContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QuerySelectItemsContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_querySelectItems(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_querySelectItems(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QuerySelectItemsContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_querySelectItems(self);
	}
}

impl<'input> CustomRuleContext<'input> for QuerySelectItemsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_querySelectItems }
	//fn type_rule_index() -> usize where Self: Sized { RULE_querySelectItems }
}
antlr_rust::tid!{QuerySelectItemsContextExt<'a>}

impl<'input> QuerySelectItemsContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QuerySelectItemsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QuerySelectItemsContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait QuerySelectItemsContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QuerySelectItemsContextExt<'input>>{

fn selectItem_all(&self) ->  Vec<Rc<SelectItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn selectItem(&self, i: usize) -> Option<Rc<SelectItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> QuerySelectItemsContextAttrs<'input> for QuerySelectItemsContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn querySelectItems(&mut self,)
	-> Result<Rc<QuerySelectItemsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QuerySelectItemsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 116, RULE_querySelectItems);
        let mut _localctx: Rc<QuerySelectItemsContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule selectItem*/
			recog.base.set_state(2886);
			recog.selectItem()?;

			recog.base.set_state(2891);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(421,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(2887);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule selectItem*/
					recog.base.set_state(2888);
					recog.selectItem()?;

					}
					} 
				}
				recog.base.set_state(2893);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(421,&mut recog.base)?;
			}
			recog.base.set_state(2895);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(422,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(2894);
					let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
					 cast_mut::<_,QuerySelectItemsContext >(&mut _localctx).tail = Some(tmp);
					  

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aggregationClause ----------------
pub type AggregationClauseContextAll<'input> = AggregationClauseContext<'input>;


pub type AggregationClauseContext<'input> = BaseParserRuleContext<'input,AggregationClauseContextExt<'input>>;

#[derive(Clone)]
pub struct AggregationClauseContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for AggregationClauseContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AggregationClauseContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aggregationClause(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_aggregationClause(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AggregationClauseContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_aggregationClause(self);
	}
}

impl<'input> CustomRuleContext<'input> for AggregationClauseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aggregationClause }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aggregationClause }
}
antlr_rust::tid!{AggregationClauseContextExt<'a>}

impl<'input> AggregationClauseContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AggregationClauseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AggregationClauseContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AggregationClauseContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<AggregationClauseContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token GROUP
/// Returns `None` if there is no child corresponding to token GROUP
fn GROUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GROUP, 0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn groupBy(&self) -> Option<Rc<GroupByContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AggregationClauseContextAttrs<'input> for AggregationClauseContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aggregationClause(&mut self,)
	-> Result<Rc<AggregationClauseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AggregationClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 118, RULE_aggregationClause);
        let mut _localctx: Rc<AggregationClauseContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2897);
			recog.base.match_token(GROUP,&mut recog.err_handler)?;

			recog.base.set_state(2898);
			recog.base.match_token(BY,&mut recog.err_handler)?;

			/*InvokeRule groupBy*/
			recog.base.set_state(2899);
			recog.groupBy()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- groupBy ----------------
#[derive(Debug)]
pub enum GroupByContextAll<'input>{
	GroupByAllContext(GroupByAllContext<'input>),
	GroupByDefaultContext(GroupByDefaultContext<'input>),
Error(GroupByContext<'input>)
}
antlr_rust::tid!{GroupByContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for GroupByContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for GroupByContextAll<'input>{}

impl<'input> Deref for GroupByContextAll<'input>{
	type Target = dyn GroupByContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use GroupByContextAll::*;
		match self{
			GroupByAllContext(inner) => inner,
			GroupByDefaultContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for GroupByContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for GroupByContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type GroupByContext<'input> = BaseParserRuleContext<'input,GroupByContextExt<'input>>;

#[derive(Clone)]
pub struct GroupByContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for GroupByContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for GroupByContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for GroupByContext<'input>{
}

impl<'input> CustomRuleContext<'input> for GroupByContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_groupBy }
	//fn type_rule_index() -> usize where Self: Sized { RULE_groupBy }
}
antlr_rust::tid!{GroupByContextExt<'a>}

impl<'input> GroupByContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<GroupByContextAll<'input>> {
		Rc::new(
		GroupByContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,GroupByContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait GroupByContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<GroupByContextExt<'input>>{


}

impl<'input> GroupByContextAttrs<'input> for GroupByContext<'input>{}

pub type GroupByAllContext<'input> = BaseParserRuleContext<'input,GroupByAllContextExt<'input>>;

pub trait GroupByAllContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ALL
	/// Returns `None` if there is no child corresponding to token ALL
	fn ALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALL, 0)
	}
}

impl<'input> GroupByAllContextAttrs<'input> for GroupByAllContext<'input>{}

pub struct GroupByAllContextExt<'input>{
	base:GroupByContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{GroupByAllContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for GroupByAllContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for GroupByAllContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_groupByAll(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_groupByAll(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for GroupByAllContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_groupByAll(self);
	}
}

impl<'input> CustomRuleContext<'input> for GroupByAllContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_groupBy }
	//fn type_rule_index() -> usize where Self: Sized { RULE_groupBy }
}

impl<'input> Borrow<GroupByContextExt<'input>> for GroupByAllContext<'input>{
	fn borrow(&self) -> &GroupByContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<GroupByContextExt<'input>> for GroupByAllContext<'input>{
	fn borrow_mut(&mut self) -> &mut GroupByContextExt<'input> { &mut self.base }
}

impl<'input> GroupByContextAttrs<'input> for GroupByAllContext<'input> {}

impl<'input> GroupByAllContextExt<'input>{
	fn new(ctx: &dyn GroupByContextAttrs<'input>) -> Rc<GroupByContextAll<'input>>  {
		Rc::new(
			GroupByContextAll::GroupByAllContext(
				BaseParserRuleContext::copy_from(ctx,GroupByAllContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type GroupByDefaultContext<'input> = BaseParserRuleContext<'input,GroupByDefaultContextExt<'input>>;

pub trait GroupByDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn groupingElement_all(&self) ->  Vec<Rc<GroupingElementContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn groupingElement(&self, i: usize) -> Option<Rc<GroupingElementContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> GroupByDefaultContextAttrs<'input> for GroupByDefaultContext<'input>{}

pub struct GroupByDefaultContextExt<'input>{
	base:GroupByContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{GroupByDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for GroupByDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for GroupByDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_groupByDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_groupByDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for GroupByDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_groupByDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for GroupByDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_groupBy }
	//fn type_rule_index() -> usize where Self: Sized { RULE_groupBy }
}

impl<'input> Borrow<GroupByContextExt<'input>> for GroupByDefaultContext<'input>{
	fn borrow(&self) -> &GroupByContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<GroupByContextExt<'input>> for GroupByDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut GroupByContextExt<'input> { &mut self.base }
}

impl<'input> GroupByContextAttrs<'input> for GroupByDefaultContext<'input> {}

impl<'input> GroupByDefaultContextExt<'input>{
	fn new(ctx: &dyn GroupByContextAttrs<'input>) -> Rc<GroupByContextAll<'input>>  {
		Rc::new(
			GroupByContextAll::GroupByDefaultContext(
				BaseParserRuleContext::copy_from(ctx,GroupByDefaultContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn groupBy(&mut self,)
	-> Result<Rc<GroupByContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = GroupByContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 120, RULE_groupBy);
        let mut _localctx: Rc<GroupByContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(2916);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(426,&mut recog.base)? {
				1 =>{
					let tmp = GroupByAllContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(2901);
					recog.base.match_token(ALL,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = GroupByDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(2903);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ALL || _la==DISTINCT {
						{
						/*InvokeRule setQuantifier*/
						recog.base.set_state(2902);
						recog.setQuantifier()?;

						}
					}

					/*InvokeRule groupingElement*/
					recog.base.set_state(2905);
					recog.groupingElement()?;

					recog.base.set_state(2910);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(424,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2906);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule groupingElement*/
							recog.base.set_state(2907);
							recog.groupingElement()?;

							}
							} 
						}
						recog.base.set_state(2912);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(424,&mut recog.base)?;
					}
					recog.base.set_state(2914);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(425,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(2913);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let GroupByContextAll::GroupByDefaultContext(ctx) = cast_mut::<_,GroupByContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- groupingElement ----------------
#[derive(Debug)]
pub enum GroupingElementContextAll<'input>{
	MultipleGroupingSetsContext(MultipleGroupingSetsContext<'input>),
	SingleGroupingSetContext(SingleGroupingSetContext<'input>),
	CubeContext(CubeContext<'input>),
	RollupContext(RollupContext<'input>),
Error(GroupingElementContext<'input>)
}
antlr_rust::tid!{GroupingElementContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for GroupingElementContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for GroupingElementContextAll<'input>{}

impl<'input> Deref for GroupingElementContextAll<'input>{
	type Target = dyn GroupingElementContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use GroupingElementContextAll::*;
		match self{
			MultipleGroupingSetsContext(inner) => inner,
			SingleGroupingSetContext(inner) => inner,
			CubeContext(inner) => inner,
			RollupContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for GroupingElementContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for GroupingElementContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type GroupingElementContext<'input> = BaseParserRuleContext<'input,GroupingElementContextExt<'input>>;

#[derive(Clone)]
pub struct GroupingElementContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for GroupingElementContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for GroupingElementContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for GroupingElementContext<'input>{
}

impl<'input> CustomRuleContext<'input> for GroupingElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_groupingElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}
antlr_rust::tid!{GroupingElementContextExt<'a>}

impl<'input> GroupingElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<GroupingElementContextAll<'input>> {
		Rc::new(
		GroupingElementContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,GroupingElementContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait GroupingElementContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<GroupingElementContextExt<'input>>{


}

impl<'input> GroupingElementContextAttrs<'input> for GroupingElementContext<'input>{}

pub type MultipleGroupingSetsContext<'input> = BaseParserRuleContext<'input,MultipleGroupingSetsContextExt<'input>>;

pub trait MultipleGroupingSetsContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token GROUPING
	/// Returns `None` if there is no child corresponding to token GROUPING
	fn GROUPING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GROUPING, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SETS
	/// Returns `None` if there is no child corresponding to token SETS
	fn SETS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SETS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn groupingSet_all(&self) ->  Vec<Rc<GroupingSetContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn groupingSet(&self, i: usize) -> Option<Rc<GroupingSetContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> MultipleGroupingSetsContextAttrs<'input> for MultipleGroupingSetsContext<'input>{}

pub struct MultipleGroupingSetsContextExt<'input>{
	base:GroupingElementContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{MultipleGroupingSetsContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for MultipleGroupingSetsContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for MultipleGroupingSetsContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_multipleGroupingSets(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_multipleGroupingSets(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for MultipleGroupingSetsContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_multipleGroupingSets(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultipleGroupingSetsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_groupingElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}

impl<'input> Borrow<GroupingElementContextExt<'input>> for MultipleGroupingSetsContext<'input>{
	fn borrow(&self) -> &GroupingElementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<GroupingElementContextExt<'input>> for MultipleGroupingSetsContext<'input>{
	fn borrow_mut(&mut self) -> &mut GroupingElementContextExt<'input> { &mut self.base }
}

impl<'input> GroupingElementContextAttrs<'input> for MultipleGroupingSetsContext<'input> {}

impl<'input> MultipleGroupingSetsContextExt<'input>{
	fn new(ctx: &dyn GroupingElementContextAttrs<'input>) -> Rc<GroupingElementContextAll<'input>>  {
		Rc::new(
			GroupingElementContextAll::MultipleGroupingSetsContext(
				BaseParserRuleContext::copy_from(ctx,MultipleGroupingSetsContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SingleGroupingSetContext<'input> = BaseParserRuleContext<'input,SingleGroupingSetContextExt<'input>>;

pub trait SingleGroupingSetContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn groupingSet(&self) -> Option<Rc<GroupingSetContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SingleGroupingSetContextAttrs<'input> for SingleGroupingSetContext<'input>{}

pub struct SingleGroupingSetContextExt<'input>{
	base:GroupingElementContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SingleGroupingSetContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SingleGroupingSetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SingleGroupingSetContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_singleGroupingSet(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_singleGroupingSet(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SingleGroupingSetContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_singleGroupingSet(self);
	}
}

impl<'input> CustomRuleContext<'input> for SingleGroupingSetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_groupingElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}

impl<'input> Borrow<GroupingElementContextExt<'input>> for SingleGroupingSetContext<'input>{
	fn borrow(&self) -> &GroupingElementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<GroupingElementContextExt<'input>> for SingleGroupingSetContext<'input>{
	fn borrow_mut(&mut self) -> &mut GroupingElementContextExt<'input> { &mut self.base }
}

impl<'input> GroupingElementContextAttrs<'input> for SingleGroupingSetContext<'input> {}

impl<'input> SingleGroupingSetContextExt<'input>{
	fn new(ctx: &dyn GroupingElementContextAttrs<'input>) -> Rc<GroupingElementContextAll<'input>>  {
		Rc::new(
			GroupingElementContextAll::SingleGroupingSetContext(
				BaseParserRuleContext::copy_from(ctx,SingleGroupingSetContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CubeContext<'input> = BaseParserRuleContext<'input,CubeContextExt<'input>>;

pub trait CubeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CUBE
	/// Returns `None` if there is no child corresponding to token CUBE
	fn CUBE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CUBE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> CubeContextAttrs<'input> for CubeContext<'input>{}

pub struct CubeContextExt<'input>{
	base:GroupingElementContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CubeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CubeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CubeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_cube(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_cube(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CubeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_cube(self);
	}
}

impl<'input> CustomRuleContext<'input> for CubeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_groupingElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}

impl<'input> Borrow<GroupingElementContextExt<'input>> for CubeContext<'input>{
	fn borrow(&self) -> &GroupingElementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<GroupingElementContextExt<'input>> for CubeContext<'input>{
	fn borrow_mut(&mut self) -> &mut GroupingElementContextExt<'input> { &mut self.base }
}

impl<'input> GroupingElementContextAttrs<'input> for CubeContext<'input> {}

impl<'input> CubeContextExt<'input>{
	fn new(ctx: &dyn GroupingElementContextAttrs<'input>) -> Rc<GroupingElementContextAll<'input>>  {
		Rc::new(
			GroupingElementContextAll::CubeContext(
				BaseParserRuleContext::copy_from(ctx,CubeContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RollupContext<'input> = BaseParserRuleContext<'input,RollupContextExt<'input>>;

pub trait RollupContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ROLLUP
	/// Returns `None` if there is no child corresponding to token ROLLUP
	fn ROLLUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ROLLUP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> RollupContextAttrs<'input> for RollupContext<'input>{}

pub struct RollupContextExt<'input>{
	base:GroupingElementContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RollupContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RollupContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RollupContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rollup(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_rollup(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RollupContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rollup(self);
	}
}

impl<'input> CustomRuleContext<'input> for RollupContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_groupingElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_groupingElement }
}

impl<'input> Borrow<GroupingElementContextExt<'input>> for RollupContext<'input>{
	fn borrow(&self) -> &GroupingElementContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<GroupingElementContextExt<'input>> for RollupContext<'input>{
	fn borrow_mut(&mut self) -> &mut GroupingElementContextExt<'input> { &mut self.base }
}

impl<'input> GroupingElementContextAttrs<'input> for RollupContext<'input> {}

impl<'input> RollupContextExt<'input>{
	fn new(ctx: &dyn GroupingElementContextAttrs<'input>) -> Rc<GroupingElementContextAll<'input>>  {
		Rc::new(
			GroupingElementContextAll::RollupContext(
				BaseParserRuleContext::copy_from(ctx,RollupContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn groupingElement(&mut self,)
	-> Result<Rc<GroupingElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = GroupingElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 122, RULE_groupingElement);
        let mut _localctx: Rc<GroupingElementContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(2967);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(435,&mut recog.base)? {
				1 =>{
					let tmp = RollupContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(2918);
					recog.base.match_token(ROLLUP,&mut recog.err_handler)?;

					recog.base.set_state(2919);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2931);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOT - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
						{
						/*InvokeRule expression*/
						recog.base.set_state(2920);
						recog.expression()?;

						recog.base.set_state(2925);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(427,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(2921);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(2922);
								recog.expression()?;

								}
								} 
							}
							recog.base.set_state(2927);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(427,&mut recog.base)?;
						}
						recog.base.set_state(2929);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(2928);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let GroupingElementContextAll::RollupContext(ctx) = cast_mut::<_,GroupingElementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(2933);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = CubeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(2934);
					recog.base.match_token(CUBE,&mut recog.err_handler)?;

					recog.base.set_state(2935);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2947);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOT - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
						{
						/*InvokeRule expression*/
						recog.base.set_state(2936);
						recog.expression()?;

						recog.base.set_state(2941);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(430,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(2937);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(2938);
								recog.expression()?;

								}
								} 
							}
							recog.base.set_state(2943);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(430,&mut recog.base)?;
						}
						recog.base.set_state(2945);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(2944);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let GroupingElementContextAll::CubeContext(ctx) = cast_mut::<_,GroupingElementContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(2949);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					let tmp = MultipleGroupingSetsContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(2950);
					recog.base.match_token(GROUPING,&mut recog.err_handler)?;

					recog.base.set_state(2951);
					recog.base.match_token(SETS,&mut recog.err_handler)?;

					recog.base.set_state(2952);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule groupingSet*/
					recog.base.set_state(2953);
					recog.groupingSet()?;

					recog.base.set_state(2958);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(433,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(2954);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule groupingSet*/
							recog.base.set_state(2955);
							recog.groupingSet()?;

							}
							} 
						}
						recog.base.set_state(2960);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(433,&mut recog.base)?;
					}
					recog.base.set_state(2962);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(2961);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let GroupingElementContextAll::MultipleGroupingSetsContext(ctx) = cast_mut::<_,GroupingElementContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(2964);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					let tmp = SingleGroupingSetContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					/*InvokeRule groupingSet*/
					recog.base.set_state(2966);
					recog.groupingSet()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- groupingSet ----------------
pub type GroupingSetContextAll<'input> = GroupingSetContext<'input>;


pub type GroupingSetContext<'input> = BaseParserRuleContext<'input,GroupingSetContextExt<'input>>;

#[derive(Clone)]
pub struct GroupingSetContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for GroupingSetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for GroupingSetContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_groupingSet(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_groupingSet(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for GroupingSetContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_groupingSet(self);
	}
}

impl<'input> CustomRuleContext<'input> for GroupingSetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_groupingSet }
	//fn type_rule_index() -> usize where Self: Sized { RULE_groupingSet }
}
antlr_rust::tid!{GroupingSetContextExt<'a>}

impl<'input> GroupingSetContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<GroupingSetContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,GroupingSetContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait GroupingSetContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<GroupingSetContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> GroupingSetContextAttrs<'input> for GroupingSetContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn groupingSet(&mut self,)
	-> Result<Rc<GroupingSetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = GroupingSetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 124, RULE_groupingSet);
        let mut _localctx: Rc<GroupingSetContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(2985);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(439,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(2969);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(2978);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOT - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
						{
						/*InvokeRule expression*/
						recog.base.set_state(2970);
						recog.expression()?;

						recog.base.set_state(2975);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(436,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(2971);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(2972);
								recog.expression()?;

								}
								} 
							}
							recog.base.set_state(2977);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(436,&mut recog.base)?;
						}
						}
					}

					recog.base.set_state(2981);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(2980);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						 cast_mut::<_,GroupingSetContext >(&mut _localctx).tail = Some(tmp);
						  

						}
					}

					recog.base.set_state(2983);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule expression*/
					recog.base.set_state(2984);
					recog.expression()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- windowDefinition ----------------
pub type WindowDefinitionContextAll<'input> = WindowDefinitionContext<'input>;


pub type WindowDefinitionContext<'input> = BaseParserRuleContext<'input,WindowDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct WindowDefinitionContextExt<'input>{
	pub name: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for WindowDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for WindowDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_windowDefinition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_windowDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for WindowDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_windowDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for WindowDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_windowDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_windowDefinition }
}
antlr_rust::tid!{WindowDefinitionContextExt<'a>}

impl<'input> WindowDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WindowDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WindowDefinitionContextExt{
				name: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait WindowDefinitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<WindowDefinitionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn windowSpecification(&self) -> Option<Rc<WindowSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WindowDefinitionContextAttrs<'input> for WindowDefinitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn windowDefinition(&mut self,)
	-> Result<Rc<WindowDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WindowDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 126, RULE_windowDefinition);
        let mut _localctx: Rc<WindowDefinitionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(2987);
			let tmp = recog.identifier()?;
			 cast_mut::<_,WindowDefinitionContext >(&mut _localctx).name = Some(tmp.clone());
			  

			recog.base.set_state(2988);
			recog.base.match_token(AS,&mut recog.err_handler)?;

			recog.base.set_state(2989);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule windowSpecification*/
			recog.base.set_state(2990);
			recog.windowSpecification()?;

			recog.base.set_state(2991);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- windowSpecification ----------------
pub type WindowSpecificationContextAll<'input> = WindowSpecificationContext<'input>;


pub type WindowSpecificationContext<'input> = BaseParserRuleContext<'input,WindowSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct WindowSpecificationContextExt<'input>{
	pub existingWindowName: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for WindowSpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for WindowSpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_windowSpecification(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_windowSpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for WindowSpecificationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_windowSpecification(self);
	}
}

impl<'input> CustomRuleContext<'input> for WindowSpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_windowSpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_windowSpecification }
}
antlr_rust::tid!{WindowSpecificationContextExt<'a>}

impl<'input> WindowSpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WindowSpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WindowSpecificationContextExt{
				existingWindowName: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait WindowSpecificationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<WindowSpecificationContextExt<'input>>{

fn windowSpecificationPartitionBy(&self) -> Option<Rc<WindowSpecificationPartitionByContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn orderBy(&self) -> Option<Rc<OrderByContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn windowFrame(&self) -> Option<Rc<WindowFrameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> WindowSpecificationContextAttrs<'input> for WindowSpecificationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn windowSpecification(&mut self,)
	-> Result<Rc<WindowSpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WindowSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 128, RULE_windowSpecification);
        let mut _localctx: Rc<WindowSpecificationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(2994);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(440,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule identifier*/
					recog.base.set_state(2993);
					let tmp = recog.identifier()?;
					 cast_mut::<_,WindowSpecificationContext >(&mut _localctx).existingWindowName = Some(tmp.clone());
					  

					}
				}

				_ => {}
			}
			recog.base.set_state(2997);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==PARTITION {
				{
				/*InvokeRule windowSpecificationPartitionBy*/
				recog.base.set_state(2996);
				recog.windowSpecificationPartitionBy()?;

				}
			}

			recog.base.set_state(3000);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ORDER {
				{
				/*InvokeRule orderBy*/
				recog.base.set_state(2999);
				recog.orderBy()?;

				}
			}

			recog.base.set_state(3003);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==GROUPS || _la==MEASURES || _la==RANGE || _la==ROWS {
				{
				/*InvokeRule windowFrame*/
				recog.base.set_state(3002);
				recog.windowFrame()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- windowSpecificationPartitionBy ----------------
pub type WindowSpecificationPartitionByContextAll<'input> = WindowSpecificationPartitionByContext<'input>;


pub type WindowSpecificationPartitionByContext<'input> = BaseParserRuleContext<'input,WindowSpecificationPartitionByContextExt<'input>>;

#[derive(Clone)]
pub struct WindowSpecificationPartitionByContextExt<'input>{
	pub expression: Option<Rc<ExpressionContextAll<'input>>>,
	pub partition:Vec<Rc<ExpressionContextAll<'input>>>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for WindowSpecificationPartitionByContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for WindowSpecificationPartitionByContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_windowSpecificationPartitionBy(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_windowSpecificationPartitionBy(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for WindowSpecificationPartitionByContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_windowSpecificationPartitionBy(self);
	}
}

impl<'input> CustomRuleContext<'input> for WindowSpecificationPartitionByContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_windowSpecificationPartitionBy }
	//fn type_rule_index() -> usize where Self: Sized { RULE_windowSpecificationPartitionBy }
}
antlr_rust::tid!{WindowSpecificationPartitionByContextExt<'a>}

impl<'input> WindowSpecificationPartitionByContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WindowSpecificationPartitionByContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WindowSpecificationPartitionByContextExt{
				COMMA: None, 
				tail: Vec::new(), 
				expression: None, 
				partition: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait WindowSpecificationPartitionByContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<WindowSpecificationPartitionByContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token PARTITION
/// Returns `None` if there is no child corresponding to token PARTITION
fn PARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITION, 0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> WindowSpecificationPartitionByContextAttrs<'input> for WindowSpecificationPartitionByContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn windowSpecificationPartitionBy(&mut self,)
	-> Result<Rc<WindowSpecificationPartitionByContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WindowSpecificationPartitionByContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 130, RULE_windowSpecificationPartitionBy);
        let mut _localctx: Rc<WindowSpecificationPartitionByContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3005);
			recog.base.match_token(PARTITION,&mut recog.err_handler)?;

			recog.base.set_state(3006);
			recog.base.match_token(BY,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(3007);
			let tmp = recog.expression()?;
			 cast_mut::<_,WindowSpecificationPartitionByContext >(&mut _localctx).expression = Some(tmp.clone());
			  

			let temp =  cast_mut::<_,WindowSpecificationPartitionByContext >(&mut _localctx).expression.clone().unwrap()
			 ;
			 cast_mut::<_,WindowSpecificationPartitionByContext >(&mut _localctx).partition.push(temp);
			  
			recog.base.set_state(3012);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(444,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3008);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(3009);
					let tmp = recog.expression()?;
					 cast_mut::<_,WindowSpecificationPartitionByContext >(&mut _localctx).expression = Some(tmp.clone());
					  

					let temp =  cast_mut::<_,WindowSpecificationPartitionByContext >(&mut _localctx).expression.clone().unwrap()
					 ;
					 cast_mut::<_,WindowSpecificationPartitionByContext >(&mut _localctx).partition.push(temp);
					  
					}
					} 
				}
				recog.base.set_state(3014);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(444,&mut recog.base)?;
			}
			recog.base.set_state(3016);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(3015);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,WindowSpecificationPartitionByContext >(&mut _localctx).COMMA = Some(tmp);
				  

				let temp =  cast_mut::<_,WindowSpecificationPartitionByContext >(&mut _localctx).COMMA.clone().unwrap()
				 ;
				 cast_mut::<_,WindowSpecificationPartitionByContext >(&mut _localctx).tail.push(temp);
				  
				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- orderBy ----------------
pub type OrderByContextAll<'input> = OrderByContext<'input>;


pub type OrderByContext<'input> = BaseParserRuleContext<'input,OrderByContextExt<'input>>;

#[derive(Clone)]
pub struct OrderByContextExt<'input>{
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for OrderByContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for OrderByContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_orderBy(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_orderBy(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for OrderByContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_orderBy(self);
	}
}

impl<'input> CustomRuleContext<'input> for OrderByContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_orderBy }
	//fn type_rule_index() -> usize where Self: Sized { RULE_orderBy }
}
antlr_rust::tid!{OrderByContextExt<'a>}

impl<'input> OrderByContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OrderByContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OrderByContextExt{
				COMMA: None, 
				tail: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait OrderByContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<OrderByContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ORDER
/// Returns `None` if there is no child corresponding to token ORDER
fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ORDER, 0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn sortItem_all(&self) ->  Vec<Rc<SortItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> OrderByContextAttrs<'input> for OrderByContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn orderBy(&mut self,)
	-> Result<Rc<OrderByContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OrderByContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 132, RULE_orderBy);
        let mut _localctx: Rc<OrderByContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3018);
			recog.base.match_token(ORDER,&mut recog.err_handler)?;

			recog.base.set_state(3019);
			recog.base.match_token(BY,&mut recog.err_handler)?;

			/*InvokeRule sortItem*/
			recog.base.set_state(3020);
			recog.sortItem()?;

			recog.base.set_state(3025);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(446,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3021);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule sortItem*/
					recog.base.set_state(3022);
					recog.sortItem()?;

					}
					} 
				}
				recog.base.set_state(3027);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(446,&mut recog.base)?;
			}
			recog.base.set_state(3029);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(447,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(3028);
					let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
					 cast_mut::<_,OrderByContext >(&mut _localctx).COMMA = Some(tmp);
					  

					let temp =  cast_mut::<_,OrderByContext >(&mut _localctx).COMMA.clone().unwrap()
					 ;
					 cast_mut::<_,OrderByContext >(&mut _localctx).tail.push(temp);
					  
					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- namedQuery ----------------
pub type NamedQueryContextAll<'input> = NamedQueryContext<'input>;


pub type NamedQueryContext<'input> = BaseParserRuleContext<'input,NamedQueryContextExt<'input>>;

#[derive(Clone)]
pub struct NamedQueryContextExt<'input>{
	pub name: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NamedQueryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NamedQueryContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_namedQuery(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_namedQuery(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NamedQueryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_namedQuery(self);
	}
}

impl<'input> CustomRuleContext<'input> for NamedQueryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_namedQuery }
	//fn type_rule_index() -> usize where Self: Sized { RULE_namedQuery }
}
antlr_rust::tid!{NamedQueryContextExt<'a>}

impl<'input> NamedQueryContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NamedQueryContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NamedQueryContextExt{
				name: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait NamedQueryContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NamedQueryContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NamedQueryContextAttrs<'input> for NamedQueryContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn namedQuery(&mut self,)
	-> Result<Rc<NamedQueryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NamedQueryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 134, RULE_namedQuery);
        let mut _localctx: Rc<NamedQueryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(3031);
			let tmp = recog.identifier()?;
			 cast_mut::<_,NamedQueryContext >(&mut _localctx).name = Some(tmp.clone());
			  

			recog.base.set_state(3033);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==LPAREN {
				{
				/*InvokeRule columnAliases*/
				recog.base.set_state(3032);
				recog.columnAliases()?;

				}
			}

			recog.base.set_state(3035);
			recog.base.match_token(AS,&mut recog.err_handler)?;

			recog.base.set_state(3036);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule query*/
			recog.base.set_state(3037);
			recog.query()?;

			recog.base.set_state(3038);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- selectItemAlias ----------------
pub type SelectItemAliasContextAll<'input> = SelectItemAliasContext<'input>;


pub type SelectItemAliasContext<'input> = BaseParserRuleContext<'input,SelectItemAliasContextExt<'input>>;

#[derive(Clone)]
pub struct SelectItemAliasContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SelectItemAliasContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SelectItemAliasContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_selectItemAlias(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_selectItemAlias(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SelectItemAliasContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_selectItemAlias(self);
	}
}

impl<'input> CustomRuleContext<'input> for SelectItemAliasContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_selectItemAlias }
	//fn type_rule_index() -> usize where Self: Sized { RULE_selectItemAlias }
}
antlr_rust::tid!{SelectItemAliasContextExt<'a>}

impl<'input> SelectItemAliasContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SelectItemAliasContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SelectItemAliasContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SelectItemAliasContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SelectItemAliasContextExt<'input>>{

fn columnName(&self) -> Option<Rc<ColumnNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SelectItemAliasContextAttrs<'input> for SelectItemAliasContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn selectItemAlias(&mut self,)
	-> Result<Rc<SelectItemAliasContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SelectItemAliasContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 136, RULE_selectItemAlias);
        let mut _localctx: Rc<SelectItemAliasContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule columnName*/
			recog.base.set_state(3040);
			recog.columnName()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- selectItem ----------------
#[derive(Debug)]
pub enum SelectItemContextAll<'input>{
	SelectSingleContext(SelectSingleContext<'input>),
	SelectMultiContext(SelectMultiContext<'input>),
Error(SelectItemContext<'input>)
}
antlr_rust::tid!{SelectItemContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for SelectItemContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for SelectItemContextAll<'input>{}

impl<'input> Deref for SelectItemContextAll<'input>{
	type Target = dyn SelectItemContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use SelectItemContextAll::*;
		match self{
			SelectSingleContext(inner) => inner,
			SelectMultiContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SelectItemContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SelectItemContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type SelectItemContext<'input> = BaseParserRuleContext<'input,SelectItemContextExt<'input>>;

#[derive(Clone)]
pub struct SelectItemContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SelectItemContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SelectItemContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SelectItemContext<'input>{
}

impl<'input> CustomRuleContext<'input> for SelectItemContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_selectItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_selectItem }
}
antlr_rust::tid!{SelectItemContextExt<'a>}

impl<'input> SelectItemContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SelectItemContextAll<'input>> {
		Rc::new(
		SelectItemContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SelectItemContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait SelectItemContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SelectItemContextExt<'input>>{


}

impl<'input> SelectItemContextAttrs<'input> for SelectItemContext<'input>{}

pub type SelectSingleContext<'input> = BaseParserRuleContext<'input,SelectSingleContextExt<'input>>;

pub trait SelectSingleContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token CONNECT_BY_ROOT
	/// Returns `None` if there is no child corresponding to token CONNECT_BY_ROOT
	fn CONNECT_BY_ROOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CONNECT_BY_ROOT, 0)
	}
	fn selectItemAlias(&self) -> Option<Rc<SelectItemAliasContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token OVER
	/// Returns `None` if there is no child corresponding to token OVER
	fn OVER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OVER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
}

impl<'input> SelectSingleContextAttrs<'input> for SelectSingleContext<'input>{}

pub struct SelectSingleContextExt<'input>{
	base:SelectItemContextExt<'input>,
	pub over_alias: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SelectSingleContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SelectSingleContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SelectSingleContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_selectSingle(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_selectSingle(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SelectSingleContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_selectSingle(self);
	}
}

impl<'input> CustomRuleContext<'input> for SelectSingleContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_selectItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_selectItem }
}

impl<'input> Borrow<SelectItemContextExt<'input>> for SelectSingleContext<'input>{
	fn borrow(&self) -> &SelectItemContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SelectItemContextExt<'input>> for SelectSingleContext<'input>{
	fn borrow_mut(&mut self) -> &mut SelectItemContextExt<'input> { &mut self.base }
}

impl<'input> SelectItemContextAttrs<'input> for SelectSingleContext<'input> {}

impl<'input> SelectSingleContextExt<'input>{
	fn new(ctx: &dyn SelectItemContextAttrs<'input>) -> Rc<SelectItemContextAll<'input>>  {
		Rc::new(
			SelectItemContextAll::SelectSingleContext(
				BaseParserRuleContext::copy_from(ctx,SelectSingleContextExt{
					over_alias:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SelectMultiContext<'input> = BaseParserRuleContext<'input,SelectMultiContextExt<'input>>;

pub trait SelectMultiContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn multiSelect(&self) -> Option<Rc<MultiSelectContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SelectMultiContextAttrs<'input> for SelectMultiContext<'input>{}

pub struct SelectMultiContextExt<'input>{
	base:SelectItemContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SelectMultiContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SelectMultiContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SelectMultiContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_selectMulti(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_selectMulti(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SelectMultiContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_selectMulti(self);
	}
}

impl<'input> CustomRuleContext<'input> for SelectMultiContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_selectItem }
	//fn type_rule_index() -> usize where Self: Sized { RULE_selectItem }
}

impl<'input> Borrow<SelectItemContextExt<'input>> for SelectMultiContext<'input>{
	fn borrow(&self) -> &SelectItemContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SelectItemContextExt<'input>> for SelectMultiContext<'input>{
	fn borrow_mut(&mut self) -> &mut SelectItemContextExt<'input> { &mut self.base }
}

impl<'input> SelectItemContextAttrs<'input> for SelectMultiContext<'input> {}

impl<'input> SelectMultiContextExt<'input>{
	fn new(ctx: &dyn SelectItemContextAttrs<'input>) -> Rc<SelectItemContextAll<'input>>  {
		Rc::new(
			SelectItemContextAll::SelectMultiContext(
				BaseParserRuleContext::copy_from(ctx,SelectMultiContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn selectItem(&mut self,)
	-> Result<Rc<SelectItemContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SelectItemContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 138, RULE_selectItem);
        let mut _localctx: Rc<SelectItemContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3054);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(452,&mut recog.base)? {
				1 =>{
					let tmp = SelectSingleContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(3043);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(449,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3042);
							recog.base.match_token(CONNECT_BY_ROOT,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					/*InvokeRule expression*/
					recog.base.set_state(3045);
					recog.expression()?;

					recog.base.set_state(3051);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(451,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3046);
							let tmp = recog.base.match_token(OVER,&mut recog.err_handler)?;
							if let SelectItemContextAll::SelectSingleContext(ctx) = cast_mut::<_,SelectItemContextAll >(&mut _localctx){
							ctx.over_alias = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						x if x == 2=>{
							{
							recog.base.set_state(3048);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==AS {
								{
								recog.base.set_state(3047);
								recog.base.match_token(AS,&mut recog.err_handler)?;

								}
							}

							/*InvokeRule selectItemAlias*/
							recog.base.set_state(3050);
							recog.selectItemAlias()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					let tmp = SelectMultiContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule multiSelect*/
					recog.base.set_state(3053);
					recog.multiSelect()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- multiSelect ----------------
pub type MultiSelectContextAll<'input> = MultiSelectContext<'input>;


pub type MultiSelectContext<'input> = BaseParserRuleContext<'input,MultiSelectContextExt<'input>>;

#[derive(Clone)]
pub struct MultiSelectContextExt<'input>{
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub from:Vec<Rc<IdentifierContextAll<'input>>>,
	pub to:Vec<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for MultiSelectContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for MultiSelectContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_multiSelect(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_multiSelect(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for MultiSelectContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_multiSelect(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiSelectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_multiSelect }
	//fn type_rule_index() -> usize where Self: Sized { RULE_multiSelect }
}
antlr_rust::tid!{MultiSelectContextExt<'a>}

impl<'input> MultiSelectContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MultiSelectContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MultiSelectContextExt{
				identifier: None, 
				from: Vec::new(), to: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait MultiSelectContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<MultiSelectContextExt<'input>>{

fn selectStar(&self) -> Option<Rc<SelectStarContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ILIKE
/// Returns `None` if there is no child corresponding to token ILIKE
fn ILIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ILIKE, 0)
}
fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EXCLUDE
/// Returns `None` if there is no child corresponding to token EXCLUDE
fn EXCLUDE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXCLUDE, 0)
}
/// Retrieves first TerminalNode corresponding to token REPLACE
/// Returns `None` if there is no child corresponding to token REPLACE
fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REPLACE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, i)
}
fn replaceDefinition_all(&self) ->  Vec<Rc<ReplaceDefinitionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn replaceDefinition(&self, i: usize) -> Option<Rc<ReplaceDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, i)
}
/// Retrieves first TerminalNode corresponding to token RENAME
/// Returns `None` if there is no child corresponding to token RENAME
fn RENAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RENAME, 0)
}
fn identifierList(&self) -> Option<Rc<IdentifierListContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifierSeq(&self) -> Option<Rc<IdentifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token AS in current rule
fn AS_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token AS, starting from 0.
/// Returns `None` if number of children corresponding to token AS is less or equal than `i`.
fn AS(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> MultiSelectContextAttrs<'input> for MultiSelectContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn multiSelect(&mut self,)
	-> Result<Rc<MultiSelectContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MultiSelectContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 140, RULE_multiSelect);
        let mut _localctx: Rc<MultiSelectContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule selectStar*/
			recog.base.set_state(3056);
			recog.selectStar()?;

			recog.base.set_state(3059);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ILIKE {
				{
				recog.base.set_state(3057);
				recog.base.match_token(ILIKE,&mut recog.err_handler)?;

				/*InvokeRule string*/
				recog.base.set_state(3058);
				recog.string()?;

				}
			}

			recog.base.set_state(3066);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==EXCLUDE {
				{
				recog.base.set_state(3061);
				recog.base.match_token(EXCLUDE,&mut recog.err_handler)?;

				recog.base.set_state(3064);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 LPAREN 
					=> {
						{
						/*InvokeRule identifierList*/
						recog.base.set_state(3062);
						recog.identifierList()?;

						}
					}

				 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
				 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
				 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
				 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
				 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
				 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
				 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
				 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
				 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
				 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
				 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE |
				 DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC |
				 EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE |
				 EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
				 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
				 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FULL |
				 FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS |
				 GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
				 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
				 INFORMATION | INITIAL | INITIALLY | INNER | INPUT | INPUTFORMAT | INTERLEAVED |
				 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JOIN | JSON |
				 JSON_ARRAY | JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP |
				 KEY | KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LATERAL |
				 LEADING | LEFT | LEVEL | LIBRARY | LIMIT | LINES | LISTAGG | LOCAL |
				 LOCATION | LOCK | LOGICAL | MAP | MASKING | MATCH | MATCHED | MATCHES |
				 MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES |
				 MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME |
				 NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER |
				 NORELY | NORMALIZE | NOVALIDATE | NULLS | OBJECT | OFFSET | OMIT | ONE |
				 ONLY | OPTION | OPTIONS | ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT |
				 OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED | PARTITIONS | PASSING |
				 PAST | PATH | PATTERN | PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD |
				 PERMUTE | PIVOT | PLACING | POLICY | POSITION | PRECEDING | PRECISION |
				 PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE |
				 PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE | REFERENCES |
				 REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT |
				 RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT | RLS | ROLE | ROLES |
				 ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS |
				 SECURE | SECURITY | SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES |
				 SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT |
				 SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED | STREAM | STRICT |
				 STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG |
				 TEMP | TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW | TIES |
				 TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION | TRANSIENT |
				 TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE | UNBOUNDED |
				 UNCOMMITTED | UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED | UNNEST |
				 UNPIVOT | UNSET | UNSIGNED | USE | USER | USING | UTF16 | UTF32 | UTF8 |
				 VACUUM | VALIDATE | VALUE | VARYING | VECTOR | VERBOSE | VERSION | VIEW |
				 VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN | WITHOUT | WORK | WRAPPER |
				 WRITE | XZ | YEAR | YES | ZONE | ZSTD | IDENTIFIER | QUOTED_IDENTIFIER |
				 BACKQUOTED_IDENTIFIER 
					=> {
						{
						/*InvokeRule identifierSeq*/
						recog.base.set_state(3063);
						recog.identifierSeq()?;

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
			}

			recog.base.set_state(3080);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==REPLACE {
				{
				recog.base.set_state(3068);
				recog.base.match_token(REPLACE,&mut recog.err_handler)?;

				recog.base.set_state(3069);
				recog.base.match_token(LPAREN,&mut recog.err_handler)?;

				/*InvokeRule replaceDefinition*/
				recog.base.set_state(3070);
				recog.replaceDefinition()?;

				recog.base.set_state(3075);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				while _la==COMMA {
					{
					{
					recog.base.set_state(3071);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule replaceDefinition*/
					recog.base.set_state(3072);
					recog.replaceDefinition()?;

					}
					}
					recog.base.set_state(3077);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
				}
				recog.base.set_state(3078);
				recog.base.match_token(RPAREN,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(3105);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==RENAME {
				{
				recog.base.set_state(3082);
				recog.base.match_token(RENAME,&mut recog.err_handler)?;

				recog.base.set_state(3103);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
				 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
				 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
				 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
				 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
				 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
				 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
				 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
				 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
				 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
				 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE |
				 DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC |
				 EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE |
				 EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
				 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
				 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FULL |
				 FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS |
				 GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
				 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
				 INFORMATION | INITIAL | INITIALLY | INNER | INPUT | INPUTFORMAT | INTERLEAVED |
				 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JOIN | JSON |
				 JSON_ARRAY | JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP |
				 KEY | KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LATERAL |
				 LEADING | LEFT | LEVEL | LIBRARY | LIMIT | LINES | LISTAGG | LOCAL |
				 LOCATION | LOCK | LOGICAL | MAP | MASKING | MATCH | MATCHED | MATCHES |
				 MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES |
				 MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME |
				 NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER |
				 NORELY | NORMALIZE | NOVALIDATE | NULLS | OBJECT | OFFSET | OMIT | ONE |
				 ONLY | OPTION | OPTIONS | ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT |
				 OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED | PARTITIONS | PASSING |
				 PAST | PATH | PATTERN | PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD |
				 PERMUTE | PIVOT | PLACING | POLICY | POSITION | PRECEDING | PRECISION |
				 PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE |
				 PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE | REFERENCES |
				 REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT |
				 RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT | RLS | ROLE | ROLES |
				 ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS |
				 SECURE | SECURITY | SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES |
				 SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT |
				 SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED | STREAM | STRICT |
				 STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG |
				 TEMP | TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW | TIES |
				 TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION | TRANSIENT |
				 TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE | UNBOUNDED |
				 UNCOMMITTED | UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED | UNNEST |
				 UNPIVOT | UNSET | UNSIGNED | USE | USER | USING | UTF16 | UTF32 | UTF8 |
				 VACUUM | VALIDATE | VALUE | VARYING | VECTOR | VERBOSE | VERSION | VIEW |
				 VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN | WITHOUT | WORK | WRAPPER |
				 WRITE | XZ | YEAR | YES | ZONE | ZSTD | IDENTIFIER | QUOTED_IDENTIFIER |
				 BACKQUOTED_IDENTIFIER 
					=> {
						{
						/*InvokeRule identifier*/
						recog.base.set_state(3083);
						let tmp = recog.identifier()?;
						 cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier = Some(tmp.clone());
						  

						let temp =  cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier.clone().unwrap()
						 ;
						 cast_mut::<_,MultiSelectContext >(&mut _localctx).from.push(temp);
						  
						recog.base.set_state(3084);
						recog.base.match_token(AS,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(3085);
						let tmp = recog.identifier()?;
						 cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier = Some(tmp.clone());
						  

						let temp =  cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier.clone().unwrap()
						 ;
						 cast_mut::<_,MultiSelectContext >(&mut _localctx).to.push(temp);
						  
						}
					}

				 LPAREN 
					=> {
						{
						recog.base.set_state(3087);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(3088);
						let tmp = recog.identifier()?;
						 cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier = Some(tmp.clone());
						  

						let temp =  cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier.clone().unwrap()
						 ;
						 cast_mut::<_,MultiSelectContext >(&mut _localctx).from.push(temp);
						  
						recog.base.set_state(3089);
						recog.base.match_token(AS,&mut recog.err_handler)?;

						/*InvokeRule identifier*/
						recog.base.set_state(3090);
						let tmp = recog.identifier()?;
						 cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier = Some(tmp.clone());
						  

						let temp =  cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier.clone().unwrap()
						 ;
						 cast_mut::<_,MultiSelectContext >(&mut _localctx).to.push(temp);
						  
						recog.base.set_state(3098);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(3091);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(3092);
							let tmp = recog.identifier()?;
							 cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier = Some(tmp.clone());
							  

							let temp =  cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier.clone().unwrap()
							 ;
							 cast_mut::<_,MultiSelectContext >(&mut _localctx).from.push(temp);
							  
							recog.base.set_state(3093);
							recog.base.match_token(AS,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(3094);
							let tmp = recog.identifier()?;
							 cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier = Some(tmp.clone());
							  

							let temp =  cast_mut::<_,MultiSelectContext >(&mut _localctx).identifier.clone().unwrap()
							 ;
							 cast_mut::<_,MultiSelectContext >(&mut _localctx).to.push(temp);
							  
							}
							}
							recog.base.set_state(3100);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						recog.base.set_state(3101);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- selectStar ----------------
pub type SelectStarContextAll<'input> = SelectStarContext<'input>;


pub type SelectStarContext<'input> = BaseParserRuleContext<'input,SelectStarContextExt<'input>>;

#[derive(Clone)]
pub struct SelectStarContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SelectStarContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SelectStarContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_selectStar(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_selectStar(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SelectStarContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_selectStar(self);
	}
}

impl<'input> CustomRuleContext<'input> for SelectStarContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_selectStar }
	//fn type_rule_index() -> usize where Self: Sized { RULE_selectStar }
}
antlr_rust::tid!{SelectStarContextExt<'a>}

impl<'input> SelectStarContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SelectStarContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SelectStarContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SelectStarContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SelectStarContextExt<'input>>{

fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
/// Retrieves first TerminalNode corresponding to token ASTERISK
/// Returns `None` if there is no child corresponding to token ASTERISK
fn ASTERISK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ASTERISK, 0)
}

}

impl<'input> SelectStarContextAttrs<'input> for SelectStarContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn selectStar(&mut self,)
	-> Result<Rc<SelectStarContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SelectStarContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 142, RULE_selectStar);
        let mut _localctx: Rc<SelectStarContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3112);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__2 | ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI |
			 APPEND_ONLY | ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH |
			 AUTHORIZATION | AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI |
			 BLOCK | BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE |
			 CASE_SENSITIVE | CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR |
			 CHARACTER | CLONE | CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT |
			 COMMITTED | COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
			 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
			 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
			 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
			 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
			 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC | EMPTY |
			 ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE | EVEN |
			 EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXISTS | EXPLAIN | EXTERNAL |
			 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
			 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FULL |
			 FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS |
			 GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
			 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
			 INFORMATION | INITIAL | INITIALLY | INNER | INPUT | INPUTFORMAT | INTERLEAVED |
			 INSERT | INTERVAL | INVOKER | IO | ISOLATION | ILIKE | JAVA | JAVASCRIPT |
			 JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE |
			 KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LATERAL |
			 LEADING | LEFT | LEVEL | LIBRARY | LIKE | LIMIT | LINES | LISTAGG | LOCAL |
			 LOCATION | LOCK | LOGICAL | MAP | MASKING | MATCH | MATCHED | MATCHES |
			 MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES | MEMORIZABLE |
			 MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME | NATURAL | NCHAR |
			 NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER | NORELY | NORMALIZE |
			 NOVALIDATE | NULL | NULLS | OBJECT | OFFSET | OMIT | ONE | ONLY | OPTION |
			 OPTIONS | ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW |
			 OWNER | PARTITION | PARTITIONED | PARTITIONS | PASSING | PAST | PATH |
			 PATTERN | PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE |
			 PIVOT | PLACING | POLICY | POSITION | PRECEDING | PRECISION | PREPARE |
			 PRIOR | PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON |
			 QUOTES | RANGE | READ | RECURSIVE | REGEXP | REFERENCE | REFERENCES |
			 REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT |
			 RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT | RLIKE | RLS | ROLE |
			 ROLES | ROLLBACK | ROLLUP | ROW | RUNNING | SCALA | SCALAR | SECOND |
			 SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI | SEQUENCE |
			 SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR |
			 SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED |
			 STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME |
			 TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW |
			 TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION |
			 TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE |
			 UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED |
			 UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER | USING | UTF16 | UTF32 |
			 UTF8 | VACUUM | VALIDATE | VALUE | VARYING | VECTOR | VERBOSE | VERSION |
			 VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN | WITHOUT | WORK |
			 WRAPPER | WRITE | XZ | YEAR | YES | ZONE | ZSTD | LPAREN | LBRACKET |
			 MINUS | DOLLAR | STRING | UNICODE_STRING | DOLLAR_QUOTED_STRING | BINARY_LITERAL |
			 INTEGER_VALUE | DECIMAL_VALUE | DOUBLE_VALUE | IDENTIFIER | QUOTED_IDENTIFIER |
			 BACKQUOTED_IDENTIFIER | VARIABLE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule primaryExpression*/
					recog.base.set_state(3107);
					recog.primaryExpression_rec(0)?;

					recog.base.set_state(3108);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					recog.base.set_state(3109);
					recog.base.match_token(ASTERISK,&mut recog.err_handler)?;

					}
				}

			 ASTERISK 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3111);
					recog.base.match_token(ASTERISK,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- relation ----------------
pub type RelationContextAll<'input> = RelationContext<'input>;


pub type RelationContext<'input> = BaseParserRuleContext<'input,RelationContextExt<'input>>;

#[derive(Clone)]
pub struct RelationContextExt<'input>{
	pub target: Option<Rc<JoinedRelationContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for RelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RelationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_relation(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_relation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_relation(self);
	}
}

impl<'input> CustomRuleContext<'input> for RelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relation }
}
antlr_rust::tid!{RelationContextExt<'a>}

impl<'input> RelationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RelationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RelationContextExt{
				target: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait RelationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<RelationContextExt<'input>>{

fn joinedRelation(&self) -> Option<Rc<JoinedRelationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RelationContextAttrs<'input> for RelationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn relation(&mut self,)
	-> Result<Rc<RelationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 144, RULE_relation);
        let mut _localctx: Rc<RelationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule joinedRelation*/
			recog.base.set_state(3114);
			let tmp = recog.joinedRelation_rec(0)?;
			 cast_mut::<_,RelationContext >(&mut _localctx).target = Some(tmp.clone());
			  

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- joinedRelation ----------------
#[derive(Debug)]
pub enum JoinedRelationContextAll<'input>{
	AsofJoinRelationContext(AsofJoinRelationContext<'input>),
	RelationDefaultContext(RelationDefaultContext<'input>),
	JoinRelationContext(JoinRelationContext<'input>),
Error(JoinedRelationContext<'input>)
}
antlr_rust::tid!{JoinedRelationContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for JoinedRelationContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for JoinedRelationContextAll<'input>{}

impl<'input> Deref for JoinedRelationContextAll<'input>{
	type Target = dyn JoinedRelationContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use JoinedRelationContextAll::*;
		match self{
			AsofJoinRelationContext(inner) => inner,
			RelationDefaultContext(inner) => inner,
			JoinRelationContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for JoinedRelationContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for JoinedRelationContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type JoinedRelationContext<'input> = BaseParserRuleContext<'input,JoinedRelationContextExt<'input>>;

#[derive(Clone)]
pub struct JoinedRelationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for JoinedRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for JoinedRelationContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for JoinedRelationContext<'input>{
}

impl<'input> CustomRuleContext<'input> for JoinedRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_joinedRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_joinedRelation }
}
antlr_rust::tid!{JoinedRelationContextExt<'a>}

impl<'input> JoinedRelationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<JoinedRelationContextAll<'input>> {
		Rc::new(
		JoinedRelationContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,JoinedRelationContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait JoinedRelationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<JoinedRelationContextExt<'input>>{


}

impl<'input> JoinedRelationContextAttrs<'input> for JoinedRelationContext<'input>{}

pub type AsofJoinRelationContext<'input> = BaseParserRuleContext<'input,AsofJoinRelationContextExt<'input>>;

pub trait AsofJoinRelationContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ASOF
	/// Returns `None` if there is no child corresponding to token ASOF
	fn ASOF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ASOF, 0)
	}
	/// Retrieves first TerminalNode corresponding to token JOIN
	/// Returns `None` if there is no child corresponding to token JOIN
	fn JOIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(JOIN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MATCH_CONDITION
	/// Returns `None` if there is no child corresponding to token MATCH_CONDITION
	fn MATCH_CONDITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MATCH_CONDITION, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn joinedRelation(&self) -> Option<Rc<JoinedRelationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn noJoinRelation(&self) -> Option<Rc<NoJoinRelationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn joinCriteria(&self) -> Option<Rc<JoinCriteriaContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> AsofJoinRelationContextAttrs<'input> for AsofJoinRelationContext<'input>{}

pub struct AsofJoinRelationContextExt<'input>{
	base:JoinedRelationContextExt<'input>,
	pub left: Option<Rc<JoinedRelationContextAll<'input>>>,
	pub right: Option<Rc<NoJoinRelationContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{AsofJoinRelationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for AsofJoinRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AsofJoinRelationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_asofJoinRelation(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_asofJoinRelation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AsofJoinRelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_asofJoinRelation(self);
	}
}

impl<'input> CustomRuleContext<'input> for AsofJoinRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_joinedRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_joinedRelation }
}

impl<'input> Borrow<JoinedRelationContextExt<'input>> for AsofJoinRelationContext<'input>{
	fn borrow(&self) -> &JoinedRelationContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<JoinedRelationContextExt<'input>> for AsofJoinRelationContext<'input>{
	fn borrow_mut(&mut self) -> &mut JoinedRelationContextExt<'input> { &mut self.base }
}

impl<'input> JoinedRelationContextAttrs<'input> for AsofJoinRelationContext<'input> {}

impl<'input> AsofJoinRelationContextExt<'input>{
	fn new(ctx: &dyn JoinedRelationContextAttrs<'input>) -> Rc<JoinedRelationContextAll<'input>>  {
		Rc::new(
			JoinedRelationContextAll::AsofJoinRelationContext(
				BaseParserRuleContext::copy_from(ctx,AsofJoinRelationContextExt{
        			left:None, right:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RelationDefaultContext<'input> = BaseParserRuleContext<'input,RelationDefaultContextExt<'input>>;

pub trait RelationDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn noJoinRelation(&self) -> Option<Rc<NoJoinRelationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> RelationDefaultContextAttrs<'input> for RelationDefaultContext<'input>{}

pub struct RelationDefaultContextExt<'input>{
	base:JoinedRelationContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RelationDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RelationDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RelationDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_relationDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_relationDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RelationDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_relationDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for RelationDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_joinedRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_joinedRelation }
}

impl<'input> Borrow<JoinedRelationContextExt<'input>> for RelationDefaultContext<'input>{
	fn borrow(&self) -> &JoinedRelationContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<JoinedRelationContextExt<'input>> for RelationDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut JoinedRelationContextExt<'input> { &mut self.base }
}

impl<'input> JoinedRelationContextAttrs<'input> for RelationDefaultContext<'input> {}

impl<'input> RelationDefaultContextExt<'input>{
	fn new(ctx: &dyn JoinedRelationContextAttrs<'input>) -> Rc<JoinedRelationContextAll<'input>>  {
		Rc::new(
			JoinedRelationContextAll::RelationDefaultContext(
				BaseParserRuleContext::copy_from(ctx,RelationDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type JoinRelationContext<'input> = BaseParserRuleContext<'input,JoinRelationContextExt<'input>>;

pub trait JoinRelationContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn joinedRelation_all(&self) ->  Vec<Rc<JoinedRelationContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn joinedRelation(&self, i: usize) -> Option<Rc<JoinedRelationContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token CROSS
	/// Returns `None` if there is no child corresponding to token CROSS
	fn CROSS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CROSS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token JOIN
	/// Returns `None` if there is no child corresponding to token JOIN
	fn JOIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(JOIN, 0)
	}
	fn joinType(&self) -> Option<Rc<JoinTypeContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token NATURAL
	/// Returns `None` if there is no child corresponding to token NATURAL
	fn NATURAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NATURAL, 0)
	}
	fn noJoinRelation(&self) -> Option<Rc<NoJoinRelationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn joinCriteria(&self) -> Option<Rc<JoinCriteriaContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> JoinRelationContextAttrs<'input> for JoinRelationContext<'input>{}

pub struct JoinRelationContextExt<'input>{
	base:JoinedRelationContextExt<'input>,
	pub left: Option<Rc<JoinedRelationContextAll<'input>>>,
	pub right: Option<Rc<NoJoinRelationContextAll<'input>>>,
	pub rightJoined: Option<Rc<JoinedRelationContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{JoinRelationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for JoinRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for JoinRelationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_joinRelation(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_joinRelation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for JoinRelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_joinRelation(self);
	}
}

impl<'input> CustomRuleContext<'input> for JoinRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_joinedRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_joinedRelation }
}

impl<'input> Borrow<JoinedRelationContextExt<'input>> for JoinRelationContext<'input>{
	fn borrow(&self) -> &JoinedRelationContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<JoinedRelationContextExt<'input>> for JoinRelationContext<'input>{
	fn borrow_mut(&mut self) -> &mut JoinedRelationContextExt<'input> { &mut self.base }
}

impl<'input> JoinedRelationContextAttrs<'input> for JoinRelationContext<'input> {}

impl<'input> JoinRelationContextExt<'input>{
	fn new(ctx: &dyn JoinedRelationContextAttrs<'input>) -> Rc<JoinedRelationContextAll<'input>>  {
		Rc::new(
			JoinedRelationContextAll::JoinRelationContext(
				BaseParserRuleContext::copy_from(ctx,JoinRelationContextExt{
        			left:None, right:None, rightJoined:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  joinedRelation(&mut self,)
	-> Result<Rc<JoinedRelationContextAll<'input>>,ANTLRError> {
		self.joinedRelation_rec(0)
	}

	fn joinedRelation_rec(&mut self, _p: isize)
	-> Result<Rc<JoinedRelationContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = JoinedRelationContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 146, RULE_joinedRelation, _p);
	    let mut _localctx: Rc<JoinedRelationContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 146;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			let mut tmp = RelationDefaultContextExt::new(&**_localctx);
			recog.ctx = Some(tmp.clone());
			_localctx = tmp;
			_prevctx = _localctx.clone();


			/*InvokeRule noJoinRelation*/
			recog.base.set_state(3117);
			recog.noJoinRelation()?;

			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(3155);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(467,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(3153);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(466,&mut recog.base)? {
						1 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = JoinRelationContextExt::new(&**JoinedRelationContextExt::new(_parentctx.clone(), _parentState));
							if let JoinedRelationContextAll::JoinRelationContext(ctx) = cast_mut::<_,JoinedRelationContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_joinedRelation);
							_localctx = tmp;
							recog.base.set_state(3119);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(3140);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(464,&mut recog.base)? {
								1 =>{
									{
									recog.base.set_state(3120);
									recog.base.match_token(CROSS,&mut recog.err_handler)?;

									recog.base.set_state(3121);
									recog.base.match_token(JOIN,&mut recog.err_handler)?;

									/*InvokeRule noJoinRelation*/
									recog.base.set_state(3122);
									let tmp = recog.noJoinRelation()?;
									if let JoinedRelationContextAll::JoinRelationContext(ctx) = cast_mut::<_,JoinedRelationContextAll >(&mut _localctx){
									ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									}
								}
							,
								2 =>{
									{
									/*InvokeRule joinType*/
									recog.base.set_state(3123);
									recog.joinType()?;

									recog.base.set_state(3124);
									recog.base.match_token(JOIN,&mut recog.err_handler)?;

									/*InvokeRule noJoinRelation*/
									recog.base.set_state(3125);
									let tmp = recog.noJoinRelation()?;
									if let JoinedRelationContextAll::JoinRelationContext(ctx) = cast_mut::<_,JoinedRelationContextAll >(&mut _localctx){
									ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									recog.base.set_state(3127);
									recog.err_handler.sync(&mut recog.base)?;
									match  recog.interpreter.adaptive_predict(462,&mut recog.base)? {
										x if x == 1=>{
											{
											/*InvokeRule joinCriteria*/
											recog.base.set_state(3126);
											recog.joinCriteria()?;

											}
										}

										_ => {}
									}
									}
								}
							,
								3 =>{
									{
									/*InvokeRule joinType*/
									recog.base.set_state(3129);
									recog.joinType()?;

									recog.base.set_state(3130);
									recog.base.match_token(JOIN,&mut recog.err_handler)?;

									/*InvokeRule joinedRelation*/
									recog.base.set_state(3131);
									let tmp = recog.joinedRelation_rec(0)?;
									if let JoinedRelationContextAll::JoinRelationContext(ctx) = cast_mut::<_,JoinedRelationContextAll >(&mut _localctx){
									ctx.rightJoined = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									recog.base.set_state(3133);
									recog.err_handler.sync(&mut recog.base)?;
									match  recog.interpreter.adaptive_predict(463,&mut recog.base)? {
										x if x == 1=>{
											{
											/*InvokeRule joinCriteria*/
											recog.base.set_state(3132);
											recog.joinCriteria()?;

											}
										}

										_ => {}
									}
									}
								}
							,
								4 =>{
									{
									recog.base.set_state(3135);
									recog.base.match_token(NATURAL,&mut recog.err_handler)?;

									/*InvokeRule joinType*/
									recog.base.set_state(3136);
									recog.joinType()?;

									recog.base.set_state(3137);
									recog.base.match_token(JOIN,&mut recog.err_handler)?;

									/*InvokeRule noJoinRelation*/
									recog.base.set_state(3138);
									let tmp = recog.noJoinRelation()?;
									if let JoinedRelationContextAll::JoinRelationContext(ctx) = cast_mut::<_,JoinedRelationContextAll >(&mut _localctx){
									ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									}
								}

								_ => {}
							}
							}
						}
					,
						2 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = AsofJoinRelationContextExt::new(&**JoinedRelationContextExt::new(_parentctx.clone(), _parentState));
							if let JoinedRelationContextAll::AsofJoinRelationContext(ctx) = cast_mut::<_,JoinedRelationContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_joinedRelation);
							_localctx = tmp;
							recog.base.set_state(3142);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(3143);
							recog.base.match_token(ASOF,&mut recog.err_handler)?;

							recog.base.set_state(3144);
							recog.base.match_token(JOIN,&mut recog.err_handler)?;

							/*InvokeRule noJoinRelation*/
							recog.base.set_state(3145);
							let tmp = recog.noJoinRelation()?;
							if let JoinedRelationContextAll::AsofJoinRelationContext(ctx) = cast_mut::<_,JoinedRelationContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							recog.base.set_state(3146);
							recog.base.match_token(MATCH_CONDITION,&mut recog.err_handler)?;

							recog.base.set_state(3147);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(3148);
							recog.expression()?;

							recog.base.set_state(3149);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							recog.base.set_state(3151);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(465,&mut recog.base)? {
								x if x == 1=>{
									{
									/*InvokeRule joinCriteria*/
									recog.base.set_state(3150);
									recog.joinCriteria()?;

									}
								}

								_ => {}
							}
							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(3157);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(467,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- joinType ----------------
pub type JoinTypeContextAll<'input> = JoinTypeContext<'input>;


pub type JoinTypeContext<'input> = BaseParserRuleContext<'input,JoinTypeContextExt<'input>>;

#[derive(Clone)]
pub struct JoinTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for JoinTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for JoinTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_joinType(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_joinType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for JoinTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_joinType(self);
	}
}

impl<'input> CustomRuleContext<'input> for JoinTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_joinType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_joinType }
}
antlr_rust::tid!{JoinTypeContextExt<'a>}

impl<'input> JoinTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<JoinTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,JoinTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait JoinTypeContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<JoinTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INNER
/// Returns `None` if there is no child corresponding to token INNER
fn INNER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INNER, 0)
}
/// Retrieves first TerminalNode corresponding to token LEFT
/// Returns `None` if there is no child corresponding to token LEFT
fn LEFT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LEFT, 0)
}
/// Retrieves first TerminalNode corresponding to token OUTER
/// Returns `None` if there is no child corresponding to token OUTER
fn OUTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OUTER, 0)
}
/// Retrieves first TerminalNode corresponding to token RIGHT
/// Returns `None` if there is no child corresponding to token RIGHT
fn RIGHT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RIGHT, 0)
}
/// Retrieves first TerminalNode corresponding to token FULL
/// Returns `None` if there is no child corresponding to token FULL
fn FULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FULL, 0)
}

}

impl<'input> JoinTypeContextAttrs<'input> for JoinTypeContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn joinType(&mut self,)
	-> Result<Rc<JoinTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = JoinTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 148, RULE_joinType);
        let mut _localctx: Rc<JoinTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3173);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INNER | JOIN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3159);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==INNER {
						{
						recog.base.set_state(3158);
						recog.base.match_token(INNER,&mut recog.err_handler)?;

						}
					}

					}
				}

			 LEFT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3161);
					recog.base.match_token(LEFT,&mut recog.err_handler)?;

					recog.base.set_state(3163);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OUTER {
						{
						recog.base.set_state(3162);
						recog.base.match_token(OUTER,&mut recog.err_handler)?;

						}
					}

					}
				}

			 RIGHT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3165);
					recog.base.match_token(RIGHT,&mut recog.err_handler)?;

					recog.base.set_state(3167);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OUTER {
						{
						recog.base.set_state(3166);
						recog.base.match_token(OUTER,&mut recog.err_handler)?;

						}
					}

					}
				}

			 FULL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(3169);
					recog.base.match_token(FULL,&mut recog.err_handler)?;

					recog.base.set_state(3171);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OUTER {
						{
						recog.base.set_state(3170);
						recog.base.match_token(OUTER,&mut recog.err_handler)?;

						}
					}

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- joinCriteria ----------------
pub type JoinCriteriaContextAll<'input> = JoinCriteriaContext<'input>;


pub type JoinCriteriaContext<'input> = BaseParserRuleContext<'input,JoinCriteriaContextExt<'input>>;

#[derive(Clone)]
pub struct JoinCriteriaContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for JoinCriteriaContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for JoinCriteriaContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_joinCriteria(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_joinCriteria(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for JoinCriteriaContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_joinCriteria(self);
	}
}

impl<'input> CustomRuleContext<'input> for JoinCriteriaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_joinCriteria }
	//fn type_rule_index() -> usize where Self: Sized { RULE_joinCriteria }
}
antlr_rust::tid!{JoinCriteriaContextExt<'a>}

impl<'input> JoinCriteriaContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<JoinCriteriaContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,JoinCriteriaContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait JoinCriteriaContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<JoinCriteriaContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ON
/// Returns `None` if there is no child corresponding to token ON
fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ON, 0)
}
fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token USING
/// Returns `None` if there is no child corresponding to token USING
fn USING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(USING, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> JoinCriteriaContextAttrs<'input> for JoinCriteriaContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn joinCriteria(&mut self,)
	-> Result<Rc<JoinCriteriaContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = JoinCriteriaContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 150, RULE_joinCriteria);
        let mut _localctx: Rc<JoinCriteriaContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(3192);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ON 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3175);
					recog.base.match_token(ON,&mut recog.err_handler)?;

					/*InvokeRule booleanExpression*/
					recog.base.set_state(3176);
					recog.booleanExpression_rec(0)?;

					}
				}

			 USING 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3177);
					recog.base.match_token(USING,&mut recog.err_handler)?;

					recog.base.set_state(3178);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(3179);
					recog.identifier()?;

					recog.base.set_state(3184);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(473,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3180);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(3181);
							recog.identifier()?;

							}
							} 
						}
						recog.base.set_state(3186);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(473,&mut recog.base)?;
					}
					recog.base.set_state(3188);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(3187);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						 cast_mut::<_,JoinCriteriaContext >(&mut _localctx).tail = Some(tmp);
						  

						}
					}

					recog.base.set_state(3190);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- noJoinRelation ----------------
pub type NoJoinRelationContextAll<'input> = NoJoinRelationContext<'input>;


pub type NoJoinRelationContext<'input> = BaseParserRuleContext<'input,NoJoinRelationContextExt<'input>>;

#[derive(Clone)]
pub struct NoJoinRelationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NoJoinRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NoJoinRelationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_noJoinRelation(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_noJoinRelation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NoJoinRelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_noJoinRelation(self);
	}
}

impl<'input> CustomRuleContext<'input> for NoJoinRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_noJoinRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_noJoinRelation }
}
antlr_rust::tid!{NoJoinRelationContextExt<'a>}

impl<'input> NoJoinRelationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NoJoinRelationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NoJoinRelationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NoJoinRelationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NoJoinRelationContextExt<'input>>{

fn sampledRelation(&self) -> Option<Rc<SampledRelationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NoJoinRelationContextAttrs<'input> for NoJoinRelationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn noJoinRelation(&mut self,)
	-> Result<Rc<NoJoinRelationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NoJoinRelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 152, RULE_noJoinRelation);
        let mut _localctx: Rc<NoJoinRelationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule sampledRelation*/
			recog.base.set_state(3194);
			recog.sampledRelation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sampledRelationTarget ----------------
#[derive(Debug)]
pub enum SampledRelationTargetContextAll<'input>{
	InlineTableDefaultContext(InlineTableDefaultContext<'input>),
	Aliased2Context(Aliased2Context<'input>),
Error(SampledRelationTargetContext<'input>)
}
antlr_rust::tid!{SampledRelationTargetContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for SampledRelationTargetContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for SampledRelationTargetContextAll<'input>{}

impl<'input> Deref for SampledRelationTargetContextAll<'input>{
	type Target = dyn SampledRelationTargetContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use SampledRelationTargetContextAll::*;
		match self{
			InlineTableDefaultContext(inner) => inner,
			Aliased2Context(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SampledRelationTargetContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SampledRelationTargetContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type SampledRelationTargetContext<'input> = BaseParserRuleContext<'input,SampledRelationTargetContextExt<'input>>;

#[derive(Clone)]
pub struct SampledRelationTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SampledRelationTargetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SampledRelationTargetContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SampledRelationTargetContext<'input>{
}

impl<'input> CustomRuleContext<'input> for SampledRelationTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sampledRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sampledRelationTarget }
}
antlr_rust::tid!{SampledRelationTargetContextExt<'a>}

impl<'input> SampledRelationTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SampledRelationTargetContextAll<'input>> {
		Rc::new(
		SampledRelationTargetContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SampledRelationTargetContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait SampledRelationTargetContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SampledRelationTargetContextExt<'input>>{


}

impl<'input> SampledRelationTargetContextAttrs<'input> for SampledRelationTargetContext<'input>{}

pub type InlineTableDefaultContext<'input> = BaseParserRuleContext<'input,InlineTableDefaultContextExt<'input>>;

pub trait InlineTableDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VALUES
	/// Returns `None` if there is no child corresponding to token VALUES
	fn VALUES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VALUES, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> InlineTableDefaultContextAttrs<'input> for InlineTableDefaultContext<'input>{}

pub struct InlineTableDefaultContextExt<'input>{
	base:SampledRelationTargetContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{InlineTableDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for InlineTableDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for InlineTableDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_inlineTableDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_inlineTableDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for InlineTableDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_inlineTableDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for InlineTableDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sampledRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sampledRelationTarget }
}

impl<'input> Borrow<SampledRelationTargetContextExt<'input>> for InlineTableDefaultContext<'input>{
	fn borrow(&self) -> &SampledRelationTargetContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SampledRelationTargetContextExt<'input>> for InlineTableDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut SampledRelationTargetContextExt<'input> { &mut self.base }
}

impl<'input> SampledRelationTargetContextAttrs<'input> for InlineTableDefaultContext<'input> {}

impl<'input> InlineTableDefaultContextExt<'input>{
	fn new(ctx: &dyn SampledRelationTargetContextAttrs<'input>) -> Rc<SampledRelationTargetContextAll<'input>>  {
		Rc::new(
			SampledRelationTargetContextAll::InlineTableDefaultContext(
				BaseParserRuleContext::copy_from(ctx,InlineTableDefaultContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type Aliased2Context<'input> = BaseParserRuleContext<'input,Aliased2ContextExt<'input>>;

pub trait Aliased2ContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn aliasedRelation2(&self) -> Option<Rc<AliasedRelation2ContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> Aliased2ContextAttrs<'input> for Aliased2Context<'input>{}

pub struct Aliased2ContextExt<'input>{
	base:SampledRelationTargetContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{Aliased2ContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for Aliased2Context<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for Aliased2Context<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_aliased2(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_aliased2(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for Aliased2Context<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_aliased2(self);
	}
}

impl<'input> CustomRuleContext<'input> for Aliased2ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sampledRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sampledRelationTarget }
}

impl<'input> Borrow<SampledRelationTargetContextExt<'input>> for Aliased2Context<'input>{
	fn borrow(&self) -> &SampledRelationTargetContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SampledRelationTargetContextExt<'input>> for Aliased2Context<'input>{
	fn borrow_mut(&mut self) -> &mut SampledRelationTargetContextExt<'input> { &mut self.base }
}

impl<'input> SampledRelationTargetContextAttrs<'input> for Aliased2Context<'input> {}

impl<'input> Aliased2ContextExt<'input>{
	fn new(ctx: &dyn SampledRelationTargetContextAttrs<'input>) -> Rc<SampledRelationTargetContextAll<'input>>  {
		Rc::new(
			SampledRelationTargetContextAll::Aliased2Context(
				BaseParserRuleContext::copy_from(ctx,Aliased2ContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sampledRelationTarget(&mut self,)
	-> Result<Rc<SampledRelationTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SampledRelationTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 154, RULE_sampledRelationTarget);
        let mut _localctx: Rc<SampledRelationTargetContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(3241);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(486,&mut recog.base)? {
				1 =>{
					let tmp = Aliased2ContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule aliasedRelation2*/
					recog.base.set_state(3196);
					recog.aliasedRelation2()?;

					}
				}
			,
				2 =>{
					let tmp = InlineTableDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(3197);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3198);
					recog.base.match_token(VALUES,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(3199);
					recog.expression()?;

					recog.base.set_state(3204);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(476,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3200);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(3201);
							recog.expression()?;

							}
							} 
						}
						recog.base.set_state(3206);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(476,&mut recog.base)?;
					}
					recog.base.set_state(3208);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(3207);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let SampledRelationTargetContextAll::InlineTableDefaultContext(ctx) = cast_mut::<_,SampledRelationTargetContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(3210);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3218);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(480,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3212);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==AS {
								{
								recog.base.set_state(3211);
								recog.base.match_token(AS,&mut recog.err_handler)?;

								}
							}

							/*InvokeRule identifier*/
							recog.base.set_state(3214);
							recog.identifier()?;

							recog.base.set_state(3216);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(479,&mut recog.base)? {
								x if x == 1=>{
									{
									/*InvokeRule columnAliases*/
									recog.base.set_state(3215);
									recog.columnAliases()?;

									}
								}

								_ => {}
							}
							}
						}

						_ => {}
					}
					}
				}
			,
				3 =>{
					let tmp = InlineTableDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(3220);
					recog.base.match_token(VALUES,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(3221);
					recog.expression()?;

					recog.base.set_state(3226);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(481,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3222);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(3223);
							recog.expression()?;

							}
							} 
						}
						recog.base.set_state(3228);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(481,&mut recog.base)?;
					}
					recog.base.set_state(3230);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(482,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3229);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let SampledRelationTargetContextAll::InlineTableDefaultContext(ctx) = cast_mut::<_,SampledRelationTargetContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					recog.base.set_state(3239);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(485,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3233);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==AS {
								{
								recog.base.set_state(3232);
								recog.base.match_token(AS,&mut recog.err_handler)?;

								}
							}

							/*InvokeRule identifier*/
							recog.base.set_state(3235);
							recog.identifier()?;

							recog.base.set_state(3237);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(484,&mut recog.base)? {
								x if x == 1=>{
									{
									/*InvokeRule columnAliases*/
									recog.base.set_state(3236);
									recog.columnAliases()?;

									}
								}

								_ => {}
							}
							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sampledRelation ----------------
pub type SampledRelationContextAll<'input> = SampledRelationContext<'input>;


pub type SampledRelationContext<'input> = BaseParserRuleContext<'input,SampledRelationContextExt<'input>>;

#[derive(Clone)]
pub struct SampledRelationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SampledRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SampledRelationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sampledRelation(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_sampledRelation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SampledRelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_sampledRelation(self);
	}
}

impl<'input> CustomRuleContext<'input> for SampledRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sampledRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sampledRelation }
}
antlr_rust::tid!{SampledRelationContextExt<'a>}

impl<'input> SampledRelationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SampledRelationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SampledRelationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SampledRelationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SampledRelationContextExt<'input>>{

fn sampledRelationTarget(&self) -> Option<Rc<SampledRelationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sampleOperator(&self) -> Option<Rc<SampleOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SampledRelationContextAttrs<'input> for SampledRelationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sampledRelation(&mut self,)
	-> Result<Rc<SampledRelationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SampledRelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 156, RULE_sampledRelation);
        let mut _localctx: Rc<SampledRelationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule sampledRelationTarget*/
			recog.base.set_state(3243);
			recog.sampledRelationTarget()?;

			recog.base.set_state(3245);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(487,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule sampleOperator*/
					recog.base.set_state(3244);
					recog.sampleOperator()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sampleOperator ----------------
pub type SampleOperatorContextAll<'input> = SampleOperatorContext<'input>;


pub type SampleOperatorContext<'input> = BaseParserRuleContext<'input,SampleOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct SampleOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SampleOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SampleOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sampleOperator(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_sampleOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SampleOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_sampleOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for SampleOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sampleOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sampleOperator }
}
antlr_rust::tid!{SampleOperatorContextExt<'a>}

impl<'input> SampleOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SampleOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SampleOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SampleOperatorContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SampleOperatorContextExt<'input>>{

fn sampleMethod(&self) -> Option<Rc<SampleMethodContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SAMPLE
/// Returns `None` if there is no child corresponding to token SAMPLE
fn SAMPLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SAMPLE, 0)
}
/// Retrieves first TerminalNode corresponding to token TABLESAMPLE
/// Returns `None` if there is no child corresponding to token TABLESAMPLE
fn TABLESAMPLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TABLESAMPLE, 0)
}

}

impl<'input> SampleOperatorContextAttrs<'input> for SampleOperatorContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sampleOperator(&mut self,)
	-> Result<Rc<SampleOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SampleOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 158, RULE_sampleOperator);
        let mut _localctx: Rc<SampleOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3247);
			_la = recog.base.input.la(1);
			if { !(_la==SAMPLE || _la==TABLESAMPLE) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			/*InvokeRule sampleMethod*/
			recog.base.set_state(3248);
			recog.sampleMethod()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sampleMethod ----------------
pub type SampleMethodContextAll<'input> = SampleMethodContext<'input>;


pub type SampleMethodContext<'input> = BaseParserRuleContext<'input,SampleMethodContextExt<'input>>;

#[derive(Clone)]
pub struct SampleMethodContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SampleMethodContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SampleMethodContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sampleMethod(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_sampleMethod(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SampleMethodContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_sampleMethod(self);
	}
}

impl<'input> CustomRuleContext<'input> for SampleMethodContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sampleMethod }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sampleMethod }
}
antlr_rust::tid!{SampleMethodContextExt<'a>}

impl<'input> SampleMethodContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SampleMethodContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SampleMethodContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SampleMethodContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SampleMethodContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn samplePercentage(&self) -> Option<Rc<SamplePercentageContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sampleCount(&self) -> Option<Rc<SampleCountContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn sampleSeed(&self) -> Option<Rc<SampleSeedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BERNOULLI
/// Returns `None` if there is no child corresponding to token BERNOULLI
fn BERNOULLI(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BERNOULLI, 0)
}
/// Retrieves first TerminalNode corresponding to token ROW
/// Returns `None` if there is no child corresponding to token ROW
fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROW, 0)
}
/// Retrieves first TerminalNode corresponding to token SYSTEM
/// Returns `None` if there is no child corresponding to token SYSTEM
fn SYSTEM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SYSTEM, 0)
}
/// Retrieves first TerminalNode corresponding to token BLOCK
/// Returns `None` if there is no child corresponding to token BLOCK
fn BLOCK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BLOCK, 0)
}

}

impl<'input> SampleMethodContextAttrs<'input> for SampleMethodContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sampleMethod(&mut self,)
	-> Result<Rc<SampleMethodContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SampleMethodContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 160, RULE_sampleMethod);
        let mut _localctx: Rc<SampleMethodContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3269);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 BERNOULLI | ROW | LPAREN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3251);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==BERNOULLI || _la==ROW {
						{
						recog.base.set_state(3250);
						_la = recog.base.input.la(1);
						if { !(_la==BERNOULLI || _la==ROW) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(3253);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3256);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(489,&mut recog.base)? {
						1 =>{
							{
							/*InvokeRule samplePercentage*/
							recog.base.set_state(3254);
							recog.samplePercentage()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule sampleCount*/
							recog.base.set_state(3255);
							recog.sampleCount()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(3258);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3260);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(490,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule sampleSeed*/
							recog.base.set_state(3259);
							recog.sampleSeed()?;

							}
						}

						_ => {}
					}
					}
				}

			 BLOCK | SYSTEM 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3262);
					_la = recog.base.input.la(1);
					if { !(_la==BLOCK || _la==SYSTEM) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(3263);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule samplePercentage*/
					recog.base.set_state(3264);
					recog.samplePercentage()?;

					recog.base.set_state(3265);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3267);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(491,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule sampleSeed*/
							recog.base.set_state(3266);
							recog.sampleSeed()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- samplePercentage ----------------
pub type SamplePercentageContextAll<'input> = SamplePercentageContext<'input>;


pub type SamplePercentageContext<'input> = BaseParserRuleContext<'input,SamplePercentageContextExt<'input>>;

#[derive(Clone)]
pub struct SamplePercentageContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SamplePercentageContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SamplePercentageContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_samplePercentage(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_samplePercentage(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SamplePercentageContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_samplePercentage(self);
	}
}

impl<'input> CustomRuleContext<'input> for SamplePercentageContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_samplePercentage }
	//fn type_rule_index() -> usize where Self: Sized { RULE_samplePercentage }
}
antlr_rust::tid!{SamplePercentageContextExt<'a>}

impl<'input> SamplePercentageContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SamplePercentageContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SamplePercentageContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SamplePercentageContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SamplePercentageContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTEGER_VALUE, 0)
}
/// Retrieves first TerminalNode corresponding to token DECIMAL_VALUE
/// Returns `None` if there is no child corresponding to token DECIMAL_VALUE
fn DECIMAL_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DECIMAL_VALUE, 0)
}

}

impl<'input> SamplePercentageContextAttrs<'input> for SamplePercentageContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn samplePercentage(&mut self,)
	-> Result<Rc<SamplePercentageContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SamplePercentageContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 162, RULE_samplePercentage);
        let mut _localctx: Rc<SamplePercentageContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3271);
			_la = recog.base.input.la(1);
			if { !(_la==INTEGER_VALUE || _la==DECIMAL_VALUE) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sampleCount ----------------
pub type SampleCountContextAll<'input> = SampleCountContext<'input>;


pub type SampleCountContext<'input> = BaseParserRuleContext<'input,SampleCountContextExt<'input>>;

#[derive(Clone)]
pub struct SampleCountContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SampleCountContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SampleCountContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sampleCount(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_sampleCount(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SampleCountContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_sampleCount(self);
	}
}

impl<'input> CustomRuleContext<'input> for SampleCountContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sampleCount }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sampleCount }
}
antlr_rust::tid!{SampleCountContextExt<'a>}

impl<'input> SampleCountContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SampleCountContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SampleCountContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SampleCountContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SampleCountContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTEGER_VALUE, 0)
}
/// Retrieves first TerminalNode corresponding to token ROWS
/// Returns `None` if there is no child corresponding to token ROWS
fn ROWS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROWS, 0)
}

}

impl<'input> SampleCountContextAttrs<'input> for SampleCountContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sampleCount(&mut self,)
	-> Result<Rc<SampleCountContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SampleCountContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 164, RULE_sampleCount);
        let mut _localctx: Rc<SampleCountContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3273);
			recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;

			recog.base.set_state(3274);
			recog.base.match_token(ROWS,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- sampleSeed ----------------
pub type SampleSeedContextAll<'input> = SampleSeedContext<'input>;


pub type SampleSeedContext<'input> = BaseParserRuleContext<'input,SampleSeedContextExt<'input>>;

#[derive(Clone)]
pub struct SampleSeedContextExt<'input>{
	pub seed: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SampleSeedContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SampleSeedContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_sampleSeed(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_sampleSeed(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SampleSeedContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_sampleSeed(self);
	}
}

impl<'input> CustomRuleContext<'input> for SampleSeedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_sampleSeed }
	//fn type_rule_index() -> usize where Self: Sized { RULE_sampleSeed }
}
antlr_rust::tid!{SampleSeedContextExt<'a>}

impl<'input> SampleSeedContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SampleSeedContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SampleSeedContextExt{
				seed: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait SampleSeedContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SampleSeedContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token REPEATABLE
/// Returns `None` if there is no child corresponding to token REPEATABLE
fn REPEATABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REPEATABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token SEED
/// Returns `None` if there is no child corresponding to token SEED
fn SEED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEED, 0)
}
/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTEGER_VALUE, 0)
}

}

impl<'input> SampleSeedContextAttrs<'input> for SampleSeedContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn sampleSeed(&mut self,)
	-> Result<Rc<SampleSeedContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SampleSeedContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 166, RULE_sampleSeed);
        let mut _localctx: Rc<SampleSeedContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3276);
			_la = recog.base.input.la(1);
			if { !(_la==REPEATABLE || _la==SEED) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			recog.base.set_state(3277);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(3278);
			let tmp = recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;
			 cast_mut::<_,SampleSeedContext >(&mut _localctx).seed = Some(tmp);
			  

			recog.base.set_state(3279);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- trimsSpecification ----------------
pub type TrimsSpecificationContextAll<'input> = TrimsSpecificationContext<'input>;


pub type TrimsSpecificationContext<'input> = BaseParserRuleContext<'input,TrimsSpecificationContextExt<'input>>;

#[derive(Clone)]
pub struct TrimsSpecificationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TrimsSpecificationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TrimsSpecificationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_trimsSpecification(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_trimsSpecification(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TrimsSpecificationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_trimsSpecification(self);
	}
}

impl<'input> CustomRuleContext<'input> for TrimsSpecificationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_trimsSpecification }
	//fn type_rule_index() -> usize where Self: Sized { RULE_trimsSpecification }
}
antlr_rust::tid!{TrimsSpecificationContextExt<'a>}

impl<'input> TrimsSpecificationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TrimsSpecificationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TrimsSpecificationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TrimsSpecificationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TrimsSpecificationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LEADING
/// Returns `None` if there is no child corresponding to token LEADING
fn LEADING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LEADING, 0)
}
/// Retrieves first TerminalNode corresponding to token TRAILING
/// Returns `None` if there is no child corresponding to token TRAILING
fn TRAILING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRAILING, 0)
}
/// Retrieves first TerminalNode corresponding to token BOTH
/// Returns `None` if there is no child corresponding to token BOTH
fn BOTH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BOTH, 0)
}

}

impl<'input> TrimsSpecificationContextAttrs<'input> for TrimsSpecificationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn trimsSpecification(&mut self,)
	-> Result<Rc<TrimsSpecificationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TrimsSpecificationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 168, RULE_trimsSpecification);
        let mut _localctx: Rc<TrimsSpecificationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3281);
			_la = recog.base.input.la(1);
			if { !(_la==BOTH || _la==LEADING || _la==TRAILING) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- listAggOverflowBehavior ----------------
pub type ListAggOverflowBehaviorContextAll<'input> = ListAggOverflowBehaviorContext<'input>;


pub type ListAggOverflowBehaviorContext<'input> = BaseParserRuleContext<'input,ListAggOverflowBehaviorContextExt<'input>>;

#[derive(Clone)]
pub struct ListAggOverflowBehaviorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ListAggOverflowBehaviorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ListAggOverflowBehaviorContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_listAggOverflowBehavior(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_listAggOverflowBehavior(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ListAggOverflowBehaviorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_listAggOverflowBehavior(self);
	}
}

impl<'input> CustomRuleContext<'input> for ListAggOverflowBehaviorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_listAggOverflowBehavior }
	//fn type_rule_index() -> usize where Self: Sized { RULE_listAggOverflowBehavior }
}
antlr_rust::tid!{ListAggOverflowBehaviorContextExt<'a>}

impl<'input> ListAggOverflowBehaviorContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ListAggOverflowBehaviorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ListAggOverflowBehaviorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ListAggOverflowBehaviorContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ListAggOverflowBehaviorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ERROR
/// Returns `None` if there is no child corresponding to token ERROR
fn ERROR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ERROR, 0)
}
/// Retrieves first TerminalNode corresponding to token TRUNCATE
/// Returns `None` if there is no child corresponding to token TRUNCATE
fn TRUNCATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRUNCATE, 0)
}
fn listaggCountIndication(&self) -> Option<Rc<ListaggCountIndicationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ListAggOverflowBehaviorContextAttrs<'input> for ListAggOverflowBehaviorContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn listAggOverflowBehavior(&mut self,)
	-> Result<Rc<ListAggOverflowBehaviorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ListAggOverflowBehaviorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 170, RULE_listAggOverflowBehavior);
        let mut _localctx: Rc<ListAggOverflowBehaviorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3289);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ERROR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3283);
					recog.base.match_token(ERROR,&mut recog.err_handler)?;

					}
				}

			 TRUNCATE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3284);
					recog.base.match_token(TRUNCATE,&mut recog.err_handler)?;

					recog.base.set_state(3286);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if ((((_la - 466)) & !0x3f) == 0 && ((1usize << (_la - 466)) & ((1usize << (STRING - 466)) | (1usize << (UNICODE_STRING - 466)) | (1usize << (DOLLAR_QUOTED_STRING - 466)))) != 0) {
						{
						/*InvokeRule string*/
						recog.base.set_state(3285);
						recog.string()?;

						}
					}

					/*InvokeRule listaggCountIndication*/
					recog.base.set_state(3288);
					recog.listaggCountIndication()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- listaggCountIndication ----------------
pub type ListaggCountIndicationContextAll<'input> = ListaggCountIndicationContext<'input>;


pub type ListaggCountIndicationContext<'input> = BaseParserRuleContext<'input,ListaggCountIndicationContextExt<'input>>;

#[derive(Clone)]
pub struct ListaggCountIndicationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ListaggCountIndicationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ListaggCountIndicationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_listaggCountIndication(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_listaggCountIndication(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ListaggCountIndicationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_listaggCountIndication(self);
	}
}

impl<'input> CustomRuleContext<'input> for ListaggCountIndicationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_listaggCountIndication }
	//fn type_rule_index() -> usize where Self: Sized { RULE_listaggCountIndication }
}
antlr_rust::tid!{ListaggCountIndicationContextExt<'a>}

impl<'input> ListaggCountIndicationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ListaggCountIndicationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ListaggCountIndicationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ListaggCountIndicationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ListaggCountIndicationContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}
/// Retrieves first TerminalNode corresponding to token COUNT
/// Returns `None` if there is no child corresponding to token COUNT
fn COUNT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COUNT, 0)
}
/// Retrieves first TerminalNode corresponding to token WITHOUT
/// Returns `None` if there is no child corresponding to token WITHOUT
fn WITHOUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITHOUT, 0)
}

}

impl<'input> ListaggCountIndicationContextAttrs<'input> for ListaggCountIndicationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn listaggCountIndication(&mut self,)
	-> Result<Rc<ListaggCountIndicationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ListaggCountIndicationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 172, RULE_listaggCountIndication);
        let mut _localctx: Rc<ListaggCountIndicationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3295);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 WITH 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3291);
					recog.base.match_token(WITH,&mut recog.err_handler)?;

					recog.base.set_state(3292);
					recog.base.match_token(COUNT,&mut recog.err_handler)?;

					}
				}

			 WITHOUT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3293);
					recog.base.match_token(WITHOUT,&mut recog.err_handler)?;

					recog.base.set_state(3294);
					recog.base.match_token(COUNT,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- patternRecognitionTarget ----------------
pub type PatternRecognitionTargetContextAll<'input> = PatternRecognitionTargetContext<'input>;


pub type PatternRecognitionTargetContext<'input> = BaseParserRuleContext<'input,PatternRecognitionTargetContextExt<'input>>;

#[derive(Clone)]
pub struct PatternRecognitionTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PatternRecognitionTargetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternRecognitionTargetContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_patternRecognitionTarget(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_patternRecognitionTarget(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternRecognitionTargetContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_patternRecognitionTarget(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternRecognitionTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternRecognitionTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternRecognitionTarget }
}
antlr_rust::tid!{PatternRecognitionTargetContextExt<'a>}

impl<'input> PatternRecognitionTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PatternRecognitionTargetContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PatternRecognitionTargetContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PatternRecognitionTargetContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PatternRecognitionTargetContextExt<'input>>{

fn changesRelation(&self) -> Option<Rc<ChangesRelationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PatternRecognitionTargetContextAttrs<'input> for PatternRecognitionTargetContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn patternRecognitionTarget(&mut self,)
	-> Result<Rc<PatternRecognitionTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PatternRecognitionTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 174, RULE_patternRecognitionTarget);
        let mut _localctx: Rc<PatternRecognitionTargetContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule changesRelation*/
			recog.base.set_state(3297);
			recog.changesRelation()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- patternRecognition ----------------
pub type PatternRecognitionContextAll<'input> = PatternRecognitionContext<'input>;


pub type PatternRecognitionContext<'input> = BaseParserRuleContext<'input,PatternRecognitionContextExt<'input>>;

#[derive(Clone)]
pub struct PatternRecognitionContextExt<'input>{
	pub expression: Option<Rc<ExpressionContextAll<'input>>>,
	pub partition:Vec<Rc<ExpressionContextAll<'input>>>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PatternRecognitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternRecognitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_patternRecognition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_patternRecognition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternRecognitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_patternRecognition(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternRecognitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternRecognition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternRecognition }
}
antlr_rust::tid!{PatternRecognitionContextExt<'a>}

impl<'input> PatternRecognitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PatternRecognitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PatternRecognitionContextExt{
				COMMA: None, 
				tail: Vec::new(), 
				expression: None, 
				partition: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait PatternRecognitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PatternRecognitionContextExt<'input>>{

fn patternRecognitionTarget(&self) -> Option<Rc<PatternRecognitionTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token MATCH_RECOGNIZE
/// Returns `None` if there is no child corresponding to token MATCH_RECOGNIZE
fn MATCH_RECOGNIZE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCH_RECOGNIZE, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, i)
}
/// Retrieves first TerminalNode corresponding to token PATTERN
/// Returns `None` if there is no child corresponding to token PATTERN
fn PATTERN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PATTERN, 0)
}
fn rowPattern(&self) -> Option<Rc<RowPatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, i)
}
/// Retrieves first TerminalNode corresponding to token DEFINE
/// Returns `None` if there is no child corresponding to token DEFINE
fn DEFINE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFINE, 0)
}
fn variableDefinition_all(&self) ->  Vec<Rc<VariableDefinitionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableDefinition(&self, i: usize) -> Option<Rc<VariableDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token PARTITION
/// Returns `None` if there is no child corresponding to token PARTITION
fn PARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITION, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token BY in current rule
fn BY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token BY, starting from 0.
/// Returns `None` if number of children corresponding to token BY is less or equal than `i`.
fn BY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, i)
}
/// Retrieves first TerminalNode corresponding to token ORDER
/// Returns `None` if there is no child corresponding to token ORDER
fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ORDER, 0)
}
fn sortItem_all(&self) ->  Vec<Rc<SortItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token MEASURES
/// Returns `None` if there is no child corresponding to token MEASURES
fn MEASURES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MEASURES, 0)
}
fn measureDefinition_all(&self) ->  Vec<Rc<MeasureDefinitionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn measureDefinition(&self, i: usize) -> Option<Rc<MeasureDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn rowsPerMatch(&self) -> Option<Rc<RowsPerMatchContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AFTER
/// Returns `None` if there is no child corresponding to token AFTER
fn AFTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AFTER, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCH
/// Returns `None` if there is no child corresponding to token MATCH
fn MATCH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCH, 0)
}
fn skipTo(&self) -> Option<Rc<SkipToContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token SUBSET
/// Returns `None` if there is no child corresponding to token SUBSET
fn SUBSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SUBSET, 0)
}
fn subsetDefinition_all(&self) ->  Vec<Rc<SubsetDefinitionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn subsetDefinition(&self, i: usize) -> Option<Rc<SubsetDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token INITIAL
/// Returns `None` if there is no child corresponding to token INITIAL
fn INITIAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INITIAL, 0)
}
/// Retrieves first TerminalNode corresponding to token SEEK
/// Returns `None` if there is no child corresponding to token SEEK
fn SEEK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEEK, 0)
}

}

impl<'input> PatternRecognitionContextAttrs<'input> for PatternRecognitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn patternRecognition(&mut self,)
	-> Result<Rc<PatternRecognitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PatternRecognitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 176, RULE_patternRecognition);
        let mut _localctx: Rc<PatternRecognitionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule patternRecognitionTarget*/
			recog.base.set_state(3299);
			recog.patternRecognitionTarget()?;

			recog.base.set_state(3389);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(513,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(3300);
					recog.base.match_token(MATCH_RECOGNIZE,&mut recog.err_handler)?;

					recog.base.set_state(3301);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3315);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==PARTITION {
						{
						recog.base.set_state(3302);
						recog.base.match_token(PARTITION,&mut recog.err_handler)?;

						recog.base.set_state(3303);
						recog.base.match_token(BY,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(3304);
						let tmp = recog.expression()?;
						 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).expression = Some(tmp.clone());
						  

						let temp =  cast_mut::<_,PatternRecognitionContext >(&mut _localctx).expression.clone().unwrap()
						 ;
						 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).partition.push(temp);
						  
						recog.base.set_state(3309);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(496,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(3305);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(3306);
								let tmp = recog.expression()?;
								 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).expression = Some(tmp.clone());
								  

								let temp =  cast_mut::<_,PatternRecognitionContext >(&mut _localctx).expression.clone().unwrap()
								 ;
								 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).partition.push(temp);
								  
								}
								} 
							}
							recog.base.set_state(3311);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(496,&mut recog.base)?;
						}
						recog.base.set_state(3313);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(3312);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA = Some(tmp);
							  

							let temp =  cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA.clone().unwrap()
							 ;
							 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).tail.push(temp);
							  
							}
						}

						}
					}

					recog.base.set_state(3330);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ORDER {
						{
						recog.base.set_state(3317);
						recog.base.match_token(ORDER,&mut recog.err_handler)?;

						recog.base.set_state(3318);
						recog.base.match_token(BY,&mut recog.err_handler)?;

						/*InvokeRule sortItem*/
						recog.base.set_state(3319);
						recog.sortItem()?;

						recog.base.set_state(3324);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(499,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(3320);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule sortItem*/
								recog.base.set_state(3321);
								recog.sortItem()?;

								}
								} 
							}
							recog.base.set_state(3326);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(499,&mut recog.base)?;
						}
						recog.base.set_state(3328);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(3327);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA = Some(tmp);
							  

							let temp =  cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA.clone().unwrap()
							 ;
							 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).tail.push(temp);
							  
							}
						}

						}
					}

					recog.base.set_state(3344);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==MEASURES {
						{
						recog.base.set_state(3332);
						recog.base.match_token(MEASURES,&mut recog.err_handler)?;

						/*InvokeRule measureDefinition*/
						recog.base.set_state(3333);
						recog.measureDefinition()?;

						recog.base.set_state(3338);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(502,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(3334);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule measureDefinition*/
								recog.base.set_state(3335);
								recog.measureDefinition()?;

								}
								} 
							}
							recog.base.set_state(3340);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(502,&mut recog.base)?;
						}
						recog.base.set_state(3342);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(3341);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA = Some(tmp);
							  

							let temp =  cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA.clone().unwrap()
							 ;
							 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).tail.push(temp);
							  
							}
						}

						}
					}

					recog.base.set_state(3347);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ALL || _la==ONE {
						{
						/*InvokeRule rowsPerMatch*/
						recog.base.set_state(3346);
						recog.rowsPerMatch()?;

						}
					}

					recog.base.set_state(3352);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==AFTER {
						{
						recog.base.set_state(3349);
						recog.base.match_token(AFTER,&mut recog.err_handler)?;

						recog.base.set_state(3350);
						recog.base.match_token(MATCH,&mut recog.err_handler)?;

						/*InvokeRule skipTo*/
						recog.base.set_state(3351);
						recog.skipTo()?;

						}
					}

					recog.base.set_state(3355);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==INITIAL || _la==SEEK {
						{
						recog.base.set_state(3354);
						_la = recog.base.input.la(1);
						if { !(_la==INITIAL || _la==SEEK) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(3357);
					recog.base.match_token(PATTERN,&mut recog.err_handler)?;

					recog.base.set_state(3358);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule rowPattern*/
					recog.base.set_state(3359);
					recog.rowPattern_rec(0)?;

					recog.base.set_state(3360);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3373);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==SUBSET {
						{
						recog.base.set_state(3361);
						recog.base.match_token(SUBSET,&mut recog.err_handler)?;

						/*InvokeRule subsetDefinition*/
						recog.base.set_state(3362);
						recog.subsetDefinition()?;

						recog.base.set_state(3367);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(508,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(3363);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule subsetDefinition*/
								recog.base.set_state(3364);
								recog.subsetDefinition()?;

								}
								} 
							}
							recog.base.set_state(3369);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(508,&mut recog.base)?;
						}
						recog.base.set_state(3371);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(3370);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA = Some(tmp);
							  

							let temp =  cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA.clone().unwrap()
							 ;
							 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).tail.push(temp);
							  
							}
						}

						}
					}

					recog.base.set_state(3375);
					recog.base.match_token(DEFINE,&mut recog.err_handler)?;

					/*InvokeRule variableDefinition*/
					recog.base.set_state(3376);
					recog.variableDefinition()?;

					recog.base.set_state(3381);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(511,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3377);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule variableDefinition*/
							recog.base.set_state(3378);
							recog.variableDefinition()?;

							}
							} 
						}
						recog.base.set_state(3383);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(511,&mut recog.base)?;
					}
					recog.base.set_state(3385);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(3384);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA = Some(tmp);
						  

						let temp =  cast_mut::<_,PatternRecognitionContext >(&mut _localctx).COMMA.clone().unwrap()
						 ;
						 cast_mut::<_,PatternRecognitionContext >(&mut _localctx).tail.push(temp);
						  
						}
					}

					recog.base.set_state(3387);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- measureDefinition ----------------
pub type MeasureDefinitionContextAll<'input> = MeasureDefinitionContext<'input>;


pub type MeasureDefinitionContext<'input> = BaseParserRuleContext<'input,MeasureDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct MeasureDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for MeasureDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for MeasureDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_measureDefinition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_measureDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for MeasureDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_measureDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for MeasureDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_measureDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_measureDefinition }
}
antlr_rust::tid!{MeasureDefinitionContextExt<'a>}

impl<'input> MeasureDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MeasureDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MeasureDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MeasureDefinitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<MeasureDefinitionContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MeasureDefinitionContextAttrs<'input> for MeasureDefinitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn measureDefinition(&mut self,)
	-> Result<Rc<MeasureDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MeasureDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 178, RULE_measureDefinition);
        let mut _localctx: Rc<MeasureDefinitionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(3391);
			recog.expression()?;

			recog.base.set_state(3392);
			recog.base.match_token(AS,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(3393);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rowsPerMatch ----------------
pub type RowsPerMatchContextAll<'input> = RowsPerMatchContext<'input>;


pub type RowsPerMatchContext<'input> = BaseParserRuleContext<'input,RowsPerMatchContextExt<'input>>;

#[derive(Clone)]
pub struct RowsPerMatchContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for RowsPerMatchContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RowsPerMatchContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rowsPerMatch(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_rowsPerMatch(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RowsPerMatchContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rowsPerMatch(self);
	}
}

impl<'input> CustomRuleContext<'input> for RowsPerMatchContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rowsPerMatch }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rowsPerMatch }
}
antlr_rust::tid!{RowsPerMatchContextExt<'a>}

impl<'input> RowsPerMatchContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RowsPerMatchContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RowsPerMatchContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RowsPerMatchContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<RowsPerMatchContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ONE
/// Returns `None` if there is no child corresponding to token ONE
fn ONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ONE, 0)
}
/// Retrieves first TerminalNode corresponding to token ROW
/// Returns `None` if there is no child corresponding to token ROW
fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROW, 0)
}
/// Retrieves first TerminalNode corresponding to token PER
/// Returns `None` if there is no child corresponding to token PER
fn PER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PER, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCH
/// Returns `None` if there is no child corresponding to token MATCH
fn MATCH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCH, 0)
}
/// Retrieves first TerminalNode corresponding to token ALL
/// Returns `None` if there is no child corresponding to token ALL
fn ALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ALL, 0)
}
/// Retrieves first TerminalNode corresponding to token ROWS
/// Returns `None` if there is no child corresponding to token ROWS
fn ROWS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROWS, 0)
}
fn emptyMatchHandling(&self) -> Option<Rc<EmptyMatchHandlingContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RowsPerMatchContextAttrs<'input> for RowsPerMatchContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rowsPerMatch(&mut self,)
	-> Result<Rc<RowsPerMatchContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RowsPerMatchContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 180, RULE_rowsPerMatch);
        let mut _localctx: Rc<RowsPerMatchContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3406);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ONE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3395);
					recog.base.match_token(ONE,&mut recog.err_handler)?;

					recog.base.set_state(3396);
					recog.base.match_token(ROW,&mut recog.err_handler)?;

					recog.base.set_state(3397);
					recog.base.match_token(PER,&mut recog.err_handler)?;

					recog.base.set_state(3398);
					recog.base.match_token(MATCH,&mut recog.err_handler)?;

					}
				}

			 ALL 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3399);
					recog.base.match_token(ALL,&mut recog.err_handler)?;

					recog.base.set_state(3400);
					recog.base.match_token(ROWS,&mut recog.err_handler)?;

					recog.base.set_state(3401);
					recog.base.match_token(PER,&mut recog.err_handler)?;

					recog.base.set_state(3402);
					recog.base.match_token(MATCH,&mut recog.err_handler)?;

					recog.base.set_state(3404);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==OMIT || _la==SHOW || _la==WITH {
						{
						/*InvokeRule emptyMatchHandling*/
						recog.base.set_state(3403);
						recog.emptyMatchHandling()?;

						}
					}

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- emptyMatchHandling ----------------
pub type EmptyMatchHandlingContextAll<'input> = EmptyMatchHandlingContext<'input>;


pub type EmptyMatchHandlingContext<'input> = BaseParserRuleContext<'input,EmptyMatchHandlingContextExt<'input>>;

#[derive(Clone)]
pub struct EmptyMatchHandlingContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for EmptyMatchHandlingContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for EmptyMatchHandlingContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_emptyMatchHandling(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_emptyMatchHandling(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for EmptyMatchHandlingContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_emptyMatchHandling(self);
	}
}

impl<'input> CustomRuleContext<'input> for EmptyMatchHandlingContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_emptyMatchHandling }
	//fn type_rule_index() -> usize where Self: Sized { RULE_emptyMatchHandling }
}
antlr_rust::tid!{EmptyMatchHandlingContextExt<'a>}

impl<'input> EmptyMatchHandlingContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<EmptyMatchHandlingContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,EmptyMatchHandlingContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait EmptyMatchHandlingContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<EmptyMatchHandlingContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SHOW
/// Returns `None` if there is no child corresponding to token SHOW
fn SHOW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SHOW, 0)
}
/// Retrieves first TerminalNode corresponding to token EMPTY
/// Returns `None` if there is no child corresponding to token EMPTY
fn EMPTY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EMPTY, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCHES
/// Returns `None` if there is no child corresponding to token MATCHES
fn MATCHES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCHES, 0)
}
/// Retrieves first TerminalNode corresponding to token OMIT
/// Returns `None` if there is no child corresponding to token OMIT
fn OMIT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OMIT, 0)
}
/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}
/// Retrieves first TerminalNode corresponding to token UNMATCHED
/// Returns `None` if there is no child corresponding to token UNMATCHED
fn UNMATCHED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNMATCHED, 0)
}
/// Retrieves first TerminalNode corresponding to token ROWS
/// Returns `None` if there is no child corresponding to token ROWS
fn ROWS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROWS, 0)
}

}

impl<'input> EmptyMatchHandlingContextAttrs<'input> for EmptyMatchHandlingContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn emptyMatchHandling(&mut self,)
	-> Result<Rc<EmptyMatchHandlingContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = EmptyMatchHandlingContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 182, RULE_emptyMatchHandling);
        let mut _localctx: Rc<EmptyMatchHandlingContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3417);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 SHOW 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3408);
					recog.base.match_token(SHOW,&mut recog.err_handler)?;

					recog.base.set_state(3409);
					recog.base.match_token(EMPTY,&mut recog.err_handler)?;

					recog.base.set_state(3410);
					recog.base.match_token(MATCHES,&mut recog.err_handler)?;

					}
				}

			 OMIT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3411);
					recog.base.match_token(OMIT,&mut recog.err_handler)?;

					recog.base.set_state(3412);
					recog.base.match_token(EMPTY,&mut recog.err_handler)?;

					recog.base.set_state(3413);
					recog.base.match_token(MATCHES,&mut recog.err_handler)?;

					}
				}

			 WITH 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3414);
					recog.base.match_token(WITH,&mut recog.err_handler)?;

					recog.base.set_state(3415);
					recog.base.match_token(UNMATCHED,&mut recog.err_handler)?;

					recog.base.set_state(3416);
					recog.base.match_token(ROWS,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- skipTo ----------------
pub type SkipToContextAll<'input> = SkipToContext<'input>;


pub type SkipToContext<'input> = BaseParserRuleContext<'input,SkipToContextExt<'input>>;

#[derive(Clone)]
pub struct SkipToContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SkipToContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SkipToContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_skipTo(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_skipTo(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SkipToContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_skipTo(self);
	}
}

impl<'input> CustomRuleContext<'input> for SkipToContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_skipTo }
	//fn type_rule_index() -> usize where Self: Sized { RULE_skipTo }
}
antlr_rust::tid!{SkipToContextExt<'a>}

impl<'input> SkipToContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SkipToContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SkipToContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SkipToContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SkipToContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token SKIP_KW
/// Returns `None` if there is no child corresponding to token SKIP_KW
fn SKIP_KW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SKIP_KW, 0)
}
/// Retrieves first TerminalNode corresponding to token TO
/// Returns `None` if there is no child corresponding to token TO
fn TO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TO, 0)
}
/// Retrieves first TerminalNode corresponding to token NEXT
/// Returns `None` if there is no child corresponding to token NEXT
fn NEXT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NEXT, 0)
}
/// Retrieves first TerminalNode corresponding to token ROW
/// Returns `None` if there is no child corresponding to token ROW
fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROW, 0)
}
/// Retrieves first TerminalNode corresponding to token PAST
/// Returns `None` if there is no child corresponding to token PAST
fn PAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PAST, 0)
}
/// Retrieves first TerminalNode corresponding to token LAST
/// Returns `None` if there is no child corresponding to token LAST
fn LAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LAST, 0)
}
/// Retrieves first TerminalNode corresponding to token FIRST
/// Returns `None` if there is no child corresponding to token FIRST
fn FIRST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FIRST, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> SkipToContextAttrs<'input> for SkipToContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn skipTo(&mut self,)
	-> Result<Rc<SkipToContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SkipToContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 184, RULE_skipTo);
        let mut _localctx: Rc<SkipToContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3438);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(517,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3419);
					recog.base.match_token(SKIP_KW,&mut recog.err_handler)?;

					recog.base.set_state(3420);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					recog.base.set_state(3421);
					recog.base.match_token(NEXT,&mut recog.err_handler)?;

					recog.base.set_state(3422);
					recog.base.match_token(ROW,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3423);
					recog.base.match_token(SKIP_KW,&mut recog.err_handler)?;

					recog.base.set_state(3424);
					recog.base.match_token(PAST,&mut recog.err_handler)?;

					recog.base.set_state(3425);
					recog.base.match_token(LAST,&mut recog.err_handler)?;

					recog.base.set_state(3426);
					recog.base.match_token(ROW,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3427);
					recog.base.match_token(SKIP_KW,&mut recog.err_handler)?;

					recog.base.set_state(3428);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					recog.base.set_state(3429);
					recog.base.match_token(FIRST,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(3430);
					recog.identifier()?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(3431);
					recog.base.match_token(SKIP_KW,&mut recog.err_handler)?;

					recog.base.set_state(3432);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					recog.base.set_state(3433);
					recog.base.match_token(LAST,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(3434);
					recog.identifier()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(3435);
					recog.base.match_token(SKIP_KW,&mut recog.err_handler)?;

					recog.base.set_state(3436);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(3437);
					recog.identifier()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- subsetDefinition ----------------
pub type SubsetDefinitionContextAll<'input> = SubsetDefinitionContext<'input>;


pub type SubsetDefinitionContext<'input> = BaseParserRuleContext<'input,SubsetDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct SubsetDefinitionContextExt<'input>{
	pub name: Option<Rc<IdentifierContextAll<'input>>>,
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub union:Vec<Rc<IdentifierContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SubsetDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SubsetDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_subsetDefinition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_subsetDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SubsetDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_subsetDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for SubsetDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_subsetDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_subsetDefinition }
}
antlr_rust::tid!{SubsetDefinitionContextExt<'a>}

impl<'input> SubsetDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SubsetDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SubsetDefinitionContextExt{
				tail: None, 
				name: None, identifier: None, 
				union: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait SubsetDefinitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SubsetDefinitionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EQ
/// Returns `None` if there is no child corresponding to token EQ
fn EQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EQ, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> SubsetDefinitionContextAttrs<'input> for SubsetDefinitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn subsetDefinition(&mut self,)
	-> Result<Rc<SubsetDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SubsetDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 186, RULE_subsetDefinition);
        let mut _localctx: Rc<SubsetDefinitionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(3440);
			let tmp = recog.identifier()?;
			 cast_mut::<_,SubsetDefinitionContext >(&mut _localctx).name = Some(tmp.clone());
			  

			recog.base.set_state(3441);
			recog.base.match_token(EQ,&mut recog.err_handler)?;

			recog.base.set_state(3442);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(3443);
			let tmp = recog.identifier()?;
			 cast_mut::<_,SubsetDefinitionContext >(&mut _localctx).identifier = Some(tmp.clone());
			  

			let temp =  cast_mut::<_,SubsetDefinitionContext >(&mut _localctx).identifier.clone().unwrap()
			 ;
			 cast_mut::<_,SubsetDefinitionContext >(&mut _localctx).union.push(temp);
			  
			recog.base.set_state(3448);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(518,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3444);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(3445);
					let tmp = recog.identifier()?;
					 cast_mut::<_,SubsetDefinitionContext >(&mut _localctx).identifier = Some(tmp.clone());
					  

					let temp =  cast_mut::<_,SubsetDefinitionContext >(&mut _localctx).identifier.clone().unwrap()
					 ;
					 cast_mut::<_,SubsetDefinitionContext >(&mut _localctx).union.push(temp);
					  
					}
					} 
				}
				recog.base.set_state(3450);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(518,&mut recog.base)?;
			}
			recog.base.set_state(3452);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(3451);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,SubsetDefinitionContext >(&mut _localctx).tail = Some(tmp);
				  

				}
			}

			recog.base.set_state(3454);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- variableDefinition ----------------
pub type VariableDefinitionContextAll<'input> = VariableDefinitionContext<'input>;


pub type VariableDefinitionContext<'input> = BaseParserRuleContext<'input,VariableDefinitionContextExt<'input>>;

#[derive(Clone)]
pub struct VariableDefinitionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for VariableDefinitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for VariableDefinitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_variableDefinition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_variableDefinition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for VariableDefinitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_variableDefinition(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableDefinitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_variableDefinition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_variableDefinition }
}
antlr_rust::tid!{VariableDefinitionContextExt<'a>}

impl<'input> VariableDefinitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<VariableDefinitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,VariableDefinitionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait VariableDefinitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<VariableDefinitionContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> VariableDefinitionContextAttrs<'input> for VariableDefinitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn variableDefinition(&mut self,)
	-> Result<Rc<VariableDefinitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = VariableDefinitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 188, RULE_variableDefinition);
        let mut _localctx: Rc<VariableDefinitionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(3456);
			recog.identifier()?;

			recog.base.set_state(3457);
			recog.base.match_token(AS,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(3458);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- atBefore ----------------
pub type AtBeforeContextAll<'input> = AtBeforeContext<'input>;


pub type AtBeforeContext<'input> = BaseParserRuleContext<'input,AtBeforeContextExt<'input>>;

#[derive(Clone)]
pub struct AtBeforeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for AtBeforeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AtBeforeContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_atBefore(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_atBefore(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AtBeforeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_atBefore(self);
	}
}

impl<'input> CustomRuleContext<'input> for AtBeforeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_atBefore }
	//fn type_rule_index() -> usize where Self: Sized { RULE_atBefore }
}
antlr_rust::tid!{AtBeforeContextExt<'a>}

impl<'input> AtBeforeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AtBeforeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AtBeforeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AtBeforeContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<AtBeforeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token TIMESTAMP
/// Returns `None` if there is no child corresponding to token TIMESTAMP
fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIMESTAMP, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OFFSET
/// Returns `None` if there is no child corresponding to token OFFSET
fn OFFSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OFFSET, 0)
}
/// Retrieves first TerminalNode corresponding to token STATEMENT
/// Returns `None` if there is no child corresponding to token STATEMENT
fn STATEMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STATEMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token STREAM
/// Returns `None` if there is no child corresponding to token STREAM
fn STREAM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STREAM, 0)
}
fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token BEFORE
/// Returns `None` if there is no child corresponding to token BEFORE
fn BEFORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BEFORE, 0)
}

}

impl<'input> AtBeforeContextAttrs<'input> for AtBeforeContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn atBefore(&mut self,)
	-> Result<Rc<AtBeforeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AtBeforeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 190, RULE_atBefore);
        let mut _localctx: Rc<AtBeforeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3485);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 AT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3460);
					recog.base.match_token(AT,&mut recog.err_handler)?;

					recog.base.set_state(3461);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3474);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 TIMESTAMP 
						=> {
							{
							recog.base.set_state(3462);
							recog.base.match_token(TIMESTAMP,&mut recog.err_handler)?;

							recog.base.set_state(3463);
							recog.base.match_token(T__0,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(3464);
							recog.expression()?;

							}
						}

					 OFFSET 
						=> {
							{
							recog.base.set_state(3465);
							recog.base.match_token(OFFSET,&mut recog.err_handler)?;

							recog.base.set_state(3466);
							recog.base.match_token(T__0,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(3467);
							recog.expression()?;

							}
						}

					 STATEMENT 
						=> {
							{
							recog.base.set_state(3468);
							recog.base.match_token(STATEMENT,&mut recog.err_handler)?;

							recog.base.set_state(3469);
							recog.base.match_token(T__0,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(3470);
							recog.expression()?;

							}
						}

					 STREAM 
						=> {
							{
							recog.base.set_state(3471);
							recog.base.match_token(STREAM,&mut recog.err_handler)?;

							recog.base.set_state(3472);
							recog.base.match_token(T__0,&mut recog.err_handler)?;

							/*InvokeRule string*/
							recog.base.set_state(3473);
							recog.string()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(3476);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

			 BEFORE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3478);
					recog.base.match_token(BEFORE,&mut recog.err_handler)?;

					recog.base.set_state(3479);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3480);
					recog.base.match_token(STATEMENT,&mut recog.err_handler)?;

					recog.base.set_state(3481);
					recog.base.match_token(T__0,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(3482);
					recog.expression()?;

					recog.base.set_state(3483);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- changeRelationTarget ----------------
#[derive(Debug)]
pub enum ChangeRelationTargetContextAll<'input>{
	AliasedContext(AliasedContext<'input>),
	DirectoryContext(DirectoryContext<'input>),
Error(ChangeRelationTargetContext<'input>)
}
antlr_rust::tid!{ChangeRelationTargetContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ChangeRelationTargetContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for ChangeRelationTargetContextAll<'input>{}

impl<'input> Deref for ChangeRelationTargetContextAll<'input>{
	type Target = dyn ChangeRelationTargetContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use ChangeRelationTargetContextAll::*;
		match self{
			AliasedContext(inner) => inner,
			DirectoryContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ChangeRelationTargetContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ChangeRelationTargetContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type ChangeRelationTargetContext<'input> = BaseParserRuleContext<'input,ChangeRelationTargetContextExt<'input>>;

#[derive(Clone)]
pub struct ChangeRelationTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ChangeRelationTargetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ChangeRelationTargetContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ChangeRelationTargetContext<'input>{
}

impl<'input> CustomRuleContext<'input> for ChangeRelationTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_changeRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_changeRelationTarget }
}
antlr_rust::tid!{ChangeRelationTargetContextExt<'a>}

impl<'input> ChangeRelationTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ChangeRelationTargetContextAll<'input>> {
		Rc::new(
		ChangeRelationTargetContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ChangeRelationTargetContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait ChangeRelationTargetContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ChangeRelationTargetContextExt<'input>>{


}

impl<'input> ChangeRelationTargetContextAttrs<'input> for ChangeRelationTargetContext<'input>{}

pub type AliasedContext<'input> = BaseParserRuleContext<'input,AliasedContextExt<'input>>;

pub trait AliasedContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn aliasedRelation(&self) -> Option<Rc<AliasedRelationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> AliasedContextAttrs<'input> for AliasedContext<'input>{}

pub struct AliasedContextExt<'input>{
	base:ChangeRelationTargetContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{AliasedContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for AliasedContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AliasedContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_aliased(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_aliased(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AliasedContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_aliased(self);
	}
}

impl<'input> CustomRuleContext<'input> for AliasedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_changeRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_changeRelationTarget }
}

impl<'input> Borrow<ChangeRelationTargetContextExt<'input>> for AliasedContext<'input>{
	fn borrow(&self) -> &ChangeRelationTargetContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ChangeRelationTargetContextExt<'input>> for AliasedContext<'input>{
	fn borrow_mut(&mut self) -> &mut ChangeRelationTargetContextExt<'input> { &mut self.base }
}

impl<'input> ChangeRelationTargetContextAttrs<'input> for AliasedContext<'input> {}

impl<'input> AliasedContextExt<'input>{
	fn new(ctx: &dyn ChangeRelationTargetContextAttrs<'input>) -> Rc<ChangeRelationTargetContextAll<'input>>  {
		Rc::new(
			ChangeRelationTargetContextAll::AliasedContext(
				BaseParserRuleContext::copy_from(ctx,AliasedContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DirectoryContext<'input> = BaseParserRuleContext<'input,DirectoryContextExt<'input>>;

pub trait DirectoryContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DIRECTORY
	/// Returns `None` if there is no child corresponding to token DIRECTORY
	fn DIRECTORY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DIRECTORY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STAGE_NAME
	/// Returns `None` if there is no child corresponding to token STAGE_NAME
	fn STAGE_NAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STAGE_NAME, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> DirectoryContextAttrs<'input> for DirectoryContext<'input>{}

pub struct DirectoryContextExt<'input>{
	base:ChangeRelationTargetContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DirectoryContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DirectoryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DirectoryContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_directory(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_directory(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DirectoryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_directory(self);
	}
}

impl<'input> CustomRuleContext<'input> for DirectoryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_changeRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_changeRelationTarget }
}

impl<'input> Borrow<ChangeRelationTargetContextExt<'input>> for DirectoryContext<'input>{
	fn borrow(&self) -> &ChangeRelationTargetContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ChangeRelationTargetContextExt<'input>> for DirectoryContext<'input>{
	fn borrow_mut(&mut self) -> &mut ChangeRelationTargetContextExt<'input> { &mut self.base }
}

impl<'input> ChangeRelationTargetContextAttrs<'input> for DirectoryContext<'input> {}

impl<'input> DirectoryContextExt<'input>{
	fn new(ctx: &dyn ChangeRelationTargetContextAttrs<'input>) -> Rc<ChangeRelationTargetContextAll<'input>>  {
		Rc::new(
			ChangeRelationTargetContextAll::DirectoryContext(
				BaseParserRuleContext::copy_from(ctx,DirectoryContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn changeRelationTarget(&mut self,)
	-> Result<Rc<ChangeRelationTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ChangeRelationTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 192, RULE_changeRelationTarget);
        let mut _localctx: Rc<ChangeRelationTargetContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3492);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(522,&mut recog.base)? {
				1 =>{
					let tmp = AliasedContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule aliasedRelation*/
					recog.base.set_state(3487);
					recog.aliasedRelation()?;

					}
				}
			,
				2 =>{
					let tmp = DirectoryContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(3488);
					recog.base.match_token(DIRECTORY,&mut recog.err_handler)?;

					recog.base.set_state(3489);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3490);
					recog.base.match_token(STAGE_NAME,&mut recog.err_handler)?;

					recog.base.set_state(3491);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- changesRelation ----------------
pub type ChangesRelationContextAll<'input> = ChangesRelationContext<'input>;


pub type ChangesRelationContext<'input> = BaseParserRuleContext<'input,ChangesRelationContextExt<'input>>;

#[derive(Clone)]
pub struct ChangesRelationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ChangesRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ChangesRelationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_changesRelation(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_changesRelation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ChangesRelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_changesRelation(self);
	}
}

impl<'input> CustomRuleContext<'input> for ChangesRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_changesRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_changesRelation }
}
antlr_rust::tid!{ChangesRelationContextExt<'a>}

impl<'input> ChangesRelationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ChangesRelationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ChangesRelationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ChangesRelationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ChangesRelationContextExt<'input>>{

fn changeRelationTarget(&self) -> Option<Rc<ChangeRelationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn atBefore_all(&self) ->  Vec<Rc<AtBeforeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn atBefore(&self, i: usize) -> Option<Rc<AtBeforeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token CHANGES
/// Returns `None` if there is no child corresponding to token CHANGES
fn CHANGES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CHANGES, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, i)
}
/// Retrieves first TerminalNode corresponding to token INFORMATION
/// Returns `None` if there is no child corresponding to token INFORMATION
fn INFORMATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INFORMATION, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, i)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
/// Retrieves first TerminalNode corresponding to token APPEND_ONLY
/// Returns `None` if there is no child corresponding to token APPEND_ONLY
fn APPEND_ONLY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(APPEND_ONLY, 0)
}
/// Retrieves first TerminalNode corresponding to token END
/// Returns `None` if there is no child corresponding to token END
fn END(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(END, 0)
}
/// Retrieves first TerminalNode corresponding to token TIMESTAMP
/// Returns `None` if there is no child corresponding to token TIMESTAMP
fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIMESTAMP, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OFFSET
/// Returns `None` if there is no child corresponding to token OFFSET
fn OFFSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OFFSET, 0)
}
/// Retrieves first TerminalNode corresponding to token STATEMENT
/// Returns `None` if there is no child corresponding to token STATEMENT
fn STATEMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STATEMENT, 0)
}

}

impl<'input> ChangesRelationContextAttrs<'input> for ChangesRelationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn changesRelation(&mut self,)
	-> Result<Rc<ChangesRelationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ChangesRelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 194, RULE_changesRelation);
        let mut _localctx: Rc<ChangesRelationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule changeRelationTarget*/
			recog.base.set_state(3494);
			recog.changeRelationTarget()?;

			recog.base.set_state(3496);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(523,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule atBefore*/
					recog.base.set_state(3495);
					recog.atBefore()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(3522);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(526,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(3498);
					recog.base.match_token(CHANGES,&mut recog.err_handler)?;

					recog.base.set_state(3499);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3500);
					recog.base.match_token(INFORMATION,&mut recog.err_handler)?;

					recog.base.set_state(3501);
					recog.base.match_token(T__0,&mut recog.err_handler)?;

					recog.base.set_state(3502);
					_la = recog.base.input.la(1);
					if { !(_la==APPEND_ONLY || _la==DEFAULT) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(3503);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule atBefore*/
					recog.base.set_state(3504);
					recog.atBefore()?;

					recog.base.set_state(3520);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(525,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3505);
							recog.base.match_token(END,&mut recog.err_handler)?;

							recog.base.set_state(3506);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							recog.base.set_state(3516);
							recog.err_handler.sync(&mut recog.base)?;
							match recog.base.input.la(1) {
							 TIMESTAMP 
								=> {
									{
									recog.base.set_state(3507);
									recog.base.match_token(TIMESTAMP,&mut recog.err_handler)?;

									recog.base.set_state(3508);
									recog.base.match_token(T__0,&mut recog.err_handler)?;

									/*InvokeRule expression*/
									recog.base.set_state(3509);
									recog.expression()?;

									}
								}

							 OFFSET 
								=> {
									{
									recog.base.set_state(3510);
									recog.base.match_token(OFFSET,&mut recog.err_handler)?;

									recog.base.set_state(3511);
									recog.base.match_token(T__0,&mut recog.err_handler)?;

									/*InvokeRule expression*/
									recog.base.set_state(3512);
									recog.expression()?;

									}
								}

							 STATEMENT 
								=> {
									{
									recog.base.set_state(3513);
									recog.base.match_token(STATEMENT,&mut recog.err_handler)?;

									recog.base.set_state(3514);
									recog.base.match_token(T__0,&mut recog.err_handler)?;

									/*InvokeRule expression*/
									recog.base.set_state(3515);
									recog.expression()?;

									}
								}

								_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
							}
							recog.base.set_state(3518);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pivotedRelationTarget ----------------
#[derive(Debug)]
pub enum PivotedRelationTargetContextAll<'input>{
	PatternContext(PatternContext<'input>),
	TableFunctionInvocationContext(TableFunctionInvocationContext<'input>),
Error(PivotedRelationTargetContext<'input>)
}
antlr_rust::tid!{PivotedRelationTargetContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PivotedRelationTargetContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PivotedRelationTargetContextAll<'input>{}

impl<'input> Deref for PivotedRelationTargetContextAll<'input>{
	type Target = dyn PivotedRelationTargetContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PivotedRelationTargetContextAll::*;
		match self{
			PatternContext(inner) => inner,
			TableFunctionInvocationContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotedRelationTargetContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotedRelationTargetContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PivotedRelationTargetContext<'input> = BaseParserRuleContext<'input,PivotedRelationTargetContextExt<'input>>;

#[derive(Clone)]
pub struct PivotedRelationTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PivotedRelationTargetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotedRelationTargetContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotedRelationTargetContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PivotedRelationTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotedRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotedRelationTarget }
}
antlr_rust::tid!{PivotedRelationTargetContextExt<'a>}

impl<'input> PivotedRelationTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PivotedRelationTargetContextAll<'input>> {
		Rc::new(
		PivotedRelationTargetContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PivotedRelationTargetContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PivotedRelationTargetContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PivotedRelationTargetContextExt<'input>>{


}

impl<'input> PivotedRelationTargetContextAttrs<'input> for PivotedRelationTargetContext<'input>{}

pub type PatternContext<'input> = BaseParserRuleContext<'input,PatternContextExt<'input>>;

pub trait PatternContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn patternRecognition(&self) -> Option<Rc<PatternRecognitionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> PatternContextAttrs<'input> for PatternContext<'input>{}

pub struct PatternContextExt<'input>{
	base:PivotedRelationTargetContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PatternContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PatternContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_pattern(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_pattern(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotedRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotedRelationTarget }
}

impl<'input> Borrow<PivotedRelationTargetContextExt<'input>> for PatternContext<'input>{
	fn borrow(&self) -> &PivotedRelationTargetContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PivotedRelationTargetContextExt<'input>> for PatternContext<'input>{
	fn borrow_mut(&mut self) -> &mut PivotedRelationTargetContextExt<'input> { &mut self.base }
}

impl<'input> PivotedRelationTargetContextAttrs<'input> for PatternContext<'input> {}

impl<'input> PatternContextExt<'input>{
	fn new(ctx: &dyn PivotedRelationTargetContextAttrs<'input>) -> Rc<PivotedRelationTargetContextAll<'input>>  {
		Rc::new(
			PivotedRelationTargetContextAll::PatternContext(
				BaseParserRuleContext::copy_from(ctx,PatternContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TableFunctionInvocationContext<'input> = BaseParserRuleContext<'input,TableFunctionInvocationContextExt<'input>>;

pub trait TableFunctionInvocationContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn tableFunctionCall(&self) -> Option<Rc<TableFunctionCallContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> TableFunctionInvocationContextAttrs<'input> for TableFunctionInvocationContext<'input>{}

pub struct TableFunctionInvocationContextExt<'input>{
	base:PivotedRelationTargetContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TableFunctionInvocationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TableFunctionInvocationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableFunctionInvocationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tableFunctionInvocation(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_tableFunctionInvocation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableFunctionInvocationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableFunctionInvocation(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableFunctionInvocationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotedRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotedRelationTarget }
}

impl<'input> Borrow<PivotedRelationTargetContextExt<'input>> for TableFunctionInvocationContext<'input>{
	fn borrow(&self) -> &PivotedRelationTargetContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PivotedRelationTargetContextExt<'input>> for TableFunctionInvocationContext<'input>{
	fn borrow_mut(&mut self) -> &mut PivotedRelationTargetContextExt<'input> { &mut self.base }
}

impl<'input> PivotedRelationTargetContextAttrs<'input> for TableFunctionInvocationContext<'input> {}

impl<'input> TableFunctionInvocationContextExt<'input>{
	fn new(ctx: &dyn PivotedRelationTargetContextAttrs<'input>) -> Rc<PivotedRelationTargetContextAll<'input>>  {
		Rc::new(
			PivotedRelationTargetContextAll::TableFunctionInvocationContext(
				BaseParserRuleContext::copy_from(ctx,TableFunctionInvocationContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pivotedRelationTarget(&mut self,)
	-> Result<Rc<PivotedRelationTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PivotedRelationTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 196, RULE_pivotedRelationTarget);
        let mut _localctx: Rc<PivotedRelationTargetContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3530);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(527,&mut recog.base)? {
				1 =>{
					let tmp = PatternContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule patternRecognition*/
					recog.base.set_state(3524);
					recog.patternRecognition()?;

					}
				}
			,
				2 =>{
					let tmp = TableFunctionInvocationContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(3525);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(3526);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule tableFunctionCall*/
					recog.base.set_state(3527);
					recog.tableFunctionCall()?;

					recog.base.set_state(3528);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pivotedRelation ----------------
pub type PivotedRelationContextAll<'input> = PivotedRelationContext<'input>;


pub type PivotedRelationContext<'input> = BaseParserRuleContext<'input,PivotedRelationContextExt<'input>>;

#[derive(Clone)]
pub struct PivotedRelationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PivotedRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotedRelationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pivotedRelation(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_pivotedRelation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotedRelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pivotedRelation(self);
	}
}

impl<'input> CustomRuleContext<'input> for PivotedRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotedRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotedRelation }
}
antlr_rust::tid!{PivotedRelationContextExt<'a>}

impl<'input> PivotedRelationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PivotedRelationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PivotedRelationContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PivotedRelationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PivotedRelationContextExt<'input>>{

fn pivotedRelationTarget(&self) -> Option<Rc<PivotedRelationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn pivotOperator_all(&self) ->  Vec<Rc<PivotOperatorContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn pivotOperator(&self, i: usize) -> Option<Rc<PivotOperatorContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> PivotedRelationContextAttrs<'input> for PivotedRelationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pivotedRelation(&mut self,)
	-> Result<Rc<PivotedRelationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PivotedRelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 198, RULE_pivotedRelation);
        let mut _localctx: Rc<PivotedRelationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule pivotedRelationTarget*/
			recog.base.set_state(3532);
			recog.pivotedRelationTarget()?;

			recog.base.set_state(3536);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(528,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					/*InvokeRule pivotOperator*/
					recog.base.set_state(3533);
					recog.pivotOperator()?;

					}
					} 
				}
				recog.base.set_state(3538);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(528,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aliasedRelation2 ----------------
pub type AliasedRelation2ContextAll<'input> = AliasedRelation2Context<'input>;


pub type AliasedRelation2Context<'input> = BaseParserRuleContext<'input,AliasedRelation2ContextExt<'input>>;

#[derive(Clone)]
pub struct AliasedRelation2ContextExt<'input>{
	pub alias1: Option<Rc<IdentifierContextAll<'input>>>,
	pub alias2: Option<Rc<StrictIdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for AliasedRelation2Context<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AliasedRelation2Context<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aliasedRelation2(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_aliasedRelation2(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AliasedRelation2Context<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_aliasedRelation2(self);
	}
}

impl<'input> CustomRuleContext<'input> for AliasedRelation2ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aliasedRelation2 }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aliasedRelation2 }
}
antlr_rust::tid!{AliasedRelation2ContextExt<'a>}

impl<'input> AliasedRelation2ContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AliasedRelation2ContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AliasedRelation2ContextExt{
				alias1: None, alias2: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait AliasedRelation2ContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<AliasedRelation2ContextExt<'input>>{

fn pivotedRelation(&self) -> Option<Rc<PivotedRelationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn strictIdentifier(&self) -> Option<Rc<StrictIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AliasedRelation2ContextAttrs<'input> for AliasedRelation2Context<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aliasedRelation2(&mut self,)
	-> Result<Rc<AliasedRelation2ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AliasedRelation2ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 200, RULE_aliasedRelation2);
        let mut _localctx: Rc<AliasedRelation2ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule pivotedRelation*/
			recog.base.set_state(3539);
			recog.pivotedRelation()?;

			recog.base.set_state(3548);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(531,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(3543);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 AS 
						=> {
							{
							recog.base.set_state(3540);
							recog.base.match_token(AS,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(3541);
							let tmp = recog.identifier()?;
							 cast_mut::<_,AliasedRelation2Context >(&mut _localctx).alias1 = Some(tmp.clone());
							  

							}
						}

					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CUBE | CURRENT_ROLE | DATA |
					 DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
					 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
					 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
					 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC |
					 EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE |
					 EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
					 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
					 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FUNCTION |
					 FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS | GRAPHVIZ |
					 GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
					 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
					 INFORMATION | INITIAL | INITIALLY | INPUT | INPUTFORMAT | INTERLEAVED |
					 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JSON | JSON_ARRAY |
					 JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP | KEY |
					 KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LEADING | LEVEL |
					 LIBRARY | LIMIT | LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL |
					 MAP | MASKING | MATCH | MATCHED | MATCHES | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE |
					 NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULLS | OBJECT | OFFSET |
					 OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER | OUTPUT |
					 OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RLS |
					 ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR | SECOND |
					 SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI | SEQUENCE |
					 SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR |
					 SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED |
					 STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME |
					 TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW |
					 TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION |
					 TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE |
					 UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED |
					 UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER | UTF16 | UTF32 |
					 UTF8 | VACUUM | VALIDATE | VALUE | VARYING | VECTOR | VERBOSE | VERSION |
					 VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN | WITHOUT | WORK |
					 WRAPPER | WRITE | XZ | YEAR | YES | ZONE | ZSTD | IDENTIFIER | QUOTED_IDENTIFIER |
					 BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule strictIdentifier*/
							recog.base.set_state(3542);
							let tmp = recog.strictIdentifier()?;
							 cast_mut::<_,AliasedRelation2Context >(&mut _localctx).alias2 = Some(tmp.clone());
							  

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(3546);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(530,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule columnAliases*/
							recog.base.set_state(3545);
							recog.columnAliases()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pivotAggregates ----------------
pub type PivotAggregatesContextAll<'input> = PivotAggregatesContext<'input>;


pub type PivotAggregatesContext<'input> = BaseParserRuleContext<'input,PivotAggregatesContextExt<'input>>;

#[derive(Clone)]
pub struct PivotAggregatesContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PivotAggregatesContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotAggregatesContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pivotAggregates(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_pivotAggregates(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotAggregatesContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pivotAggregates(self);
	}
}

impl<'input> CustomRuleContext<'input> for PivotAggregatesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotAggregates }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotAggregates }
}
antlr_rust::tid!{PivotAggregatesContextExt<'a>}

impl<'input> PivotAggregatesContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PivotAggregatesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PivotAggregatesContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PivotAggregatesContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PivotAggregatesContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PivotAggregatesContextAttrs<'input> for PivotAggregatesContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pivotAggregates(&mut self,)
	-> Result<Rc<PivotAggregatesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PivotAggregatesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 202, RULE_pivotAggregates);
        let mut _localctx: Rc<PivotAggregatesContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(3550);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pivotFrom ----------------
pub type PivotFromContextAll<'input> = PivotFromContext<'input>;


pub type PivotFromContext<'input> = BaseParserRuleContext<'input,PivotFromContextExt<'input>>;

#[derive(Clone)]
pub struct PivotFromContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PivotFromContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotFromContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pivotFrom(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_pivotFrom(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotFromContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pivotFrom(self);
	}
}

impl<'input> CustomRuleContext<'input> for PivotFromContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotFrom }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotFrom }
}
antlr_rust::tid!{PivotFromContextExt<'a>}

impl<'input> PivotFromContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PivotFromContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PivotFromContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PivotFromContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PivotFromContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PivotFromContextAttrs<'input> for PivotFromContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pivotFrom(&mut self,)
	-> Result<Rc<PivotFromContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PivotFromContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 204, RULE_pivotFrom);
        let mut _localctx: Rc<PivotFromContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(3552);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pivotInto ----------------
#[derive(Debug)]
pub enum PivotIntoContextAll<'input>{
	PivotIntoDefaultContext(PivotIntoDefaultContext<'input>),
Error(PivotIntoContext<'input>)
}
antlr_rust::tid!{PivotIntoContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PivotIntoContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PivotIntoContextAll<'input>{}

impl<'input> Deref for PivotIntoContextAll<'input>{
	type Target = dyn PivotIntoContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PivotIntoContextAll::*;
		match self{
			PivotIntoDefaultContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotIntoContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotIntoContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PivotIntoContext<'input> = BaseParserRuleContext<'input,PivotIntoContextExt<'input>>;

#[derive(Clone)]
pub struct PivotIntoContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PivotIntoContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotIntoContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotIntoContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PivotIntoContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotInto }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotInto }
}
antlr_rust::tid!{PivotIntoContextExt<'a>}

impl<'input> PivotIntoContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PivotIntoContextAll<'input>> {
		Rc::new(
		PivotIntoContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PivotIntoContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PivotIntoContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PivotIntoContextExt<'input>>{


}

impl<'input> PivotIntoContextAttrs<'input> for PivotIntoContext<'input>{}

pub type PivotIntoDefaultContext<'input> = BaseParserRuleContext<'input,PivotIntoDefaultContextExt<'input>>;

pub trait PivotIntoDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> PivotIntoDefaultContextAttrs<'input> for PivotIntoDefaultContext<'input>{}

pub struct PivotIntoDefaultContextExt<'input>{
	base:PivotIntoContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PivotIntoDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PivotIntoDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotIntoDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_pivotIntoDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_pivotIntoDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotIntoDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pivotIntoDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for PivotIntoDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotInto }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotInto }
}

impl<'input> Borrow<PivotIntoContextExt<'input>> for PivotIntoDefaultContext<'input>{
	fn borrow(&self) -> &PivotIntoContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PivotIntoContextExt<'input>> for PivotIntoDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut PivotIntoContextExt<'input> { &mut self.base }
}

impl<'input> PivotIntoContextAttrs<'input> for PivotIntoDefaultContext<'input> {}

impl<'input> PivotIntoDefaultContextExt<'input>{
	fn new(ctx: &dyn PivotIntoContextAttrs<'input>) -> Rc<PivotIntoContextAll<'input>>  {
		Rc::new(
			PivotIntoContextAll::PivotIntoDefaultContext(
				BaseParserRuleContext::copy_from(ctx,PivotIntoDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pivotInto(&mut self,)
	-> Result<Rc<PivotIntoContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PivotIntoContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 206, RULE_pivotInto);
        let mut _localctx: Rc<PivotIntoContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let tmp = PivotIntoDefaultContextExt::new(&**_localctx);
			recog.base.enter_outer_alt(Some(tmp.clone()), 1);
			_localctx = tmp;
			{
			/*InvokeRule expression*/
			recog.base.set_state(3554);
			recog.expression()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pivotAsAlias ----------------
pub type PivotAsAliasContextAll<'input> = PivotAsAliasContext<'input>;


pub type PivotAsAliasContext<'input> = BaseParserRuleContext<'input,PivotAsAliasContextExt<'input>>;

#[derive(Clone)]
pub struct PivotAsAliasContextExt<'input>{
	pub alias1: Option<Rc<IdentifierContextAll<'input>>>,
	pub alias2: Option<Rc<StrictIdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PivotAsAliasContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotAsAliasContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pivotAsAlias(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_pivotAsAlias(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotAsAliasContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pivotAsAlias(self);
	}
}

impl<'input> CustomRuleContext<'input> for PivotAsAliasContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotAsAlias }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotAsAlias }
}
antlr_rust::tid!{PivotAsAliasContextExt<'a>}

impl<'input> PivotAsAliasContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PivotAsAliasContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PivotAsAliasContextExt{
				alias1: None, alias2: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait PivotAsAliasContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PivotAsAliasContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn strictIdentifier(&self) -> Option<Rc<StrictIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PivotAsAliasContextAttrs<'input> for PivotAsAliasContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pivotAsAlias(&mut self,)
	-> Result<Rc<PivotAsAliasContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PivotAsAliasContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 208, RULE_pivotAsAlias);
        let mut _localctx: Rc<PivotAsAliasContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3564);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(534,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(3559);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 AS 
						=> {
							{
							recog.base.set_state(3556);
							recog.base.match_token(AS,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(3557);
							let tmp = recog.identifier()?;
							 cast_mut::<_,PivotAsAliasContext >(&mut _localctx).alias1 = Some(tmp.clone());
							  

							}
						}

					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CUBE | CURRENT_ROLE | DATA |
					 DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
					 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
					 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
					 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC |
					 EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE |
					 EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
					 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
					 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FUNCTION |
					 FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS | GRAPHVIZ |
					 GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
					 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
					 INFORMATION | INITIAL | INITIALLY | INPUT | INPUTFORMAT | INTERLEAVED |
					 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JSON | JSON_ARRAY |
					 JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP | KEY |
					 KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LEADING | LEVEL |
					 LIBRARY | LIMIT | LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL |
					 MAP | MASKING | MATCH | MATCHED | MATCHES | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE |
					 NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULLS | OBJECT | OFFSET |
					 OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER | OUTPUT |
					 OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RLS |
					 ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR | SECOND |
					 SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI | SEQUENCE |
					 SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR |
					 SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED |
					 STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME |
					 TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW |
					 TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION |
					 TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE |
					 UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED |
					 UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER | UTF16 | UTF32 |
					 UTF8 | VACUUM | VALIDATE | VALUE | VARYING | VECTOR | VERBOSE | VERSION |
					 VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN | WITHOUT | WORK |
					 WRAPPER | WRITE | XZ | YEAR | YES | ZONE | ZSTD | IDENTIFIER | QUOTED_IDENTIFIER |
					 BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule strictIdentifier*/
							recog.base.set_state(3558);
							let tmp = recog.strictIdentifier()?;
							 cast_mut::<_,PivotAsAliasContext >(&mut _localctx).alias2 = Some(tmp.clone());
							  

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(3562);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(533,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule columnAliases*/
							recog.base.set_state(3561);
							recog.columnAliases()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- singleColumnUnpivot ----------------
pub type SingleColumnUnpivotContextAll<'input> = SingleColumnUnpivotContext<'input>;


pub type SingleColumnUnpivotContext<'input> = BaseParserRuleContext<'input,SingleColumnUnpivotContextExt<'input>>;

#[derive(Clone)]
pub struct SingleColumnUnpivotContextExt<'input>{
	pub valuesColumn: Option<Rc<IdentifierContextAll<'input>>>,
	pub nameColumn: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SingleColumnUnpivotContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SingleColumnUnpivotContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_singleColumnUnpivot(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_singleColumnUnpivot(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SingleColumnUnpivotContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_singleColumnUnpivot(self);
	}
}

impl<'input> CustomRuleContext<'input> for SingleColumnUnpivotContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_singleColumnUnpivot }
	//fn type_rule_index() -> usize where Self: Sized { RULE_singleColumnUnpivot }
}
antlr_rust::tid!{SingleColumnUnpivotContextExt<'a>}

impl<'input> SingleColumnUnpivotContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SingleColumnUnpivotContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SingleColumnUnpivotContextExt{
				valuesColumn: None, nameColumn: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait SingleColumnUnpivotContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SingleColumnUnpivotContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token IN
/// Returns `None` if there is no child corresponding to token IN
fn IN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IN, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn columnsToUnpivot(&self) -> Option<Rc<ColumnsToUnpivotContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> SingleColumnUnpivotContextAttrs<'input> for SingleColumnUnpivotContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn singleColumnUnpivot(&mut self,)
	-> Result<Rc<SingleColumnUnpivotContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SingleColumnUnpivotContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 210, RULE_singleColumnUnpivot);
        let mut _localctx: Rc<SingleColumnUnpivotContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(3566);
			let tmp = recog.identifier()?;
			 cast_mut::<_,SingleColumnUnpivotContext >(&mut _localctx).valuesColumn = Some(tmp.clone());
			  

			recog.base.set_state(3567);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			/*InvokeRule identifier*/
			recog.base.set_state(3568);
			let tmp = recog.identifier()?;
			 cast_mut::<_,SingleColumnUnpivotContext >(&mut _localctx).nameColumn = Some(tmp.clone());
			  

			recog.base.set_state(3569);
			recog.base.match_token(IN,&mut recog.err_handler)?;

			recog.base.set_state(3570);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule columnsToUnpivot*/
			recog.base.set_state(3571);
			recog.columnsToUnpivot()?;

			recog.base.set_state(3572);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnsToUnpivot ----------------
pub type ColumnsToUnpivotContextAll<'input> = ColumnsToUnpivotContext<'input>;


pub type ColumnsToUnpivotContext<'input> = BaseParserRuleContext<'input,ColumnsToUnpivotContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnsToUnpivotContextExt<'input>{
	pub identifier: Option<Rc<IdentifierContextAll<'input>>>,
	pub unpivotCol:Vec<Rc<IdentifierContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnsToUnpivotContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnsToUnpivotContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_columnsToUnpivot(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_columnsToUnpivot(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnsToUnpivotContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnsToUnpivot(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnsToUnpivotContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnsToUnpivot }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnsToUnpivot }
}
antlr_rust::tid!{ColumnsToUnpivotContextExt<'a>}

impl<'input> ColumnsToUnpivotContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnsToUnpivotContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnsToUnpivotContextExt{
				tail: None, 
				identifier: None, 
				unpivotCol: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnsToUnpivotContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnsToUnpivotContextExt<'input>>{

fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> ColumnsToUnpivotContextAttrs<'input> for ColumnsToUnpivotContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnsToUnpivot(&mut self,)
	-> Result<Rc<ColumnsToUnpivotContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnsToUnpivotContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 212, RULE_columnsToUnpivot);
        let mut _localctx: Rc<ColumnsToUnpivotContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(3574);
			let tmp = recog.identifier()?;
			 cast_mut::<_,ColumnsToUnpivotContext >(&mut _localctx).identifier = Some(tmp.clone());
			  

			let temp =  cast_mut::<_,ColumnsToUnpivotContext >(&mut _localctx).identifier.clone().unwrap()
			 ;
			 cast_mut::<_,ColumnsToUnpivotContext >(&mut _localctx).unpivotCol.push(temp);
			  
			recog.base.set_state(3579);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(535,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3575);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(3576);
					let tmp = recog.identifier()?;
					 cast_mut::<_,ColumnsToUnpivotContext >(&mut _localctx).identifier = Some(tmp.clone());
					  

					let temp =  cast_mut::<_,ColumnsToUnpivotContext >(&mut _localctx).identifier.clone().unwrap()
					 ;
					 cast_mut::<_,ColumnsToUnpivotContext >(&mut _localctx).unpivotCol.push(temp);
					  
					}
					} 
				}
				recog.base.set_state(3581);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(535,&mut recog.base)?;
			}
			recog.base.set_state(3583);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(3582);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,ColumnsToUnpivotContext >(&mut _localctx).tail = Some(tmp);
				  

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnUnpivot ----------------
#[derive(Debug)]
pub enum ColumnUnpivotContextAll<'input>{
	SingleColumnUnpivotDefaultContext(SingleColumnUnpivotDefaultContext<'input>),
Error(ColumnUnpivotContext<'input>)
}
antlr_rust::tid!{ColumnUnpivotContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ColumnUnpivotContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for ColumnUnpivotContextAll<'input>{}

impl<'input> Deref for ColumnUnpivotContextAll<'input>{
	type Target = dyn ColumnUnpivotContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use ColumnUnpivotContextAll::*;
		match self{
			SingleColumnUnpivotDefaultContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnUnpivotContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnUnpivotContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type ColumnUnpivotContext<'input> = BaseParserRuleContext<'input,ColumnUnpivotContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnUnpivotContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnUnpivotContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnUnpivotContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnUnpivotContext<'input>{
}

impl<'input> CustomRuleContext<'input> for ColumnUnpivotContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnUnpivot }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnUnpivot }
}
antlr_rust::tid!{ColumnUnpivotContextExt<'a>}

impl<'input> ColumnUnpivotContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnUnpivotContextAll<'input>> {
		Rc::new(
		ColumnUnpivotContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnUnpivotContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait ColumnUnpivotContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnUnpivotContextExt<'input>>{


}

impl<'input> ColumnUnpivotContextAttrs<'input> for ColumnUnpivotContext<'input>{}

pub type SingleColumnUnpivotDefaultContext<'input> = BaseParserRuleContext<'input,SingleColumnUnpivotDefaultContextExt<'input>>;

pub trait SingleColumnUnpivotDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn singleColumnUnpivot(&self) -> Option<Rc<SingleColumnUnpivotContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SingleColumnUnpivotDefaultContextAttrs<'input> for SingleColumnUnpivotDefaultContext<'input>{}

pub struct SingleColumnUnpivotDefaultContextExt<'input>{
	base:ColumnUnpivotContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SingleColumnUnpivotDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SingleColumnUnpivotDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SingleColumnUnpivotDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_singleColumnUnpivotDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_singleColumnUnpivotDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SingleColumnUnpivotDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_singleColumnUnpivotDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for SingleColumnUnpivotDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnUnpivot }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnUnpivot }
}

impl<'input> Borrow<ColumnUnpivotContextExt<'input>> for SingleColumnUnpivotDefaultContext<'input>{
	fn borrow(&self) -> &ColumnUnpivotContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ColumnUnpivotContextExt<'input>> for SingleColumnUnpivotDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut ColumnUnpivotContextExt<'input> { &mut self.base }
}

impl<'input> ColumnUnpivotContextAttrs<'input> for SingleColumnUnpivotDefaultContext<'input> {}

impl<'input> SingleColumnUnpivotDefaultContextExt<'input>{
	fn new(ctx: &dyn ColumnUnpivotContextAttrs<'input>) -> Rc<ColumnUnpivotContextAll<'input>>  {
		Rc::new(
			ColumnUnpivotContextAll::SingleColumnUnpivotDefaultContext(
				BaseParserRuleContext::copy_from(ctx,SingleColumnUnpivotDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnUnpivot(&mut self,)
	-> Result<Rc<ColumnUnpivotContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnUnpivotContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 214, RULE_columnUnpivot);
        let mut _localctx: Rc<ColumnUnpivotContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let tmp = SingleColumnUnpivotDefaultContextExt::new(&**_localctx);
			recog.base.enter_outer_alt(Some(tmp.clone()), 1);
			_localctx = tmp;
			{
			/*InvokeRule singleColumnUnpivot*/
			recog.base.set_state(3585);
			recog.singleColumnUnpivot()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pivotIntos ----------------
#[derive(Debug)]
pub enum PivotIntosContextAll<'input>{
	PivotIntosAnyContext(PivotIntosAnyContext<'input>),
	PivotIntosDefaultContext(PivotIntosDefaultContext<'input>),
	PivotIntosQueryContext(PivotIntosQueryContext<'input>),
Error(PivotIntosContext<'input>)
}
antlr_rust::tid!{PivotIntosContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PivotIntosContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PivotIntosContextAll<'input>{}

impl<'input> Deref for PivotIntosContextAll<'input>{
	type Target = dyn PivotIntosContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PivotIntosContextAll::*;
		match self{
			PivotIntosAnyContext(inner) => inner,
			PivotIntosDefaultContext(inner) => inner,
			PivotIntosQueryContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotIntosContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotIntosContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PivotIntosContext<'input> = BaseParserRuleContext<'input,PivotIntosContextExt<'input>>;

#[derive(Clone)]
pub struct PivotIntosContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PivotIntosContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotIntosContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotIntosContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PivotIntosContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotIntos }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotIntos }
}
antlr_rust::tid!{PivotIntosContextExt<'a>}

impl<'input> PivotIntosContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PivotIntosContextAll<'input>> {
		Rc::new(
		PivotIntosContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PivotIntosContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PivotIntosContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PivotIntosContextExt<'input>>{


}

impl<'input> PivotIntosContextAttrs<'input> for PivotIntosContext<'input>{}

pub type PivotIntosAnyContext<'input> = BaseParserRuleContext<'input,PivotIntosAnyContextExt<'input>>;

pub trait PivotIntosAnyContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ANY
	/// Returns `None` if there is no child corresponding to token ANY
	fn ANY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ANY, 0)
	}
	fn orderBy(&self) -> Option<Rc<OrderByContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> PivotIntosAnyContextAttrs<'input> for PivotIntosAnyContext<'input>{}

pub struct PivotIntosAnyContextExt<'input>{
	base:PivotIntosContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PivotIntosAnyContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PivotIntosAnyContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotIntosAnyContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_pivotIntosAny(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_pivotIntosAny(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotIntosAnyContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pivotIntosAny(self);
	}
}

impl<'input> CustomRuleContext<'input> for PivotIntosAnyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotIntos }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotIntos }
}

impl<'input> Borrow<PivotIntosContextExt<'input>> for PivotIntosAnyContext<'input>{
	fn borrow(&self) -> &PivotIntosContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PivotIntosContextExt<'input>> for PivotIntosAnyContext<'input>{
	fn borrow_mut(&mut self) -> &mut PivotIntosContextExt<'input> { &mut self.base }
}

impl<'input> PivotIntosContextAttrs<'input> for PivotIntosAnyContext<'input> {}

impl<'input> PivotIntosAnyContextExt<'input>{
	fn new(ctx: &dyn PivotIntosContextAttrs<'input>) -> Rc<PivotIntosContextAll<'input>>  {
		Rc::new(
			PivotIntosContextAll::PivotIntosAnyContext(
				BaseParserRuleContext::copy_from(ctx,PivotIntosAnyContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PivotIntosDefaultContext<'input> = BaseParserRuleContext<'input,PivotIntosDefaultContextExt<'input>>;

pub trait PivotIntosDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn pivotInto_all(&self) ->  Vec<Rc<PivotIntoContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn pivotInto(&self, i: usize) -> Option<Rc<PivotIntoContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> PivotIntosDefaultContextAttrs<'input> for PivotIntosDefaultContext<'input>{}

pub struct PivotIntosDefaultContextExt<'input>{
	base:PivotIntosContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PivotIntosDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PivotIntosDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotIntosDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_pivotIntosDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_pivotIntosDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotIntosDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pivotIntosDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for PivotIntosDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotIntos }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotIntos }
}

impl<'input> Borrow<PivotIntosContextExt<'input>> for PivotIntosDefaultContext<'input>{
	fn borrow(&self) -> &PivotIntosContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PivotIntosContextExt<'input>> for PivotIntosDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut PivotIntosContextExt<'input> { &mut self.base }
}

impl<'input> PivotIntosContextAttrs<'input> for PivotIntosDefaultContext<'input> {}

impl<'input> PivotIntosDefaultContextExt<'input>{
	fn new(ctx: &dyn PivotIntosContextAttrs<'input>) -> Rc<PivotIntosContextAll<'input>>  {
		Rc::new(
			PivotIntosContextAll::PivotIntosDefaultContext(
				BaseParserRuleContext::copy_from(ctx,PivotIntosDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PivotIntosQueryContext<'input> = BaseParserRuleContext<'input,PivotIntosQueryContextExt<'input>>;

pub trait PivotIntosQueryContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> PivotIntosQueryContextAttrs<'input> for PivotIntosQueryContext<'input>{}

pub struct PivotIntosQueryContextExt<'input>{
	base:PivotIntosContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PivotIntosQueryContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PivotIntosQueryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotIntosQueryContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_pivotIntosQuery(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_pivotIntosQuery(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotIntosQueryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pivotIntosQuery(self);
	}
}

impl<'input> CustomRuleContext<'input> for PivotIntosQueryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotIntos }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotIntos }
}

impl<'input> Borrow<PivotIntosContextExt<'input>> for PivotIntosQueryContext<'input>{
	fn borrow(&self) -> &PivotIntosContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PivotIntosContextExt<'input>> for PivotIntosQueryContext<'input>{
	fn borrow_mut(&mut self) -> &mut PivotIntosContextExt<'input> { &mut self.base }
}

impl<'input> PivotIntosContextAttrs<'input> for PivotIntosQueryContext<'input> {}

impl<'input> PivotIntosQueryContextExt<'input>{
	fn new(ctx: &dyn PivotIntosContextAttrs<'input>) -> Rc<PivotIntosContextAll<'input>>  {
		Rc::new(
			PivotIntosContextAll::PivotIntosQueryContext(
				BaseParserRuleContext::copy_from(ctx,PivotIntosQueryContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pivotIntos(&mut self,)
	-> Result<Rc<PivotIntosContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PivotIntosContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 216, RULE_pivotIntos);
        let mut _localctx: Rc<PivotIntosContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(3603);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(540,&mut recog.base)? {
				1 =>{
					let tmp = PivotIntosDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule pivotInto*/
					recog.base.set_state(3587);
					recog.pivotInto()?;

					recog.base.set_state(3592);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(537,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3588);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule pivotInto*/
							recog.base.set_state(3589);
							recog.pivotInto()?;

							}
							} 
						}
						recog.base.set_state(3594);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(537,&mut recog.base)?;
					}
					recog.base.set_state(3596);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(3595);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						}
					}

					}
				}
			,
				2 =>{
					let tmp = PivotIntosAnyContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(3598);
					recog.base.match_token(ANY,&mut recog.err_handler)?;

					recog.base.set_state(3600);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ORDER {
						{
						/*InvokeRule orderBy*/
						recog.base.set_state(3599);
						recog.orderBy()?;

						}
					}

					}
				}
			,
				3 =>{
					let tmp = PivotIntosQueryContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					/*InvokeRule query*/
					recog.base.set_state(3602);
					recog.query()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pivotOperator ----------------
#[derive(Debug)]
pub enum PivotOperatorContextAll<'input>{
	UnpivotContext(UnpivotContext<'input>),
	PivotContext(PivotContext<'input>),
Error(PivotOperatorContext<'input>)
}
antlr_rust::tid!{PivotOperatorContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PivotOperatorContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PivotOperatorContextAll<'input>{}

impl<'input> Deref for PivotOperatorContextAll<'input>{
	type Target = dyn PivotOperatorContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PivotOperatorContextAll::*;
		match self{
			UnpivotContext(inner) => inner,
			PivotContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotOperatorContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotOperatorContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PivotOperatorContext<'input> = BaseParserRuleContext<'input,PivotOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct PivotOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PivotOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotOperatorContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotOperatorContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PivotOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotOperator }
}
antlr_rust::tid!{PivotOperatorContextExt<'a>}

impl<'input> PivotOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PivotOperatorContextAll<'input>> {
		Rc::new(
		PivotOperatorContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PivotOperatorContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PivotOperatorContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PivotOperatorContextExt<'input>>{


}

impl<'input> PivotOperatorContextAttrs<'input> for PivotOperatorContext<'input>{}

pub type UnpivotContext<'input> = BaseParserRuleContext<'input,UnpivotContextExt<'input>>;

pub trait UnpivotContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token UNPIVOT
	/// Returns `None` if there is no child corresponding to token UNPIVOT
	fn UNPIVOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(UNPIVOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn columnUnpivot(&self) -> Option<Rc<ColumnUnpivotContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn pivotAsAlias(&self) -> Option<Rc<PivotAsAliasContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn unpivotNullClause(&self) -> Option<Rc<UnpivotNullClauseContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> UnpivotContextAttrs<'input> for UnpivotContext<'input>{}

pub struct UnpivotContextExt<'input>{
	base:PivotOperatorContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UnpivotContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UnpivotContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UnpivotContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unpivot(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_unpivot(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UnpivotContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_unpivot(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnpivotContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotOperator }
}

impl<'input> Borrow<PivotOperatorContextExt<'input>> for UnpivotContext<'input>{
	fn borrow(&self) -> &PivotOperatorContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PivotOperatorContextExt<'input>> for UnpivotContext<'input>{
	fn borrow_mut(&mut self) -> &mut PivotOperatorContextExt<'input> { &mut self.base }
}

impl<'input> PivotOperatorContextAttrs<'input> for UnpivotContext<'input> {}

impl<'input> UnpivotContextExt<'input>{
	fn new(ctx: &dyn PivotOperatorContextAttrs<'input>) -> Rc<PivotOperatorContextAll<'input>>  {
		Rc::new(
			PivotOperatorContextAll::UnpivotContext(
				BaseParserRuleContext::copy_from(ctx,UnpivotContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PivotContext<'input> = BaseParserRuleContext<'input,PivotContextExt<'input>>;

pub trait PivotContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token PIVOT
	/// Returns `None` if there is no child corresponding to token PIVOT
	fn PIVOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PIVOT, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	fn pivotAggregates(&self) -> Option<Rc<PivotAggregatesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token FOR
	/// Returns `None` if there is no child corresponding to token FOR
	fn FOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FOR, 0)
	}
	fn pivotFrom(&self) -> Option<Rc<PivotFromContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token IN
	/// Returns `None` if there is no child corresponding to token IN
	fn IN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IN, 0)
	}
	fn pivotIntos(&self) -> Option<Rc<PivotIntosContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	fn pivotAsAlias(&self) -> Option<Rc<PivotAsAliasContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> PivotContextAttrs<'input> for PivotContext<'input>{}

pub struct PivotContextExt<'input>{
	base:PivotOperatorContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PivotContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PivotContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PivotContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_pivot(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_pivot(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PivotContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pivot(self);
	}
}

impl<'input> CustomRuleContext<'input> for PivotContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pivotOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pivotOperator }
}

impl<'input> Borrow<PivotOperatorContextExt<'input>> for PivotContext<'input>{
	fn borrow(&self) -> &PivotOperatorContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PivotOperatorContextExt<'input>> for PivotContext<'input>{
	fn borrow_mut(&mut self) -> &mut PivotOperatorContextExt<'input> { &mut self.base }
}

impl<'input> PivotOperatorContextAttrs<'input> for PivotContext<'input> {}

impl<'input> PivotContextExt<'input>{
	fn new(ctx: &dyn PivotOperatorContextAttrs<'input>) -> Rc<PivotOperatorContextAll<'input>>  {
		Rc::new(
			PivotOperatorContextAll::PivotContext(
				BaseParserRuleContext::copy_from(ctx,PivotContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pivotOperator(&mut self,)
	-> Result<Rc<PivotOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PivotOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 218, RULE_pivotOperator);
        let mut _localctx: Rc<PivotOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3626);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 PIVOT 
				=> {
					let tmp = PivotContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(3605);
					recog.base.match_token(PIVOT,&mut recog.err_handler)?;

					recog.base.set_state(3606);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule pivotAggregates*/
					recog.base.set_state(3607);
					recog.pivotAggregates()?;

					recog.base.set_state(3608);
					recog.base.match_token(FOR,&mut recog.err_handler)?;

					/*InvokeRule pivotFrom*/
					recog.base.set_state(3609);
					recog.pivotFrom()?;

					recog.base.set_state(3610);
					recog.base.match_token(IN,&mut recog.err_handler)?;

					recog.base.set_state(3611);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule pivotIntos*/
					recog.base.set_state(3612);
					recog.pivotIntos()?;

					recog.base.set_state(3613);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3614);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule pivotAsAlias*/
					recog.base.set_state(3615);
					recog.pivotAsAlias()?;

					}
				}

			 UNPIVOT 
				=> {
					let tmp = UnpivotContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(3617);
					recog.base.match_token(UNPIVOT,&mut recog.err_handler)?;

					recog.base.set_state(3619);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==EXCLUDE || _la==INCLUDE {
						{
						/*InvokeRule unpivotNullClause*/
						recog.base.set_state(3618);
						recog.unpivotNullClause()?;

						}
					}

					recog.base.set_state(3621);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule columnUnpivot*/
					recog.base.set_state(3622);
					recog.columnUnpivot()?;

					recog.base.set_state(3623);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule pivotAsAlias*/
					recog.base.set_state(3624);
					recog.pivotAsAlias()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aliasedRelationTarget ----------------
pub type AliasedRelationTargetContextAll<'input> = AliasedRelationTargetContext<'input>;


pub type AliasedRelationTargetContext<'input> = BaseParserRuleContext<'input,AliasedRelationTargetContextExt<'input>>;

#[derive(Clone)]
pub struct AliasedRelationTargetContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for AliasedRelationTargetContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AliasedRelationTargetContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aliasedRelationTarget(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_aliasedRelationTarget(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AliasedRelationTargetContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_aliasedRelationTarget(self);
	}
}

impl<'input> CustomRuleContext<'input> for AliasedRelationTargetContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aliasedRelationTarget }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aliasedRelationTarget }
}
antlr_rust::tid!{AliasedRelationTargetContextExt<'a>}

impl<'input> AliasedRelationTargetContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AliasedRelationTargetContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AliasedRelationTargetContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait AliasedRelationTargetContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<AliasedRelationTargetContextExt<'input>>{

fn relationPrimary(&self) -> Option<Rc<RelationPrimaryContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AliasedRelationTargetContextAttrs<'input> for AliasedRelationTargetContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aliasedRelationTarget(&mut self,)
	-> Result<Rc<AliasedRelationTargetContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AliasedRelationTargetContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 220, RULE_aliasedRelationTarget);
        let mut _localctx: Rc<AliasedRelationTargetContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule relationPrimary*/
			recog.base.set_state(3628);
			recog.relationPrimary()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- aliasedRelation ----------------
pub type AliasedRelationContextAll<'input> = AliasedRelationContext<'input>;


pub type AliasedRelationContext<'input> = BaseParserRuleContext<'input,AliasedRelationContextExt<'input>>;

#[derive(Clone)]
pub struct AliasedRelationContextExt<'input>{
	pub alias1: Option<Rc<IdentifierContextAll<'input>>>,
	pub alias2: Option<Rc<StrictIdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for AliasedRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AliasedRelationContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_aliasedRelation(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_aliasedRelation(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AliasedRelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_aliasedRelation(self);
	}
}

impl<'input> CustomRuleContext<'input> for AliasedRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_aliasedRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_aliasedRelation }
}
antlr_rust::tid!{AliasedRelationContextExt<'a>}

impl<'input> AliasedRelationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<AliasedRelationContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,AliasedRelationContextExt{
				alias1: None, alias2: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait AliasedRelationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<AliasedRelationContextExt<'input>>{

fn aliasedRelationTarget(&self) -> Option<Rc<AliasedRelationTargetContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn strictIdentifier(&self) -> Option<Rc<StrictIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> AliasedRelationContextAttrs<'input> for AliasedRelationContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn aliasedRelation(&mut self,)
	-> Result<Rc<AliasedRelationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = AliasedRelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 222, RULE_aliasedRelation);
        let mut _localctx: Rc<AliasedRelationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule aliasedRelationTarget*/
			recog.base.set_state(3630);
			recog.aliasedRelationTarget()?;

			recog.base.set_state(3639);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(545,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(3634);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 AS 
						=> {
							{
							recog.base.set_state(3631);
							recog.base.match_token(AS,&mut recog.err_handler)?;

							/*InvokeRule identifier*/
							recog.base.set_state(3632);
							let tmp = recog.identifier()?;
							 cast_mut::<_,AliasedRelationContext >(&mut _localctx).alias1 = Some(tmp.clone());
							  

							}
						}

					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CUBE | CURRENT_ROLE | DATA |
					 DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
					 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
					 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
					 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC |
					 EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE |
					 EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
					 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
					 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FUNCTION |
					 FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS | GRAPHVIZ |
					 GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
					 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
					 INFORMATION | INITIAL | INITIALLY | INPUT | INPUTFORMAT | INTERLEAVED |
					 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JSON | JSON_ARRAY |
					 JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP | KEY |
					 KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LEADING | LEVEL |
					 LIBRARY | LIMIT | LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL |
					 MAP | MASKING | MATCH | MATCHED | MATCHES | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE |
					 NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULLS | OBJECT | OFFSET |
					 OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER | OUTPUT |
					 OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RLS |
					 ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR | SECOND |
					 SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI | SEQUENCE |
					 SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR |
					 SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED |
					 STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME |
					 TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW |
					 TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION |
					 TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE |
					 UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED |
					 UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER | UTF16 | UTF32 |
					 UTF8 | VACUUM | VALIDATE | VALUE | VARYING | VECTOR | VERBOSE | VERSION |
					 VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN | WITHOUT | WORK |
					 WRAPPER | WRITE | XZ | YEAR | YES | ZONE | ZSTD | IDENTIFIER | QUOTED_IDENTIFIER |
					 BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule strictIdentifier*/
							recog.base.set_state(3633);
							let tmp = recog.strictIdentifier()?;
							 cast_mut::<_,AliasedRelationContext >(&mut _localctx).alias2 = Some(tmp.clone());
							  

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					recog.base.set_state(3637);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(544,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule columnAliases*/
							recog.base.set_state(3636);
							recog.columnAliases()?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- columnAliases ----------------
pub type ColumnAliasesContextAll<'input> = ColumnAliasesContext<'input>;


pub type ColumnAliasesContext<'input> = BaseParserRuleContext<'input,ColumnAliasesContextExt<'input>>;

#[derive(Clone)]
pub struct ColumnAliasesContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ColumnAliasesContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnAliasesContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_columnAliases(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_columnAliases(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnAliasesContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnAliases(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnAliasesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_columnAliases }
	//fn type_rule_index() -> usize where Self: Sized { RULE_columnAliases }
}
antlr_rust::tid!{ColumnAliasesContextExt<'a>}

impl<'input> ColumnAliasesContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ColumnAliasesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ColumnAliasesContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait ColumnAliasesContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ColumnAliasesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn identifierSeq(&self) -> Option<Rc<IdentifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token COMMA
/// Returns `None` if there is no child corresponding to token COMMA
fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, 0)
}

}

impl<'input> ColumnAliasesContextAttrs<'input> for ColumnAliasesContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn columnAliases(&mut self,)
	-> Result<Rc<ColumnAliasesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ColumnAliasesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 224, RULE_columnAliases);
        let mut _localctx: Rc<ColumnAliasesContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3641);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule identifierSeq*/
			recog.base.set_state(3642);
			recog.identifierSeq()?;

			recog.base.set_state(3644);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(3643);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,ColumnAliasesContext >(&mut _localctx).tail = Some(tmp);
				  

				}
			}

			recog.base.set_state(3646);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- relationPrimary ----------------
#[derive(Debug)]
pub enum RelationPrimaryContextAll<'input>{
	SubqueryRelationContext(SubqueryRelationContext<'input>),
	ParenthesizedRelationContext(ParenthesizedRelationContext<'input>),
	LateralContext(LateralContext<'input>),
	TableNameContext(TableNameContext<'input>),
Error(RelationPrimaryContext<'input>)
}
antlr_rust::tid!{RelationPrimaryContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for RelationPrimaryContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for RelationPrimaryContextAll<'input>{}

impl<'input> Deref for RelationPrimaryContextAll<'input>{
	type Target = dyn RelationPrimaryContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use RelationPrimaryContextAll::*;
		match self{
			SubqueryRelationContext(inner) => inner,
			ParenthesizedRelationContext(inner) => inner,
			LateralContext(inner) => inner,
			TableNameContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RelationPrimaryContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RelationPrimaryContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type RelationPrimaryContext<'input> = BaseParserRuleContext<'input,RelationPrimaryContextExt<'input>>;

#[derive(Clone)]
pub struct RelationPrimaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for RelationPrimaryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RelationPrimaryContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RelationPrimaryContext<'input>{
}

impl<'input> CustomRuleContext<'input> for RelationPrimaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}
antlr_rust::tid!{RelationPrimaryContextExt<'a>}

impl<'input> RelationPrimaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RelationPrimaryContextAll<'input>> {
		Rc::new(
		RelationPrimaryContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RelationPrimaryContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait RelationPrimaryContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<RelationPrimaryContextExt<'input>>{


}

impl<'input> RelationPrimaryContextAttrs<'input> for RelationPrimaryContext<'input>{}

pub type SubqueryRelationContext<'input> = BaseParserRuleContext<'input,SubqueryRelationContextExt<'input>>;

pub trait SubqueryRelationContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> SubqueryRelationContextAttrs<'input> for SubqueryRelationContext<'input>{}

pub struct SubqueryRelationContextExt<'input>{
	base:RelationPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SubqueryRelationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SubqueryRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SubqueryRelationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_subqueryRelation(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_subqueryRelation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SubqueryRelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_subqueryRelation(self);
	}
}

impl<'input> CustomRuleContext<'input> for SubqueryRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>> for SubqueryRelationContext<'input>{
	fn borrow(&self) -> &RelationPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>> for SubqueryRelationContext<'input>{
	fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> RelationPrimaryContextAttrs<'input> for SubqueryRelationContext<'input> {}

impl<'input> SubqueryRelationContextExt<'input>{
	fn new(ctx: &dyn RelationPrimaryContextAttrs<'input>) -> Rc<RelationPrimaryContextAll<'input>>  {
		Rc::new(
			RelationPrimaryContextAll::SubqueryRelationContext(
				BaseParserRuleContext::copy_from(ctx,SubqueryRelationContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ParenthesizedRelationContext<'input> = BaseParserRuleContext<'input,ParenthesizedRelationContextExt<'input>>;

pub trait ParenthesizedRelationContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn relation(&self) -> Option<Rc<RelationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ParenthesizedRelationContextAttrs<'input> for ParenthesizedRelationContext<'input>{}

pub struct ParenthesizedRelationContextExt<'input>{
	base:RelationPrimaryContextExt<'input>,
	pub rel: Option<Rc<RelationContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ParenthesizedRelationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ParenthesizedRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ParenthesizedRelationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parenthesizedRelation(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_parenthesizedRelation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ParenthesizedRelationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedRelation(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>> for ParenthesizedRelationContext<'input>{
	fn borrow(&self) -> &RelationPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>> for ParenthesizedRelationContext<'input>{
	fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> RelationPrimaryContextAttrs<'input> for ParenthesizedRelationContext<'input> {}

impl<'input> ParenthesizedRelationContextExt<'input>{
	fn new(ctx: &dyn RelationPrimaryContextAttrs<'input>) -> Rc<RelationPrimaryContextAll<'input>>  {
		Rc::new(
			RelationPrimaryContextAll::ParenthesizedRelationContext(
				BaseParserRuleContext::copy_from(ctx,ParenthesizedRelationContextExt{
        			rel:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type LateralContext<'input> = BaseParserRuleContext<'input,LateralContextExt<'input>>;

pub trait LateralContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LATERAL
	/// Returns `None` if there is no child corresponding to token LATERAL
	fn LATERAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LATERAL, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn tableFunctionCall(&self) -> Option<Rc<TableFunctionCallContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> LateralContextAttrs<'input> for LateralContext<'input>{}

pub struct LateralContextExt<'input>{
	base:RelationPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{LateralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for LateralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LateralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lateral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_lateral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LateralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_lateral(self);
	}
}

impl<'input> CustomRuleContext<'input> for LateralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>> for LateralContext<'input>{
	fn borrow(&self) -> &RelationPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>> for LateralContext<'input>{
	fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> RelationPrimaryContextAttrs<'input> for LateralContext<'input> {}

impl<'input> LateralContextExt<'input>{
	fn new(ctx: &dyn RelationPrimaryContextAttrs<'input>) -> Rc<RelationPrimaryContextAll<'input>>  {
		Rc::new(
			RelationPrimaryContextAll::LateralContext(
				BaseParserRuleContext::copy_from(ctx,LateralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TableNameContext<'input> = BaseParserRuleContext<'input,TableNameContextExt<'input>>;

pub trait TableNameContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn pathExpression(&self) -> Option<Rc<PathExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token VARIABLE
	/// Returns `None` if there is no child corresponding to token VARIABLE
	fn VARIABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VARIABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STAGE_NAME
	/// Returns `None` if there is no child corresponding to token STAGE_NAME
	fn STAGE_NAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STAGE_NAME, 0)
	}
	fn stageFileSpec_all(&self) ->  Vec<Rc<StageFileSpecContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn stageFileSpec(&self, i: usize) -> Option<Rc<StageFileSpecContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	/// Retrieves first TerminalNode corresponding to token STRING
	/// Returns `None` if there is no child corresponding to token STRING
	fn STRING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRING, 0)
	}
}

impl<'input> TableNameContextAttrs<'input> for TableNameContext<'input>{}

pub struct TableNameContextExt<'input>{
	base:RelationPrimaryContextExt<'input>,
	pub tableNameRef: Option<Rc<PathExpressionContextAll<'input>>>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TableNameContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TableNameContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableNameContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tableName(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_tableName(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableName(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_relationPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_relationPrimary }
}

impl<'input> Borrow<RelationPrimaryContextExt<'input>> for TableNameContext<'input>{
	fn borrow(&self) -> &RelationPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<RelationPrimaryContextExt<'input>> for TableNameContext<'input>{
	fn borrow_mut(&mut self) -> &mut RelationPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> RelationPrimaryContextAttrs<'input> for TableNameContext<'input> {}

impl<'input> TableNameContextExt<'input>{
	fn new(ctx: &dyn RelationPrimaryContextAttrs<'input>) -> Rc<RelationPrimaryContextAll<'input>>  {
		Rc::new(
			RelationPrimaryContextAll::TableNameContext(
				BaseParserRuleContext::copy_from(ctx,TableNameContextExt{
					COMMA:None, 
        			tail:Vec::new(), 
        			tableNameRef:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn relationPrimary(&mut self,)
	-> Result<Rc<RelationPrimaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RelationPrimaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 226, RULE_relationPrimary);
        let mut _localctx: Rc<RelationPrimaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(3703);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(554,&mut recog.base)? {
				1 =>{
					let tmp = LateralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(3648);
					recog.base.match_token(LATERAL,&mut recog.err_handler)?;

					recog.base.set_state(3654);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 LPAREN 
						=> {
							{
							recog.base.set_state(3649);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule query*/
							recog.base.set_state(3650);
							recog.query()?;

							recog.base.set_state(3651);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INSERT | INTERVAL | INVOKER | IO | ISOLATION |
					 ILIKE | JAVA | JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS |
					 JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA |
					 LANGUAGE | LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY |
					 LIKE | LIMIT | LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL |
					 MAP | MASKING | MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE |
					 MATERIALIZED | MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE |
					 MOD | MODEL | MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC |
					 NFKD | NO | NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULLS |
					 OBJECT | OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY |
					 OUTER | OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION |
					 PARTITIONED | PARTITIONS | PASSING | PAST | PATH | PATTERN | PER |
					 PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING |
					 POLICY | POSITION | PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE |
					 PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE |
					 READ | RECURSIVE | REGEXP | REFERENCE | REFERENCES | REFRESH | RELY |
					 RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT | RESTRICTED |
					 RETURN | RETURNING | RETURNS | RIGHT | RLIKE | RLS | ROLE | ROLES |
					 ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS |
					 SECURE | SECURITY | SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES |
					 SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT |
					 SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED | STREAM | STRICT |
					 STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG |
					 TEMP | TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW | TIES |
					 TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION | TRANSIENT |
					 TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE | UNBOUNDED |
					 UNCOMMITTED | UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED | UNNEST |
					 UNPIVOT | UNSET | UNSIGNED | USE | USER | USING | UTF16 | UTF32 | UTF8 |
					 VACUUM | VALIDATE | VALUE | VARYING | VECTOR | VERBOSE | VERSION |
					 VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN | WITHOUT | WORK |
					 WRAPPER | WRITE | XZ | YEAR | YES | ZONE | ZSTD | IDENTIFIER | QUOTED_IDENTIFIER |
					 BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule tableFunctionCall*/
							recog.base.set_state(3653);
							recog.tableFunctionCall()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}
			,
				2 =>{
					let tmp = TableNameContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule pathExpression*/
					recog.base.set_state(3656);
					let tmp = recog.pathExpression()?;
					if let RelationPrimaryContextAll::TableNameContext(ctx) = cast_mut::<_,RelationPrimaryContextAll >(&mut _localctx){
					ctx.tableNameRef = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				3 =>{
					let tmp = TableNameContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(3657);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(3658);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3659);
					recog.base.match_token(VARIABLE,&mut recog.err_handler)?;

					recog.base.set_state(3660);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					let tmp = TableNameContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					recog.base.set_state(3661);
					recog.base.match_token(STAGE_NAME,&mut recog.err_handler)?;

					recog.base.set_state(3676);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(550,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3662);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule stageFileSpec*/
							recog.base.set_state(3663);
							recog.stageFileSpec()?;

							recog.base.set_state(3668);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(548,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(3664);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule stageFileSpec*/
									recog.base.set_state(3665);
									recog.stageFileSpec()?;

									}
									} 
								}
								recog.base.set_state(3670);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(548,&mut recog.base)?;
							}
							recog.base.set_state(3672);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(3671);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let RelationPrimaryContextAll::TableNameContext(ctx) = cast_mut::<_,RelationPrimaryContextAll >(&mut _localctx){
								ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

								let temp = if let RelationPrimaryContextAll::TableNameContext(ctx) = cast_mut::<_,RelationPrimaryContextAll >(&mut _localctx){
								ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
								if let RelationPrimaryContextAll::TableNameContext(ctx) = cast_mut::<_,RelationPrimaryContextAll >(&mut _localctx){
								ctx.tail.push(temp); } else {unreachable!("cant cast");}  
								}
							}

							recog.base.set_state(3674);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				5 =>{
					let tmp = TableNameContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 5);
					_localctx = tmp;
					{
					recog.base.set_state(3678);
					recog.base.match_token(STRING,&mut recog.err_handler)?;

					recog.base.set_state(3693);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(553,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3679);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule stageFileSpec*/
							recog.base.set_state(3680);
							recog.stageFileSpec()?;

							recog.base.set_state(3685);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(551,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(3681);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule stageFileSpec*/
									recog.base.set_state(3682);
									recog.stageFileSpec()?;

									}
									} 
								}
								recog.base.set_state(3687);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(551,&mut recog.base)?;
							}
							recog.base.set_state(3689);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(3688);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let RelationPrimaryContextAll::TableNameContext(ctx) = cast_mut::<_,RelationPrimaryContextAll >(&mut _localctx){
								ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

								let temp = if let RelationPrimaryContextAll::TableNameContext(ctx) = cast_mut::<_,RelationPrimaryContextAll >(&mut _localctx){
								ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
								if let RelationPrimaryContextAll::TableNameContext(ctx) = cast_mut::<_,RelationPrimaryContextAll >(&mut _localctx){
								ctx.tail.push(temp); } else {unreachable!("cant cast");}  
								}
							}

							recog.base.set_state(3691);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				6 =>{
					let tmp = SubqueryRelationContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 6);
					_localctx = tmp;
					{
					recog.base.set_state(3695);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(3696);
					recog.query()?;

					recog.base.set_state(3697);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					let tmp = ParenthesizedRelationContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 7);
					_localctx = tmp;
					{
					recog.base.set_state(3699);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule relation*/
					recog.base.set_state(3700);
					let tmp = recog.relation()?;
					if let RelationPrimaryContextAll::ParenthesizedRelationContext(ctx) = cast_mut::<_,RelationPrimaryContextAll >(&mut _localctx){
					ctx.rel = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(3701);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableFunctionCall ----------------
#[derive(Debug)]
pub enum TableFunctionCallContextAll<'input>{
	DefaultTableFunctionCallContext(DefaultTableFunctionCallContext<'input>),
	ValidateContext(ValidateContext<'input>),
Error(TableFunctionCallContext<'input>)
}
antlr_rust::tid!{TableFunctionCallContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for TableFunctionCallContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for TableFunctionCallContextAll<'input>{}

impl<'input> Deref for TableFunctionCallContextAll<'input>{
	type Target = dyn TableFunctionCallContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use TableFunctionCallContextAll::*;
		match self{
			DefaultTableFunctionCallContext(inner) => inner,
			ValidateContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableFunctionCallContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableFunctionCallContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type TableFunctionCallContext<'input> = BaseParserRuleContext<'input,TableFunctionCallContextExt<'input>>;

#[derive(Clone)]
pub struct TableFunctionCallContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TableFunctionCallContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableFunctionCallContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableFunctionCallContext<'input>{
}

impl<'input> CustomRuleContext<'input> for TableFunctionCallContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableFunctionCall }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableFunctionCall }
}
antlr_rust::tid!{TableFunctionCallContextExt<'a>}

impl<'input> TableFunctionCallContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableFunctionCallContextAll<'input>> {
		Rc::new(
		TableFunctionCallContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableFunctionCallContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait TableFunctionCallContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TableFunctionCallContextExt<'input>>{


}

impl<'input> TableFunctionCallContextAttrs<'input> for TableFunctionCallContext<'input>{}

pub type DefaultTableFunctionCallContext<'input> = BaseParserRuleContext<'input,DefaultTableFunctionCallContextExt<'input>>;

pub trait DefaultTableFunctionCallContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn functionName(&self) -> Option<Rc<FunctionNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn tableFunctionArgument_all(&self) ->  Vec<Rc<TableFunctionArgumentContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn tableFunctionArgument(&self, i: usize) -> Option<Rc<TableFunctionArgumentContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn tableFunctionArgumentCopartition(&self) -> Option<Rc<TableFunctionArgumentCopartitionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn over(&self) -> Option<Rc<OverContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	fn queryNoWith(&self) -> Option<Rc<QueryNoWithContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn tableFunctionArgumentName(&self) -> Option<Rc<TableFunctionArgumentNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> DefaultTableFunctionCallContextAttrs<'input> for DefaultTableFunctionCallContext<'input>{}

pub struct DefaultTableFunctionCallContextExt<'input>{
	base:TableFunctionCallContextExt<'input>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
	pub subquery: Option<Rc<QueryNoWithContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DefaultTableFunctionCallContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DefaultTableFunctionCallContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DefaultTableFunctionCallContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultTableFunctionCall(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_defaultTableFunctionCall(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DefaultTableFunctionCallContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_defaultTableFunctionCall(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultTableFunctionCallContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableFunctionCall }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableFunctionCall }
}

impl<'input> Borrow<TableFunctionCallContextExt<'input>> for DefaultTableFunctionCallContext<'input>{
	fn borrow(&self) -> &TableFunctionCallContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<TableFunctionCallContextExt<'input>> for DefaultTableFunctionCallContext<'input>{
	fn borrow_mut(&mut self) -> &mut TableFunctionCallContextExt<'input> { &mut self.base }
}

impl<'input> TableFunctionCallContextAttrs<'input> for DefaultTableFunctionCallContext<'input> {}

impl<'input> DefaultTableFunctionCallContextExt<'input>{
	fn new(ctx: &dyn TableFunctionCallContextAttrs<'input>) -> Rc<TableFunctionCallContextAll<'input>>  {
		Rc::new(
			TableFunctionCallContextAll::DefaultTableFunctionCallContext(
				BaseParserRuleContext::copy_from(ctx,DefaultTableFunctionCallContextExt{
					COMMA:None, 
        			tail:Vec::new(), 
        			subquery:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ValidateContext<'input> = BaseParserRuleContext<'input,ValidateContextExt<'input>>;

pub trait ValidateContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token VALIDATE
	/// Returns `None` if there is no child corresponding to token VALIDATE
	fn VALIDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VALIDATE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token COMMA
	/// Returns `None` if there is no child corresponding to token COMMA
	fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, 0)
	}
	fn callArgument(&self) -> Option<Rc<CallArgumentContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> ValidateContextAttrs<'input> for ValidateContext<'input>{}

pub struct ValidateContextExt<'input>{
	base:TableFunctionCallContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ValidateContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ValidateContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ValidateContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_validate(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_validate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ValidateContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_validate(self);
	}
}

impl<'input> CustomRuleContext<'input> for ValidateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableFunctionCall }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableFunctionCall }
}

impl<'input> Borrow<TableFunctionCallContextExt<'input>> for ValidateContext<'input>{
	fn borrow(&self) -> &TableFunctionCallContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<TableFunctionCallContextExt<'input>> for ValidateContext<'input>{
	fn borrow_mut(&mut self) -> &mut TableFunctionCallContextExt<'input> { &mut self.base }
}

impl<'input> TableFunctionCallContextAttrs<'input> for ValidateContext<'input> {}

impl<'input> ValidateContextExt<'input>{
	fn new(ctx: &dyn TableFunctionCallContextAttrs<'input>) -> Rc<TableFunctionCallContextAll<'input>>  {
		Rc::new(
			TableFunctionCallContextAll::ValidateContext(
				BaseParserRuleContext::copy_from(ctx,ValidateContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableFunctionCall(&mut self,)
	-> Result<Rc<TableFunctionCallContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableFunctionCallContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 228, RULE_tableFunctionCall);
        let mut _localctx: Rc<TableFunctionCallContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(3747);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(562,&mut recog.base)? {
				1 =>{
					let tmp = ValidateContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(3705);
					recog.base.match_token(VALIDATE,&mut recog.err_handler)?;

					recog.base.set_state(3706);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(3707);
					recog.qualifiedName()?;

					recog.base.set_state(3708);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule callArgument*/
					recog.base.set_state(3709);
					recog.callArgument()?;

					recog.base.set_state(3710);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = DefaultTableFunctionCallContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule functionName*/
					recog.base.set_state(3712);
					recog.functionName()?;

					recog.base.set_state(3713);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3725);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(557,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule tableFunctionArgument*/
							recog.base.set_state(3714);
							recog.tableFunctionArgument()?;

							recog.base.set_state(3719);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(555,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(3715);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule tableFunctionArgument*/
									recog.base.set_state(3716);
									recog.tableFunctionArgument()?;

									}
									} 
								}
								recog.base.set_state(3721);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(555,&mut recog.base)?;
							}
							recog.base.set_state(3723);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(3722);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let TableFunctionCallContextAll::DefaultTableFunctionCallContext(ctx) = cast_mut::<_,TableFunctionCallContextAll >(&mut _localctx){
								ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

								let temp = if let TableFunctionCallContextAll::DefaultTableFunctionCallContext(ctx) = cast_mut::<_,TableFunctionCallContextAll >(&mut _localctx){
								ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
								if let TableFunctionCallContextAll::DefaultTableFunctionCallContext(ctx) = cast_mut::<_,TableFunctionCallContextAll >(&mut _localctx){
								ctx.tail.push(temp); } else {unreachable!("cant cast");}  
								}
							}

							}
						}

						_ => {}
					}
					recog.base.set_state(3728);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COPARTITION {
						{
						/*InvokeRule tableFunctionArgumentCopartition*/
						recog.base.set_state(3727);
						recog.tableFunctionArgumentCopartition()?;

						}
					}

					recog.base.set_state(3730);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3732);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(559,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule over*/
							recog.base.set_state(3731);
							recog.over()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				3 =>{
					let tmp = DefaultTableFunctionCallContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					/*InvokeRule functionName*/
					recog.base.set_state(3734);
					recog.functionName()?;

					recog.base.set_state(3735);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3739);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule tableFunctionArgumentName*/
						recog.base.set_state(3736);
						recog.tableFunctionArgumentName()?;

						recog.base.set_state(3737);
						recog.base.match_token(T__0,&mut recog.err_handler)?;

						}
					}

					/*InvokeRule queryNoWith*/
					recog.base.set_state(3741);
					let tmp = recog.queryNoWith()?;
					if let TableFunctionCallContextAll::DefaultTableFunctionCallContext(ctx) = cast_mut::<_,TableFunctionCallContextAll >(&mut _localctx){
					ctx.subquery = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(3743);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(3742);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let TableFunctionCallContextAll::DefaultTableFunctionCallContext(ctx) = cast_mut::<_,TableFunctionCallContextAll >(&mut _localctx){
						ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

						let temp = if let TableFunctionCallContextAll::DefaultTableFunctionCallContext(ctx) = cast_mut::<_,TableFunctionCallContextAll >(&mut _localctx){
						ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
						if let TableFunctionCallContextAll::DefaultTableFunctionCallContext(ctx) = cast_mut::<_,TableFunctionCallContextAll >(&mut _localctx){
						ctx.tail.push(temp); } else {unreachable!("cant cast");}  
						}
					}

					recog.base.set_state(3745);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableFunctionArgumentCopartition ----------------
pub type TableFunctionArgumentCopartitionContextAll<'input> = TableFunctionArgumentCopartitionContext<'input>;


pub type TableFunctionArgumentCopartitionContext<'input> = BaseParserRuleContext<'input,TableFunctionArgumentCopartitionContextExt<'input>>;

#[derive(Clone)]
pub struct TableFunctionArgumentCopartitionContextExt<'input>{
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TableFunctionArgumentCopartitionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableFunctionArgumentCopartitionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tableFunctionArgumentCopartition(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_tableFunctionArgumentCopartition(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableFunctionArgumentCopartitionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableFunctionArgumentCopartition(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableFunctionArgumentCopartitionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableFunctionArgumentCopartition }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableFunctionArgumentCopartition }
}
antlr_rust::tid!{TableFunctionArgumentCopartitionContextExt<'a>}

impl<'input> TableFunctionArgumentCopartitionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableFunctionArgumentCopartitionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableFunctionArgumentCopartitionContextExt{
				COMMA: None, 
				tail: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait TableFunctionArgumentCopartitionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TableFunctionArgumentCopartitionContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COPARTITION
/// Returns `None` if there is no child corresponding to token COPARTITION
fn COPARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COPARTITION, 0)
}
fn copartitionTables_all(&self) ->  Vec<Rc<CopartitionTablesContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn copartitionTables(&self, i: usize) -> Option<Rc<CopartitionTablesContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TableFunctionArgumentCopartitionContextAttrs<'input> for TableFunctionArgumentCopartitionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableFunctionArgumentCopartition(&mut self,)
	-> Result<Rc<TableFunctionArgumentCopartitionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableFunctionArgumentCopartitionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 230, RULE_tableFunctionArgumentCopartition);
        let mut _localctx: Rc<TableFunctionArgumentCopartitionContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3749);
			recog.base.match_token(COPARTITION,&mut recog.err_handler)?;

			/*InvokeRule copartitionTables*/
			recog.base.set_state(3750);
			recog.copartitionTables()?;

			recog.base.set_state(3755);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(563,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3751);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule copartitionTables*/
					recog.base.set_state(3752);
					recog.copartitionTables()?;

					}
					} 
				}
				recog.base.set_state(3757);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(563,&mut recog.base)?;
			}
			recog.base.set_state(3759);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(3758);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,TableFunctionArgumentCopartitionContext >(&mut _localctx).COMMA = Some(tmp);
				  

				let temp =  cast_mut::<_,TableFunctionArgumentCopartitionContext >(&mut _localctx).COMMA.clone().unwrap()
				 ;
				 cast_mut::<_,TableFunctionArgumentCopartitionContext >(&mut _localctx).tail.push(temp);
				  
				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableFunctionArgumentName ----------------
pub type TableFunctionArgumentNameContextAll<'input> = TableFunctionArgumentNameContext<'input>;


pub type TableFunctionArgumentNameContext<'input> = BaseParserRuleContext<'input,TableFunctionArgumentNameContextExt<'input>>;

#[derive(Clone)]
pub struct TableFunctionArgumentNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TableFunctionArgumentNameContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableFunctionArgumentNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tableFunctionArgumentName(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_tableFunctionArgumentName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableFunctionArgumentNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableFunctionArgumentName(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableFunctionArgumentNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableFunctionArgumentName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableFunctionArgumentName }
}
antlr_rust::tid!{TableFunctionArgumentNameContextExt<'a>}

impl<'input> TableFunctionArgumentNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableFunctionArgumentNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableFunctionArgumentNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableFunctionArgumentNameContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TableFunctionArgumentNameContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token OUTER
/// Returns `None` if there is no child corresponding to token OUTER
fn OUTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OUTER, 0)
}
/// Retrieves first TerminalNode corresponding to token RECURSIVE
/// Returns `None` if there is no child corresponding to token RECURSIVE
fn RECURSIVE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RECURSIVE, 0)
}

}

impl<'input> TableFunctionArgumentNameContextAttrs<'input> for TableFunctionArgumentNameContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableFunctionArgumentName(&mut self,)
	-> Result<Rc<TableFunctionArgumentNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableFunctionArgumentNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 232, RULE_tableFunctionArgumentName);
        let mut _localctx: Rc<TableFunctionArgumentNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3764);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(565,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule identifier*/
					recog.base.set_state(3761);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3762);
					recog.base.match_token(OUTER,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(3763);
					recog.base.match_token(RECURSIVE,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableFunctionArgument ----------------
pub type TableFunctionArgumentContextAll<'input> = TableFunctionArgumentContext<'input>;


pub type TableFunctionArgumentContext<'input> = BaseParserRuleContext<'input,TableFunctionArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct TableFunctionArgumentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TableFunctionArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableFunctionArgumentContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tableFunctionArgument(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_tableFunctionArgument(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableFunctionArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableFunctionArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableFunctionArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableFunctionArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableFunctionArgument }
}
antlr_rust::tid!{TableFunctionArgumentContextExt<'a>}

impl<'input> TableFunctionArgumentContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableFunctionArgumentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableFunctionArgumentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TableFunctionArgumentContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TableFunctionArgumentContextExt<'input>>{

fn tableArgument(&self) -> Option<Rc<TableArgumentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn descriptorArgument(&self) -> Option<Rc<DescriptorArgumentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn tableFunctionArgumentName(&self) -> Option<Rc<TableFunctionArgumentNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TableFunctionArgumentContextAttrs<'input> for TableFunctionArgumentContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableFunctionArgument(&mut self,)
	-> Result<Rc<TableFunctionArgumentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableFunctionArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 234, RULE_tableFunctionArgument);
        let mut _localctx: Rc<TableFunctionArgumentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3769);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(566,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule tableFunctionArgumentName*/
					recog.base.set_state(3766);
					recog.tableFunctionArgumentName()?;

					recog.base.set_state(3767);
					recog.base.match_token(T__0,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			recog.base.set_state(3774);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(567,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule tableArgument*/
					recog.base.set_state(3771);
					recog.tableArgument()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule descriptorArgument*/
					recog.base.set_state(3772);
					recog.descriptorArgument()?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule expression*/
					recog.base.set_state(3773);
					recog.expression()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableArgument ----------------
pub type TableArgumentContextAll<'input> = TableArgumentContext<'input>;


pub type TableArgumentContext<'input> = BaseParserRuleContext<'input,TableArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct TableArgumentContextExt<'input>{
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TableArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableArgumentContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_tableArgument(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_tableArgument(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableArgument }
}
antlr_rust::tid!{TableArgumentContextExt<'a>}

impl<'input> TableArgumentContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableArgumentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableArgumentContextExt{
				COMMA: None, 
				tail: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait TableArgumentContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TableArgumentContextExt<'input>>{

fn tableArgumentRelation(&self) -> Option<Rc<TableArgumentRelationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PARTITION
/// Returns `None` if there is no child corresponding to token PARTITION
fn PARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITION, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token BY in current rule
fn BY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token BY, starting from 0.
/// Returns `None` if number of children corresponding to token BY is less or equal than `i`.
fn BY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, i)
}
/// Retrieves first TerminalNode corresponding to token PRUNE
/// Returns `None` if there is no child corresponding to token PRUNE
fn PRUNE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRUNE, 0)
}
/// Retrieves first TerminalNode corresponding to token WHEN
/// Returns `None` if there is no child corresponding to token WHEN
fn WHEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WHEN, 0)
}
/// Retrieves first TerminalNode corresponding to token EMPTY
/// Returns `None` if there is no child corresponding to token EMPTY
fn EMPTY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EMPTY, 0)
}
/// Retrieves first TerminalNode corresponding to token KEEP
/// Returns `None` if there is no child corresponding to token KEEP
fn KEEP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(KEEP, 0)
}
/// Retrieves first TerminalNode corresponding to token ORDER
/// Returns `None` if there is no child corresponding to token ORDER
fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ORDER, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, i)
}
/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, i)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
fn sortItem_all(&self) ->  Vec<Rc<SortItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> TableArgumentContextAttrs<'input> for TableArgumentContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableArgument(&mut self,)
	-> Result<Rc<TableArgumentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 236, RULE_tableArgument);
        let mut _localctx: Rc<TableArgumentContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule tableArgumentRelation*/
			recog.base.set_state(3776);
			recog.tableArgumentRelation()?;

			recog.base.set_state(3797);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==PARTITION {
				{
				recog.base.set_state(3777);
				recog.base.match_token(PARTITION,&mut recog.err_handler)?;

				recog.base.set_state(3778);
				recog.base.match_token(BY,&mut recog.err_handler)?;

				recog.base.set_state(3795);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(571,&mut recog.base)? {
					1 =>{
						{
						recog.base.set_state(3779);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						recog.base.set_state(3791);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOT - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
							{
							/*InvokeRule expression*/
							recog.base.set_state(3780);
							recog.expression()?;

							recog.base.set_state(3785);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(568,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(3781);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule expression*/
									recog.base.set_state(3782);
									recog.expression()?;

									}
									} 
								}
								recog.base.set_state(3787);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(568,&mut recog.base)?;
							}
							recog.base.set_state(3789);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(3788);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								 cast_mut::<_,TableArgumentContext >(&mut _localctx).COMMA = Some(tmp);
								  

								let temp =  cast_mut::<_,TableArgumentContext >(&mut _localctx).COMMA.clone().unwrap()
								 ;
								 cast_mut::<_,TableArgumentContext >(&mut _localctx).tail.push(temp);
								  
								}
							}

							}
						}

						recog.base.set_state(3793);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}
				,
					2 =>{
						{
						/*InvokeRule expression*/
						recog.base.set_state(3794);
						recog.expression()?;

						}
					}

					_ => {}
				}
				}
			}

			recog.base.set_state(3805);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 PRUNE 
				=> {
			    	{
			    	recog.base.set_state(3799);
			    	recog.base.match_token(PRUNE,&mut recog.err_handler)?;

			    	recog.base.set_state(3800);
			    	recog.base.match_token(WHEN,&mut recog.err_handler)?;

			    	recog.base.set_state(3801);
			    	recog.base.match_token(EMPTY,&mut recog.err_handler)?;

			    	}
			    }

			 KEEP 
				=> {
			    	{
			    	recog.base.set_state(3802);
			    	recog.base.match_token(KEEP,&mut recog.err_handler)?;

			    	recog.base.set_state(3803);
			    	recog.base.match_token(WHEN,&mut recog.err_handler)?;

			    	recog.base.set_state(3804);
			    	recog.base.match_token(EMPTY,&mut recog.err_handler)?;

			    	}
			    }

			 COMMA | COPARTITION | ORDER | RPAREN 
				=> {
			    }

				_ => {}
			}
			recog.base.set_state(3826);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ORDER {
				{
				recog.base.set_state(3807);
				recog.base.match_token(ORDER,&mut recog.err_handler)?;

				recog.base.set_state(3808);
				recog.base.match_token(BY,&mut recog.err_handler)?;

				recog.base.set_state(3824);
				recog.err_handler.sync(&mut recog.base)?;
				match  recog.interpreter.adaptive_predict(576,&mut recog.base)? {
					1 =>{
						{
						recog.base.set_state(3809);
						recog.base.match_token(LPAREN,&mut recog.err_handler)?;

						/*InvokeRule sortItem*/
						recog.base.set_state(3810);
						recog.sortItem()?;

						recog.base.set_state(3815);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(574,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(3811);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule sortItem*/
								recog.base.set_state(3812);
								recog.sortItem()?;

								}
								} 
							}
							recog.base.set_state(3817);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(574,&mut recog.base)?;
						}
						recog.base.set_state(3819);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(3818);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							 cast_mut::<_,TableArgumentContext >(&mut _localctx).COMMA = Some(tmp);
							  

							let temp =  cast_mut::<_,TableArgumentContext >(&mut _localctx).COMMA.clone().unwrap()
							 ;
							 cast_mut::<_,TableArgumentContext >(&mut _localctx).tail.push(temp);
							  
							}
						}

						recog.base.set_state(3821);
						recog.base.match_token(RPAREN,&mut recog.err_handler)?;

						}
					}
				,
					2 =>{
						{
						/*InvokeRule sortItem*/
						recog.base.set_state(3823);
						recog.sortItem()?;

						}
					}

					_ => {}
				}
				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- tableArgumentRelation ----------------
#[derive(Debug)]
pub enum TableArgumentRelationContextAll<'input>{
	TableArgumentQueryContext(TableArgumentQueryContext<'input>),
	TableArgumentTableContext(TableArgumentTableContext<'input>),
Error(TableArgumentRelationContext<'input>)
}
antlr_rust::tid!{TableArgumentRelationContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for TableArgumentRelationContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for TableArgumentRelationContextAll<'input>{}

impl<'input> Deref for TableArgumentRelationContextAll<'input>{
	type Target = dyn TableArgumentRelationContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use TableArgumentRelationContextAll::*;
		match self{
			TableArgumentQueryContext(inner) => inner,
			TableArgumentTableContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableArgumentRelationContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableArgumentRelationContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type TableArgumentRelationContext<'input> = BaseParserRuleContext<'input,TableArgumentRelationContextExt<'input>>;

#[derive(Clone)]
pub struct TableArgumentRelationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TableArgumentRelationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableArgumentRelationContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableArgumentRelationContext<'input>{
}

impl<'input> CustomRuleContext<'input> for TableArgumentRelationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableArgumentRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableArgumentRelation }
}
antlr_rust::tid!{TableArgumentRelationContextExt<'a>}

impl<'input> TableArgumentRelationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TableArgumentRelationContextAll<'input>> {
		Rc::new(
		TableArgumentRelationContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TableArgumentRelationContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait TableArgumentRelationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TableArgumentRelationContextExt<'input>>{


}

impl<'input> TableArgumentRelationContextAttrs<'input> for TableArgumentRelationContext<'input>{}

pub type TableArgumentQueryContext<'input> = BaseParserRuleContext<'input,TableArgumentQueryContextExt<'input>>;

pub trait TableArgumentQueryContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> TableArgumentQueryContextAttrs<'input> for TableArgumentQueryContext<'input>{}

pub struct TableArgumentQueryContextExt<'input>{
	base:TableArgumentRelationContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TableArgumentQueryContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TableArgumentQueryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableArgumentQueryContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tableArgumentQuery(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_tableArgumentQuery(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableArgumentQueryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableArgumentQuery(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableArgumentQueryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableArgumentRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableArgumentRelation }
}

impl<'input> Borrow<TableArgumentRelationContextExt<'input>> for TableArgumentQueryContext<'input>{
	fn borrow(&self) -> &TableArgumentRelationContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<TableArgumentRelationContextExt<'input>> for TableArgumentQueryContext<'input>{
	fn borrow_mut(&mut self) -> &mut TableArgumentRelationContextExt<'input> { &mut self.base }
}

impl<'input> TableArgumentRelationContextAttrs<'input> for TableArgumentQueryContext<'input> {}

impl<'input> TableArgumentQueryContextExt<'input>{
	fn new(ctx: &dyn TableArgumentRelationContextAttrs<'input>) -> Rc<TableArgumentRelationContextAll<'input>>  {
		Rc::new(
			TableArgumentRelationContextAll::TableArgumentQueryContext(
				BaseParserRuleContext::copy_from(ctx,TableArgumentQueryContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TableArgumentTableContext<'input> = BaseParserRuleContext<'input,TableArgumentTableContextExt<'input>>;

pub trait TableArgumentTableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token TABLE
	/// Returns `None` if there is no child corresponding to token TABLE
	fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn columnAliases(&self) -> Option<Rc<ColumnAliasesContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> TableArgumentTableContextAttrs<'input> for TableArgumentTableContext<'input>{}

pub struct TableArgumentTableContextExt<'input>{
	base:TableArgumentRelationContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TableArgumentTableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TableArgumentTableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TableArgumentTableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_tableArgumentTable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_tableArgumentTable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TableArgumentTableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_tableArgumentTable(self);
	}
}

impl<'input> CustomRuleContext<'input> for TableArgumentTableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_tableArgumentRelation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_tableArgumentRelation }
}

impl<'input> Borrow<TableArgumentRelationContextExt<'input>> for TableArgumentTableContext<'input>{
	fn borrow(&self) -> &TableArgumentRelationContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<TableArgumentRelationContextExt<'input>> for TableArgumentTableContext<'input>{
	fn borrow_mut(&mut self) -> &mut TableArgumentRelationContextExt<'input> { &mut self.base }
}

impl<'input> TableArgumentRelationContextAttrs<'input> for TableArgumentTableContext<'input> {}

impl<'input> TableArgumentTableContextExt<'input>{
	fn new(ctx: &dyn TableArgumentRelationContextAttrs<'input>) -> Rc<TableArgumentRelationContextAll<'input>>  {
		Rc::new(
			TableArgumentRelationContextAll::TableArgumentTableContext(
				BaseParserRuleContext::copy_from(ctx,TableArgumentTableContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn tableArgumentRelation(&mut self,)
	-> Result<Rc<TableArgumentRelationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TableArgumentRelationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 238, RULE_tableArgumentRelation);
        let mut _localctx: Rc<TableArgumentRelationContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3854);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(584,&mut recog.base)? {
				1 =>{
					let tmp = TableArgumentTableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(3828);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(3829);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(3830);
					recog.qualifiedName()?;

					recog.base.set_state(3831);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3839);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(580,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3833);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==AS {
								{
								recog.base.set_state(3832);
								recog.base.match_token(AS,&mut recog.err_handler)?;

								}
							}

							/*InvokeRule identifier*/
							recog.base.set_state(3835);
							recog.identifier()?;

							recog.base.set_state(3837);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==LPAREN {
								{
								/*InvokeRule columnAliases*/
								recog.base.set_state(3836);
								recog.columnAliases()?;

								}
							}

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					let tmp = TableArgumentQueryContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(3841);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					recog.base.set_state(3842);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(3843);
					recog.query()?;

					recog.base.set_state(3844);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3852);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(583,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3846);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==AS {
								{
								recog.base.set_state(3845);
								recog.base.match_token(AS,&mut recog.err_handler)?;

								}
							}

							/*InvokeRule identifier*/
							recog.base.set_state(3848);
							recog.identifier()?;

							recog.base.set_state(3850);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==LPAREN {
								{
								/*InvokeRule columnAliases*/
								recog.base.set_state(3849);
								recog.columnAliases()?;

								}
							}

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- descriptorArgument ----------------
pub type DescriptorArgumentContextAll<'input> = DescriptorArgumentContext<'input>;


pub type DescriptorArgumentContext<'input> = BaseParserRuleContext<'input,DescriptorArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct DescriptorArgumentContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for DescriptorArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DescriptorArgumentContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_descriptorArgument(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_descriptorArgument(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DescriptorArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_descriptorArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for DescriptorArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_descriptorArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_descriptorArgument }
}
antlr_rust::tid!{DescriptorArgumentContextExt<'a>}

impl<'input> DescriptorArgumentContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DescriptorArgumentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DescriptorArgumentContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait DescriptorArgumentContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<DescriptorArgumentContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DESCRIPTOR
/// Returns `None` if there is no child corresponding to token DESCRIPTOR
fn DESCRIPTOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DESCRIPTOR, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn descriptorField_all(&self) ->  Vec<Rc<DescriptorFieldContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn descriptorField(&self, i: usize) -> Option<Rc<DescriptorFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves first TerminalNode corresponding to token CAST
/// Returns `None` if there is no child corresponding to token CAST
fn CAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CAST, 0)
}
/// Retrieves first TerminalNode corresponding to token NULL
/// Returns `None` if there is no child corresponding to token NULL
fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULL, 0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}

}

impl<'input> DescriptorArgumentContextAttrs<'input> for DescriptorArgumentContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn descriptorArgument(&mut self,)
	-> Result<Rc<DescriptorArgumentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DescriptorArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 240, RULE_descriptorArgument);
        let mut _localctx: Rc<DescriptorArgumentContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(3877);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 DESCRIPTOR 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(3856);
					recog.base.match_token(DESCRIPTOR,&mut recog.err_handler)?;

					recog.base.set_state(3857);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule descriptorField*/
					recog.base.set_state(3858);
					recog.descriptorField()?;

					recog.base.set_state(3863);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(585,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3859);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule descriptorField*/
							recog.base.set_state(3860);
							recog.descriptorField()?;

							}
							} 
						}
						recog.base.set_state(3865);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(585,&mut recog.base)?;
					}
					recog.base.set_state(3867);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(3866);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						 cast_mut::<_,DescriptorArgumentContext >(&mut _localctx).tail = Some(tmp);
						  

						}
					}

					recog.base.set_state(3869);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

			 CAST 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(3871);
					recog.base.match_token(CAST,&mut recog.err_handler)?;

					recog.base.set_state(3872);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(3873);
					recog.base.match_token(NULL,&mut recog.err_handler)?;

					recog.base.set_state(3874);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					recog.base.set_state(3875);
					recog.base.match_token(DESCRIPTOR,&mut recog.err_handler)?;

					recog.base.set_state(3876);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- descriptorField ----------------
pub type DescriptorFieldContextAll<'input> = DescriptorFieldContext<'input>;


pub type DescriptorFieldContext<'input> = BaseParserRuleContext<'input,DescriptorFieldContextExt<'input>>;

#[derive(Clone)]
pub struct DescriptorFieldContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for DescriptorFieldContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DescriptorFieldContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_descriptorField(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_descriptorField(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DescriptorFieldContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_descriptorField(self);
	}
}

impl<'input> CustomRuleContext<'input> for DescriptorFieldContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_descriptorField }
	//fn type_rule_index() -> usize where Self: Sized { RULE_descriptorField }
}
antlr_rust::tid!{DescriptorFieldContextExt<'a>}

impl<'input> DescriptorFieldContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DescriptorFieldContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DescriptorFieldContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DescriptorFieldContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<DescriptorFieldContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DescriptorFieldContextAttrs<'input> for DescriptorFieldContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn descriptorField(&mut self,)
	-> Result<Rc<DescriptorFieldContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DescriptorFieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 242, RULE_descriptorField);
        let mut _localctx: Rc<DescriptorFieldContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(3879);
			recog.identifier()?;

			recog.base.set_state(3881);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULL - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 462)) & !0x3f) == 0 && ((1usize << (_la - 462)) & ((1usize << (DOLLAR - 462)) | (1usize << (IDENTIFIER - 462)) | (1usize << (QUOTED_IDENTIFIER - 462)) | (1usize << (BACKQUOTED_IDENTIFIER - 462)))) != 0) {
				{
				/*InvokeRule type_*/
				recog.base.set_state(3880);
				recog.type_()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- copartitionTables ----------------
pub type CopartitionTablesContextAll<'input> = CopartitionTablesContext<'input>;


pub type CopartitionTablesContext<'input> = BaseParserRuleContext<'input,CopartitionTablesContextExt<'input>>;

#[derive(Clone)]
pub struct CopartitionTablesContextExt<'input>{
	pub tail: Option<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for CopartitionTablesContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CopartitionTablesContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_copartitionTables(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_copartitionTables(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CopartitionTablesContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_copartitionTables(self);
	}
}

impl<'input> CustomRuleContext<'input> for CopartitionTablesContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_copartitionTables }
	//fn type_rule_index() -> usize where Self: Sized { RULE_copartitionTables }
}
antlr_rust::tid!{CopartitionTablesContextExt<'a>}

impl<'input> CopartitionTablesContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CopartitionTablesContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CopartitionTablesContextExt{
				tail: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait CopartitionTablesContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<CopartitionTablesContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn qualifiedName_all(&self) ->  Vec<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn qualifiedName(&self, i: usize) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}

}

impl<'input> CopartitionTablesContextAttrs<'input> for CopartitionTablesContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn copartitionTables(&mut self,)
	-> Result<Rc<CopartitionTablesContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CopartitionTablesContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 244, RULE_copartitionTables);
        let mut _localctx: Rc<CopartitionTablesContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3883);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule qualifiedName*/
			recog.base.set_state(3884);
			recog.qualifiedName()?;

			recog.base.set_state(3885);
			recog.base.match_token(COMMA,&mut recog.err_handler)?;

			/*InvokeRule qualifiedName*/
			recog.base.set_state(3886);
			recog.qualifiedName()?;

			recog.base.set_state(3891);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(589,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(3887);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule qualifiedName*/
					recog.base.set_state(3888);
					recog.qualifiedName()?;

					}
					} 
				}
				recog.base.set_state(3893);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(589,&mut recog.base)?;
			}
			recog.base.set_state(3895);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==COMMA {
				{
				recog.base.set_state(3894);
				let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
				 cast_mut::<_,CopartitionTablesContext >(&mut _localctx).tail = Some(tmp);
				  

				}
			}

			recog.base.set_state(3897);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- expression ----------------
pub type ExpressionContextAll<'input> = ExpressionContext<'input>;


pub type ExpressionContext<'input> = BaseParserRuleContext<'input,ExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_expression(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_expression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_expression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_expression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_expression }
}
antlr_rust::tid!{ExpressionContextExt<'a>}

impl<'input> ExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ExpressionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ExpressionContextExt<'input>>{

fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> ExpressionContextAttrs<'input> for ExpressionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn expression(&mut self,)
	-> Result<Rc<ExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 246, RULE_expression);
        let mut _localctx: Rc<ExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule booleanExpression*/
			recog.base.set_state(3899);
			recog.booleanExpression_rec(0)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- booleanExpression ----------------
#[derive(Debug)]
pub enum BooleanExpressionContextAll<'input>{
	DefaultBooleanExpressionContext(DefaultBooleanExpressionContext<'input>),
	LogicalNotContext(LogicalNotContext<'input>),
	OrContext(OrContext<'input>),
	PredicatedContext(PredicatedContext<'input>),
	AndContext(AndContext<'input>),
Error(BooleanExpressionContext<'input>)
}
antlr_rust::tid!{BooleanExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for BooleanExpressionContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for BooleanExpressionContextAll<'input>{}

impl<'input> Deref for BooleanExpressionContextAll<'input>{
	type Target = dyn BooleanExpressionContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use BooleanExpressionContextAll::*;
		match self{
			DefaultBooleanExpressionContext(inner) => inner,
			LogicalNotContext(inner) => inner,
			OrContext(inner) => inner,
			PredicatedContext(inner) => inner,
			AndContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for BooleanExpressionContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for BooleanExpressionContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type BooleanExpressionContext<'input> = BaseParserRuleContext<'input,BooleanExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct BooleanExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for BooleanExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for BooleanExpressionContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for BooleanExpressionContext<'input>{
}

impl<'input> CustomRuleContext<'input> for BooleanExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}
antlr_rust::tid!{BooleanExpressionContextExt<'a>}

impl<'input> BooleanExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BooleanExpressionContextAll<'input>> {
		Rc::new(
		BooleanExpressionContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BooleanExpressionContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait BooleanExpressionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<BooleanExpressionContextExt<'input>>{


}

impl<'input> BooleanExpressionContextAttrs<'input> for BooleanExpressionContext<'input>{}

pub type DefaultBooleanExpressionContext<'input> = BaseParserRuleContext<'input,DefaultBooleanExpressionContextExt<'input>>;

pub trait DefaultBooleanExpressionContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn nonComparisonExpression(&self) -> Option<Rc<NonComparisonExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> DefaultBooleanExpressionContextAttrs<'input> for DefaultBooleanExpressionContext<'input>{}

pub struct DefaultBooleanExpressionContextExt<'input>{
	base:BooleanExpressionContextExt<'input>,
	pub left: Option<Rc<NonComparisonExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DefaultBooleanExpressionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DefaultBooleanExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DefaultBooleanExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_defaultBooleanExpression(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_defaultBooleanExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DefaultBooleanExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_defaultBooleanExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for DefaultBooleanExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}

impl<'input> Borrow<BooleanExpressionContextExt<'input>> for DefaultBooleanExpressionContext<'input>{
	fn borrow(&self) -> &BooleanExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<BooleanExpressionContextExt<'input>> for DefaultBooleanExpressionContext<'input>{
	fn borrow_mut(&mut self) -> &mut BooleanExpressionContextExt<'input> { &mut self.base }
}

impl<'input> BooleanExpressionContextAttrs<'input> for DefaultBooleanExpressionContext<'input> {}

impl<'input> DefaultBooleanExpressionContextExt<'input>{
	fn new(ctx: &dyn BooleanExpressionContextAttrs<'input>) -> Rc<BooleanExpressionContextAll<'input>>  {
		Rc::new(
			BooleanExpressionContextAll::DefaultBooleanExpressionContext(
				BaseParserRuleContext::copy_from(ctx,DefaultBooleanExpressionContextExt{
        			left:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type LogicalNotContext<'input> = BaseParserRuleContext<'input,LogicalNotContextExt<'input>>;

pub trait LogicalNotContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> LogicalNotContextAttrs<'input> for LogicalNotContext<'input>{}

pub struct LogicalNotContextExt<'input>{
	base:BooleanExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{LogicalNotContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for LogicalNotContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LogicalNotContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_logicalNot(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_logicalNot(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LogicalNotContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_logicalNot(self);
	}
}

impl<'input> CustomRuleContext<'input> for LogicalNotContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}

impl<'input> Borrow<BooleanExpressionContextExt<'input>> for LogicalNotContext<'input>{
	fn borrow(&self) -> &BooleanExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<BooleanExpressionContextExt<'input>> for LogicalNotContext<'input>{
	fn borrow_mut(&mut self) -> &mut BooleanExpressionContextExt<'input> { &mut self.base }
}

impl<'input> BooleanExpressionContextAttrs<'input> for LogicalNotContext<'input> {}

impl<'input> LogicalNotContextExt<'input>{
	fn new(ctx: &dyn BooleanExpressionContextAttrs<'input>) -> Rc<BooleanExpressionContextAll<'input>>  {
		Rc::new(
			BooleanExpressionContextAll::LogicalNotContext(
				BaseParserRuleContext::copy_from(ctx,LogicalNotContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type OrContext<'input> = BaseParserRuleContext<'input,OrContextExt<'input>>;

pub trait OrContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn booleanExpression_all(&self) ->  Vec<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn booleanExpression(&self, i: usize) -> Option<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token OR
	/// Returns `None` if there is no child corresponding to token OR
	fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OR, 0)
	}
}

impl<'input> OrContextAttrs<'input> for OrContext<'input>{}

pub struct OrContextExt<'input>{
	base:BooleanExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{OrContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for OrContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for OrContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_or(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_or(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for OrContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_or(self);
	}
}

impl<'input> CustomRuleContext<'input> for OrContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}

impl<'input> Borrow<BooleanExpressionContextExt<'input>> for OrContext<'input>{
	fn borrow(&self) -> &BooleanExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<BooleanExpressionContextExt<'input>> for OrContext<'input>{
	fn borrow_mut(&mut self) -> &mut BooleanExpressionContextExt<'input> { &mut self.base }
}

impl<'input> BooleanExpressionContextAttrs<'input> for OrContext<'input> {}

impl<'input> OrContextExt<'input>{
	fn new(ctx: &dyn BooleanExpressionContextAttrs<'input>) -> Rc<BooleanExpressionContextAll<'input>>  {
		Rc::new(
			BooleanExpressionContextAll::OrContext(
				BaseParserRuleContext::copy_from(ctx,OrContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PredicatedContext<'input> = BaseParserRuleContext<'input,PredicatedContextExt<'input>>;

pub trait PredicatedContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn comparisonPredicate(&self) -> Option<Rc<ComparisonPredicateContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> PredicatedContextAttrs<'input> for PredicatedContext<'input>{}

pub struct PredicatedContextExt<'input>{
	base:BooleanExpressionContextExt<'input>,
	pub left: Option<Rc<BooleanExpressionContextAll<'input>>>,
	pub pred: Option<Rc<ComparisonPredicateContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PredicatedContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PredicatedContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PredicatedContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_predicated(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_predicated(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PredicatedContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_predicated(self);
	}
}

impl<'input> CustomRuleContext<'input> for PredicatedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}

impl<'input> Borrow<BooleanExpressionContextExt<'input>> for PredicatedContext<'input>{
	fn borrow(&self) -> &BooleanExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<BooleanExpressionContextExt<'input>> for PredicatedContext<'input>{
	fn borrow_mut(&mut self) -> &mut BooleanExpressionContextExt<'input> { &mut self.base }
}

impl<'input> BooleanExpressionContextAttrs<'input> for PredicatedContext<'input> {}

impl<'input> PredicatedContextExt<'input>{
	fn new(ctx: &dyn BooleanExpressionContextAttrs<'input>) -> Rc<BooleanExpressionContextAll<'input>>  {
		Rc::new(
			BooleanExpressionContextAll::PredicatedContext(
				BaseParserRuleContext::copy_from(ctx,PredicatedContextExt{
        			left:None, pred:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type AndContext<'input> = BaseParserRuleContext<'input,AndContextExt<'input>>;

pub trait AndContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn booleanExpression_all(&self) ->  Vec<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn booleanExpression(&self, i: usize) -> Option<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token AND
	/// Returns `None` if there is no child corresponding to token AND
	fn AND(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AND, 0)
	}
}

impl<'input> AndContextAttrs<'input> for AndContext<'input>{}

pub struct AndContextExt<'input>{
	base:BooleanExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{AndContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for AndContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AndContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_and(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_and(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AndContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_and(self);
	}
}

impl<'input> CustomRuleContext<'input> for AndContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanExpression }
}

impl<'input> Borrow<BooleanExpressionContextExt<'input>> for AndContext<'input>{
	fn borrow(&self) -> &BooleanExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<BooleanExpressionContextExt<'input>> for AndContext<'input>{
	fn borrow_mut(&mut self) -> &mut BooleanExpressionContextExt<'input> { &mut self.base }
}

impl<'input> BooleanExpressionContextAttrs<'input> for AndContext<'input> {}

impl<'input> AndContextExt<'input>{
	fn new(ctx: &dyn BooleanExpressionContextAttrs<'input>) -> Rc<BooleanExpressionContextAll<'input>>  {
		Rc::new(
			BooleanExpressionContextAll::AndContext(
				BaseParserRuleContext::copy_from(ctx,AndContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  booleanExpression(&mut self,)
	-> Result<Rc<BooleanExpressionContextAll<'input>>,ANTLRError> {
		self.booleanExpression_rec(0)
	}

	fn booleanExpression_rec(&mut self, _p: isize)
	-> Result<Rc<BooleanExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = BooleanExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 248, RULE_booleanExpression, _p);
	    let mut _localctx: Rc<BooleanExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 248;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(3905);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 T__2 | ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI |
			 APPEND_ONLY | ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH |
			 AUTHORIZATION | AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI |
			 BLOCK | BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE |
			 CASE_SENSITIVE | CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR |
			 CHARACTER | CLONE | CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT |
			 COMMITTED | COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
			 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
			 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
			 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
			 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
			 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC | EMPTY |
			 ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE | EVEN |
			 EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXISTS | EXPLAIN | EXTERNAL |
			 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
			 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FULL |
			 FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS |
			 GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
			 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
			 INFORMATION | INITIAL | INITIALLY | INNER | INPUT | INPUTFORMAT | INTERLEAVED |
			 INSERT | INTERVAL | INVOKER | IO | ISOLATION | ILIKE | JAVA | JAVASCRIPT |
			 JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE |
			 KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LATERAL |
			 LEADING | LEFT | LEVEL | LIBRARY | LIKE | LIMIT | LINES | LISTAGG | LOCAL |
			 LOCATION | LOCK | LOGICAL | MAP | MASKING | MATCH | MATCHED | MATCHES |
			 MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES | MEMORIZABLE |
			 MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME | NATURAL | NCHAR |
			 NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER | NORELY | NORMALIZE |
			 NOVALIDATE | NULL | NULLS | OBJECT | OFFSET | OMIT | ONE | ONLY | OPTION |
			 OPTIONS | ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW |
			 OWNER | PARTITION | PARTITIONED | PARTITIONS | PASSING | PAST | PATH |
			 PATTERN | PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE |
			 PIVOT | PLACING | POLICY | POSITION | PRECEDING | PRECISION | PREPARE |
			 PRIOR | PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON |
			 QUOTES | RANGE | READ | RECURSIVE | REGEXP | REFERENCE | REFERENCES |
			 REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT |
			 RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT | RLIKE | RLS | ROLE |
			 ROLES | ROLLBACK | ROLLUP | ROW | RUNNING | SCALA | SCALAR | SECOND |
			 SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI | SEQUENCE |
			 SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR |
			 SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED |
			 STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME |
			 TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW |
			 TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION |
			 TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE |
			 UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED |
			 UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER | USING | UTF16 | UTF32 |
			 UTF8 | VACUUM | VALIDATE | VALUE | VARYING | VECTOR | VERBOSE | VERSION |
			 VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN | WITHOUT | WORK |
			 WRAPPER | WRITE | XZ | YEAR | YES | ZONE | ZSTD | LPAREN | LBRACKET |
			 PLUS | MINUS | DOLLAR | POSIX | STRING | UNICODE_STRING | DOLLAR_QUOTED_STRING |
			 BINARY_LITERAL | INTEGER_VALUE | DECIMAL_VALUE | DOUBLE_VALUE | IDENTIFIER |
			 QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER | VARIABLE 
				=> {
					{
					let mut tmp = DefaultBooleanExpressionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();


					/*InvokeRule nonComparisonExpression*/
					recog.base.set_state(3902);
					let tmp = recog.nonComparisonExpression()?;
					if let BooleanExpressionContextAll::DefaultBooleanExpressionContext(ctx) = cast_mut::<_,BooleanExpressionContextAll >(&mut _localctx){
					ctx.left = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}

			 NOT 
				=> {
					{
					let mut tmp = LogicalNotContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(3903);
					recog.base.match_token(NOT,&mut recog.err_handler)?;

					/*InvokeRule booleanExpression*/
					recog.base.set_state(3904);
					recog.booleanExpression_rec(3)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(3917);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(593,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(3915);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(592,&mut recog.base)? {
						1 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = AndContextExt::new(&**BooleanExpressionContextExt::new(_parentctx.clone(), _parentState));
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_booleanExpression);
							_localctx = tmp;
							recog.base.set_state(3907);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(3908);
							recog.base.match_token(AND,&mut recog.err_handler)?;

							/*InvokeRule booleanExpression*/
							recog.base.set_state(3909);
							recog.booleanExpression_rec(3)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = OrContextExt::new(&**BooleanExpressionContextExt::new(_parentctx.clone(), _parentState));
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_booleanExpression);
							_localctx = tmp;
							recog.base.set_state(3910);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(3911);
							recog.base.match_token(OR,&mut recog.err_handler)?;

							/*InvokeRule booleanExpression*/
							recog.base.set_state(3912);
							recog.booleanExpression_rec(2)?;

							}
						}
					,
						3 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = PredicatedContextExt::new(&**BooleanExpressionContextExt::new(_parentctx.clone(), _parentState));
							if let BooleanExpressionContextAll::PredicatedContext(ctx) = cast_mut::<_,BooleanExpressionContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_booleanExpression);
							_localctx = tmp;
							recog.base.set_state(3913);
							if !({recog.precpred(None, 5)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 5)".to_owned()), None))?;
							}
							/*InvokeRule comparisonPredicate*/
							recog.base.set_state(3914);
							let tmp = recog.comparisonPredicate()?;
							if let BooleanExpressionContextAll::PredicatedContext(ctx) = cast_mut::<_,BooleanExpressionContextAll >(&mut _localctx){
							ctx.pred = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(3919);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(593,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- comparisonPredicate ----------------
#[derive(Debug)]
pub enum ComparisonPredicateContextAll<'input>{
	ComparisonContext(ComparisonContext<'input>),
	QuantifiedComparisonContext(QuantifiedComparisonContext<'input>),
Error(ComparisonPredicateContext<'input>)
}
antlr_rust::tid!{ComparisonPredicateContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ComparisonPredicateContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for ComparisonPredicateContextAll<'input>{}

impl<'input> Deref for ComparisonPredicateContextAll<'input>{
	type Target = dyn ComparisonPredicateContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use ComparisonPredicateContextAll::*;
		match self{
			ComparisonContext(inner) => inner,
			QuantifiedComparisonContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ComparisonPredicateContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ComparisonPredicateContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type ComparisonPredicateContext<'input> = BaseParserRuleContext<'input,ComparisonPredicateContextExt<'input>>;

#[derive(Clone)]
pub struct ComparisonPredicateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ComparisonPredicateContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ComparisonPredicateContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ComparisonPredicateContext<'input>{
}

impl<'input> CustomRuleContext<'input> for ComparisonPredicateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_comparisonPredicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_comparisonPredicate }
}
antlr_rust::tid!{ComparisonPredicateContextExt<'a>}

impl<'input> ComparisonPredicateContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ComparisonPredicateContextAll<'input>> {
		Rc::new(
		ComparisonPredicateContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ComparisonPredicateContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait ComparisonPredicateContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ComparisonPredicateContextExt<'input>>{


}

impl<'input> ComparisonPredicateContextAttrs<'input> for ComparisonPredicateContext<'input>{}

pub type ComparisonContext<'input> = BaseParserRuleContext<'input,ComparisonContextExt<'input>>;

pub trait ComparisonContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn comparisonOperator(&self) -> Option<Rc<ComparisonOperatorContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token COLLATE
	/// Returns `None` if there is no child corresponding to token COLLATE
	fn COLLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COLLATE, 0)
	}
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ComparisonContextAttrs<'input> for ComparisonContext<'input>{}

pub struct ComparisonContextExt<'input>{
	base:ComparisonPredicateContextExt<'input>,
	pub right: Option<Rc<ValueExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ComparisonContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ComparisonContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ComparisonContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_comparison(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_comparison(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ComparisonContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_comparison(self);
	}
}

impl<'input> CustomRuleContext<'input> for ComparisonContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_comparisonPredicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_comparisonPredicate }
}

impl<'input> Borrow<ComparisonPredicateContextExt<'input>> for ComparisonContext<'input>{
	fn borrow(&self) -> &ComparisonPredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ComparisonPredicateContextExt<'input>> for ComparisonContext<'input>{
	fn borrow_mut(&mut self) -> &mut ComparisonPredicateContextExt<'input> { &mut self.base }
}

impl<'input> ComparisonPredicateContextAttrs<'input> for ComparisonContext<'input> {}

impl<'input> ComparisonContextExt<'input>{
	fn new(ctx: &dyn ComparisonPredicateContextAttrs<'input>) -> Rc<ComparisonPredicateContextAll<'input>>  {
		Rc::new(
			ComparisonPredicateContextAll::ComparisonContext(
				BaseParserRuleContext::copy_from(ctx,ComparisonContextExt{
        			right:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type QuantifiedComparisonContext<'input> = BaseParserRuleContext<'input,QuantifiedComparisonContextExt<'input>>;

pub trait QuantifiedComparisonContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn comparisonOperator(&self) -> Option<Rc<ComparisonOperatorContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn comparisonQuantifier(&self) -> Option<Rc<ComparisonQuantifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> QuantifiedComparisonContextAttrs<'input> for QuantifiedComparisonContext<'input>{}

pub struct QuantifiedComparisonContextExt<'input>{
	base:ComparisonPredicateContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{QuantifiedComparisonContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for QuantifiedComparisonContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QuantifiedComparisonContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_quantifiedComparison(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_quantifiedComparison(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QuantifiedComparisonContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_quantifiedComparison(self);
	}
}

impl<'input> CustomRuleContext<'input> for QuantifiedComparisonContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_comparisonPredicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_comparisonPredicate }
}

impl<'input> Borrow<ComparisonPredicateContextExt<'input>> for QuantifiedComparisonContext<'input>{
	fn borrow(&self) -> &ComparisonPredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ComparisonPredicateContextExt<'input>> for QuantifiedComparisonContext<'input>{
	fn borrow_mut(&mut self) -> &mut ComparisonPredicateContextExt<'input> { &mut self.base }
}

impl<'input> ComparisonPredicateContextAttrs<'input> for QuantifiedComparisonContext<'input> {}

impl<'input> QuantifiedComparisonContextExt<'input>{
	fn new(ctx: &dyn ComparisonPredicateContextAttrs<'input>) -> Rc<ComparisonPredicateContextAll<'input>>  {
		Rc::new(
			ComparisonPredicateContextAll::QuantifiedComparisonContext(
				BaseParserRuleContext::copy_from(ctx,QuantifiedComparisonContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn comparisonPredicate(&mut self,)
	-> Result<Rc<ComparisonPredicateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ComparisonPredicateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 250, RULE_comparisonPredicate);
        let mut _localctx: Rc<ComparisonPredicateContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(3932);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(595,&mut recog.base)? {
				1 =>{
					let tmp = ComparisonContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule comparisonOperator*/
					recog.base.set_state(3920);
					recog.comparisonOperator()?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(3921);
					let tmp = recog.valueExpression_rec(0)?;
					if let ComparisonPredicateContextAll::ComparisonContext(ctx) = cast_mut::<_,ComparisonPredicateContextAll >(&mut _localctx){
					ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(3924);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(594,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3922);
							recog.base.match_token(COLLATE,&mut recog.err_handler)?;

							/*InvokeRule string*/
							recog.base.set_state(3923);
							recog.string()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					let tmp = QuantifiedComparisonContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule comparisonOperator*/
					recog.base.set_state(3926);
					recog.comparisonOperator()?;

					/*InvokeRule comparisonQuantifier*/
					recog.base.set_state(3927);
					recog.comparisonQuantifier()?;

					recog.base.set_state(3928);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(3929);
					recog.query()?;

					recog.base.set_state(3930);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nonComparisonExpression ----------------
pub type NonComparisonExpressionContextAll<'input> = NonComparisonExpressionContext<'input>;


pub type NonComparisonExpressionContext<'input> = BaseParserRuleContext<'input,NonComparisonExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct NonComparisonExpressionContextExt<'input>{
	pub left: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub pred: Option<Rc<PredicateContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NonComparisonExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NonComparisonExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nonComparisonExpression(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_nonComparisonExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NonComparisonExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_nonComparisonExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for NonComparisonExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonComparisonExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonComparisonExpression }
}
antlr_rust::tid!{NonComparisonExpressionContextExt<'a>}

impl<'input> NonComparisonExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NonComparisonExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NonComparisonExpressionContextExt{
				left: None, pred: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait NonComparisonExpressionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NonComparisonExpressionContextExt<'input>>{

fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn predicate(&self) -> Option<Rc<PredicateContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NonComparisonExpressionContextAttrs<'input> for NonComparisonExpressionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nonComparisonExpression(&mut self,)
	-> Result<Rc<NonComparisonExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NonComparisonExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 252, RULE_nonComparisonExpression);
        let mut _localctx: Rc<NonComparisonExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule valueExpression*/
			recog.base.set_state(3934);
			let tmp = recog.valueExpression_rec(0)?;
			 cast_mut::<_,NonComparisonExpressionContext >(&mut _localctx).left = Some(tmp.clone());
			  

			recog.base.set_state(3936);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(596,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule predicate*/
					recog.base.set_state(3935);
					let tmp = recog.predicate()?;
					 cast_mut::<_,NonComparisonExpressionContext >(&mut _localctx).pred = Some(tmp.clone());
					  

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- predicate ----------------
#[derive(Debug)]
pub enum PredicateContextAll<'input>{
	RlikeContext(RlikeContext<'input>),
	CollateContext(CollateContext<'input>),
	RegexpContext(RegexpContext<'input>),
	UnknownPredicateContext(UnknownPredicateContext<'input>),
	LikeAnyContext(LikeAnyContext<'input>),
	LikeContext(LikeContext<'input>),
	InSubqueryContext(InSubqueryContext<'input>),
	DistinctFromContext(DistinctFromContext<'input>),
	SimilarToContext(SimilarToContext<'input>),
	InListContext(InListContext<'input>),
	NullPredicateContext(NullPredicateContext<'input>),
	BetweenContext(BetweenContext<'input>),
Error(PredicateContext<'input>)
}
antlr_rust::tid!{PredicateContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PredicateContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PredicateContextAll<'input>{}

impl<'input> Deref for PredicateContextAll<'input>{
	type Target = dyn PredicateContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PredicateContextAll::*;
		match self{
			RlikeContext(inner) => inner,
			CollateContext(inner) => inner,
			RegexpContext(inner) => inner,
			UnknownPredicateContext(inner) => inner,
			LikeAnyContext(inner) => inner,
			LikeContext(inner) => inner,
			InSubqueryContext(inner) => inner,
			DistinctFromContext(inner) => inner,
			SimilarToContext(inner) => inner,
			InListContext(inner) => inner,
			NullPredicateContext(inner) => inner,
			BetweenContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PredicateContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PredicateContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PredicateContext<'input> = BaseParserRuleContext<'input,PredicateContextExt<'input>>;

#[derive(Clone)]
pub struct PredicateContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PredicateContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PredicateContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PredicateContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PredicateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}
antlr_rust::tid!{PredicateContextExt<'a>}

impl<'input> PredicateContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PredicateContextAll<'input>> {
		Rc::new(
		PredicateContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PredicateContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PredicateContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PredicateContextExt<'input>>{


}

impl<'input> PredicateContextAttrs<'input> for PredicateContext<'input>{}

pub type RlikeContext<'input> = BaseParserRuleContext<'input,RlikeContextExt<'input>>;

pub trait RlikeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token RLIKE
	/// Returns `None` if there is no child corresponding to token RLIKE
	fn RLIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RLIKE, 0)
	}
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> RlikeContextAttrs<'input> for RlikeContext<'input>{}

pub struct RlikeContextExt<'input>{
	base:PredicateContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RlikeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RlikeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RlikeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rlike(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_rlike(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RlikeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rlike(self);
	}
}

impl<'input> CustomRuleContext<'input> for RlikeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for RlikeContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for RlikeContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for RlikeContext<'input> {}

impl<'input> RlikeContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::RlikeContext(
				BaseParserRuleContext::copy_from(ctx,RlikeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CollateContext<'input> = BaseParserRuleContext<'input,CollateContextExt<'input>>;

pub trait CollateContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token COLLATE
	/// Returns `None` if there is no child corresponding to token COLLATE
	fn COLLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COLLATE, 0)
	}
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> CollateContextAttrs<'input> for CollateContext<'input>{}

pub struct CollateContextExt<'input>{
	base:PredicateContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CollateContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CollateContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CollateContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_collate(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_collate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CollateContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_collate(self);
	}
}

impl<'input> CustomRuleContext<'input> for CollateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for CollateContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for CollateContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for CollateContext<'input> {}

impl<'input> CollateContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::CollateContext(
				BaseParserRuleContext::copy_from(ctx,CollateContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RegexpContext<'input> = BaseParserRuleContext<'input,RegexpContextExt<'input>>;

pub trait RegexpContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token REGEXP
	/// Returns `None` if there is no child corresponding to token REGEXP
	fn REGEXP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REGEXP, 0)
	}
	fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> RegexpContextAttrs<'input> for RegexpContext<'input>{}

pub struct RegexpContextExt<'input>{
	base:PredicateContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RegexpContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RegexpContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RegexpContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_regexp(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_regexp(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RegexpContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_regexp(self);
	}
}

impl<'input> CustomRuleContext<'input> for RegexpContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for RegexpContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for RegexpContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for RegexpContext<'input> {}

impl<'input> RegexpContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::RegexpContext(
				BaseParserRuleContext::copy_from(ctx,RegexpContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type UnknownPredicateContext<'input> = BaseParserRuleContext<'input,UnknownPredicateContextExt<'input>>;

pub trait UnknownPredicateContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token IS
	/// Returns `None` if there is no child corresponding to token IS
	fn IS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token UNKNOWN
	/// Returns `None` if there is no child corresponding to token UNKNOWN
	fn UNKNOWN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(UNKNOWN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> UnknownPredicateContextAttrs<'input> for UnknownPredicateContext<'input>{}

pub struct UnknownPredicateContextExt<'input>{
	base:PredicateContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UnknownPredicateContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UnknownPredicateContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UnknownPredicateContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unknownPredicate(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_unknownPredicate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UnknownPredicateContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_unknownPredicate(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnknownPredicateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for UnknownPredicateContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for UnknownPredicateContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for UnknownPredicateContext<'input> {}

impl<'input> UnknownPredicateContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::UnknownPredicateContext(
				BaseParserRuleContext::copy_from(ctx,UnknownPredicateContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type LikeAnyContext<'input> = BaseParserRuleContext<'input,LikeAnyContextExt<'input>>;

pub trait LikeAnyContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LIKE
	/// Returns `None` if there is no child corresponding to token LIKE
	fn LIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LIKE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ILIKE
	/// Returns `None` if there is no child corresponding to token ILIKE
	fn ILIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ILIKE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ANY
	/// Returns `None` if there is no child corresponding to token ANY
	fn ANY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ANY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ALL
	/// Returns `None` if there is no child corresponding to token ALL
	fn ALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ALL, 0)
	}
	fn valueExpression_all(&self) ->  Vec<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token ESCAPE
	/// Returns `None` if there is no child corresponding to token ESCAPE
	fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ESCAPE, 0)
	}
}

impl<'input> LikeAnyContextAttrs<'input> for LikeAnyContext<'input>{}

pub struct LikeAnyContextExt<'input>{
	base:PredicateContextExt<'input>,
	pub pattern: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub escape: Option<Rc<ValueExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{LikeAnyContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for LikeAnyContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LikeAnyContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_likeAny(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_likeAny(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LikeAnyContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_likeAny(self);
	}
}

impl<'input> CustomRuleContext<'input> for LikeAnyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for LikeAnyContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for LikeAnyContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for LikeAnyContext<'input> {}

impl<'input> LikeAnyContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::LikeAnyContext(
				BaseParserRuleContext::copy_from(ctx,LikeAnyContextExt{
        			pattern:None, escape:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type LikeContext<'input> = BaseParserRuleContext<'input,LikeContextExt<'input>>;

pub trait LikeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LIKE
	/// Returns `None` if there is no child corresponding to token LIKE
	fn LIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LIKE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ILIKE
	/// Returns `None` if there is no child corresponding to token ILIKE
	fn ILIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ILIKE, 0)
	}
	fn valueExpression_all(&self) ->  Vec<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ESCAPE
	/// Returns `None` if there is no child corresponding to token ESCAPE
	fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ESCAPE, 0)
	}
}

impl<'input> LikeContextAttrs<'input> for LikeContext<'input>{}

pub struct LikeContextExt<'input>{
	base:PredicateContextExt<'input>,
	pub pattern: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub escape: Option<Rc<ValueExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{LikeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for LikeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LikeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_like(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_like(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LikeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_like(self);
	}
}

impl<'input> CustomRuleContext<'input> for LikeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for LikeContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for LikeContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for LikeContext<'input> {}

impl<'input> LikeContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::LikeContext(
				BaseParserRuleContext::copy_from(ctx,LikeContextExt{
        			pattern:None, escape:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type InSubqueryContext<'input> = BaseParserRuleContext<'input,InSubqueryContextExt<'input>>;

pub trait InSubqueryContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token IN
	/// Returns `None` if there is no child corresponding to token IN
	fn IN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> InSubqueryContextAttrs<'input> for InSubqueryContext<'input>{}

pub struct InSubqueryContextExt<'input>{
	base:PredicateContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{InSubqueryContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for InSubqueryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for InSubqueryContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_inSubquery(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_inSubquery(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for InSubqueryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_inSubquery(self);
	}
}

impl<'input> CustomRuleContext<'input> for InSubqueryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for InSubqueryContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for InSubqueryContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for InSubqueryContext<'input> {}

impl<'input> InSubqueryContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::InSubqueryContext(
				BaseParserRuleContext::copy_from(ctx,InSubqueryContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DistinctFromContext<'input> = BaseParserRuleContext<'input,DistinctFromContextExt<'input>>;

pub trait DistinctFromContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token IS
	/// Returns `None` if there is no child corresponding to token IS
	fn IS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DISTINCT
	/// Returns `None` if there is no child corresponding to token DISTINCT
	fn DISTINCT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DISTINCT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FROM
	/// Returns `None` if there is no child corresponding to token FROM
	fn FROM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FROM, 0)
	}
	fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> DistinctFromContextAttrs<'input> for DistinctFromContext<'input>{}

pub struct DistinctFromContextExt<'input>{
	base:PredicateContextExt<'input>,
	pub right: Option<Rc<ValueExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DistinctFromContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DistinctFromContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DistinctFromContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_distinctFrom(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_distinctFrom(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DistinctFromContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_distinctFrom(self);
	}
}

impl<'input> CustomRuleContext<'input> for DistinctFromContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for DistinctFromContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for DistinctFromContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for DistinctFromContext<'input> {}

impl<'input> DistinctFromContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::DistinctFromContext(
				BaseParserRuleContext::copy_from(ctx,DistinctFromContextExt{
        			right:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SimilarToContext<'input> = BaseParserRuleContext<'input,SimilarToContextExt<'input>>;

pub trait SimilarToContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token SIMILAR
	/// Returns `None` if there is no child corresponding to token SIMILAR
	fn SIMILAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SIMILAR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TO
	/// Returns `None` if there is no child corresponding to token TO
	fn TO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TO, 0)
	}
	fn valueExpression_all(&self) ->  Vec<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ESCAPE
	/// Returns `None` if there is no child corresponding to token ESCAPE
	fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ESCAPE, 0)
	}
}

impl<'input> SimilarToContextAttrs<'input> for SimilarToContext<'input>{}

pub struct SimilarToContextExt<'input>{
	base:PredicateContextExt<'input>,
	pub pattern: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub escape: Option<Rc<ValueExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SimilarToContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SimilarToContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SimilarToContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_similarTo(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_similarTo(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SimilarToContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_similarTo(self);
	}
}

impl<'input> CustomRuleContext<'input> for SimilarToContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for SimilarToContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for SimilarToContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for SimilarToContext<'input> {}

impl<'input> SimilarToContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::SimilarToContext(
				BaseParserRuleContext::copy_from(ctx,SimilarToContextExt{
        			pattern:None, escape:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type InListContext<'input> = BaseParserRuleContext<'input,InListContextExt<'input>>;

pub trait InListContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token IN
	/// Returns `None` if there is no child corresponding to token IN
	fn IN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> InListContextAttrs<'input> for InListContext<'input>{}

pub struct InListContextExt<'input>{
	base:PredicateContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{InListContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for InListContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for InListContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_inList(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_inList(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for InListContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_inList(self);
	}
}

impl<'input> CustomRuleContext<'input> for InListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for InListContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for InListContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for InListContext<'input> {}

impl<'input> InListContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::InListContext(
				BaseParserRuleContext::copy_from(ctx,InListContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type NullPredicateContext<'input> = BaseParserRuleContext<'input,NullPredicateContextExt<'input>>;

pub trait NullPredicateContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token IS
	/// Returns `None` if there is no child corresponding to token IS
	fn IS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NULL
	/// Returns `None` if there is no child corresponding to token NULL
	fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> NullPredicateContextAttrs<'input> for NullPredicateContext<'input>{}

pub struct NullPredicateContextExt<'input>{
	base:PredicateContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{NullPredicateContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for NullPredicateContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NullPredicateContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_nullPredicate(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_nullPredicate(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NullPredicateContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_nullPredicate(self);
	}
}

impl<'input> CustomRuleContext<'input> for NullPredicateContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for NullPredicateContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for NullPredicateContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for NullPredicateContext<'input> {}

impl<'input> NullPredicateContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::NullPredicateContext(
				BaseParserRuleContext::copy_from(ctx,NullPredicateContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type BetweenContext<'input> = BaseParserRuleContext<'input,BetweenContextExt<'input>>;

pub trait BetweenContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token BETWEEN
	/// Returns `None` if there is no child corresponding to token BETWEEN
	fn BETWEEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BETWEEN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token AND
	/// Returns `None` if there is no child corresponding to token AND
	fn AND(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AND, 0)
	}
	fn valueExpression_all(&self) ->  Vec<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
}

impl<'input> BetweenContextAttrs<'input> for BetweenContext<'input>{}

pub struct BetweenContextExt<'input>{
	base:PredicateContextExt<'input>,
	pub lower: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub upper: Option<Rc<ValueExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{BetweenContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for BetweenContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for BetweenContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_between(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_between(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for BetweenContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_between(self);
	}
}

impl<'input> CustomRuleContext<'input> for BetweenContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_predicate }
	//fn type_rule_index() -> usize where Self: Sized { RULE_predicate }
}

impl<'input> Borrow<PredicateContextExt<'input>> for BetweenContext<'input>{
	fn borrow(&self) -> &PredicateContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PredicateContextExt<'input>> for BetweenContext<'input>{
	fn borrow_mut(&mut self) -> &mut PredicateContextExt<'input> { &mut self.base }
}

impl<'input> PredicateContextAttrs<'input> for BetweenContext<'input> {}

impl<'input> BetweenContextExt<'input>{
	fn new(ctx: &dyn PredicateContextAttrs<'input>) -> Rc<PredicateContextAll<'input>>  {
		Rc::new(
			PredicateContextAll::BetweenContext(
				BaseParserRuleContext::copy_from(ctx,BetweenContextExt{
        			lower:None, upper:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn predicate(&mut self,)
	-> Result<Rc<PredicateContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PredicateContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 254, RULE_predicate);
        let mut _localctx: Rc<PredicateContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(4027);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(612,&mut recog.base)? {
				1 =>{
					let tmp = BetweenContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(3939);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(3938);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(3941);
					recog.base.match_token(BETWEEN,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(3942);
					let tmp = recog.valueExpression_rec(0)?;
					if let PredicateContextAll::BetweenContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
					ctx.lower = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(3943);
					recog.base.match_token(AND,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(3944);
					let tmp = recog.valueExpression_rec(0)?;
					if let PredicateContextAll::BetweenContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
					ctx.upper = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				2 =>{
					let tmp = InListContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(3947);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(3946);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(3949);
					recog.base.match_token(IN,&mut recog.err_handler)?;

					recog.base.set_state(3950);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(3951);
					recog.expression()?;

					recog.base.set_state(3956);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(599,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(3952);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(3953);
							recog.expression()?;

							}
							} 
						}
						recog.base.set_state(3958);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(599,&mut recog.base)?;
					}
					recog.base.set_state(3960);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(3959);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let PredicateContextAll::InListContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(3962);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					let tmp = InSubqueryContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(3965);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(3964);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(3967);
					recog.base.match_token(IN,&mut recog.err_handler)?;

					recog.base.set_state(3968);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(3969);
					recog.query()?;

					recog.base.set_state(3970);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					let tmp = LikeAnyContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					recog.base.set_state(3972);
					_la = recog.base.input.la(1);
					if { !(_la==ILIKE || _la==LIKE) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(3973);
					_la = recog.base.input.la(1);
					if { !(_la==ALL || _la==ANY) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule valueExpression*/
					recog.base.set_state(3974);
					let tmp = recog.valueExpression_rec(0)?;
					if let PredicateContextAll::LikeAnyContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
					ctx.pattern = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(3977);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(602,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3975);
							recog.base.match_token(ESCAPE,&mut recog.err_handler)?;

							/*InvokeRule valueExpression*/
							recog.base.set_state(3976);
							let tmp = recog.valueExpression_rec(0)?;
							if let PredicateContextAll::LikeAnyContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
							ctx.escape = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					}
				}
			,
				5 =>{
					let tmp = CollateContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 5);
					_localctx = tmp;
					{
					recog.base.set_state(3979);
					recog.base.match_token(COLLATE,&mut recog.err_handler)?;

					/*InvokeRule string*/
					recog.base.set_state(3980);
					recog.string()?;

					}
				}
			,
				6 =>{
					let tmp = RegexpContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 6);
					_localctx = tmp;
					{
					recog.base.set_state(3982);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(3981);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(3984);
					recog.base.match_token(REGEXP,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(3985);
					recog.valueExpression_rec(0)?;

					}
				}
			,
				7 =>{
					let tmp = RlikeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 7);
					_localctx = tmp;
					{
					recog.base.set_state(3987);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(3986);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(3989);
					recog.base.match_token(RLIKE,&mut recog.err_handler)?;

					/*InvokeRule string*/
					recog.base.set_state(3990);
					recog.string()?;

					}
				}
			,
				8 =>{
					let tmp = LikeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 8);
					_localctx = tmp;
					{
					recog.base.set_state(3992);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(3991);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(3994);
					_la = recog.base.input.la(1);
					if { !(_la==ILIKE || _la==LIKE) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule valueExpression*/
					recog.base.set_state(3995);
					let tmp = recog.valueExpression_rec(0)?;
					if let PredicateContextAll::LikeContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
					ctx.pattern = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(3998);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(606,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(3996);
							recog.base.match_token(ESCAPE,&mut recog.err_handler)?;

							/*InvokeRule valueExpression*/
							recog.base.set_state(3997);
							let tmp = recog.valueExpression_rec(0)?;
							if let PredicateContextAll::LikeContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
							ctx.escape = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					}
				}
			,
				9 =>{
					let tmp = SimilarToContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 9);
					_localctx = tmp;
					{
					recog.base.set_state(4001);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(4000);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(4003);
					recog.base.match_token(SIMILAR,&mut recog.err_handler)?;

					recog.base.set_state(4004);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4005);
					let tmp = recog.valueExpression_rec(0)?;
					if let PredicateContextAll::SimilarToContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
					ctx.pattern = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4008);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(608,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(4006);
							recog.base.match_token(ESCAPE,&mut recog.err_handler)?;

							/*InvokeRule valueExpression*/
							recog.base.set_state(4007);
							let tmp = recog.valueExpression_rec(0)?;
							if let PredicateContextAll::SimilarToContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
							ctx.escape = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					}
				}
			,
				10 =>{
					let tmp = NullPredicateContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 10);
					_localctx = tmp;
					{
					recog.base.set_state(4010);
					recog.base.match_token(IS,&mut recog.err_handler)?;

					recog.base.set_state(4012);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(4011);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(4014);
					recog.base.match_token(NULL,&mut recog.err_handler)?;

					}
				}
			,
				11 =>{
					let tmp = DistinctFromContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 11);
					_localctx = tmp;
					{
					recog.base.set_state(4015);
					recog.base.match_token(IS,&mut recog.err_handler)?;

					recog.base.set_state(4017);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(4016);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(4019);
					recog.base.match_token(DISTINCT,&mut recog.err_handler)?;

					recog.base.set_state(4020);
					recog.base.match_token(FROM,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4021);
					let tmp = recog.valueExpression_rec(0)?;
					if let PredicateContextAll::DistinctFromContext(ctx) = cast_mut::<_,PredicateContextAll >(&mut _localctx){
					ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				12 =>{
					let tmp = UnknownPredicateContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 12);
					_localctx = tmp;
					{
					recog.base.set_state(4022);
					recog.base.match_token(IS,&mut recog.err_handler)?;

					recog.base.set_state(4024);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==NOT {
						{
						recog.base.set_state(4023);
						recog.base.match_token(NOT,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(4026);
					recog.base.match_token(UNKNOWN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- valueExpression ----------------
#[derive(Debug)]
pub enum ValueExpressionContextAll<'input>{
	ValueExpressionDefaultContext(ValueExpressionDefaultContext<'input>),
	ConcatenationContext(ConcatenationContext<'input>),
	ArithmeticBinaryContext(ArithmeticBinaryContext<'input>),
	ArithmeticUnaryContext(ArithmeticUnaryContext<'input>),
	AtTimeZoneContext(AtTimeZoneContext<'input>),
Error(ValueExpressionContext<'input>)
}
antlr_rust::tid!{ValueExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ValueExpressionContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for ValueExpressionContextAll<'input>{}

impl<'input> Deref for ValueExpressionContextAll<'input>{
	type Target = dyn ValueExpressionContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use ValueExpressionContextAll::*;
		match self{
			ValueExpressionDefaultContext(inner) => inner,
			ConcatenationContext(inner) => inner,
			ArithmeticBinaryContext(inner) => inner,
			ArithmeticUnaryContext(inner) => inner,
			AtTimeZoneContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ValueExpressionContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ValueExpressionContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type ValueExpressionContext<'input> = BaseParserRuleContext<'input,ValueExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct ValueExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ValueExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ValueExpressionContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ValueExpressionContext<'input>{
}

impl<'input> CustomRuleContext<'input> for ValueExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}
antlr_rust::tid!{ValueExpressionContextExt<'a>}

impl<'input> ValueExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ValueExpressionContextAll<'input>> {
		Rc::new(
		ValueExpressionContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ValueExpressionContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait ValueExpressionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ValueExpressionContextExt<'input>>{


}

impl<'input> ValueExpressionContextAttrs<'input> for ValueExpressionContext<'input>{}

pub type ValueExpressionDefaultContext<'input> = BaseParserRuleContext<'input,ValueExpressionDefaultContextExt<'input>>;

pub trait ValueExpressionDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ValueExpressionDefaultContextAttrs<'input> for ValueExpressionDefaultContext<'input>{}

pub struct ValueExpressionDefaultContextExt<'input>{
	base:ValueExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ValueExpressionDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ValueExpressionDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ValueExpressionDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_valueExpressionDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_valueExpressionDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ValueExpressionDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_valueExpressionDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for ValueExpressionDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>> for ValueExpressionDefaultContext<'input>{
	fn borrow(&self) -> &ValueExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>> for ValueExpressionDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> { &mut self.base }
}

impl<'input> ValueExpressionContextAttrs<'input> for ValueExpressionDefaultContext<'input> {}

impl<'input> ValueExpressionDefaultContextExt<'input>{
	fn new(ctx: &dyn ValueExpressionContextAttrs<'input>) -> Rc<ValueExpressionContextAll<'input>>  {
		Rc::new(
			ValueExpressionContextAll::ValueExpressionDefaultContext(
				BaseParserRuleContext::copy_from(ctx,ValueExpressionDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ConcatenationContext<'input> = BaseParserRuleContext<'input,ConcatenationContextExt<'input>>;

pub trait ConcatenationContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CONCAT
	/// Returns `None` if there is no child corresponding to token CONCAT
	fn CONCAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CONCAT, 0)
	}
	fn valueExpression_all(&self) ->  Vec<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> ConcatenationContextAttrs<'input> for ConcatenationContext<'input>{}

pub struct ConcatenationContextExt<'input>{
	base:ValueExpressionContextExt<'input>,
	pub left: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub right: Option<Rc<ValueExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ConcatenationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ConcatenationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ConcatenationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_concatenation(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_concatenation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ConcatenationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_concatenation(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConcatenationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>> for ConcatenationContext<'input>{
	fn borrow(&self) -> &ValueExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>> for ConcatenationContext<'input>{
	fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> { &mut self.base }
}

impl<'input> ValueExpressionContextAttrs<'input> for ConcatenationContext<'input> {}

impl<'input> ConcatenationContextExt<'input>{
	fn new(ctx: &dyn ValueExpressionContextAttrs<'input>) -> Rc<ValueExpressionContextAll<'input>>  {
		Rc::new(
			ValueExpressionContextAll::ConcatenationContext(
				BaseParserRuleContext::copy_from(ctx,ConcatenationContextExt{
        			left:None, right:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ArithmeticBinaryContext<'input> = BaseParserRuleContext<'input,ArithmeticBinaryContextExt<'input>>;

pub trait ArithmeticBinaryContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn valueExpression_all(&self) ->  Vec<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token ASTERISK
	/// Returns `None` if there is no child corresponding to token ASTERISK
	fn ASTERISK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ASTERISK, 0)
	}
	/// Retrieves first TerminalNode corresponding to token SLASH
	/// Returns `None` if there is no child corresponding to token SLASH
	fn SLASH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SLASH, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PERCENT
	/// Returns `None` if there is no child corresponding to token PERCENT
	fn PERCENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PERCENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PLUS
	/// Returns `None` if there is no child corresponding to token PLUS
	fn PLUS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PLUS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MINUS
	/// Returns `None` if there is no child corresponding to token MINUS
	fn MINUS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MINUS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token BITWISE_SHIFT_LEFT
	/// Returns `None` if there is no child corresponding to token BITWISE_SHIFT_LEFT
	fn BITWISE_SHIFT_LEFT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BITWISE_SHIFT_LEFT, 0)
	}
}

impl<'input> ArithmeticBinaryContextAttrs<'input> for ArithmeticBinaryContext<'input>{}

pub struct ArithmeticBinaryContextExt<'input>{
	base:ValueExpressionContextExt<'input>,
	pub left: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub operator: Option<TokenType<'input>>,
	pub right: Option<Rc<ValueExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ArithmeticBinaryContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ArithmeticBinaryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ArithmeticBinaryContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_arithmeticBinary(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_arithmeticBinary(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ArithmeticBinaryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_arithmeticBinary(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArithmeticBinaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>> for ArithmeticBinaryContext<'input>{
	fn borrow(&self) -> &ValueExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>> for ArithmeticBinaryContext<'input>{
	fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> { &mut self.base }
}

impl<'input> ValueExpressionContextAttrs<'input> for ArithmeticBinaryContext<'input> {}

impl<'input> ArithmeticBinaryContextExt<'input>{
	fn new(ctx: &dyn ValueExpressionContextAttrs<'input>) -> Rc<ValueExpressionContextAll<'input>>  {
		Rc::new(
			ValueExpressionContextAll::ArithmeticBinaryContext(
				BaseParserRuleContext::copy_from(ctx,ArithmeticBinaryContextExt{
					operator:None, 
        			left:None, right:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ArithmeticUnaryContext<'input> = BaseParserRuleContext<'input,ArithmeticUnaryContextExt<'input>>;

pub trait ArithmeticUnaryContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token MINUS
	/// Returns `None` if there is no child corresponding to token MINUS
	fn MINUS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MINUS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PLUS
	/// Returns `None` if there is no child corresponding to token PLUS
	fn PLUS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PLUS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token POSIX
	/// Returns `None` if there is no child corresponding to token POSIX
	fn POSIX(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(POSIX, 0)
	}
}

impl<'input> ArithmeticUnaryContextAttrs<'input> for ArithmeticUnaryContext<'input>{}

pub struct ArithmeticUnaryContextExt<'input>{
	base:ValueExpressionContextExt<'input>,
	pub operator: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ArithmeticUnaryContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ArithmeticUnaryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ArithmeticUnaryContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_arithmeticUnary(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_arithmeticUnary(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ArithmeticUnaryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_arithmeticUnary(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArithmeticUnaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>> for ArithmeticUnaryContext<'input>{
	fn borrow(&self) -> &ValueExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>> for ArithmeticUnaryContext<'input>{
	fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> { &mut self.base }
}

impl<'input> ValueExpressionContextAttrs<'input> for ArithmeticUnaryContext<'input> {}

impl<'input> ArithmeticUnaryContextExt<'input>{
	fn new(ctx: &dyn ValueExpressionContextAttrs<'input>) -> Rc<ValueExpressionContextAll<'input>>  {
		Rc::new(
			ValueExpressionContextAll::ArithmeticUnaryContext(
				BaseParserRuleContext::copy_from(ctx,ArithmeticUnaryContextExt{
					operator:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type AtTimeZoneContext<'input> = BaseParserRuleContext<'input,AtTimeZoneContextExt<'input>>;

pub trait AtTimeZoneContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token AT
	/// Returns `None` if there is no child corresponding to token AT
	fn AT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AT, 0)
	}
	fn timeZoneSpecifier(&self) -> Option<Rc<TimeZoneSpecifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> AtTimeZoneContextAttrs<'input> for AtTimeZoneContext<'input>{}

pub struct AtTimeZoneContextExt<'input>{
	base:ValueExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{AtTimeZoneContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for AtTimeZoneContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for AtTimeZoneContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_atTimeZone(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_atTimeZone(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for AtTimeZoneContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_atTimeZone(self);
	}
}

impl<'input> CustomRuleContext<'input> for AtTimeZoneContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_valueExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_valueExpression }
}

impl<'input> Borrow<ValueExpressionContextExt<'input>> for AtTimeZoneContext<'input>{
	fn borrow(&self) -> &ValueExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ValueExpressionContextExt<'input>> for AtTimeZoneContext<'input>{
	fn borrow_mut(&mut self) -> &mut ValueExpressionContextExt<'input> { &mut self.base }
}

impl<'input> ValueExpressionContextAttrs<'input> for AtTimeZoneContext<'input> {}

impl<'input> AtTimeZoneContextExt<'input>{
	fn new(ctx: &dyn ValueExpressionContextAttrs<'input>) -> Rc<ValueExpressionContextAll<'input>>  {
		Rc::new(
			ValueExpressionContextAll::AtTimeZoneContext(
				BaseParserRuleContext::copy_from(ctx,AtTimeZoneContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  valueExpression(&mut self,)
	-> Result<Rc<ValueExpressionContextAll<'input>>,ANTLRError> {
		self.valueExpression_rec(0)
	}

	fn valueExpression_rec(&mut self, _p: isize)
	-> Result<Rc<ValueExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = ValueExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 256, RULE_valueExpression, _p);
	    let mut _localctx: Rc<ValueExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 256;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(4036);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(614,&mut recog.base)? {
				1 =>{
					{
					let mut tmp = ValueExpressionDefaultContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();


					/*InvokeRule primaryExpression*/
					recog.base.set_state(4030);
					recog.primaryExpression_rec(0)?;

					recog.base.set_state(4032);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(613,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(4031);
							recog.base.match_token(T__1,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					{
					let mut tmp = ArithmeticUnaryContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4034);
					if let ValueExpressionContextAll::ArithmeticUnaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
					ctx.operator = recog.base.input.lt(1).cloned(); } else {unreachable!("cant cast");} 
					_la = recog.base.input.la(1);
					if { !(((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (POSIX - 453)))) != 0)) } {
						let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
						if let ValueExpressionContextAll::ArithmeticUnaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
						ctx.operator = Some(tmp); } else {unreachable!("cant cast");}  

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					/*InvokeRule valueExpression*/
					recog.base.set_state(4035);
					recog.valueExpression_rec(5)?;

					}
				}

				_ => {}
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(4055);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(616,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(4053);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(615,&mut recog.base)? {
						1 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = ArithmeticBinaryContextExt::new(&**ValueExpressionContextExt::new(_parentctx.clone(), _parentState));
							if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_valueExpression);
							_localctx = tmp;
							recog.base.set_state(4038);
							if !({recog.precpred(None, 4)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 4)".to_owned()), None))?;
							}
							recog.base.set_state(4039);
							if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.operator = recog.base.input.lt(1).cloned(); } else {unreachable!("cant cast");} 
							_la = recog.base.input.la(1);
							if { !(((((_la - 455)) & !0x3f) == 0 && ((1usize << (_la - 455)) & ((1usize << (ASTERISK - 455)) | (1usize << (SLASH - 455)) | (1usize << (PERCENT - 455)))) != 0)) } {
								let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
								if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
								ctx.operator = Some(tmp); } else {unreachable!("cant cast");}  

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							/*InvokeRule valueExpression*/
							recog.base.set_state(4040);
							let tmp = recog.valueExpression_rec(5)?;
							if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}
					,
						2 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = ArithmeticBinaryContextExt::new(&**ValueExpressionContextExt::new(_parentctx.clone(), _parentState));
							if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_valueExpression);
							_localctx = tmp;
							recog.base.set_state(4041);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(4042);
							if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.operator = recog.base.input.lt(1).cloned(); } else {unreachable!("cant cast");} 
							_la = recog.base.input.la(1);
							if { !(_la==PLUS || _la==MINUS) } {
								let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
								if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
								ctx.operator = Some(tmp); } else {unreachable!("cant cast");}  

							}
							else {
								if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
								recog.err_handler.report_match(&mut recog.base);
								recog.base.consume(&mut recog.err_handler);
							}
							/*InvokeRule valueExpression*/
							recog.base.set_state(4043);
							let tmp = recog.valueExpression_rec(4)?;
							if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}
					,
						3 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = ConcatenationContextExt::new(&**ValueExpressionContextExt::new(_parentctx.clone(), _parentState));
							if let ValueExpressionContextAll::ConcatenationContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_valueExpression);
							_localctx = tmp;
							recog.base.set_state(4044);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							recog.base.set_state(4045);
							recog.base.match_token(CONCAT,&mut recog.err_handler)?;

							/*InvokeRule valueExpression*/
							recog.base.set_state(4046);
							let tmp = recog.valueExpression_rec(3)?;
							if let ValueExpressionContextAll::ConcatenationContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}
					,
						4 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = ArithmeticBinaryContextExt::new(&**ValueExpressionContextExt::new(_parentctx.clone(), _parentState));
							if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut tmp){
								ctx.left = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_valueExpression);
							_localctx = tmp;
							recog.base.set_state(4047);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(4048);
							let tmp = recog.base.match_token(BITWISE_SHIFT_LEFT,&mut recog.err_handler)?;
							if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.operator = Some(tmp); } else {unreachable!("cant cast");}  

							/*InvokeRule valueExpression*/
							recog.base.set_state(4049);
							let tmp = recog.valueExpression_rec(2)?;
							if let ValueExpressionContextAll::ArithmeticBinaryContext(ctx) = cast_mut::<_,ValueExpressionContextAll >(&mut _localctx){
							ctx.right = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}
					,
						5 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = AtTimeZoneContextExt::new(&**ValueExpressionContextExt::new(_parentctx.clone(), _parentState));
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_valueExpression);
							_localctx = tmp;
							recog.base.set_state(4050);
							if !({recog.precpred(None, 6)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 6)".to_owned()), None))?;
							}
							recog.base.set_state(4051);
							recog.base.match_token(AT,&mut recog.err_handler)?;

							/*InvokeRule timeZoneSpecifier*/
							recog.base.set_state(4052);
							recog.timeZoneSpecifier()?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(4057);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(616,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- primaryExpression ----------------
#[derive(Debug)]
pub enum PrimaryExpressionContextAll<'input>{
	DereferenceContext(DereferenceContext<'input>),
	ModContext(ModContext<'input>),
	FirstValueFunctionContext(FirstValueFunctionContext<'input>),
	ColumnReferenceByPositionContext(ColumnReferenceByPositionContext<'input>),
	ValueDereferenceContext(ValueDereferenceContext<'input>),
	IdentifierExpressionContext(IdentifierExpressionContext<'input>),
	ArrayAggFunctionContext(ArrayAggFunctionContext<'input>),
	DecodeContext(DecodeContext<'input>),
	DereferenceByPositionContext(DereferenceByPositionContext<'input>),
	CountStarContext(CountStarContext<'input>),
	PercentileContFunctionContext(PercentileContFunctionContext<'input>),
	CastContext(CastContext<'input>),
	MinhashContext(MinhashContext<'input>),
	LambdaContext(LambdaContext<'input>),
	ParenthesizedExpressionContext(ParenthesizedExpressionContext<'input>),
	TrimContext(TrimContext<'input>),
	ArrayContext(ArrayContext<'input>),
	NormalizeContext(NormalizeContext<'input>),
	CastOperatorContext(CastOperatorContext<'input>),
	SimpleCaseContext(SimpleCaseContext<'input>),
	ColumnReferenceContext(ColumnReferenceContext<'input>),
	RowConstructorContext(RowConstructorContext<'input>),
	ObjectLiteralContext(ObjectLiteralContext<'input>),
	SubqueryExpressionContext(SubqueryExpressionContext<'input>),
	ConstantDefaultContext(ConstantDefaultContext<'input>),
	ExtractContext(ExtractContext<'input>),
	MeasureContext(MeasureContext<'input>),
	FunctionCallContext(FunctionCallContext<'input>),
	VariableContext(VariableContext<'input>),
	ExistsContext(ExistsContext<'input>),
	PercentileDiscFunctionContext(PercentileDiscFunctionContext<'input>),
	PositionContext(PositionContext<'input>),
	ListaggContext(ListaggContext<'input>),
	SearchedCaseContext(SearchedCaseContext<'input>),
Error(PrimaryExpressionContext<'input>)
}
antlr_rust::tid!{PrimaryExpressionContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PrimaryExpressionContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PrimaryExpressionContextAll<'input>{}

impl<'input> Deref for PrimaryExpressionContextAll<'input>{
	type Target = dyn PrimaryExpressionContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PrimaryExpressionContextAll::*;
		match self{
			DereferenceContext(inner) => inner,
			ModContext(inner) => inner,
			FirstValueFunctionContext(inner) => inner,
			ColumnReferenceByPositionContext(inner) => inner,
			ValueDereferenceContext(inner) => inner,
			IdentifierExpressionContext(inner) => inner,
			ArrayAggFunctionContext(inner) => inner,
			DecodeContext(inner) => inner,
			DereferenceByPositionContext(inner) => inner,
			CountStarContext(inner) => inner,
			PercentileContFunctionContext(inner) => inner,
			CastContext(inner) => inner,
			MinhashContext(inner) => inner,
			LambdaContext(inner) => inner,
			ParenthesizedExpressionContext(inner) => inner,
			TrimContext(inner) => inner,
			ArrayContext(inner) => inner,
			NormalizeContext(inner) => inner,
			CastOperatorContext(inner) => inner,
			SimpleCaseContext(inner) => inner,
			ColumnReferenceContext(inner) => inner,
			RowConstructorContext(inner) => inner,
			ObjectLiteralContext(inner) => inner,
			SubqueryExpressionContext(inner) => inner,
			ConstantDefaultContext(inner) => inner,
			ExtractContext(inner) => inner,
			MeasureContext(inner) => inner,
			FunctionCallContext(inner) => inner,
			VariableContext(inner) => inner,
			ExistsContext(inner) => inner,
			PercentileDiscFunctionContext(inner) => inner,
			PositionContext(inner) => inner,
			ListaggContext(inner) => inner,
			SearchedCaseContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PrimaryExpressionContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PrimaryExpressionContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PrimaryExpressionContext<'input> = BaseParserRuleContext<'input,PrimaryExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PrimaryExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PrimaryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PrimaryExpressionContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PrimaryExpressionContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PrimaryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}
antlr_rust::tid!{PrimaryExpressionContextExt<'a>}

impl<'input> PrimaryExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrimaryExpressionContextAll<'input>> {
		Rc::new(
		PrimaryExpressionContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrimaryExpressionContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PrimaryExpressionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PrimaryExpressionContextExt<'input>>{


}

impl<'input> PrimaryExpressionContextAttrs<'input> for PrimaryExpressionContext<'input>{}

pub type DereferenceContext<'input> = BaseParserRuleContext<'input,DereferenceContextExt<'input>>;

pub trait DereferenceContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token PRIOR
	/// Returns `None` if there is no child corresponding to token PRIOR
	fn PRIOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PRIOR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DOT
	/// Returns `None` if there is no child corresponding to token DOT
	fn DOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOT, 0)
	}
	fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn columnNameComponent(&self) -> Option<Rc<ColumnNameComponentContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> DereferenceContextAttrs<'input> for DereferenceContext<'input>{}

pub struct DereferenceContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub base_: Option<Rc<PrimaryExpressionContextAll<'input>>>,
	pub fieldName: Option<Rc<ColumnNameComponentContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DereferenceContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DereferenceContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DereferenceContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dereference(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_dereference(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DereferenceContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dereference(self);
	}
}

impl<'input> CustomRuleContext<'input> for DereferenceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for DereferenceContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for DereferenceContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for DereferenceContext<'input> {}

impl<'input> DereferenceContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::DereferenceContext(
				BaseParserRuleContext::copy_from(ctx,DereferenceContextExt{
        			base_:None, fieldName:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ModContext<'input> = BaseParserRuleContext<'input,ModContextExt<'input>>;

pub trait ModContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token MOD
	/// Returns `None` if there is no child corresponding to token MOD
	fn MOD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MOD, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COMMA
	/// Returns `None` if there is no child corresponding to token COMMA
	fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> ModContextAttrs<'input> for ModContext<'input>{}

pub struct ModContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ModContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ModContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ModContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_mod(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_mod(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ModContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_mod(self);
	}
}

impl<'input> CustomRuleContext<'input> for ModContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ModContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ModContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ModContext<'input> {}

impl<'input> ModContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ModContext(
				BaseParserRuleContext::copy_from(ctx,ModContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type FirstValueFunctionContext<'input> = BaseParserRuleContext<'input,FirstValueFunctionContextExt<'input>>;

pub trait FirstValueFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn over(&self) -> Option<Rc<OverContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token FIRST_VALUE
	/// Returns `None` if there is no child corresponding to token FIRST_VALUE
	fn FIRST_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FIRST_VALUE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LAST_VALUE
	/// Returns `None` if there is no child corresponding to token LAST_VALUE
	fn LAST_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LAST_VALUE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LAG
	/// Returns `None` if there is no child corresponding to token LAG
	fn LAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LAG, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NULLS
	/// Returns `None` if there is no child corresponding to token NULLS
	fn NULLS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULLS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IGNORE
	/// Returns `None` if there is no child corresponding to token IGNORE
	fn IGNORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IGNORE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RESPECT
	/// Returns `None` if there is no child corresponding to token RESPECT
	fn RESPECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RESPECT, 0)
	}
}

impl<'input> FirstValueFunctionContextAttrs<'input> for FirstValueFunctionContext<'input>{}

pub struct FirstValueFunctionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{FirstValueFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for FirstValueFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FirstValueFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_firstValueFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_firstValueFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FirstValueFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_firstValueFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for FirstValueFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for FirstValueFunctionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for FirstValueFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for FirstValueFunctionContext<'input> {}

impl<'input> FirstValueFunctionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::FirstValueFunctionContext(
				BaseParserRuleContext::copy_from(ctx,FirstValueFunctionContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ColumnReferenceByPositionContext<'input> = BaseParserRuleContext<'input,ColumnReferenceByPositionContextExt<'input>>;

pub trait ColumnReferenceByPositionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DOLLAR
	/// Returns `None` if there is no child corresponding to token DOLLAR
	fn DOLLAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOLLAR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
	/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
	fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INTEGER_VALUE, 0)
	}
}

impl<'input> ColumnReferenceByPositionContextAttrs<'input> for ColumnReferenceByPositionContext<'input>{}

pub struct ColumnReferenceByPositionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ColumnReferenceByPositionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ColumnReferenceByPositionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnReferenceByPositionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_columnReferenceByPosition(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_columnReferenceByPosition(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnReferenceByPositionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnReferenceByPosition(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnReferenceByPositionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ColumnReferenceByPositionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ColumnReferenceByPositionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ColumnReferenceByPositionContext<'input> {}

impl<'input> ColumnReferenceByPositionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ColumnReferenceByPositionContext(
				BaseParserRuleContext::copy_from(ctx,ColumnReferenceByPositionContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ValueDereferenceContext<'input> = BaseParserRuleContext<'input,ValueDereferenceContextExt<'input>>;

pub trait ValueDereferenceContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn dereferenceKey(&self) -> Option<Rc<DereferenceKeyContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ValueDereferenceContextAttrs<'input> for ValueDereferenceContext<'input>{}

pub struct ValueDereferenceContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub value: Option<Rc<PrimaryExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ValueDereferenceContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ValueDereferenceContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ValueDereferenceContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_valueDereference(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_valueDereference(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ValueDereferenceContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_valueDereference(self);
	}
}

impl<'input> CustomRuleContext<'input> for ValueDereferenceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ValueDereferenceContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ValueDereferenceContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ValueDereferenceContext<'input> {}

impl<'input> ValueDereferenceContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ValueDereferenceContext(
				BaseParserRuleContext::copy_from(ctx,ValueDereferenceContextExt{
        			value:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type IdentifierExpressionContext<'input> = BaseParserRuleContext<'input,IdentifierExpressionContextExt<'input>>;

pub trait IdentifierExpressionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token IDENTIFIER_KW
	/// Returns `None` if there is no child corresponding to token IDENTIFIER_KW
	fn IDENTIFIER_KW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IDENTIFIER_KW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> IdentifierExpressionContextAttrs<'input> for IdentifierExpressionContext<'input>{}

pub struct IdentifierExpressionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{IdentifierExpressionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for IdentifierExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IdentifierExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_identifierExpression(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_identifierExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IdentifierExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_identifierExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for IdentifierExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for IdentifierExpressionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for IdentifierExpressionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for IdentifierExpressionContext<'input> {}

impl<'input> IdentifierExpressionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::IdentifierExpressionContext(
				BaseParserRuleContext::copy_from(ctx,IdentifierExpressionContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ArrayAggFunctionContext<'input> = BaseParserRuleContext<'input,ArrayAggFunctionContextExt<'input>>;

pub trait ArrayAggFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token ARRAY_AGG
	/// Returns `None` if there is no child corresponding to token ARRAY_AGG
	fn ARRAY_AGG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ARRAY_AGG, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ARRAYAGG
	/// Returns `None` if there is no child corresponding to token ARRAYAGG
	fn ARRAYAGG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ARRAYAGG, 0)
	}
	fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token WITHIN
	/// Returns `None` if there is no child corresponding to token WITHIN
	fn WITHIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITHIN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GROUP
	/// Returns `None` if there is no child corresponding to token GROUP
	fn GROUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GROUP, 0)
	}
	fn over(&self) -> Option<Rc<OverContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token ORDER
	/// Returns `None` if there is no child corresponding to token ORDER
	fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ORDER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token BY
	/// Returns `None` if there is no child corresponding to token BY
	fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BY, 0)
	}
	fn sortItem_all(&self) ->  Vec<Rc<SortItemContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> ArrayAggFunctionContextAttrs<'input> for ArrayAggFunctionContext<'input>{}

pub struct ArrayAggFunctionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ArrayAggFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ArrayAggFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ArrayAggFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_arrayAggFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_arrayAggFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ArrayAggFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_arrayAggFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArrayAggFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ArrayAggFunctionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ArrayAggFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ArrayAggFunctionContext<'input> {}

impl<'input> ArrayAggFunctionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ArrayAggFunctionContext(
				BaseParserRuleContext::copy_from(ctx,ArrayAggFunctionContextExt{
					COMMA:None, 
        			tail:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DecodeContext<'input> = BaseParserRuleContext<'input,DecodeContextExt<'input>>;

pub trait DecodeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DECODE
	/// Returns `None` if there is no child corresponding to token DECODE
	fn DECODE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DECODE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn callArgument_all(&self) ->  Vec<Rc<CallArgumentContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn callArgument(&self, i: usize) -> Option<Rc<CallArgumentContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> DecodeContextAttrs<'input> for DecodeContext<'input>{}

pub struct DecodeContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DecodeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DecodeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DecodeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_decode(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_decode(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DecodeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_decode(self);
	}
}

impl<'input> CustomRuleContext<'input> for DecodeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for DecodeContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for DecodeContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for DecodeContext<'input> {}

impl<'input> DecodeContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::DecodeContext(
				BaseParserRuleContext::copy_from(ctx,DecodeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DereferenceByPositionContext<'input> = BaseParserRuleContext<'input,DereferenceByPositionContextExt<'input>>;

pub trait DereferenceByPositionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DOT
	/// Returns `None` if there is no child corresponding to token DOT
	fn DOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DOLLAR
	/// Returns `None` if there is no child corresponding to token DOLLAR
	fn DOLLAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOLLAR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
	/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
	fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INTEGER_VALUE, 0)
	}
	fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> DereferenceByPositionContextAttrs<'input> for DereferenceByPositionContext<'input>{}

pub struct DereferenceByPositionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub base_: Option<Rc<PrimaryExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DereferenceByPositionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DereferenceByPositionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DereferenceByPositionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dereferenceByPosition(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_dereferenceByPosition(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DereferenceByPositionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dereferenceByPosition(self);
	}
}

impl<'input> CustomRuleContext<'input> for DereferenceByPositionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for DereferenceByPositionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for DereferenceByPositionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for DereferenceByPositionContext<'input> {}

impl<'input> DereferenceByPositionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::DereferenceByPositionContext(
				BaseParserRuleContext::copy_from(ctx,DereferenceByPositionContextExt{
        			base_:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CountStarContext<'input> = BaseParserRuleContext<'input,CountStarContextExt<'input>>;

pub trait CountStarContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token COUNT
	/// Returns `None` if there is no child corresponding to token COUNT
	fn COUNT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COUNT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ASTERISK
	/// Returns `None` if there is no child corresponding to token ASTERISK
	fn ASTERISK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ASTERISK, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn functionCallTail(&self) -> Option<Rc<FunctionCallTailContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> CountStarContextAttrs<'input> for CountStarContext<'input>{}

pub struct CountStarContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CountStarContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CountStarContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CountStarContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_countStar(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_countStar(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CountStarContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_countStar(self);
	}
}

impl<'input> CustomRuleContext<'input> for CountStarContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for CountStarContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for CountStarContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for CountStarContext<'input> {}

impl<'input> CountStarContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::CountStarContext(
				BaseParserRuleContext::copy_from(ctx,CountStarContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PercentileContFunctionContext<'input> = BaseParserRuleContext<'input,PercentileContFunctionContextExt<'input>>;

pub trait PercentileContFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token PERCENTILE_CONT
	/// Returns `None` if there is no child corresponding to token PERCENTILE_CONT
	fn PERCENTILE_CONT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PERCENTILE_CONT, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	fn number(&self) -> Option<Rc<NumberContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token WITHIN
	/// Returns `None` if there is no child corresponding to token WITHIN
	fn WITHIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITHIN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GROUP
	/// Returns `None` if there is no child corresponding to token GROUP
	fn GROUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GROUP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ORDER
	/// Returns `None` if there is no child corresponding to token ORDER
	fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ORDER, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token BY in current rule
	fn BY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token BY, starting from 0.
	/// Returns `None` if number of children corresponding to token BY is less or equal than `i`.
	fn BY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BY, i)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token OVER
	/// Returns `None` if there is no child corresponding to token OVER
	fn OVER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OVER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ASC
	/// Returns `None` if there is no child corresponding to token ASC
	fn ASC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ASC, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DESC
	/// Returns `None` if there is no child corresponding to token DESC
	fn DESC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DESC, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PARTITION
	/// Returns `None` if there is no child corresponding to token PARTITION
	fn PARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PARTITION, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> PercentileContFunctionContextAttrs<'input> for PercentileContFunctionContext<'input>{}

pub struct PercentileContFunctionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PercentileContFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PercentileContFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PercentileContFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_percentileContFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_percentileContFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PercentileContFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_percentileContFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for PercentileContFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for PercentileContFunctionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for PercentileContFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for PercentileContFunctionContext<'input> {}

impl<'input> PercentileContFunctionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::PercentileContFunctionContext(
				BaseParserRuleContext::copy_from(ctx,PercentileContFunctionContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CastContext<'input> = BaseParserRuleContext<'input,CastContextExt<'input>>;

pub trait CastContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CAST
	/// Returns `None` if there is no child corresponding to token CAST
	fn CAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CAST, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token AS
	/// Returns `None` if there is no child corresponding to token AS
	fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(AS, 0)
	}
	fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TRY_CAST
	/// Returns `None` if there is no child corresponding to token TRY_CAST
	fn TRY_CAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TRY_CAST, 0)
	}
}

impl<'input> CastContextAttrs<'input> for CastContext<'input>{}

pub struct CastContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CastContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CastContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CastContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_cast(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_cast(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CastContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_cast(self);
	}
}

impl<'input> CustomRuleContext<'input> for CastContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for CastContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for CastContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for CastContext<'input> {}

impl<'input> CastContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::CastContext(
				BaseParserRuleContext::copy_from(ctx,CastContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type MinhashContext<'input> = BaseParserRuleContext<'input,MinhashContextExt<'input>>;

pub trait MinhashContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token MINHASH
	/// Returns `None` if there is no child corresponding to token MINHASH
	fn MINHASH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MINHASH, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COMMA
	/// Returns `None` if there is no child corresponding to token COMMA
	fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ASTERISK
	/// Returns `None` if there is no child corresponding to token ASTERISK
	fn ASTERISK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ASTERISK, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn number(&self) -> Option<Rc<NumberContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> MinhashContextAttrs<'input> for MinhashContext<'input>{}

pub struct MinhashContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub k: Option<Rc<NumberContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{MinhashContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for MinhashContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for MinhashContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_minhash(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_minhash(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for MinhashContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_minhash(self);
	}
}

impl<'input> CustomRuleContext<'input> for MinhashContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for MinhashContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for MinhashContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for MinhashContext<'input> {}

impl<'input> MinhashContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::MinhashContext(
				BaseParserRuleContext::copy_from(ctx,MinhashContextExt{
        			k:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type LambdaContext<'input> = BaseParserRuleContext<'input,LambdaContextExt<'input>>;

pub trait LambdaContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> LambdaContextAttrs<'input> for LambdaContext<'input>{}

pub struct LambdaContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{LambdaContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for LambdaContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LambdaContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lambda(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_lambda(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LambdaContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_lambda(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for LambdaContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for LambdaContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for LambdaContext<'input> {}

impl<'input> LambdaContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::LambdaContext(
				BaseParserRuleContext::copy_from(ctx,LambdaContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ParenthesizedExpressionContext<'input> = BaseParserRuleContext<'input,ParenthesizedExpressionContextExt<'input>>;

pub trait ParenthesizedExpressionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> ParenthesizedExpressionContextAttrs<'input> for ParenthesizedExpressionContext<'input>{}

pub struct ParenthesizedExpressionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ParenthesizedExpressionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ParenthesizedExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ParenthesizedExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_parenthesizedExpression(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_parenthesizedExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ParenthesizedExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_parenthesizedExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for ParenthesizedExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ParenthesizedExpressionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ParenthesizedExpressionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ParenthesizedExpressionContext<'input> {}

impl<'input> ParenthesizedExpressionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ParenthesizedExpressionContext(
				BaseParserRuleContext::copy_from(ctx,ParenthesizedExpressionContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TrimContext<'input> = BaseParserRuleContext<'input,TrimContextExt<'input>>;

pub trait TrimContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token TRIM
	/// Returns `None` if there is no child corresponding to token TRIM
	fn TRIM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TRIM, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn valueExpression_all(&self) ->  Vec<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token FROM
	/// Returns `None` if there is no child corresponding to token FROM
	fn FROM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FROM, 0)
	}
	fn trimsSpecification(&self) -> Option<Rc<TrimsSpecificationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> TrimContextAttrs<'input> for TrimContext<'input>{}

pub struct TrimContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub trimChar: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub trimSource: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TrimContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TrimContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TrimContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_trim(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_trim(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TrimContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_trim(self);
	}
}

impl<'input> CustomRuleContext<'input> for TrimContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for TrimContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for TrimContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for TrimContext<'input> {}

impl<'input> TrimContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::TrimContext(
				BaseParserRuleContext::copy_from(ctx,TrimContextExt{
					tail:None, 
        			trimChar:None, trimSource:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ArrayContext<'input> = BaseParserRuleContext<'input,ArrayContextExt<'input>>;

pub trait ArrayContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LBRACKET
	/// Returns `None` if there is no child corresponding to token LBRACKET
	fn LBRACKET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LBRACKET, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RBRACKET
	/// Returns `None` if there is no child corresponding to token RBRACKET
	fn RBRACKET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RBRACKET, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> ArrayContextAttrs<'input> for ArrayContext<'input>{}

pub struct ArrayContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ArrayContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ArrayContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ArrayContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_array(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_array(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ArrayContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_array(self);
	}
}

impl<'input> CustomRuleContext<'input> for ArrayContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ArrayContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ArrayContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ArrayContext<'input> {}

impl<'input> ArrayContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ArrayContext(
				BaseParserRuleContext::copy_from(ctx,ArrayContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type NormalizeContext<'input> = BaseParserRuleContext<'input,NormalizeContextExt<'input>>;

pub trait NormalizeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token NORMALIZE
	/// Returns `None` if there is no child corresponding to token NORMALIZE
	fn NORMALIZE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NORMALIZE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	fn normalForm(&self) -> Option<Rc<NormalFormContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> NormalizeContextAttrs<'input> for NormalizeContext<'input>{}

pub struct NormalizeContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{NormalizeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for NormalizeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NormalizeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_normalize(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_normalize(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NormalizeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_normalize(self);
	}
}

impl<'input> CustomRuleContext<'input> for NormalizeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for NormalizeContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for NormalizeContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for NormalizeContext<'input> {}

impl<'input> NormalizeContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::NormalizeContext(
				BaseParserRuleContext::copy_from(ctx,NormalizeContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CastOperatorContext<'input> = BaseParserRuleContext<'input,CastOperatorContextExt<'input>>;

pub trait CastOperatorContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn primaryExpression(&self) -> Option<Rc<PrimaryExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> CastOperatorContextAttrs<'input> for CastOperatorContext<'input>{}

pub struct CastOperatorContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CastOperatorContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CastOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CastOperatorContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_castOperator(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_castOperator(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CastOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_castOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for CastOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for CastOperatorContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for CastOperatorContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for CastOperatorContext<'input> {}

impl<'input> CastOperatorContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::CastOperatorContext(
				BaseParserRuleContext::copy_from(ctx,CastOperatorContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SimpleCaseContext<'input> = BaseParserRuleContext<'input,SimpleCaseContextExt<'input>>;

pub trait SimpleCaseContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CASE
	/// Returns `None` if there is no child corresponding to token CASE
	fn CASE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CASE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token END
	/// Returns `None` if there is no child corresponding to token END
	fn END(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(END, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn whenClause_all(&self) ->  Vec<Rc<WhenClauseContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn whenClause(&self, i: usize) -> Option<Rc<WhenClauseContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token ELSE
	/// Returns `None` if there is no child corresponding to token ELSE
	fn ELSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ELSE, 0)
	}
}

impl<'input> SimpleCaseContextAttrs<'input> for SimpleCaseContext<'input>{}

pub struct SimpleCaseContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub operand: Option<Rc<ExpressionContextAll<'input>>>,
	pub elseExpression: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SimpleCaseContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SimpleCaseContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SimpleCaseContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_simpleCase(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_simpleCase(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SimpleCaseContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_simpleCase(self);
	}
}

impl<'input> CustomRuleContext<'input> for SimpleCaseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for SimpleCaseContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for SimpleCaseContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for SimpleCaseContext<'input> {}

impl<'input> SimpleCaseContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::SimpleCaseContext(
				BaseParserRuleContext::copy_from(ctx,SimpleCaseContextExt{
        			operand:None, elseExpression:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ColumnReferenceContext<'input> = BaseParserRuleContext<'input,ColumnReferenceContextExt<'input>>;

pub trait ColumnReferenceContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn columnName(&self) -> Option<Rc<ColumnNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token PRIOR
	/// Returns `None` if there is no child corresponding to token PRIOR
	fn PRIOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PRIOR, 0)
	}
}

impl<'input> ColumnReferenceContextAttrs<'input> for ColumnReferenceContext<'input>{}

pub struct ColumnReferenceContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ColumnReferenceContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ColumnReferenceContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ColumnReferenceContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_columnReference(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_columnReference(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ColumnReferenceContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_columnReference(self);
	}
}

impl<'input> CustomRuleContext<'input> for ColumnReferenceContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ColumnReferenceContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ColumnReferenceContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ColumnReferenceContext<'input> {}

impl<'input> ColumnReferenceContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ColumnReferenceContext(
				BaseParserRuleContext::copy_from(ctx,ColumnReferenceContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RowConstructorContext<'input> = BaseParserRuleContext<'input,RowConstructorContextExt<'input>>;

pub trait RowConstructorContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	/// Retrieves first TerminalNode corresponding to token ROW
	/// Returns `None` if there is no child corresponding to token ROW
	fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ROW, 0)
	}
}

impl<'input> RowConstructorContextAttrs<'input> for RowConstructorContext<'input>{}

pub struct RowConstructorContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RowConstructorContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RowConstructorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RowConstructorContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rowConstructor(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_rowConstructor(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RowConstructorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rowConstructor(self);
	}
}

impl<'input> CustomRuleContext<'input> for RowConstructorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for RowConstructorContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for RowConstructorContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for RowConstructorContext<'input> {}

impl<'input> RowConstructorContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::RowConstructorContext(
				BaseParserRuleContext::copy_from(ctx,RowConstructorContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ObjectLiteralContext<'input> = BaseParserRuleContext<'input,ObjectLiteralContextExt<'input>>;

pub trait ObjectLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn string_all(&self) ->  Vec<Rc<StringContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COLON in current rule
	fn COLON_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COLON, starting from 0.
	/// Returns `None` if number of children corresponding to token COLON is less or equal than `i`.
	fn COLON(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COLON, i)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> ObjectLiteralContextAttrs<'input> for ObjectLiteralContext<'input>{}

pub struct ObjectLiteralContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ObjectLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ObjectLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ObjectLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_objectLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_objectLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ObjectLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_objectLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for ObjectLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ObjectLiteralContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ObjectLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ObjectLiteralContext<'input> {}

impl<'input> ObjectLiteralContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ObjectLiteralContext(
				BaseParserRuleContext::copy_from(ctx,ObjectLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SubqueryExpressionContext<'input> = BaseParserRuleContext<'input,SubqueryExpressionContextExt<'input>>;

pub trait SubqueryExpressionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> SubqueryExpressionContextAttrs<'input> for SubqueryExpressionContext<'input>{}

pub struct SubqueryExpressionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SubqueryExpressionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SubqueryExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SubqueryExpressionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_subqueryExpression(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_subqueryExpression(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SubqueryExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_subqueryExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for SubqueryExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for SubqueryExpressionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for SubqueryExpressionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for SubqueryExpressionContext<'input> {}

impl<'input> SubqueryExpressionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::SubqueryExpressionContext(
				BaseParserRuleContext::copy_from(ctx,SubqueryExpressionContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ConstantDefaultContext<'input> = BaseParserRuleContext<'input,ConstantDefaultContextExt<'input>>;

pub trait ConstantDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn constant(&self) -> Option<Rc<ConstantContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ConstantDefaultContextAttrs<'input> for ConstantDefaultContext<'input>{}

pub struct ConstantDefaultContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ConstantDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ConstantDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ConstantDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_constantDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_constantDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ConstantDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_constantDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for ConstantDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ConstantDefaultContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ConstantDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ConstantDefaultContext<'input> {}

impl<'input> ConstantDefaultContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ConstantDefaultContext(
				BaseParserRuleContext::copy_from(ctx,ConstantDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ExtractContext<'input> = BaseParserRuleContext<'input,ExtractContextExt<'input>>;

pub trait ExtractContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token EXTRACT
	/// Returns `None` if there is no child corresponding to token EXTRACT
	fn EXTRACT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXTRACT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token FROM
	/// Returns `None` if there is no child corresponding to token FROM
	fn FROM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FROM, 0)
	}
	fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> ExtractContextAttrs<'input> for ExtractContext<'input>{}

pub struct ExtractContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ExtractContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ExtractContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ExtractContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_extract(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_extract(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ExtractContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_extract(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExtractContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ExtractContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ExtractContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ExtractContext<'input> {}

impl<'input> ExtractContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ExtractContext(
				BaseParserRuleContext::copy_from(ctx,ExtractContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type MeasureContext<'input> = BaseParserRuleContext<'input,MeasureContextExt<'input>>;

pub trait MeasureContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn over(&self) -> Option<Rc<OverContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> MeasureContextAttrs<'input> for MeasureContext<'input>{}

pub struct MeasureContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{MeasureContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for MeasureContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for MeasureContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_measure(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_measure(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for MeasureContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_measure(self);
	}
}

impl<'input> CustomRuleContext<'input> for MeasureContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for MeasureContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for MeasureContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for MeasureContext<'input> {}

impl<'input> MeasureContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::MeasureContext(
				BaseParserRuleContext::copy_from(ctx,MeasureContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type FunctionCallContext<'input> = BaseParserRuleContext<'input,FunctionCallContextExt<'input>>;

pub trait FunctionCallContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn functionCallHead(&self) -> Option<Rc<FunctionCallHeadContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn functionName(&self) -> Option<Rc<FunctionNameContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn functionCallTail(&self) -> Option<Rc<FunctionCallTailContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn functionExtraArguments(&self) -> Option<Rc<FunctionExtraArgumentsContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn queryNoWith(&self) -> Option<Rc<QueryNoWithContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	fn callArgument_all(&self) ->  Vec<Rc<CallArgumentContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn callArgument(&self, i: usize) -> Option<Rc<CallArgumentContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> FunctionCallContextAttrs<'input> for FunctionCallContext<'input>{}

pub struct FunctionCallContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub subquery: Option<Rc<QueryNoWithContextAll<'input>>>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{FunctionCallContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for FunctionCallContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FunctionCallContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionCall(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_functionCall(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FunctionCallContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_functionCall(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionCallContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for FunctionCallContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for FunctionCallContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for FunctionCallContext<'input> {}

impl<'input> FunctionCallContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::FunctionCallContext(
				BaseParserRuleContext::copy_from(ctx,FunctionCallContextExt{
					COMMA:None, 
        			tail:Vec::new(), 
        			subquery:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type VariableContext<'input> = BaseParserRuleContext<'input,VariableContextExt<'input>>;

pub trait VariableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token VARIABLE
	/// Returns `None` if there is no child corresponding to token VARIABLE
	fn VARIABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VARIABLE, 0)
	}
}

impl<'input> VariableContextAttrs<'input> for VariableContext<'input>{}

pub struct VariableContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{VariableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for VariableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for VariableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_variable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_variable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for VariableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_variable(self);
	}
}

impl<'input> CustomRuleContext<'input> for VariableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for VariableContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for VariableContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for VariableContext<'input> {}

impl<'input> VariableContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::VariableContext(
				BaseParserRuleContext::copy_from(ctx,VariableContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ExistsContext<'input> = BaseParserRuleContext<'input,ExistsContextExt<'input>>;

pub trait ExistsContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token EXISTS
	/// Returns `None` if there is no child corresponding to token EXISTS
	fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(EXISTS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn query(&self) -> Option<Rc<QueryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> ExistsContextAttrs<'input> for ExistsContext<'input>{}

pub struct ExistsContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ExistsContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ExistsContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ExistsContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_exists(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_exists(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ExistsContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_exists(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExistsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ExistsContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ExistsContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ExistsContext<'input> {}

impl<'input> ExistsContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ExistsContext(
				BaseParserRuleContext::copy_from(ctx,ExistsContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PercentileDiscFunctionContext<'input> = BaseParserRuleContext<'input,PercentileDiscFunctionContextExt<'input>>;

pub trait PercentileDiscFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token PERCENTILE_DISC
	/// Returns `None` if there is no child corresponding to token PERCENTILE_DISC
	fn PERCENTILE_DISC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PERCENTILE_DISC, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	fn number(&self) -> Option<Rc<NumberContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	/// Retrieves first TerminalNode corresponding to token WITHIN
	/// Returns `None` if there is no child corresponding to token WITHIN
	fn WITHIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITHIN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GROUP
	/// Returns `None` if there is no child corresponding to token GROUP
	fn GROUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GROUP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ORDER
	/// Returns `None` if there is no child corresponding to token ORDER
	fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ORDER, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token BY in current rule
	fn BY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token BY, starting from 0.
	/// Returns `None` if number of children corresponding to token BY is less or equal than `i`.
	fn BY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BY, i)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token OVER
	/// Returns `None` if there is no child corresponding to token OVER
	fn OVER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OVER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ASC
	/// Returns `None` if there is no child corresponding to token ASC
	fn ASC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ASC, 0)
	}
	/// Retrieves first TerminalNode corresponding to token DESC
	/// Returns `None` if there is no child corresponding to token DESC
	fn DESC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DESC, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PARTITION
	/// Returns `None` if there is no child corresponding to token PARTITION
	fn PARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PARTITION, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> PercentileDiscFunctionContextAttrs<'input> for PercentileDiscFunctionContext<'input>{}

pub struct PercentileDiscFunctionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PercentileDiscFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PercentileDiscFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PercentileDiscFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_percentileDiscFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_percentileDiscFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PercentileDiscFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_percentileDiscFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for PercentileDiscFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for PercentileDiscFunctionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for PercentileDiscFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for PercentileDiscFunctionContext<'input> {}

impl<'input> PercentileDiscFunctionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::PercentileDiscFunctionContext(
				BaseParserRuleContext::copy_from(ctx,PercentileDiscFunctionContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PositionContext<'input> = BaseParserRuleContext<'input,PositionContextExt<'input>>;

pub trait PositionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token POSITION
	/// Returns `None` if there is no child corresponding to token POSITION
	fn POSITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(POSITION, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token IN
	/// Returns `None` if there is no child corresponding to token IN
	fn IN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn valueExpression_all(&self) ->  Vec<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn valueExpression(&self, i: usize) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> PositionContextAttrs<'input> for PositionContext<'input>{}

pub struct PositionContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub needle: Option<Rc<ValueExpressionContextAll<'input>>>,
	pub haystack: Option<Rc<ValueExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PositionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PositionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PositionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_position(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_position(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PositionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_position(self);
	}
}

impl<'input> CustomRuleContext<'input> for PositionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for PositionContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for PositionContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for PositionContext<'input> {}

impl<'input> PositionContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::PositionContext(
				BaseParserRuleContext::copy_from(ctx,PositionContextExt{
        			needle:None, haystack:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ListaggContext<'input> = BaseParserRuleContext<'input,ListaggContextExt<'input>>;

pub trait ListaggContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LISTAGG
	/// Returns `None` if there is no child corresponding to token LISTAGG
	fn LISTAGG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LISTAGG, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token LPAREN in current rule
	fn LPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token LPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token LPAREN is less or equal than `i`.
	fn LPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token RPAREN in current rule
	fn RPAREN_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token RPAREN, starting from 0.
	/// Returns `None` if number of children corresponding to token RPAREN is less or equal than `i`.
	fn RPAREN(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, i)
	}
	fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	fn setQuantifier(&self) -> Option<Rc<SetQuantifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	/// Retrieves first TerminalNode corresponding to token WITHIN
	/// Returns `None` if there is no child corresponding to token WITHIN
	fn WITHIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITHIN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token GROUP
	/// Returns `None` if there is no child corresponding to token GROUP
	fn GROUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GROUP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ORDER
	/// Returns `None` if there is no child corresponding to token ORDER
	fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ORDER, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token BY in current rule
	fn BY_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token BY, starting from 0.
	/// Returns `None` if number of children corresponding to token BY is less or equal than `i`.
	fn BY(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BY, i)
	}
	fn sortItem_all(&self) ->  Vec<Rc<SortItemContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token OVER
	/// Returns `None` if there is no child corresponding to token OVER
	fn OVER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OVER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PARTITION
	/// Returns `None` if there is no child corresponding to token PARTITION
	fn PARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PARTITION, 0)
	}
}

impl<'input> ListaggContextAttrs<'input> for ListaggContext<'input>{}

pub struct ListaggContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub expression: Option<Rc<ExpressionContextAll<'input>>>,
	pub agg_exprs:Vec<Rc<ExpressionContextAll<'input>>>,
	pub agg_expr:Vec<Rc<ExpressionContextAll<'input>>>,
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ListaggContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ListaggContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ListaggContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_listagg(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_listagg(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ListaggContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_listagg(self);
	}
}

impl<'input> CustomRuleContext<'input> for ListaggContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for ListaggContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for ListaggContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for ListaggContext<'input> {}

impl<'input> ListaggContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::ListaggContext(
				BaseParserRuleContext::copy_from(ctx,ListaggContextExt{
					COMMA:None, 
        			tail:Vec::new(), 
        			expression:None, 
        			agg_exprs:Vec::new(), agg_expr:Vec::new(), 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SearchedCaseContext<'input> = BaseParserRuleContext<'input,SearchedCaseContextExt<'input>>;

pub trait SearchedCaseContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CASE
	/// Returns `None` if there is no child corresponding to token CASE
	fn CASE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CASE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token END
	/// Returns `None` if there is no child corresponding to token END
	fn END(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(END, 0)
	}
	fn whenClause_all(&self) ->  Vec<Rc<WhenClauseContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn whenClause(&self, i: usize) -> Option<Rc<WhenClauseContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token ELSE
	/// Returns `None` if there is no child corresponding to token ELSE
	fn ELSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ELSE, 0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SearchedCaseContextAttrs<'input> for SearchedCaseContext<'input>{}

pub struct SearchedCaseContextExt<'input>{
	base:PrimaryExpressionContextExt<'input>,
	pub elseExpression: Option<Rc<ExpressionContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SearchedCaseContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SearchedCaseContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SearchedCaseContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_searchedCase(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_searchedCase(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SearchedCaseContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_searchedCase(self);
	}
}

impl<'input> CustomRuleContext<'input> for SearchedCaseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_primaryExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_primaryExpression }
}

impl<'input> Borrow<PrimaryExpressionContextExt<'input>> for SearchedCaseContext<'input>{
	fn borrow(&self) -> &PrimaryExpressionContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrimaryExpressionContextExt<'input>> for SearchedCaseContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrimaryExpressionContextExt<'input> { &mut self.base }
}

impl<'input> PrimaryExpressionContextAttrs<'input> for SearchedCaseContext<'input> {}

impl<'input> SearchedCaseContextExt<'input>{
	fn new(ctx: &dyn PrimaryExpressionContextAttrs<'input>) -> Rc<PrimaryExpressionContextAll<'input>>  {
		Rc::new(
			PrimaryExpressionContextAll::SearchedCaseContext(
				BaseParserRuleContext::copy_from(ctx,SearchedCaseContextExt{
        			elseExpression:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  primaryExpression(&mut self,)
	-> Result<Rc<PrimaryExpressionContextAll<'input>>,ANTLRError> {
		self.primaryExpression_rec(0)
	}

	fn primaryExpression_rec(&mut self, _p: isize)
	-> Result<Rc<PrimaryExpressionContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = PrimaryExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 258, RULE_primaryExpression, _p);
	    let mut _localctx: Rc<PrimaryExpressionContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 258;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(4493);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(674,&mut recog.base)? {
				1 =>{
					{
					let mut tmp = ConstantDefaultContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();


					/*InvokeRule constant*/
					recog.base.set_state(4059);
					recog.constant()?;

					}
				}
			,
				2 =>{
					{
					let mut tmp = ObjectLiteralContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4060);
					recog.base.match_token(T__2,&mut recog.err_handler)?;

					recog.base.set_state(4074);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if ((((_la - 466)) & !0x3f) == 0 && ((1usize << (_la - 466)) & ((1usize << (STRING - 466)) | (1usize << (UNICODE_STRING - 466)) | (1usize << (DOLLAR_QUOTED_STRING - 466)))) != 0) {
						{
						/*InvokeRule string*/
						recog.base.set_state(4061);
						recog.string()?;

						recog.base.set_state(4062);
						recog.base.match_token(COLON,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(4063);
						recog.expression()?;

						recog.base.set_state(4071);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(4064);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule string*/
							recog.base.set_state(4065);
							recog.string()?;

							recog.base.set_state(4066);
							recog.base.match_token(COLON,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(4067);
							recog.expression()?;

							}
							}
							recog.base.set_state(4073);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						}
					}

					recog.base.set_state(4076);
					recog.base.match_token(T__3,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					{
					let mut tmp = RowConstructorContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4077);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4078);
					recog.expression()?;

					recog.base.set_state(4081); 
					recog.err_handler.sync(&mut recog.base)?;
					_alt = 1;
					loop {
						match _alt {
						    x if x == 1=>
							{
							{
							recog.base.set_state(4079);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(4080);
							recog.expression()?;

							}
							}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
						}
						recog.base.set_state(4083); 
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(619,&mut recog.base)?;
						if _alt==2 || _alt==INVALID_ALT { break }
					}
					recog.base.set_state(4086);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(4085);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let PrimaryExpressionContextAll::RowConstructorContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(4088);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					{
					let mut tmp = RowConstructorContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4090);
					recog.base.match_token(ROW,&mut recog.err_handler)?;

					recog.base.set_state(4091);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4092);
					recog.expression()?;

					recog.base.set_state(4097);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						recog.base.set_state(4093);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(4094);
						recog.expression()?;

						}
						}
						recog.base.set_state(4099);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(4100);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					{
					let mut tmp = PositionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4102);
					recog.base.match_token(POSITION,&mut recog.err_handler)?;

					recog.base.set_state(4103);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4104);
					let tmp = recog.valueExpression_rec(0)?;
					if let PrimaryExpressionContextAll::PositionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.needle = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4105);
					recog.base.match_token(IN,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4106);
					let tmp = recog.valueExpression_rec(0)?;
					if let PrimaryExpressionContextAll::PositionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.haystack = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4107);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					{
					let mut tmp = ListaggContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4109);
					recog.base.match_token(LISTAGG,&mut recog.err_handler)?;

					recog.base.set_state(4110);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4112);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ALL || _la==DISTINCT {
						{
						/*InvokeRule setQuantifier*/
						recog.base.set_state(4111);
						recog.setQuantifier()?;

						}
					}

					/*InvokeRule expression*/
					recog.base.set_state(4114);
					let tmp = recog.expression()?;
					if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.expression = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					let temp = if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.expression.clone().unwrap() } else {unreachable!("cant cast");} ;
					if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.agg_exprs.push(temp); } else {unreachable!("cant cast");}  
					recog.base.set_state(4117);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(623,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(4115);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule expression*/
							recog.base.set_state(4116);
							let tmp = recog.expression()?;
							if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.expression = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							let temp = if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.expression.clone().unwrap() } else {unreachable!("cant cast");} ;
							if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.agg_expr.push(temp); } else {unreachable!("cant cast");}  
							}
						}

						_ => {}
					}
					recog.base.set_state(4120);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(4119);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

						let temp = if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
						if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.tail.push(temp); } else {unreachable!("cant cast");}  
						}
					}

					recog.base.set_state(4122);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4141);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(627,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(4123);
							recog.base.match_token(WITHIN,&mut recog.err_handler)?;

							recog.base.set_state(4124);
							recog.base.match_token(GROUP,&mut recog.err_handler)?;

							recog.base.set_state(4125);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							recog.base.set_state(4126);
							recog.base.match_token(ORDER,&mut recog.err_handler)?;

							recog.base.set_state(4127);
							recog.base.match_token(BY,&mut recog.err_handler)?;

							/*InvokeRule sortItem*/
							recog.base.set_state(4128);
							recog.sortItem()?;

							recog.base.set_state(4133);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(625,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(4129);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule sortItem*/
									recog.base.set_state(4130);
									recog.sortItem()?;

									}
									} 
								}
								recog.base.set_state(4135);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(625,&mut recog.base)?;
							}
							recog.base.set_state(4137);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(4136);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
								ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

								let temp = if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
								ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
								if let PrimaryExpressionContextAll::ListaggContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
								ctx.tail.push(temp); } else {unreachable!("cant cast");}  
								}
							}

							recog.base.set_state(4139);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(4158);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(630,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(4143);
							recog.base.match_token(OVER,&mut recog.err_handler)?;

							recog.base.set_state(4144);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							recog.base.set_state(4155);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==PARTITION {
								{
								recog.base.set_state(4145);
								recog.base.match_token(PARTITION,&mut recog.err_handler)?;

								recog.base.set_state(4146);
								recog.base.match_token(BY,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(4147);
								recog.expression()?;

								recog.base.set_state(4152);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
								while _la==COMMA {
									{
									{
									recog.base.set_state(4148);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule expression*/
									recog.base.set_state(4149);
									recog.expression()?;

									}
									}
									recog.base.set_state(4154);
									recog.err_handler.sync(&mut recog.base)?;
									_la = recog.base.input.la(1);
								}
								}
							}

							recog.base.set_state(4157);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				7 =>{
					{
					let mut tmp = ExistsContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4160);
					recog.base.match_token(EXISTS,&mut recog.err_handler)?;

					recog.base.set_state(4161);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(4162);
					recog.query()?;

					recog.base.set_state(4163);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				8 =>{
					{
					let mut tmp = SimpleCaseContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4165);
					recog.base.match_token(CASE,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4166);
					let tmp = recog.expression()?;
					if let PrimaryExpressionContextAll::SimpleCaseContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.operand = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4168); 
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					loop {
						{
						{
						/*InvokeRule whenClause*/
						recog.base.set_state(4167);
						recog.whenClause()?;

						}
						}
						recog.base.set_state(4170); 
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if !(_la==WHEN) {break}
					}
					recog.base.set_state(4174);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ELSE {
						{
						recog.base.set_state(4172);
						recog.base.match_token(ELSE,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(4173);
						let tmp = recog.expression()?;
						if let PrimaryExpressionContextAll::SimpleCaseContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.elseExpression = Some(tmp.clone()); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(4176);
					recog.base.match_token(END,&mut recog.err_handler)?;

					}
				}
			,
				9 =>{
					{
					let mut tmp = SearchedCaseContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4178);
					recog.base.match_token(CASE,&mut recog.err_handler)?;

					recog.base.set_state(4180); 
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					loop {
						{
						{
						/*InvokeRule whenClause*/
						recog.base.set_state(4179);
						recog.whenClause()?;

						}
						}
						recog.base.set_state(4182); 
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if !(_la==WHEN) {break}
					}
					recog.base.set_state(4186);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ELSE {
						{
						recog.base.set_state(4184);
						recog.base.match_token(ELSE,&mut recog.err_handler)?;

						/*InvokeRule expression*/
						recog.base.set_state(4185);
						let tmp = recog.expression()?;
						if let PrimaryExpressionContextAll::SearchedCaseContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.elseExpression = Some(tmp.clone()); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(4188);
					recog.base.match_token(END,&mut recog.err_handler)?;

					}
				}
			,
				10 =>{
					{
					let mut tmp = CastContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4190);
					recog.base.match_token(CAST,&mut recog.err_handler)?;

					recog.base.set_state(4191);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4192);
					recog.expression()?;

					recog.base.set_state(4193);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					/*InvokeRule type_*/
					recog.base.set_state(4194);
					recog.type_()?;

					recog.base.set_state(4195);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				11 =>{
					{
					let mut tmp = CastContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4197);
					recog.base.match_token(TRY_CAST,&mut recog.err_handler)?;

					recog.base.set_state(4198);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4199);
					recog.expression()?;

					recog.base.set_state(4200);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					/*InvokeRule type_*/
					recog.base.set_state(4201);
					recog.type_()?;

					recog.base.set_state(4202);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				12 =>{
					{
					let mut tmp = TrimContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4204);
					recog.base.match_token(TRIM,&mut recog.err_handler)?;

					recog.base.set_state(4205);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					{
					recog.base.set_state(4207);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(635,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule trimsSpecification*/
							recog.base.set_state(4206);
							recog.trimsSpecification()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(4210);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
						{
						/*InvokeRule valueExpression*/
						recog.base.set_state(4209);
						let tmp = recog.valueExpression_rec(0)?;
						if let PrimaryExpressionContextAll::TrimContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.trimChar = Some(tmp.clone()); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(4212);
					recog.base.match_token(FROM,&mut recog.err_handler)?;

					}
					/*InvokeRule valueExpression*/
					recog.base.set_state(4214);
					let tmp = recog.valueExpression_rec(0)?;
					if let PrimaryExpressionContextAll::TrimContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.trimSource = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4215);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				13 =>{
					{
					let mut tmp = TrimContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4217);
					recog.base.match_token(TRIM,&mut recog.err_handler)?;

					recog.base.set_state(4218);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4226);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(639,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule trimsSpecification*/
							recog.base.set_state(4219);
							recog.trimsSpecification()?;

							recog.base.set_state(4221);
							recog.err_handler.sync(&mut recog.base)?;
							match  recog.interpreter.adaptive_predict(637,&mut recog.base)? {
								x if x == 1=>{
									{
									/*InvokeRule valueExpression*/
									recog.base.set_state(4220);
									let tmp = recog.valueExpression_rec(0)?;
									if let PrimaryExpressionContextAll::TrimContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
									ctx.trimChar = Some(tmp.clone()); } else {unreachable!("cant cast");}  

									}
								}

								_ => {}
							}
							recog.base.set_state(4224);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==FROM {
								{
								recog.base.set_state(4223);
								recog.base.match_token(FROM,&mut recog.err_handler)?;

								}
							}

							}
						}

						_ => {}
					}
					/*InvokeRule valueExpression*/
					recog.base.set_state(4228);
					let tmp = recog.valueExpression_rec(0)?;
					if let PrimaryExpressionContextAll::TrimContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.trimSource = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4229);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				14 =>{
					{
					let mut tmp = TrimContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4231);
					recog.base.match_token(TRIM,&mut recog.err_handler)?;

					recog.base.set_state(4232);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4233);
					let tmp = recog.valueExpression_rec(0)?;
					if let PrimaryExpressionContextAll::TrimContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.trimSource = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4234);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4235);
					let tmp = recog.valueExpression_rec(0)?;
					if let PrimaryExpressionContextAll::TrimContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.trimChar = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4237);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(4236);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let PrimaryExpressionContextAll::TrimContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(4239);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				15 =>{
					{
					let mut tmp = NormalizeContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4241);
					recog.base.match_token(NORMALIZE,&mut recog.err_handler)?;

					recog.base.set_state(4242);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4243);
					recog.valueExpression_rec(0)?;

					recog.base.set_state(4246);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(641,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(4244);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule normalForm*/
							recog.base.set_state(4245);
							recog.normalForm()?;

							}
						}

						_ => {}
					}
					recog.base.set_state(4249);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(4248);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let PrimaryExpressionContextAll::NormalizeContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(4251);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				16 =>{
					{
					let mut tmp = ExtractContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4253);
					recog.base.match_token(EXTRACT,&mut recog.err_handler)?;

					recog.base.set_state(4254);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(4255);
					recog.identifier()?;

					recog.base.set_state(4256);
					recog.base.match_token(FROM,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4257);
					recog.valueExpression_rec(0)?;

					recog.base.set_state(4258);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				17 =>{
					{
					let mut tmp = MinhashContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4260);
					recog.base.match_token(MINHASH,&mut recog.err_handler)?;

					recog.base.set_state(4261);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule number*/
					recog.base.set_state(4262);
					let tmp = recog.number()?;
					if let PrimaryExpressionContextAll::MinhashContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.k = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4263);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(4264);
					recog.base.match_token(ASTERISK,&mut recog.err_handler)?;

					recog.base.set_state(4265);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				18 =>{
					{
					let mut tmp = IdentifierExpressionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4267);
					recog.base.match_token(IDENTIFIER_KW,&mut recog.err_handler)?;

					recog.base.set_state(4268);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule string*/
					recog.base.set_state(4269);
					recog.string()?;

					recog.base.set_state(4270);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				19 =>{
					{
					let mut tmp = ModContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4272);
					recog.base.match_token(MOD,&mut recog.err_handler)?;

					recog.base.set_state(4273);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4274);
					recog.expression()?;

					recog.base.set_state(4275);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4276);
					recog.expression()?;

					recog.base.set_state(4277);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				20 =>{
					{
					let mut tmp = DecodeContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4279);
					recog.base.match_token(DECODE,&mut recog.err_handler)?;

					recog.base.set_state(4280);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4289);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOT - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (ASTERISK - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
						{
						/*InvokeRule callArgument*/
						recog.base.set_state(4281);
						recog.callArgument()?;

						recog.base.set_state(4286);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						while _la==COMMA {
							{
							{
							recog.base.set_state(4282);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule callArgument*/
							recog.base.set_state(4283);
							recog.callArgument()?;

							}
							}
							recog.base.set_state(4288);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
						}
						}
					}

					recog.base.set_state(4291);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				21 =>{
					{
					let mut tmp = CountStarContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4292);
					recog.base.match_token(COUNT,&mut recog.err_handler)?;

					recog.base.set_state(4293);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4294);
					recog.base.match_token(ASTERISK,&mut recog.err_handler)?;

					recog.base.set_state(4295);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule functionCallTail*/
					recog.base.set_state(4296);
					recog.functionCallTail()?;

					}
				}
			,
				22 =>{
					{
					let mut tmp = FunctionCallContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					/*InvokeRule functionCallHead*/
					recog.base.set_state(4297);
					recog.functionCallHead()?;

					/*InvokeRule functionName*/
					recog.base.set_state(4298);
					recog.functionName()?;

					recog.base.set_state(4299);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4315);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(648,&mut recog.base)? {
						1 =>{
							{
							recog.base.set_state(4311);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ALL) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTINCT - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOT - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (ASTERISK - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
								{
								recog.base.set_state(4301);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
								if _la==ALL || _la==DISTINCT {
									{
									/*InvokeRule setQuantifier*/
									recog.base.set_state(4300);
									recog.setQuantifier()?;

									}
								}

								/*InvokeRule callArgument*/
								recog.base.set_state(4303);
								recog.callArgument()?;

								recog.base.set_state(4308);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(646,&mut recog.base)?;
								while { _alt!=2 && _alt!=INVALID_ALT } {
									if _alt==1 {
										{
										{
										recog.base.set_state(4304);
										recog.base.match_token(COMMA,&mut recog.err_handler)?;

										/*InvokeRule callArgument*/
										recog.base.set_state(4305);
										recog.callArgument()?;

										}
										} 
									}
									recog.base.set_state(4310);
									recog.err_handler.sync(&mut recog.base)?;
									_alt = recog.interpreter.adaptive_predict(646,&mut recog.base)?;
								}
								}
							}

							/*InvokeRule functionExtraArguments*/
							recog.base.set_state(4313);
							recog.functionExtraArguments()?;

							}
						}
					,
						2 =>{
							{
							/*InvokeRule queryNoWith*/
							recog.base.set_state(4314);
							let tmp = recog.queryNoWith()?;
							if let PrimaryExpressionContextAll::FunctionCallContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.subquery = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					recog.base.set_state(4318);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(4317);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let PrimaryExpressionContextAll::FunctionCallContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

						let temp = if let PrimaryExpressionContextAll::FunctionCallContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
						if let PrimaryExpressionContextAll::FunctionCallContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.tail.push(temp); } else {unreachable!("cant cast");}  
						}
					}

					recog.base.set_state(4320);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule functionCallTail*/
					recog.base.set_state(4321);
					recog.functionCallTail()?;

					}
				}
			,
				23 =>{
					{
					let mut tmp = MeasureContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					/*InvokeRule identifier*/
					recog.base.set_state(4323);
					recog.identifier()?;

					/*InvokeRule over*/
					recog.base.set_state(4324);
					recog.over()?;

					}
				}
			,
				24 =>{
					{
					let mut tmp = LambdaContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					/*InvokeRule identifier*/
					recog.base.set_state(4326);
					recog.identifier()?;

					recog.base.set_state(4328);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULL - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 462)) & !0x3f) == 0 && ((1usize << (_la - 462)) & ((1usize << (DOLLAR - 462)) | (1usize << (IDENTIFIER - 462)) | (1usize << (QUOTED_IDENTIFIER - 462)) | (1usize << (BACKQUOTED_IDENTIFIER - 462)))) != 0) {
						{
						/*InvokeRule type_*/
						recog.base.set_state(4327);
						recog.type_()?;

						}
					}

					recog.base.set_state(4330);
					recog.base.match_token(T__4,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4331);
					recog.expression()?;

					}
				}
			,
				25 =>{
					{
					let mut tmp = LambdaContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4333);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4348);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 473)) & !0x3f) == 0 && ((1usize << (_la - 473)) & ((1usize << (IDENTIFIER - 473)) | (1usize << (QUOTED_IDENTIFIER - 473)) | (1usize << (BACKQUOTED_IDENTIFIER - 473)))) != 0) {
						{
						/*InvokeRule identifier*/
						recog.base.set_state(4334);
						recog.identifier()?;

						recog.base.set_state(4336);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULL - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 462)) & !0x3f) == 0 && ((1usize << (_la - 462)) & ((1usize << (DOLLAR - 462)) | (1usize << (IDENTIFIER - 462)) | (1usize << (QUOTED_IDENTIFIER - 462)) | (1usize << (BACKQUOTED_IDENTIFIER - 462)))) != 0) {
							{
							/*InvokeRule type_*/
							recog.base.set_state(4335);
							recog.type_()?;

							}
						}

						recog.base.set_state(4345);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(653,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(4338);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule identifier*/
								recog.base.set_state(4339);
								recog.identifier()?;

								recog.base.set_state(4341);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
								if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FULL - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INNER - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JOIN - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LATERAL - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEFT - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_CONDITION - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NATURAL - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULL - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 323)) & !0x3f) == 0 && ((1usize << (_la - 323)) & ((1usize << (RIGHT - 323)) | (1usize << (RLS - 323)) | (1usize << (ROLE - 323)) | (1usize << (ROLES - 323)) | (1usize << (ROLLBACK - 323)) | (1usize << (ROLLUP - 323)) | (1usize << (RUNNING - 323)) | (1usize << (SCALA - 323)) | (1usize << (SCALAR - 323)) | (1usize << (SECOND - 323)) | (1usize << (SCHEMA - 323)) | (1usize << (SCHEMAS - 323)) | (1usize << (SECURE - 323)) | (1usize << (SECURITY - 323)) | (1usize << (SEED - 323)) | (1usize << (SEEK - 323)) | (1usize << (SEMI - 323)) | (1usize << (SEQUENCE - 323)) | (1usize << (SERDE - 323)) | (1usize << (SERDEPROPERTIES - 323)) | (1usize << (SERIALIZABLE - 323)) | (1usize << (SESSION - 323)) | (1usize << (SETS - 323)) | (1usize << (SHOW - 323)) | (1usize << (SIMILAR - 323)) | (1usize << (SKIP_KW - 323)))) != 0) || ((((_la - 355)) & !0x3f) == 0 && ((1usize << (_la - 355)) & ((1usize << (SNAPSHOT - 355)) | (1usize << (SORTKEY - 355)) | (1usize << (SQL - 355)) | (1usize << (STAGE - 355)) | (1usize << (STATEMENT - 355)) | (1usize << (STATS - 355)) | (1usize << (STORED - 355)) | (1usize << (STREAM - 355)) | (1usize << (STRICT - 355)) | (1usize << (STRUCT - 355)) | (1usize << (SUBSET - 355)) | (1usize << (SUBSTRING - 355)) | (1usize << (SYSTEM - 355)) | (1usize << (SYSTEM_TIME - 355)) | (1usize << (TABLES - 355)) | (1usize << (TAG - 355)) | (1usize << (TEMP - 355)) | (1usize << (TEMPLATE - 355)) | (1usize << (TEMPORARY - 355)) | (1usize << (TERMINATED - 355)) | (1usize << (TEXT - 355)) | (1usize << (STRING_KW - 355)) | (1usize << (TIES - 355)) | (1usize << (TIME - 355)) | (1usize << (TIMESTAMP - 355)) | (1usize << (TOP - 355)))) != 0) || ((((_la - 387)) & !0x3f) == 0 && ((1usize << (_la - 387)) & ((1usize << (TRAILING - 387)) | (1usize << (TARGET_LAG - 387)) | (1usize << (TRANSACTION - 387)) | (1usize << (TRANSIENT - 387)) | (1usize << (TRIM - 387)) | (1usize << (TRUE - 387)) | (1usize << (TRUNCATE - 387)) | (1usize << (TRY_CAST - 387)) | (1usize << (TUPLE - 387)) | (1usize << (TYPE - 387)) | (1usize << (UESCAPE - 387)) | (1usize << (UNBOUNDED - 387)) | (1usize << (UNCOMMITTED - 387)) | (1usize << (UNCONDITIONAL - 387)) | (1usize << (UNKNOWN - 387)) | (1usize << (UNLOAD - 387)) | (1usize << (UNMATCHED - 387)) | (1usize << (UNNEST - 387)) | (1usize << (UNPIVOT - 387)) | (1usize << (UNSET - 387)) | (1usize << (UNSIGNED - 387)) | (1usize << (USE - 387)) | (1usize << (USER - 387)) | (1usize << (USING - 387)) | (1usize << (UTF16 - 387)) | (1usize << (UTF32 - 387)) | (1usize << (UTF8 - 387)) | (1usize << (VACUUM - 387)) | (1usize << (VALIDATE - 387)))) != 0) || ((((_la - 419)) & !0x3f) == 0 && ((1usize << (_la - 419)) & ((1usize << (VALUE - 419)) | (1usize << (VARYING - 419)) | (1usize << (VECTOR - 419)) | (1usize << (VERBOSE - 419)) | (1usize << (VERSION - 419)) | (1usize << (VIEW - 419)) | (1usize << (VOLATILE - 419)) | (1usize << (WAREHOUSE - 419)) | (1usize << (WHEN - 419)) | (1usize << (WINDOW - 419)) | (1usize << (WITHIN - 419)) | (1usize << (WITHOUT - 419)) | (1usize << (WORK - 419)) | (1usize << (WRAPPER - 419)) | (1usize << (WRITE - 419)) | (1usize << (XZ - 419)) | (1usize << (YEAR - 419)) | (1usize << (YES - 419)) | (1usize << (ZONE - 419)) | (1usize << (ZSTD - 419)))) != 0) || ((((_la - 462)) & !0x3f) == 0 && ((1usize << (_la - 462)) & ((1usize << (DOLLAR - 462)) | (1usize << (IDENTIFIER - 462)) | (1usize << (QUOTED_IDENTIFIER - 462)) | (1usize << (BACKQUOTED_IDENTIFIER - 462)))) != 0) {
									{
									/*InvokeRule type_*/
									recog.base.set_state(4340);
									recog.type_()?;

									}
								}

								}
								} 
							}
							recog.base.set_state(4347);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(653,&mut recog.base)?;
						}
						}
					}

					recog.base.set_state(4351);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(4350);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let PrimaryExpressionContextAll::LambdaContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(4353);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4354);
					recog.base.match_token(T__4,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4355);
					recog.expression()?;

					}
				}
			,
				26 =>{
					{
					let mut tmp = SubqueryExpressionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4356);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule query*/
					recog.base.set_state(4357);
					recog.query()?;

					recog.base.set_state(4358);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				27 =>{
					{
					let mut tmp = DereferenceContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4360);
					recog.base.match_token(PRIOR,&mut recog.err_handler)?;

					/*InvokeRule primaryExpression*/
					recog.base.set_state(4361);
					let tmp = recog.primaryExpression_rec(0)?;
					if let PrimaryExpressionContextAll::DereferenceContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.base_ = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(4362);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule columnNameComponent*/
					recog.base.set_state(4363);
					let tmp = recog.columnNameComponent()?;
					if let PrimaryExpressionContextAll::DereferenceContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
					ctx.fieldName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					}
				}
			,
				28 =>{
					{
					let mut tmp = ColumnReferenceContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					/*InvokeRule columnName*/
					recog.base.set_state(4365);
					recog.columnName()?;

					}
				}
			,
				29 =>{
					{
					let mut tmp = ColumnReferenceContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4366);
					recog.base.match_token(PRIOR,&mut recog.err_handler)?;

					/*InvokeRule columnName*/
					recog.base.set_state(4367);
					recog.columnName()?;

					}
				}
			,
				30 =>{
					{
					let mut tmp = ColumnReferenceByPositionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4368);
					recog.base.match_token(DOLLAR,&mut recog.err_handler)?;

					recog.base.set_state(4369);
					recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;

					}
				}
			,
				31 =>{
					{
					let mut tmp = ParenthesizedExpressionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4370);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4371);
					recog.expression()?;

					recog.base.set_state(4372);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				32 =>{
					{
					let mut tmp = ArrayContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4374);
					recog.base.match_token(LBRACKET,&mut recog.err_handler)?;

					recog.base.set_state(4386);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if (((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << T__2) | (1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << ASOF) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CROSS - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 129)) & !0x3f) == 0 && ((1usize << (_la - 129)) & ((1usize << (EXISTS - 129)) | (1usize << (EXPLAIN - 129)) | (1usize << (EXTERNAL - 129)) | (1usize << (EXTRACT - 129)) | (1usize << (FALSE - 129)) | (1usize << (FETCH - 129)) | (1usize << (FIELDS - 129)) | (1usize << (FILE_FORMAT - 129)) | (1usize << (FILES - 129)) | (1usize << (FILTER - 129)) | (1usize << (FINAL - 129)) | (1usize << (FIRST - 129)) | (1usize << (FIRST_VALUE - 129)) | (1usize << (FLOAT - 129)) | (1usize << (FOREIGN - 129)) | (1usize << (FORMAT - 129)) | (1usize << (FORMAT_NAME - 129)) | (1usize << (FULL - 129)) | (1usize << (FUNCTION - 129)) | (1usize << (FUNCTIONS - 129)) | (1usize << (GENERATED - 129)) | (1usize << (GLOBAL - 129)) | (1usize << (GRACE - 129)) | (1usize << (GRANTED - 129)) | (1usize << (GRANTS - 129)) | (1usize << (GRAPHVIZ - 129)) | (1usize << (GROUPING - 129)))) != 0) || ((((_la - 161)) & !0x3f) == 0 && ((1usize << (_la - 161)) & ((1usize << (GROUPS - 161)) | (1usize << (GZIP - 161)) | (1usize << (HEADER - 161)) | (1usize << (HOUR - 161)) | (1usize << (ICEBERG - 161)) | (1usize << (IDENTIFIER_KW - 161)) | (1usize << (IDENTITY - 161)) | (1usize << (IF - 161)) | (1usize << (IGNORE - 161)) | (1usize << (IMMEDIATE - 161)) | (1usize << (IMMUTABLE - 161)) | (1usize << (INCLUDE - 161)) | (1usize << (INCLUDING - 161)) | (1usize << (INFORMATION - 161)) | (1usize << (INITIAL - 161)) | (1usize << (INITIALLY - 161)) | (1usize << (INNER - 161)) | (1usize << (INPUT - 161)) | (1usize << (INPUTFORMAT - 161)) | (1usize << (INTERLEAVED - 161)) | (1usize << (INSERT - 161)) | (1usize << (INTERVAL - 161)) | (1usize << (INVOKER - 161)) | (1usize << (IO - 161)) | (1usize << (ISOLATION - 161)) | (1usize << (ILIKE - 161)))) != 0) || ((((_la - 193)) & !0x3f) == 0 && ((1usize << (_la - 193)) & ((1usize << (JAVA - 193)) | (1usize << (JAVASCRIPT - 193)) | (1usize << (JOIN - 193)) | (1usize << (JSON - 193)) | (1usize << (JSON_ARRAY - 193)) | (1usize << (JSON_EXISTS - 193)) | (1usize << (JSON_OBJECT - 193)) | (1usize << (JSON_QUERY - 193)) | (1usize << (JSON_VALUE - 193)) | (1usize << (KEEP - 193)) | (1usize << (KEY - 193)) | (1usize << (KEYS - 193)) | (1usize << (LAG - 193)) | (1usize << (LAMBDA - 193)) | (1usize << (LANGUAGE - 193)) | (1usize << (LAST - 193)) | (1usize << (LAST_VALUE - 193)) | (1usize << (LATERAL - 193)) | (1usize << (LEADING - 193)) | (1usize << (LEFT - 193)) | (1usize << (LEVEL - 193)) | (1usize << (LIBRARY - 193)) | (1usize << (LIKE - 193)) | (1usize << (LIMIT - 193)) | (1usize << (LINES - 193)) | (1usize << (LISTAGG - 193)) | (1usize << (LOCAL - 193)) | (1usize << (LOCATION - 193)) | (1usize << (LOCK - 193)) | (1usize << (LOGICAL - 193)) | (1usize << (MAP - 193)) | (1usize << (MASKING - 193)))) != 0) || ((((_la - 225)) & !0x3f) == 0 && ((1usize << (_la - 225)) & ((1usize << (MATCH - 225)) | (1usize << (MATCHED - 225)) | (1usize << (MATCHES - 225)) | (1usize << (MATCH_CONDITION - 225)) | (1usize << (MATCH_RECOGNIZE - 225)) | (1usize << (MATERIALIZED - 225)) | (1usize << (MAX - 225)) | (1usize << (MEASURES - 225)) | (1usize << (MEMORIZABLE - 225)) | (1usize << (MERGE - 225)) | (1usize << (MINHASH - 225)) | (1usize << (MINUTE - 225)) | (1usize << (MOD - 225)) | (1usize << (MODEL - 225)) | (1usize << (MONTH - 225)) | (1usize << (NAME - 225)) | (1usize << (NATURAL - 225)) | (1usize << (NCHAR - 225)) | (1usize << (NEXT - 225)) | (1usize << (NFC - 225)) | (1usize << (NFD - 225)) | (1usize << (NFKC - 225)) | (1usize << (NFKD - 225)) | (1usize << (NO - 225)) | (1usize << (NONE - 225)) | (1usize << (NOORDER - 225)) | (1usize << (NORELY - 225)) | (1usize << (NORMALIZE - 225)) | (1usize << (NOT - 225)) | (1usize << (NOVALIDATE - 225)) | (1usize << (NULL - 225)))) != 0) || ((((_la - 257)) & !0x3f) == 0 && ((1usize << (_la - 257)) & ((1usize << (NULLS - 257)) | (1usize << (OBJECT - 257)) | (1usize << (OFFSET - 257)) | (1usize << (OMIT - 257)) | (1usize << (ONE - 257)) | (1usize << (ONLY - 257)) | (1usize << (OPTION - 257)) | (1usize << (OPTIONS - 257)) | (1usize << (ORDINALITY - 257)) | (1usize << (OUTER - 257)) | (1usize << (OUTPUT - 257)) | (1usize << (OUTPUTFORMAT - 257)) | (1usize << (OVER - 257)) | (1usize << (OVERFLOW - 257)) | (1usize << (OWNER - 257)) | (1usize << (PARTITION - 257)) | (1usize << (PARTITIONED - 257)) | (1usize << (PARTITIONS - 257)) | (1usize << (PASSING - 257)) | (1usize << (PAST - 257)) | (1usize << (PATH - 257)) | (1usize << (PATTERN - 257)) | (1usize << (PER - 257)) | (1usize << (PERCENTILE_CONT - 257)) | (1usize << (PERCENTILE_DISC - 257)) | (1usize << (PERIOD - 257)) | (1usize << (PERMUTE - 257)) | (1usize << (PIVOT - 257)))) != 0) || ((((_la - 289)) & !0x3f) == 0 && ((1usize << (_la - 289)) & ((1usize << (PLACING - 289)) | (1usize << (POLICY - 289)) | (1usize << (POSITION - 289)) | (1usize << (PRECEDING - 289)) | (1usize << (PRECISION - 289)) | (1usize << (PREPARE - 289)) | (1usize << (PRIOR - 289)) | (1usize << (PROCEDURE - 289)) | (1usize << (PRIMARY - 289)) | (1usize << (PRIVILEGES - 289)) | (1usize << (PROPERTIES - 289)) | (1usize << (PRUNE - 289)) | (1usize << (PYTHON - 289)) | (1usize << (QUOTES - 289)) | (1usize << (RANGE - 289)) | (1usize << (READ - 289)) | (1usize << (RECURSIVE - 289)) | (1usize << (REGEXP - 289)) | (1usize << (REFERENCE - 289)) | (1usize << (REFERENCES - 289)) | (1usize << (REFRESH - 289)) | (1usize << (RELY - 289)) | (1usize << (RENAME - 289)) | (1usize << (REPEATABLE - 289)) | (1usize << (REPLACE - 289)) | (1usize << (RESET - 289)) | (1usize << (RESPECT - 289)) | (1usize << (RESTRICT - 289)) | (1usize << (RESTRICTED - 289)) | (1usize << (RETURN - 289)) | (1usize << (RETURNING - 289)))) != 0) || ((((_la - 321)) & !0x3f) == 0 && ((1usize << (_la - 321)) & ((1usize << (RETURNS - 321)) | (1usize << (RIGHT - 321)) | (1usize << (RLIKE - 321)) | (1usize << (RLS - 321)) | (1usize << (ROLE - 321)) | (1usize << (ROLES - 321)) | (1usize << (ROLLBACK - 321)) | (1usize << (ROLLUP - 321)) | (1usize << (ROW - 321)) | (1usize << (RUNNING - 321)) | (1usize << (SCALA - 321)) | (1usize << (SCALAR - 321)) | (1usize << (SECOND - 321)) | (1usize << (SCHEMA - 321)) | (1usize << (SCHEMAS - 321)) | (1usize << (SECURE - 321)) | (1usize << (SECURITY - 321)) | (1usize << (SEED - 321)) | (1usize << (SEEK - 321)) | (1usize << (SEMI - 321)) | (1usize << (SEQUENCE - 321)) | (1usize << (SERDE - 321)) | (1usize << (SERDEPROPERTIES - 321)) | (1usize << (SERIALIZABLE - 321)) | (1usize << (SESSION - 321)) | (1usize << (SETS - 321)) | (1usize << (SHOW - 321)))) != 0) || ((((_la - 353)) & !0x3f) == 0 && ((1usize << (_la - 353)) & ((1usize << (SIMILAR - 353)) | (1usize << (SKIP_KW - 353)) | (1usize << (SNAPSHOT - 353)) | (1usize << (SORTKEY - 353)) | (1usize << (SQL - 353)) | (1usize << (STAGE - 353)) | (1usize << (STATEMENT - 353)) | (1usize << (STATS - 353)) | (1usize << (STORED - 353)) | (1usize << (STREAM - 353)) | (1usize << (STRICT - 353)) | (1usize << (STRUCT - 353)) | (1usize << (SUBSET - 353)) | (1usize << (SUBSTRING - 353)) | (1usize << (SYSTEM - 353)) | (1usize << (SYSTEM_TIME - 353)) | (1usize << (TABLES - 353)) | (1usize << (TAG - 353)) | (1usize << (TEMP - 353)) | (1usize << (TEMPLATE - 353)) | (1usize << (TEMPORARY - 353)) | (1usize << (TERMINATED - 353)) | (1usize << (TEXT - 353)) | (1usize << (STRING_KW - 353)) | (1usize << (TIES - 353)) | (1usize << (TIME - 353)) | (1usize << (TIMESTAMP - 353)))) != 0) || ((((_la - 386)) & !0x3f) == 0 && ((1usize << (_la - 386)) & ((1usize << (TOP - 386)) | (1usize << (TRAILING - 386)) | (1usize << (TARGET_LAG - 386)) | (1usize << (TRANSACTION - 386)) | (1usize << (TRANSIENT - 386)) | (1usize << (TRIM - 386)) | (1usize << (TRUE - 386)) | (1usize << (TRUNCATE - 386)) | (1usize << (TRY_CAST - 386)) | (1usize << (TUPLE - 386)) | (1usize << (TYPE - 386)) | (1usize << (UESCAPE - 386)) | (1usize << (UNBOUNDED - 386)) | (1usize << (UNCOMMITTED - 386)) | (1usize << (UNCONDITIONAL - 386)) | (1usize << (UNKNOWN - 386)) | (1usize << (UNLOAD - 386)) | (1usize << (UNMATCHED - 386)) | (1usize << (UNNEST - 386)) | (1usize << (UNPIVOT - 386)) | (1usize << (UNSET - 386)) | (1usize << (UNSIGNED - 386)) | (1usize << (USE - 386)) | (1usize << (USER - 386)) | (1usize << (USING - 386)) | (1usize << (UTF16 - 386)) | (1usize << (UTF32 - 386)) | (1usize << (UTF8 - 386)) | (1usize << (VACUUM - 386)))) != 0) || ((((_la - 418)) & !0x3f) == 0 && ((1usize << (_la - 418)) & ((1usize << (VALIDATE - 418)) | (1usize << (VALUE - 418)) | (1usize << (VARYING - 418)) | (1usize << (VECTOR - 418)) | (1usize << (VERBOSE - 418)) | (1usize << (VERSION - 418)) | (1usize << (VIEW - 418)) | (1usize << (VOLATILE - 418)) | (1usize << (WAREHOUSE - 418)) | (1usize << (WHEN - 418)) | (1usize << (WINDOW - 418)) | (1usize << (WITHIN - 418)) | (1usize << (WITHOUT - 418)) | (1usize << (WORK - 418)) | (1usize << (WRAPPER - 418)) | (1usize << (WRITE - 418)) | (1usize << (XZ - 418)) | (1usize << (YEAR - 418)) | (1usize << (YES - 418)) | (1usize << (ZONE - 418)) | (1usize << (ZSTD - 418)) | (1usize << (LPAREN - 418)) | (1usize << (LBRACKET - 418)))) != 0) || ((((_la - 453)) & !0x3f) == 0 && ((1usize << (_la - 453)) & ((1usize << (PLUS - 453)) | (1usize << (MINUS - 453)) | (1usize << (DOLLAR - 453)) | (1usize << (POSIX - 453)) | (1usize << (STRING - 453)) | (1usize << (UNICODE_STRING - 453)) | (1usize << (DOLLAR_QUOTED_STRING - 453)) | (1usize << (BINARY_LITERAL - 453)) | (1usize << (INTEGER_VALUE - 453)) | (1usize << (DECIMAL_VALUE - 453)) | (1usize << (DOUBLE_VALUE - 453)) | (1usize << (IDENTIFIER - 453)) | (1usize << (QUOTED_IDENTIFIER - 453)) | (1usize << (BACKQUOTED_IDENTIFIER - 453)) | (1usize << (VARIABLE - 453)))) != 0) {
						{
						/*InvokeRule expression*/
						recog.base.set_state(4375);
						recog.expression()?;

						recog.base.set_state(4380);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(656,&mut recog.base)?;
						while { _alt!=2 && _alt!=INVALID_ALT } {
							if _alt==1 {
								{
								{
								recog.base.set_state(4376);
								recog.base.match_token(COMMA,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(4377);
								recog.expression()?;

								}
								} 
							}
							recog.base.set_state(4382);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(656,&mut recog.base)?;
						}
						recog.base.set_state(4384);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
						if _la==COMMA {
							{
							recog.base.set_state(4383);
							let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
							if let PrimaryExpressionContextAll::ArrayContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						}
					}

					recog.base.set_state(4388);
					recog.base.match_token(RBRACKET,&mut recog.err_handler)?;

					}
				}
			,
				33 =>{
					{
					let mut tmp = VariableContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4389);
					recog.base.match_token(VARIABLE,&mut recog.err_handler)?;

					}
				}
			,
				34 =>{
					{
					let mut tmp = ArrayAggFunctionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4390);
					_la = recog.base.input.la(1);
					if { !(_la==ARRAYAGG || _la==ARRAY_AGG) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(4391);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4393);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ALL || _la==DISTINCT {
						{
						/*InvokeRule setQuantifier*/
						recog.base.set_state(4392);
						recog.setQuantifier()?;

						}
					}

					/*InvokeRule expression*/
					recog.base.set_state(4395);
					recog.expression()?;

					recog.base.set_state(4396);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4416);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(663,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(4397);
							recog.base.match_token(WITHIN,&mut recog.err_handler)?;

							recog.base.set_state(4398);
							recog.base.match_token(GROUP,&mut recog.err_handler)?;

							recog.base.set_state(4399);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							recog.base.set_state(4410);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==ORDER {
								{
								recog.base.set_state(4400);
								recog.base.match_token(ORDER,&mut recog.err_handler)?;

								recog.base.set_state(4401);
								recog.base.match_token(BY,&mut recog.err_handler)?;

								/*InvokeRule sortItem*/
								recog.base.set_state(4402);
								recog.sortItem()?;

								recog.base.set_state(4407);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(660,&mut recog.base)?;
								while { _alt!=2 && _alt!=INVALID_ALT } {
									if _alt==1 {
										{
										{
										recog.base.set_state(4403);
										recog.base.match_token(COMMA,&mut recog.err_handler)?;

										/*InvokeRule sortItem*/
										recog.base.set_state(4404);
										recog.sortItem()?;

										}
										} 
									}
									recog.base.set_state(4409);
									recog.err_handler.sync(&mut recog.base)?;
									_alt = recog.interpreter.adaptive_predict(660,&mut recog.base)?;
								}
								}
							}

							recog.base.set_state(4413);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(4412);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let PrimaryExpressionContextAll::ArrayAggFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
								ctx.COMMA = Some(tmp); } else {unreachable!("cant cast");}  

								let temp = if let PrimaryExpressionContextAll::ArrayAggFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
								ctx.COMMA.clone().unwrap() } else {unreachable!("cant cast");} ;
								if let PrimaryExpressionContextAll::ArrayAggFunctionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
								ctx.tail.push(temp); } else {unreachable!("cant cast");}  
								}
							}

							recog.base.set_state(4415);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(4419);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(664,&mut recog.base)? {
						x if x == 1=>{
							{
							/*InvokeRule over*/
							recog.base.set_state(4418);
							recog.over()?;

							}
						}

						_ => {}
					}
					}
				}
			,
				35 =>{
					{
					let mut tmp = PercentileContFunctionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4421);
					recog.base.match_token(PERCENTILE_CONT,&mut recog.err_handler)?;

					recog.base.set_state(4422);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule number*/
					recog.base.set_state(4423);
					recog.number()?;

					recog.base.set_state(4424);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4425);
					recog.base.match_token(WITHIN,&mut recog.err_handler)?;

					recog.base.set_state(4426);
					recog.base.match_token(GROUP,&mut recog.err_handler)?;

					recog.base.set_state(4427);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4428);
					recog.base.match_token(ORDER,&mut recog.err_handler)?;

					recog.base.set_state(4429);
					recog.base.match_token(BY,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4430);
					recog.expression()?;

					recog.base.set_state(4432);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ASC || _la==DESC {
						{
						recog.base.set_state(4431);
						_la = recog.base.input.la(1);
						if { !(_la==ASC || _la==DESC) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(4434);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4450);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(668,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(4435);
							recog.base.match_token(OVER,&mut recog.err_handler)?;

							recog.base.set_state(4436);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							recog.base.set_state(4447);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==PARTITION {
								{
								recog.base.set_state(4437);
								recog.base.match_token(PARTITION,&mut recog.err_handler)?;

								recog.base.set_state(4438);
								recog.base.match_token(BY,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(4439);
								recog.expression()?;

								recog.base.set_state(4444);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
								while _la==COMMA {
									{
									{
									recog.base.set_state(4440);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule expression*/
									recog.base.set_state(4441);
									recog.expression()?;

									}
									}
									recog.base.set_state(4446);
									recog.err_handler.sync(&mut recog.base)?;
									_la = recog.base.input.la(1);
								}
								}
							}

							recog.base.set_state(4449);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				36 =>{
					{
					let mut tmp = PercentileDiscFunctionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4452);
					recog.base.match_token(PERCENTILE_DISC,&mut recog.err_handler)?;

					recog.base.set_state(4453);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule number*/
					recog.base.set_state(4454);
					recog.number()?;

					recog.base.set_state(4455);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4456);
					recog.base.match_token(WITHIN,&mut recog.err_handler)?;

					recog.base.set_state(4457);
					recog.base.match_token(GROUP,&mut recog.err_handler)?;

					recog.base.set_state(4458);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4459);
					recog.base.match_token(ORDER,&mut recog.err_handler)?;

					recog.base.set_state(4460);
					recog.base.match_token(BY,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4461);
					recog.expression()?;

					recog.base.set_state(4463);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==ASC || _la==DESC {
						{
						recog.base.set_state(4462);
						_la = recog.base.input.la(1);
						if { !(_la==ASC || _la==DESC) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						}
					}

					recog.base.set_state(4465);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					recog.base.set_state(4481);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(672,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(4466);
							recog.base.match_token(OVER,&mut recog.err_handler)?;

							recog.base.set_state(4467);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							recog.base.set_state(4478);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==PARTITION {
								{
								recog.base.set_state(4468);
								recog.base.match_token(PARTITION,&mut recog.err_handler)?;

								recog.base.set_state(4469);
								recog.base.match_token(BY,&mut recog.err_handler)?;

								/*InvokeRule expression*/
								recog.base.set_state(4470);
								recog.expression()?;

								recog.base.set_state(4475);
								recog.err_handler.sync(&mut recog.base)?;
								_la = recog.base.input.la(1);
								while _la==COMMA {
									{
									{
									recog.base.set_state(4471);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule expression*/
									recog.base.set_state(4472);
									recog.expression()?;

									}
									}
									recog.base.set_state(4477);
									recog.err_handler.sync(&mut recog.base)?;
									_la = recog.base.input.la(1);
								}
								}
							}

							recog.base.set_state(4480);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				37 =>{
					{
					let mut tmp = FirstValueFunctionContextExt::new(&**_localctx);
					recog.ctx = Some(tmp.clone());
					_localctx = tmp;
					_prevctx = _localctx.clone();
					recog.base.set_state(4483);
					_la = recog.base.input.la(1);
					if { !(_la==FIRST_VALUE || _la==LAG || _la==LAST_VALUE) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(4484);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4485);
					recog.expression()?;

					recog.base.set_state(4488);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IGNORE || _la==RESPECT {
						{
						recog.base.set_state(4486);
						_la = recog.base.input.la(1);
						if { !(_la==IGNORE || _la==RESPECT) } {
							recog.err_handler.recover_inline(&mut recog.base)?;

						}
						else {
							if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
							recog.err_handler.report_match(&mut recog.base);
							recog.base.consume(&mut recog.err_handler);
						}
						recog.base.set_state(4487);
						recog.base.match_token(NULLS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(4490);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					/*InvokeRule over*/
					recog.base.set_state(4491);
					recog.over()?;

					}
				}

				_ => {}
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(4509);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(676,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(4507);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(675,&mut recog.base)? {
						1 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = CastOperatorContextExt::new(&**PrimaryExpressionContextExt::new(_parentctx.clone(), _parentState));
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_primaryExpression);
							_localctx = tmp;
							recog.base.set_state(4495);
							if !({recog.precpred(None, 15)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 15)".to_owned()), None))?;
							}
							recog.base.set_state(4496);
							recog.base.match_token(T__5,&mut recog.err_handler)?;

							/*InvokeRule type_*/
							recog.base.set_state(4497);
							recog.type_()?;

							}
						}
					,
						2 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = ValueDereferenceContextExt::new(&**PrimaryExpressionContextExt::new(_parentctx.clone(), _parentState));
							if let PrimaryExpressionContextAll::ValueDereferenceContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut tmp){
								ctx.value = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_primaryExpression);
							_localctx = tmp;
							recog.base.set_state(4498);
							if !({recog.precpred(None, 14)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 14)".to_owned()), None))?;
							}
							/*InvokeRule dereferenceKey*/
							recog.base.set_state(4499);
							recog.dereferenceKey()?;

							}
						}
					,
						3 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = DereferenceContextExt::new(&**PrimaryExpressionContextExt::new(_parentctx.clone(), _parentState));
							if let PrimaryExpressionContextAll::DereferenceContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut tmp){
								ctx.base_ = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_primaryExpression);
							_localctx = tmp;
							recog.base.set_state(4500);
							if !({recog.precpred(None, 13)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 13)".to_owned()), None))?;
							}
							recog.base.set_state(4501);
							recog.base.match_token(DOT,&mut recog.err_handler)?;

							/*InvokeRule columnNameComponent*/
							recog.base.set_state(4502);
							let tmp = recog.columnNameComponent()?;
							if let PrimaryExpressionContextAll::DereferenceContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut _localctx){
							ctx.fieldName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							}
						}
					,
						4 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = DereferenceByPositionContextExt::new(&**PrimaryExpressionContextExt::new(_parentctx.clone(), _parentState));
							if let PrimaryExpressionContextAll::DereferenceByPositionContext(ctx) = cast_mut::<_,PrimaryExpressionContextAll >(&mut tmp){
								ctx.base_ = Some(_prevctx.clone());
							} else {unreachable!("cant cast");}
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_primaryExpression);
							_localctx = tmp;
							recog.base.set_state(4503);
							if !({recog.precpred(None, 11)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 11)".to_owned()), None))?;
							}
							recog.base.set_state(4504);
							recog.base.match_token(DOT,&mut recog.err_handler)?;

							recog.base.set_state(4505);
							recog.base.match_token(DOLLAR,&mut recog.err_handler)?;

							recog.base.set_state(4506);
							recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(4511);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(676,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- functionCallHead ----------------
pub type FunctionCallHeadContextAll<'input> = FunctionCallHeadContext<'input>;


pub type FunctionCallHeadContext<'input> = BaseParserRuleContext<'input,FunctionCallHeadContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionCallHeadContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for FunctionCallHeadContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FunctionCallHeadContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionCallHead(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_functionCallHead(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FunctionCallHeadContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_functionCallHead(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionCallHeadContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionCallHead }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionCallHead }
}
antlr_rust::tid!{FunctionCallHeadContextExt<'a>}

impl<'input> FunctionCallHeadContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionCallHeadContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionCallHeadContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionCallHeadContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<FunctionCallHeadContextExt<'input>>{

fn processingMode(&self) -> Option<Rc<ProcessingModeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionCallHeadContextAttrs<'input> for FunctionCallHeadContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionCallHead(&mut self,)
	-> Result<Rc<FunctionCallHeadContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionCallHeadContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 260, RULE_functionCallHead);
        let mut _localctx: Rc<FunctionCallHeadContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(4513);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(677,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule processingMode*/
					recog.base.set_state(4512);
					recog.processingMode()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionCallTail ----------------
pub type FunctionCallTailContextAll<'input> = FunctionCallTailContext<'input>;


pub type FunctionCallTailContext<'input> = BaseParserRuleContext<'input,FunctionCallTailContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionCallTailContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for FunctionCallTailContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FunctionCallTailContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionCallTail(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_functionCallTail(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FunctionCallTailContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_functionCallTail(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionCallTailContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionCallTail }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionCallTail }
}
antlr_rust::tid!{FunctionCallTailContextExt<'a>}

impl<'input> FunctionCallTailContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionCallTailContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionCallTailContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionCallTailContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<FunctionCallTailContextExt<'input>>{

fn filter(&self) -> Option<Rc<FilterContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn over(&self) -> Option<Rc<OverContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn nullTreatment(&self) -> Option<Rc<NullTreatmentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FunctionCallTailContextAttrs<'input> for FunctionCallTailContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionCallTail(&mut self,)
	-> Result<Rc<FunctionCallTailContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionCallTailContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 262, RULE_functionCallTail);
        let mut _localctx: Rc<FunctionCallTailContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(4516);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(678,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule filter*/
					recog.base.set_state(4515);
					recog.filter()?;

					}
				}

				_ => {}
			}
			recog.base.set_state(4522);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(680,&mut recog.base)? {
				x if x == 1=>{
					{
					recog.base.set_state(4519);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==IGNORE || _la==RESPECT {
						{
						/*InvokeRule nullTreatment*/
						recog.base.set_state(4518);
						recog.nullTreatment()?;

						}
					}

					/*InvokeRule over*/
					recog.base.set_state(4521);
					recog.over()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- callArgument ----------------
#[derive(Debug)]
pub enum CallArgumentContextAll<'input>{
	PositionalArgumentContext(PositionalArgumentContext<'input>),
	FilesNamedFunctionArgumentContext(FilesNamedFunctionArgumentContext<'input>),
	NamedArgumentContext(NamedArgumentContext<'input>),
	MultiArgumentContext(MultiArgumentContext<'input>),
Error(CallArgumentContext<'input>)
}
antlr_rust::tid!{CallArgumentContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for CallArgumentContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for CallArgumentContextAll<'input>{}

impl<'input> Deref for CallArgumentContextAll<'input>{
	type Target = dyn CallArgumentContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use CallArgumentContextAll::*;
		match self{
			PositionalArgumentContext(inner) => inner,
			FilesNamedFunctionArgumentContext(inner) => inner,
			NamedArgumentContext(inner) => inner,
			MultiArgumentContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CallArgumentContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CallArgumentContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type CallArgumentContext<'input> = BaseParserRuleContext<'input,CallArgumentContextExt<'input>>;

#[derive(Clone)]
pub struct CallArgumentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for CallArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CallArgumentContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CallArgumentContext<'input>{
}

impl<'input> CustomRuleContext<'input> for CallArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_callArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_callArgument }
}
antlr_rust::tid!{CallArgumentContextExt<'a>}

impl<'input> CallArgumentContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<CallArgumentContextAll<'input>> {
		Rc::new(
		CallArgumentContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,CallArgumentContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait CallArgumentContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<CallArgumentContextExt<'input>>{


}

impl<'input> CallArgumentContextAttrs<'input> for CallArgumentContext<'input>{}

pub type PositionalArgumentContext<'input> = BaseParserRuleContext<'input,PositionalArgumentContextExt<'input>>;

pub trait PositionalArgumentContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> PositionalArgumentContextAttrs<'input> for PositionalArgumentContext<'input>{}

pub struct PositionalArgumentContextExt<'input>{
	base:CallArgumentContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PositionalArgumentContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PositionalArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PositionalArgumentContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_positionalArgument(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_positionalArgument(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PositionalArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_positionalArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for PositionalArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_callArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_callArgument }
}

impl<'input> Borrow<CallArgumentContextExt<'input>> for PositionalArgumentContext<'input>{
	fn borrow(&self) -> &CallArgumentContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<CallArgumentContextExt<'input>> for PositionalArgumentContext<'input>{
	fn borrow_mut(&mut self) -> &mut CallArgumentContextExt<'input> { &mut self.base }
}

impl<'input> CallArgumentContextAttrs<'input> for PositionalArgumentContext<'input> {}

impl<'input> PositionalArgumentContextExt<'input>{
	fn new(ctx: &dyn CallArgumentContextAttrs<'input>) -> Rc<CallArgumentContextAll<'input>>  {
		Rc::new(
			CallArgumentContextAll::PositionalArgumentContext(
				BaseParserRuleContext::copy_from(ctx,PositionalArgumentContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type FilesNamedFunctionArgumentContext<'input> = BaseParserRuleContext<'input,FilesNamedFunctionArgumentContextExt<'input>>;

pub trait FilesNamedFunctionArgumentContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token FILES
	/// Returns `None` if there is no child corresponding to token FILES
	fn FILES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FILES, 0)
	}
	fn string_all(&self) ->  Vec<Rc<StringContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn string(&self, i: usize) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> FilesNamedFunctionArgumentContextAttrs<'input> for FilesNamedFunctionArgumentContext<'input>{}

pub struct FilesNamedFunctionArgumentContextExt<'input>{
	base:CallArgumentContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{FilesNamedFunctionArgumentContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for FilesNamedFunctionArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FilesNamedFunctionArgumentContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_filesNamedFunctionArgument(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_filesNamedFunctionArgument(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FilesNamedFunctionArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_filesNamedFunctionArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for FilesNamedFunctionArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_callArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_callArgument }
}

impl<'input> Borrow<CallArgumentContextExt<'input>> for FilesNamedFunctionArgumentContext<'input>{
	fn borrow(&self) -> &CallArgumentContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<CallArgumentContextExt<'input>> for FilesNamedFunctionArgumentContext<'input>{
	fn borrow_mut(&mut self) -> &mut CallArgumentContextExt<'input> { &mut self.base }
}

impl<'input> CallArgumentContextAttrs<'input> for FilesNamedFunctionArgumentContext<'input> {}

impl<'input> FilesNamedFunctionArgumentContextExt<'input>{
	fn new(ctx: &dyn CallArgumentContextAttrs<'input>) -> Rc<CallArgumentContextAll<'input>>  {
		Rc::new(
			CallArgumentContextAll::FilesNamedFunctionArgumentContext(
				BaseParserRuleContext::copy_from(ctx,FilesNamedFunctionArgumentContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type NamedArgumentContext<'input> = BaseParserRuleContext<'input,NamedArgumentContextExt<'input>>;

pub trait NamedArgumentContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> NamedArgumentContextAttrs<'input> for NamedArgumentContext<'input>{}

pub struct NamedArgumentContextExt<'input>{
	base:CallArgumentContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{NamedArgumentContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for NamedArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NamedArgumentContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_namedArgument(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_namedArgument(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NamedArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_namedArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for NamedArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_callArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_callArgument }
}

impl<'input> Borrow<CallArgumentContextExt<'input>> for NamedArgumentContext<'input>{
	fn borrow(&self) -> &CallArgumentContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<CallArgumentContextExt<'input>> for NamedArgumentContext<'input>{
	fn borrow_mut(&mut self) -> &mut CallArgumentContextExt<'input> { &mut self.base }
}

impl<'input> CallArgumentContextAttrs<'input> for NamedArgumentContext<'input> {}

impl<'input> NamedArgumentContextExt<'input>{
	fn new(ctx: &dyn CallArgumentContextAttrs<'input>) -> Rc<CallArgumentContextAll<'input>>  {
		Rc::new(
			CallArgumentContextAll::NamedArgumentContext(
				BaseParserRuleContext::copy_from(ctx,NamedArgumentContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type MultiArgumentContext<'input> = BaseParserRuleContext<'input,MultiArgumentContextExt<'input>>;

pub trait MultiArgumentContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn multiSelect(&self) -> Option<Rc<MultiSelectContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> MultiArgumentContextAttrs<'input> for MultiArgumentContext<'input>{}

pub struct MultiArgumentContextExt<'input>{
	base:CallArgumentContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{MultiArgumentContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for MultiArgumentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for MultiArgumentContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_multiArgument(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_multiArgument(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for MultiArgumentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_multiArgument(self);
	}
}

impl<'input> CustomRuleContext<'input> for MultiArgumentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_callArgument }
	//fn type_rule_index() -> usize where Self: Sized { RULE_callArgument }
}

impl<'input> Borrow<CallArgumentContextExt<'input>> for MultiArgumentContext<'input>{
	fn borrow(&self) -> &CallArgumentContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<CallArgumentContextExt<'input>> for MultiArgumentContext<'input>{
	fn borrow_mut(&mut self) -> &mut CallArgumentContextExt<'input> { &mut self.base }
}

impl<'input> CallArgumentContextAttrs<'input> for MultiArgumentContext<'input> {}

impl<'input> MultiArgumentContextExt<'input>{
	fn new(ctx: &dyn CallArgumentContextAttrs<'input>) -> Rc<CallArgumentContextAll<'input>>  {
		Rc::new(
			CallArgumentContextAll::MultiArgumentContext(
				BaseParserRuleContext::copy_from(ctx,MultiArgumentContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn callArgument(&mut self,)
	-> Result<Rc<CallArgumentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = CallArgumentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 264, RULE_callArgument);
        let mut _localctx: Rc<CallArgumentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(4540);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(682,&mut recog.base)? {
				1 =>{
					let tmp = PositionalArgumentContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule expression*/
					recog.base.set_state(4524);
					recog.expression()?;

					}
				}
			,
				2 =>{
					let tmp = NamedArgumentContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule identifier*/
					recog.base.set_state(4525);
					recog.identifier()?;

					recog.base.set_state(4526);
					recog.base.match_token(T__0,&mut recog.err_handler)?;

					/*InvokeRule expression*/
					recog.base.set_state(4527);
					recog.expression()?;

					}
				}
			,
				3 =>{
					let tmp = FilesNamedFunctionArgumentContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(4529);
					recog.base.match_token(FILES,&mut recog.err_handler)?;

					recog.base.set_state(4530);
					recog.base.match_token(T__0,&mut recog.err_handler)?;

					/*InvokeRule string*/
					recog.base.set_state(4531);
					recog.string()?;

					recog.base.set_state(4536);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(681,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(4532);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule string*/
							recog.base.set_state(4533);
							recog.string()?;

							}
							} 
						}
						recog.base.set_state(4538);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(681,&mut recog.base)?;
					}
					}
				}
			,
				4 =>{
					let tmp = MultiArgumentContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					/*InvokeRule multiSelect*/
					recog.base.set_state(4539);
					recog.multiSelect()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionExtraArguments ----------------
pub type FunctionExtraArgumentsContextAll<'input> = FunctionExtraArgumentsContext<'input>;


pub type FunctionExtraArgumentsContext<'input> = BaseParserRuleContext<'input,FunctionExtraArgumentsContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionExtraArgumentsContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for FunctionExtraArgumentsContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FunctionExtraArgumentsContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionExtraArguments(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_functionExtraArguments(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FunctionExtraArgumentsContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_functionExtraArguments(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionExtraArgumentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionExtraArguments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionExtraArguments }
}
antlr_rust::tid!{FunctionExtraArgumentsContextExt<'a>}

impl<'input> FunctionExtraArgumentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionExtraArgumentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionExtraArgumentsContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionExtraArgumentsContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<FunctionExtraArgumentsContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ORDER
/// Returns `None` if there is no child corresponding to token ORDER
fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ORDER, 0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
fn sortItem_all(&self) ->  Vec<Rc<SortItemContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn sortItem(&self, i: usize) -> Option<Rc<SortItemContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> FunctionExtraArgumentsContextAttrs<'input> for FunctionExtraArgumentsContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionExtraArguments(&mut self,)
	-> Result<Rc<FunctionExtraArgumentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionExtraArgumentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 266, RULE_functionExtraArguments);
        let mut _localctx: Rc<FunctionExtraArgumentsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(4552);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==ORDER {
				{
				recog.base.set_state(4542);
				recog.base.match_token(ORDER,&mut recog.err_handler)?;

				recog.base.set_state(4543);
				recog.base.match_token(BY,&mut recog.err_handler)?;

				/*InvokeRule sortItem*/
				recog.base.set_state(4544);
				recog.sortItem()?;

				recog.base.set_state(4549);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(683,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(4545);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule sortItem*/
						recog.base.set_state(4546);
						recog.sortItem()?;

						}
						} 
					}
					recog.base.set_state(4551);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(683,&mut recog.base)?;
				}
				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- constant ----------------
#[derive(Debug)]
pub enum ConstantContextAll<'input>{
	BinaryLiteralContext(BinaryLiteralContext<'input>),
	NullLiteralContext(NullLiteralContext<'input>),
	StringLiteralContext(StringLiteralContext<'input>),
	TypeConstructorContext(TypeConstructorContext<'input>),
	IntervalLiteralContext(IntervalLiteralContext<'input>),
	NumericLiteralContext(NumericLiteralContext<'input>),
	BooleanLiteralContext(BooleanLiteralContext<'input>),
Error(ConstantContext<'input>)
}
antlr_rust::tid!{ConstantContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for ConstantContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for ConstantContextAll<'input>{}

impl<'input> Deref for ConstantContextAll<'input>{
	type Target = dyn ConstantContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use ConstantContextAll::*;
		match self{
			BinaryLiteralContext(inner) => inner,
			NullLiteralContext(inner) => inner,
			StringLiteralContext(inner) => inner,
			TypeConstructorContext(inner) => inner,
			IntervalLiteralContext(inner) => inner,
			NumericLiteralContext(inner) => inner,
			BooleanLiteralContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ConstantContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ConstantContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type ConstantContext<'input> = BaseParserRuleContext<'input,ConstantContextExt<'input>>;

#[derive(Clone)]
pub struct ConstantContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ConstantContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ConstantContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ConstantContext<'input>{
}

impl<'input> CustomRuleContext<'input> for ConstantContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant }
}
antlr_rust::tid!{ConstantContextExt<'a>}

impl<'input> ConstantContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ConstantContextAll<'input>> {
		Rc::new(
		ConstantContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ConstantContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait ConstantContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ConstantContextExt<'input>>{


}

impl<'input> ConstantContextAttrs<'input> for ConstantContext<'input>{}

pub type BinaryLiteralContext<'input> = BaseParserRuleContext<'input,BinaryLiteralContextExt<'input>>;

pub trait BinaryLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token BINARY_LITERAL
	/// Returns `None` if there is no child corresponding to token BINARY_LITERAL
	fn BINARY_LITERAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BINARY_LITERAL, 0)
	}
}

impl<'input> BinaryLiteralContextAttrs<'input> for BinaryLiteralContext<'input>{}

pub struct BinaryLiteralContextExt<'input>{
	base:ConstantContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{BinaryLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for BinaryLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for BinaryLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_binaryLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_binaryLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for BinaryLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_binaryLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for BinaryLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant }
}

impl<'input> Borrow<ConstantContextExt<'input>> for BinaryLiteralContext<'input>{
	fn borrow(&self) -> &ConstantContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ConstantContextExt<'input>> for BinaryLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut ConstantContextExt<'input> { &mut self.base }
}

impl<'input> ConstantContextAttrs<'input> for BinaryLiteralContext<'input> {}

impl<'input> BinaryLiteralContextExt<'input>{
	fn new(ctx: &dyn ConstantContextAttrs<'input>) -> Rc<ConstantContextAll<'input>>  {
		Rc::new(
			ConstantContextAll::BinaryLiteralContext(
				BaseParserRuleContext::copy_from(ctx,BinaryLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type NullLiteralContext<'input> = BaseParserRuleContext<'input,NullLiteralContextExt<'input>>;

pub trait NullLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token NULL
	/// Returns `None` if there is no child corresponding to token NULL
	fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, 0)
	}
}

impl<'input> NullLiteralContextAttrs<'input> for NullLiteralContext<'input>{}

pub struct NullLiteralContextExt<'input>{
	base:ConstantContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{NullLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for NullLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NullLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_nullLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_nullLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NullLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_nullLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for NullLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant }
}

impl<'input> Borrow<ConstantContextExt<'input>> for NullLiteralContext<'input>{
	fn borrow(&self) -> &ConstantContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ConstantContextExt<'input>> for NullLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut ConstantContextExt<'input> { &mut self.base }
}

impl<'input> ConstantContextAttrs<'input> for NullLiteralContext<'input> {}

impl<'input> NullLiteralContextExt<'input>{
	fn new(ctx: &dyn ConstantContextAttrs<'input>) -> Rc<ConstantContextAll<'input>>  {
		Rc::new(
			ConstantContextAll::NullLiteralContext(
				BaseParserRuleContext::copy_from(ctx,NullLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type StringLiteralContext<'input> = BaseParserRuleContext<'input,StringLiteralContextExt<'input>>;

pub trait StringLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> StringLiteralContextAttrs<'input> for StringLiteralContext<'input>{}

pub struct StringLiteralContextExt<'input>{
	base:ConstantContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{StringLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for StringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StringLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_stringLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_stringLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_stringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for StringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant }
}

impl<'input> Borrow<ConstantContextExt<'input>> for StringLiteralContext<'input>{
	fn borrow(&self) -> &ConstantContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ConstantContextExt<'input>> for StringLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut ConstantContextExt<'input> { &mut self.base }
}

impl<'input> ConstantContextAttrs<'input> for StringLiteralContext<'input> {}

impl<'input> StringLiteralContextExt<'input>{
	fn new(ctx: &dyn ConstantContextAttrs<'input>) -> Rc<ConstantContextAll<'input>>  {
		Rc::new(
			ConstantContextAll::StringLiteralContext(
				BaseParserRuleContext::copy_from(ctx,StringLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TypeConstructorContext<'input> = BaseParserRuleContext<'input,TypeConstructorContextExt<'input>>;

pub trait TypeConstructorContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token DOUBLE
	/// Returns `None` if there is no child corresponding to token DOUBLE
	fn DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOUBLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PRECISION
	/// Returns `None` if there is no child corresponding to token PRECISION
	fn PRECISION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PRECISION, 0)
	}
}

impl<'input> TypeConstructorContextAttrs<'input> for TypeConstructorContext<'input>{}

pub struct TypeConstructorContextExt<'input>{
	base:ConstantContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TypeConstructorContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TypeConstructorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TypeConstructorContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeConstructor(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_typeConstructor(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TypeConstructorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_typeConstructor(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeConstructorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant }
}

impl<'input> Borrow<ConstantContextExt<'input>> for TypeConstructorContext<'input>{
	fn borrow(&self) -> &ConstantContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ConstantContextExt<'input>> for TypeConstructorContext<'input>{
	fn borrow_mut(&mut self) -> &mut ConstantContextExt<'input> { &mut self.base }
}

impl<'input> ConstantContextAttrs<'input> for TypeConstructorContext<'input> {}

impl<'input> TypeConstructorContextExt<'input>{
	fn new(ctx: &dyn ConstantContextAttrs<'input>) -> Rc<ConstantContextAll<'input>>  {
		Rc::new(
			ConstantContextAll::TypeConstructorContext(
				BaseParserRuleContext::copy_from(ctx,TypeConstructorContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type IntervalLiteralContext<'input> = BaseParserRuleContext<'input,IntervalLiteralContextExt<'input>>;

pub trait IntervalLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn interval(&self) -> Option<Rc<IntervalContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> IntervalLiteralContextAttrs<'input> for IntervalLiteralContext<'input>{}

pub struct IntervalLiteralContextExt<'input>{
	base:ConstantContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{IntervalLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for IntervalLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IntervalLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_intervalLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_intervalLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IntervalLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_intervalLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for IntervalLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant }
}

impl<'input> Borrow<ConstantContextExt<'input>> for IntervalLiteralContext<'input>{
	fn borrow(&self) -> &ConstantContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ConstantContextExt<'input>> for IntervalLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut ConstantContextExt<'input> { &mut self.base }
}

impl<'input> ConstantContextAttrs<'input> for IntervalLiteralContext<'input> {}

impl<'input> IntervalLiteralContextExt<'input>{
	fn new(ctx: &dyn ConstantContextAttrs<'input>) -> Rc<ConstantContextAll<'input>>  {
		Rc::new(
			ConstantContextAll::IntervalLiteralContext(
				BaseParserRuleContext::copy_from(ctx,IntervalLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type NumericLiteralContext<'input> = BaseParserRuleContext<'input,NumericLiteralContextExt<'input>>;

pub trait NumericLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn number(&self) -> Option<Rc<NumberContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> NumericLiteralContextAttrs<'input> for NumericLiteralContext<'input>{}

pub struct NumericLiteralContextExt<'input>{
	base:ConstantContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{NumericLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for NumericLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NumericLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_numericLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_numericLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NumericLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_numericLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for NumericLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant }
}

impl<'input> Borrow<ConstantContextExt<'input>> for NumericLiteralContext<'input>{
	fn borrow(&self) -> &ConstantContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ConstantContextExt<'input>> for NumericLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut ConstantContextExt<'input> { &mut self.base }
}

impl<'input> ConstantContextAttrs<'input> for NumericLiteralContext<'input> {}

impl<'input> NumericLiteralContextExt<'input>{
	fn new(ctx: &dyn ConstantContextAttrs<'input>) -> Rc<ConstantContextAll<'input>>  {
		Rc::new(
			ConstantContextAll::NumericLiteralContext(
				BaseParserRuleContext::copy_from(ctx,NumericLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type BooleanLiteralContext<'input> = BaseParserRuleContext<'input,BooleanLiteralContextExt<'input>>;

pub trait BooleanLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn booleanValue(&self) -> Option<Rc<BooleanValueContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> BooleanLiteralContextAttrs<'input> for BooleanLiteralContext<'input>{}

pub struct BooleanLiteralContextExt<'input>{
	base:ConstantContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{BooleanLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for BooleanLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for BooleanLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_booleanLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_booleanLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for BooleanLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_booleanLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for BooleanLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_constant }
	//fn type_rule_index() -> usize where Self: Sized { RULE_constant }
}

impl<'input> Borrow<ConstantContextExt<'input>> for BooleanLiteralContext<'input>{
	fn borrow(&self) -> &ConstantContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<ConstantContextExt<'input>> for BooleanLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut ConstantContextExt<'input> { &mut self.base }
}

impl<'input> ConstantContextAttrs<'input> for BooleanLiteralContext<'input> {}

impl<'input> BooleanLiteralContextExt<'input>{
	fn new(ctx: &dyn ConstantContextAttrs<'input>) -> Rc<ConstantContextAll<'input>>  {
		Rc::new(
			ConstantContextAll::BooleanLiteralContext(
				BaseParserRuleContext::copy_from(ctx,BooleanLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn constant(&mut self,)
	-> Result<Rc<ConstantContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ConstantContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 268, RULE_constant);
        let mut _localctx: Rc<ConstantContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(4566);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(685,&mut recog.base)? {
				1 =>{
					let tmp = NullLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(4554);
					recog.base.match_token(NULL,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = IntervalLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule interval*/
					recog.base.set_state(4555);
					recog.interval()?;

					}
				}
			,
				3 =>{
					let tmp = NumericLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					/*InvokeRule number*/
					recog.base.set_state(4556);
					recog.number()?;

					}
				}
			,
				4 =>{
					let tmp = BooleanLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					/*InvokeRule booleanValue*/
					recog.base.set_state(4557);
					recog.booleanValue()?;

					}
				}
			,
				5 =>{
					let tmp = StringLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 5);
					_localctx = tmp;
					{
					/*InvokeRule string*/
					recog.base.set_state(4558);
					recog.string()?;

					}
				}
			,
				6 =>{
					let tmp = BinaryLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 6);
					_localctx = tmp;
					{
					recog.base.set_state(4559);
					recog.base.match_token(BINARY_LITERAL,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					let tmp = TypeConstructorContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 7);
					_localctx = tmp;
					{
					/*InvokeRule identifier*/
					recog.base.set_state(4560);
					recog.identifier()?;

					/*InvokeRule string*/
					recog.base.set_state(4561);
					recog.string()?;

					}
				}
			,
				8 =>{
					let tmp = TypeConstructorContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 8);
					_localctx = tmp;
					{
					recog.base.set_state(4563);
					recog.base.match_token(DOUBLE,&mut recog.err_handler)?;

					recog.base.set_state(4564);
					recog.base.match_token(PRECISION,&mut recog.err_handler)?;

					/*InvokeRule string*/
					recog.base.set_state(4565);
					recog.string()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dereferenceKey ----------------
pub type DereferenceKeyContextAll<'input> = DereferenceKeyContext<'input>;


pub type DereferenceKeyContext<'input> = BaseParserRuleContext<'input,DereferenceKeyContextExt<'input>>;

#[derive(Clone)]
pub struct DereferenceKeyContextExt<'input>{
	pub index: Option<Rc<ValueExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for DereferenceKeyContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DereferenceKeyContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dereferenceKey(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_dereferenceKey(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DereferenceKeyContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dereferenceKey(self);
	}
}

impl<'input> CustomRuleContext<'input> for DereferenceKeyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dereferenceKey }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dereferenceKey }
}
antlr_rust::tid!{DereferenceKeyContextExt<'a>}

impl<'input> DereferenceKeyContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DereferenceKeyContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DereferenceKeyContextExt{
				index: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait DereferenceKeyContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<DereferenceKeyContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token COLON
/// Returns `None` if there is no child corresponding to token COLON
fn COLON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COLON, 0)
}
fn dereferenceKeyText(&self) -> Option<Rc<DereferenceKeyTextContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dereferenceKeyElement_all(&self) ->  Vec<Rc<DereferenceKeyElementContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn dereferenceKeyElement(&self, i: usize) -> Option<Rc<DereferenceKeyElementContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token LBRACKET
/// Returns `None` if there is no child corresponding to token LBRACKET
fn LBRACKET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LBRACKET, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACKET
/// Returns `None` if there is no child corresponding to token RBRACKET
fn RBRACKET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RBRACKET, 0)
}
fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DereferenceKeyContextAttrs<'input> for DereferenceKeyContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dereferenceKey(&mut self,)
	-> Result<Rc<DereferenceKeyContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DereferenceKeyContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 270, RULE_dereferenceKey);
        let mut _localctx: Rc<DereferenceKeyContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(4585);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 COLON 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(4568);
					recog.base.match_token(COLON,&mut recog.err_handler)?;

					/*InvokeRule dereferenceKeyText*/
					recog.base.set_state(4569);
					recog.dereferenceKeyText()?;

					recog.base.set_state(4573);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(686,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							/*InvokeRule dereferenceKeyElement*/
							recog.base.set_state(4570);
							recog.dereferenceKeyElement()?;

							}
							} 
						}
						recog.base.set_state(4575);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(686,&mut recog.base)?;
					}
					}
				}

			 LBRACKET 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(4576);
					recog.base.match_token(LBRACKET,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4577);
					let tmp = recog.valueExpression_rec(0)?;
					 cast_mut::<_,DereferenceKeyContext >(&mut _localctx).index = Some(tmp.clone());
					  

					recog.base.set_state(4578);
					recog.base.match_token(RBRACKET,&mut recog.err_handler)?;

					recog.base.set_state(4582);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(687,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							/*InvokeRule dereferenceKeyElement*/
							recog.base.set_state(4579);
							recog.dereferenceKeyElement()?;

							}
							} 
						}
						recog.base.set_state(4584);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(687,&mut recog.base)?;
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dereferenceKeyElement ----------------
pub type DereferenceKeyElementContextAll<'input> = DereferenceKeyElementContext<'input>;


pub type DereferenceKeyElementContext<'input> = BaseParserRuleContext<'input,DereferenceKeyElementContextExt<'input>>;

#[derive(Clone)]
pub struct DereferenceKeyElementContextExt<'input>{
	pub index: Option<Rc<ValueExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for DereferenceKeyElementContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DereferenceKeyElementContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dereferenceKeyElement(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_dereferenceKeyElement(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DereferenceKeyElementContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dereferenceKeyElement(self);
	}
}

impl<'input> CustomRuleContext<'input> for DereferenceKeyElementContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dereferenceKeyElement }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dereferenceKeyElement }
}
antlr_rust::tid!{DereferenceKeyElementContextExt<'a>}

impl<'input> DereferenceKeyElementContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DereferenceKeyElementContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DereferenceKeyElementContextExt{
				index: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait DereferenceKeyElementContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<DereferenceKeyElementContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token DOT
/// Returns `None` if there is no child corresponding to token DOT
fn DOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DOT, 0)
}
fn dereferenceKeyText(&self) -> Option<Rc<DereferenceKeyTextContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LBRACKET
/// Returns `None` if there is no child corresponding to token LBRACKET
fn LBRACKET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LBRACKET, 0)
}
/// Retrieves first TerminalNode corresponding to token RBRACKET
/// Returns `None` if there is no child corresponding to token RBRACKET
fn RBRACKET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RBRACKET, 0)
}
fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DereferenceKeyElementContextAttrs<'input> for DereferenceKeyElementContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dereferenceKeyElement(&mut self,)
	-> Result<Rc<DereferenceKeyElementContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DereferenceKeyElementContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 272, RULE_dereferenceKeyElement);
        let mut _localctx: Rc<DereferenceKeyElementContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(4593);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 DOT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(4587);
					recog.base.match_token(DOT,&mut recog.err_handler)?;

					/*InvokeRule dereferenceKeyText*/
					recog.base.set_state(4588);
					recog.dereferenceKeyText()?;

					}
				}

			 LBRACKET 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(4589);
					recog.base.match_token(LBRACKET,&mut recog.err_handler)?;

					/*InvokeRule valueExpression*/
					recog.base.set_state(4590);
					let tmp = recog.valueExpression_rec(0)?;
					 cast_mut::<_,DereferenceKeyElementContext >(&mut _localctx).index = Some(tmp.clone());
					  

					recog.base.set_state(4591);
					recog.base.match_token(RBRACKET,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dereferenceKeyText ----------------
pub type DereferenceKeyTextContextAll<'input> = DereferenceKeyTextContext<'input>;


pub type DereferenceKeyTextContext<'input> = BaseParserRuleContext<'input,DereferenceKeyTextContextExt<'input>>;

#[derive(Clone)]
pub struct DereferenceKeyTextContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for DereferenceKeyTextContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DereferenceKeyTextContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dereferenceKeyText(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_dereferenceKeyText(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DereferenceKeyTextContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dereferenceKeyText(self);
	}
}

impl<'input> CustomRuleContext<'input> for DereferenceKeyTextContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dereferenceKeyText }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dereferenceKeyText }
}
antlr_rust::tid!{DereferenceKeyTextContextExt<'a>}

impl<'input> DereferenceKeyTextContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DereferenceKeyTextContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DereferenceKeyTextContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DereferenceKeyTextContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<DereferenceKeyTextContextExt<'input>>{

fn quotedIdentifier(&self) -> Option<Rc<QuotedIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token IDENTIFIER
/// Returns `None` if there is no child corresponding to token IDENTIFIER
fn IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IDENTIFIER, 0)
}
/// Retrieves first TerminalNode corresponding to token BACKQUOTED_IDENTIFIER
/// Returns `None` if there is no child corresponding to token BACKQUOTED_IDENTIFIER
fn BACKQUOTED_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BACKQUOTED_IDENTIFIER, 0)
}
fn nonReserved(&self) -> Option<Rc<NonReservedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token ABORT
/// Returns `None` if there is no child corresponding to token ABORT
fn ABORT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ABORT, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSENT
/// Returns `None` if there is no child corresponding to token ABSENT
fn ABSENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ABSENT, 0)
}
/// Retrieves first TerminalNode corresponding to token ACCESS
/// Returns `None` if there is no child corresponding to token ACCESS
fn ACCESS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ACCESS, 0)
}
/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
/// Retrieves first TerminalNode corresponding to token ADMIN
/// Returns `None` if there is no child corresponding to token ADMIN
fn ADMIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ADMIN, 0)
}
/// Retrieves first TerminalNode corresponding to token AFTER
/// Returns `None` if there is no child corresponding to token AFTER
fn AFTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AFTER, 0)
}
/// Retrieves first TerminalNode corresponding to token ALL
/// Returns `None` if there is no child corresponding to token ALL
fn ALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ALL, 0)
}
/// Retrieves first TerminalNode corresponding to token ALTER
/// Returns `None` if there is no child corresponding to token ALTER
fn ALTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ALTER, 0)
}
/// Retrieves first TerminalNode corresponding to token ANALYZE
/// Returns `None` if there is no child corresponding to token ANALYZE
fn ANALYZE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ANALYZE, 0)
}
/// Retrieves first TerminalNode corresponding to token AND
/// Returns `None` if there is no child corresponding to token AND
fn AND(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AND, 0)
}
/// Retrieves first TerminalNode corresponding to token ANTI
/// Returns `None` if there is no child corresponding to token ANTI
fn ANTI(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ANTI, 0)
}
/// Retrieves first TerminalNode corresponding to token ANY
/// Returns `None` if there is no child corresponding to token ANY
fn ANY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ANY, 0)
}
/// Retrieves first TerminalNode corresponding to token ARRAY
/// Returns `None` if there is no child corresponding to token ARRAY
fn ARRAY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ARRAY, 0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
/// Retrieves first TerminalNode corresponding to token ASC
/// Returns `None` if there is no child corresponding to token ASC
fn ASC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ASC, 0)
}
/// Retrieves first TerminalNode corresponding to token ASOF
/// Returns `None` if there is no child corresponding to token ASOF
fn ASOF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ASOF, 0)
}
/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
/// Retrieves first TerminalNode corresponding to token ATTACH
/// Returns `None` if there is no child corresponding to token ATTACH
fn ATTACH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ATTACH, 0)
}
/// Retrieves first TerminalNode corresponding to token AUTHORIZATION
/// Returns `None` if there is no child corresponding to token AUTHORIZATION
fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AUTHORIZATION, 0)
}
/// Retrieves first TerminalNode corresponding to token AUTO
/// Returns `None` if there is no child corresponding to token AUTO
fn AUTO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AUTO, 0)
}
/// Retrieves first TerminalNode corresponding to token AUTOINCREMENT
/// Returns `None` if there is no child corresponding to token AUTOINCREMENT
fn AUTOINCREMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AUTOINCREMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token BACKUP
/// Returns `None` if there is no child corresponding to token BACKUP
fn BACKUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BACKUP, 0)
}
/// Retrieves first TerminalNode corresponding to token BEFORE
/// Returns `None` if there is no child corresponding to token BEFORE
fn BEFORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BEFORE, 0)
}
/// Retrieves first TerminalNode corresponding to token BEGIN
/// Returns `None` if there is no child corresponding to token BEGIN
fn BEGIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BEGIN, 0)
}
/// Retrieves first TerminalNode corresponding to token BERNOULLI
/// Returns `None` if there is no child corresponding to token BERNOULLI
fn BERNOULLI(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BERNOULLI, 0)
}
/// Retrieves first TerminalNode corresponding to token BETWEEN
/// Returns `None` if there is no child corresponding to token BETWEEN
fn BETWEEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BETWEEN, 0)
}
/// Retrieves first TerminalNode corresponding to token BLOCK
/// Returns `None` if there is no child corresponding to token BLOCK
fn BLOCK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BLOCK, 0)
}
/// Retrieves first TerminalNode corresponding to token BOTH
/// Returns `None` if there is no child corresponding to token BOTH
fn BOTH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BOTH, 0)
}
/// Retrieves first TerminalNode corresponding to token BY
/// Returns `None` if there is no child corresponding to token BY
fn BY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BY, 0)
}
/// Retrieves first TerminalNode corresponding to token CALL
/// Returns `None` if there is no child corresponding to token CALL
fn CALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CALL, 0)
}
/// Retrieves first TerminalNode corresponding to token CALLED
/// Returns `None` if there is no child corresponding to token CALLED
fn CALLED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CALLED, 0)
}
/// Retrieves first TerminalNode corresponding to token CANCEL
/// Returns `None` if there is no child corresponding to token CANCEL
fn CANCEL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CANCEL, 0)
}
/// Retrieves first TerminalNode corresponding to token CASCADE
/// Returns `None` if there is no child corresponding to token CASCADE
fn CASCADE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CASCADE, 0)
}
/// Retrieves first TerminalNode corresponding to token CASE
/// Returns `None` if there is no child corresponding to token CASE
fn CASE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CASE, 0)
}
/// Retrieves first TerminalNode corresponding to token CAST
/// Returns `None` if there is no child corresponding to token CAST
fn CAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CAST, 0)
}
/// Retrieves first TerminalNode corresponding to token CATALOGS
/// Returns `None` if there is no child corresponding to token CATALOGS
fn CATALOGS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CATALOGS, 0)
}
/// Retrieves first TerminalNode corresponding to token CHANGES
/// Returns `None` if there is no child corresponding to token CHANGES
fn CHANGES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CHANGES, 0)
}
/// Retrieves first TerminalNode corresponding to token CHAR
/// Returns `None` if there is no child corresponding to token CHAR
fn CHAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CHAR, 0)
}
/// Retrieves first TerminalNode corresponding to token CHARACTER
/// Returns `None` if there is no child corresponding to token CHARACTER
fn CHARACTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CHARACTER, 0)
}
/// Retrieves first TerminalNode corresponding to token CLONE
/// Returns `None` if there is no child corresponding to token CLONE
fn CLONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CLONE, 0)
}
/// Retrieves first TerminalNode corresponding to token CLOSE
/// Returns `None` if there is no child corresponding to token CLOSE
fn CLOSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CLOSE, 0)
}
/// Retrieves first TerminalNode corresponding to token CLUSTER
/// Returns `None` if there is no child corresponding to token CLUSTER
fn CLUSTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CLUSTER, 0)
}
/// Retrieves first TerminalNode corresponding to token COLLATE
/// Returns `None` if there is no child corresponding to token COLLATE
fn COLLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COLLATE, 0)
}
/// Retrieves first TerminalNode corresponding to token COLUMN
/// Returns `None` if there is no child corresponding to token COLUMN
fn COLUMN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COLUMN, 0)
}
/// Retrieves first TerminalNode corresponding to token COLUMNS
/// Returns `None` if there is no child corresponding to token COLUMNS
fn COLUMNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COLUMNS, 0)
}
/// Retrieves first TerminalNode corresponding to token COMMENT
/// Returns `None` if there is no child corresponding to token COMMENT
fn COMMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token COMMIT
/// Returns `None` if there is no child corresponding to token COMMIT
fn COMMIT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMIT, 0)
}
/// Retrieves first TerminalNode corresponding to token COMMITTED
/// Returns `None` if there is no child corresponding to token COMMITTED
fn COMMITTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMITTED, 0)
}
/// Retrieves first TerminalNode corresponding to token COMPOUND
/// Returns `None` if there is no child corresponding to token COMPOUND
fn COMPOUND(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMPOUND, 0)
}
/// Retrieves first TerminalNode corresponding to token COMPRESSION
/// Returns `None` if there is no child corresponding to token COMPRESSION
fn COMPRESSION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMPRESSION, 0)
}
/// Retrieves first TerminalNode corresponding to token CONDITIONAL
/// Returns `None` if there is no child corresponding to token CONDITIONAL
fn CONDITIONAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONDITIONAL, 0)
}
/// Retrieves first TerminalNode corresponding to token CONNECT
/// Returns `None` if there is no child corresponding to token CONNECT
fn CONNECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONNECT, 0)
}
/// Retrieves first TerminalNode corresponding to token CONNECTION
/// Returns `None` if there is no child corresponding to token CONNECTION
fn CONNECTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONNECTION, 0)
}
/// Retrieves first TerminalNode corresponding to token CONSTRAINT
/// Returns `None` if there is no child corresponding to token CONSTRAINT
fn CONSTRAINT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONSTRAINT, 0)
}
/// Retrieves first TerminalNode corresponding to token COPARTITION
/// Returns `None` if there is no child corresponding to token COPARTITION
fn COPARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COPARTITION, 0)
}
/// Retrieves first TerminalNode corresponding to token COPY
/// Returns `None` if there is no child corresponding to token COPY
fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COPY, 0)
}
/// Retrieves first TerminalNode corresponding to token COUNT
/// Returns `None` if there is no child corresponding to token COUNT
fn COUNT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COUNT, 0)
}
/// Retrieves first TerminalNode corresponding to token CREATE
/// Returns `None` if there is no child corresponding to token CREATE
fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CREATE, 0)
}
/// Retrieves first TerminalNode corresponding to token CROSS
/// Returns `None` if there is no child corresponding to token CROSS
fn CROSS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CROSS, 0)
}
/// Retrieves first TerminalNode corresponding to token CUBE
/// Returns `None` if there is no child corresponding to token CUBE
fn CUBE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CUBE, 0)
}
/// Retrieves first TerminalNode corresponding to token CURRENT
/// Returns `None` if there is no child corresponding to token CURRENT
fn CURRENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CURRENT, 0)
}
/// Retrieves first TerminalNode corresponding to token DATA
/// Returns `None` if there is no child corresponding to token DATA
fn DATA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DATA, 0)
}
/// Retrieves first TerminalNode corresponding to token DATABASE
/// Returns `None` if there is no child corresponding to token DATABASE
fn DATABASE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DATABASE, 0)
}
/// Retrieves first TerminalNode corresponding to token DATASHARE
/// Returns `None` if there is no child corresponding to token DATASHARE
fn DATASHARE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DATASHARE, 0)
}
/// Retrieves first TerminalNode corresponding to token DAY
/// Returns `None` if there is no child corresponding to token DAY
fn DAY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DAY, 0)
}
/// Retrieves first TerminalNode corresponding to token DEALLOCATE
/// Returns `None` if there is no child corresponding to token DEALLOCATE
fn DEALLOCATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEALLOCATE, 0)
}
/// Retrieves first TerminalNode corresponding to token DECLARE
/// Returns `None` if there is no child corresponding to token DECLARE
fn DECLARE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DECLARE, 0)
}
/// Retrieves first TerminalNode corresponding to token DECODE
/// Returns `None` if there is no child corresponding to token DECODE
fn DECODE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DECODE, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULTS
/// Returns `None` if there is no child corresponding to token DEFAULTS
fn DEFAULTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFAULTS, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFINE
/// Returns `None` if there is no child corresponding to token DEFINE
fn DEFINE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFINE, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFINER
/// Returns `None` if there is no child corresponding to token DEFINER
fn DEFINER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFINER, 0)
}
/// Retrieves first TerminalNode corresponding to token DELETE
/// Returns `None` if there is no child corresponding to token DELETE
fn DELETE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DELETE, 0)
}
/// Retrieves first TerminalNode corresponding to token DELIMITED
/// Returns `None` if there is no child corresponding to token DELIMITED
fn DELIMITED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DELIMITED, 0)
}
/// Retrieves first TerminalNode corresponding to token DELIMITER
/// Returns `None` if there is no child corresponding to token DELIMITER
fn DELIMITER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DELIMITER, 0)
}
/// Retrieves first TerminalNode corresponding to token DENY
/// Returns `None` if there is no child corresponding to token DENY
fn DENY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DENY, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFERRABLE
/// Returns `None` if there is no child corresponding to token DEFERRABLE
fn DEFERRABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFERRABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFERRED
/// Returns `None` if there is no child corresponding to token DEFERRED
fn DEFERRED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFERRED, 0)
}
/// Retrieves first TerminalNode corresponding to token DESC
/// Returns `None` if there is no child corresponding to token DESC
fn DESC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DESC, 0)
}
/// Retrieves first TerminalNode corresponding to token DESCRIBE
/// Returns `None` if there is no child corresponding to token DESCRIBE
fn DESCRIBE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DESCRIBE, 0)
}
/// Retrieves first TerminalNode corresponding to token DESCRIPTOR
/// Returns `None` if there is no child corresponding to token DESCRIPTOR
fn DESCRIPTOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DESCRIPTOR, 0)
}
/// Retrieves first TerminalNode corresponding to token DIRECTORY
/// Returns `None` if there is no child corresponding to token DIRECTORY
fn DIRECTORY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DIRECTORY, 0)
}
/// Retrieves first TerminalNode corresponding to token DISABLE
/// Returns `None` if there is no child corresponding to token DISABLE
fn DISABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DISTINCT
/// Returns `None` if there is no child corresponding to token DISTINCT
fn DISTINCT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISTINCT, 0)
}
/// Retrieves first TerminalNode corresponding to token DISTKEY
/// Returns `None` if there is no child corresponding to token DISTKEY
fn DISTKEY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISTKEY, 0)
}
/// Retrieves first TerminalNode corresponding to token DISTRIBUTED
/// Returns `None` if there is no child corresponding to token DISTRIBUTED
fn DISTRIBUTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISTRIBUTED, 0)
}
/// Retrieves first TerminalNode corresponding to token DISTSTYLE
/// Returns `None` if there is no child corresponding to token DISTSTYLE
fn DISTSTYLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISTSTYLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DETACH
/// Returns `None` if there is no child corresponding to token DETACH
fn DETACH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DETACH, 0)
}
/// Retrieves first TerminalNode corresponding to token DOWNSTREAM
/// Returns `None` if there is no child corresponding to token DOWNSTREAM
fn DOWNSTREAM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DOWNSTREAM, 0)
}
/// Retrieves first TerminalNode corresponding to token DOUBLE
/// Returns `None` if there is no child corresponding to token DOUBLE
fn DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DOUBLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DROP
/// Returns `None` if there is no child corresponding to token DROP
fn DROP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DROP, 0)
}
/// Retrieves first TerminalNode corresponding to token DYNAMIC
/// Returns `None` if there is no child corresponding to token DYNAMIC
fn DYNAMIC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DYNAMIC, 0)
}
/// Retrieves first TerminalNode corresponding to token ELSE
/// Returns `None` if there is no child corresponding to token ELSE
fn ELSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ELSE, 0)
}
/// Retrieves first TerminalNode corresponding to token EMPTY
/// Returns `None` if there is no child corresponding to token EMPTY
fn EMPTY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EMPTY, 0)
}
/// Retrieves first TerminalNode corresponding to token ENABLE
/// Returns `None` if there is no child corresponding to token ENABLE
fn ENABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token ENCODE
/// Returns `None` if there is no child corresponding to token ENCODE
fn ENCODE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENCODE, 0)
}
/// Retrieves first TerminalNode corresponding to token ENCODING
/// Returns `None` if there is no child corresponding to token ENCODING
fn ENCODING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENCODING, 0)
}
/// Retrieves first TerminalNode corresponding to token END
/// Returns `None` if there is no child corresponding to token END
fn END(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(END, 0)
}
/// Retrieves first TerminalNode corresponding to token ENFORCED
/// Returns `None` if there is no child corresponding to token ENFORCED
fn ENFORCED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENFORCED, 0)
}
/// Retrieves first TerminalNode corresponding to token ERROR
/// Returns `None` if there is no child corresponding to token ERROR
fn ERROR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ERROR, 0)
}
/// Retrieves first TerminalNode corresponding to token ESCAPE
/// Returns `None` if there is no child corresponding to token ESCAPE
fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ESCAPE, 0)
}
/// Retrieves first TerminalNode corresponding to token EVEN
/// Returns `None` if there is no child corresponding to token EVEN
fn EVEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EVEN, 0)
}
/// Retrieves first TerminalNode corresponding to token EVENT
/// Returns `None` if there is no child corresponding to token EVENT
fn EVENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EVENT, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCEPT
/// Returns `None` if there is no child corresponding to token EXCEPT
fn EXCEPT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXCEPT, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCLUDE
/// Returns `None` if there is no child corresponding to token EXCLUDE
fn EXCLUDE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXCLUDE, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCLUDING
/// Returns `None` if there is no child corresponding to token EXCLUDING
fn EXCLUDING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXCLUDING, 0)
}
/// Retrieves first TerminalNode corresponding to token EXECUTE
/// Returns `None` if there is no child corresponding to token EXECUTE
fn EXECUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXECUTE, 0)
}
/// Retrieves first TerminalNode corresponding to token EXISTS
/// Returns `None` if there is no child corresponding to token EXISTS
fn EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXISTS, 0)
}
/// Retrieves first TerminalNode corresponding to token EXPLAIN
/// Returns `None` if there is no child corresponding to token EXPLAIN
fn EXPLAIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXPLAIN, 0)
}
/// Retrieves first TerminalNode corresponding to token EXTERNAL
/// Returns `None` if there is no child corresponding to token EXTERNAL
fn EXTERNAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token EXTRACT
/// Returns `None` if there is no child corresponding to token EXTRACT
fn EXTRACT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token FALSE
/// Returns `None` if there is no child corresponding to token FALSE
fn FALSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FALSE, 0)
}
/// Retrieves first TerminalNode corresponding to token FETCH
/// Returns `None` if there is no child corresponding to token FETCH
fn FETCH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FETCH, 0)
}
/// Retrieves first TerminalNode corresponding to token FIELDS
/// Returns `None` if there is no child corresponding to token FIELDS
fn FIELDS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FIELDS, 0)
}
/// Retrieves first TerminalNode corresponding to token FILES
/// Returns `None` if there is no child corresponding to token FILES
fn FILES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FILES, 0)
}
/// Retrieves first TerminalNode corresponding to token FILTER
/// Returns `None` if there is no child corresponding to token FILTER
fn FILTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FILTER, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token FIRST
/// Returns `None` if there is no child corresponding to token FIRST
fn FIRST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FIRST, 0)
}
/// Retrieves first TerminalNode corresponding to token FLOAT
/// Returns `None` if there is no child corresponding to token FLOAT
fn FLOAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FLOAT, 0)
}
/// Retrieves first TerminalNode corresponding to token FOLLOWING
/// Returns `None` if there is no child corresponding to token FOLLOWING
fn FOLLOWING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FOLLOWING, 0)
}
/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
/// Retrieves first TerminalNode corresponding to token FOREIGN
/// Returns `None` if there is no child corresponding to token FOREIGN
fn FOREIGN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FOREIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token FORMAT
/// Returns `None` if there is no child corresponding to token FORMAT
fn FORMAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FORMAT, 0)
}
/// Retrieves first TerminalNode corresponding to token FROM
/// Returns `None` if there is no child corresponding to token FROM
fn FROM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FROM, 0)
}
/// Retrieves first TerminalNode corresponding to token FULL
/// Returns `None` if there is no child corresponding to token FULL
fn FULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FULL, 0)
}
/// Retrieves first TerminalNode corresponding to token FUNCTION
/// Returns `None` if there is no child corresponding to token FUNCTION
fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FUNCTION, 0)
}
/// Retrieves first TerminalNode corresponding to token FUNCTIONS
/// Returns `None` if there is no child corresponding to token FUNCTIONS
fn FUNCTIONS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FUNCTIONS, 0)
}
/// Retrieves first TerminalNode corresponding to token GENERATED
/// Returns `None` if there is no child corresponding to token GENERATED
fn GENERATED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GENERATED, 0)
}
/// Retrieves first TerminalNode corresponding to token GLOBAL
/// Returns `None` if there is no child corresponding to token GLOBAL
fn GLOBAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GLOBAL, 0)
}
/// Retrieves first TerminalNode corresponding to token GRACE
/// Returns `None` if there is no child corresponding to token GRACE
fn GRACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token GRANT
/// Returns `None` if there is no child corresponding to token GRANT
fn GRANT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRANT, 0)
}
/// Retrieves first TerminalNode corresponding to token GRANTED
/// Returns `None` if there is no child corresponding to token GRANTED
fn GRANTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRANTED, 0)
}
/// Retrieves first TerminalNode corresponding to token GRANTS
/// Returns `None` if there is no child corresponding to token GRANTS
fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRANTS, 0)
}
/// Retrieves first TerminalNode corresponding to token GRAPHVIZ
/// Returns `None` if there is no child corresponding to token GRAPHVIZ
fn GRAPHVIZ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRAPHVIZ, 0)
}
/// Retrieves first TerminalNode corresponding to token GROUP
/// Returns `None` if there is no child corresponding to token GROUP
fn GROUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GROUP, 0)
}
/// Retrieves first TerminalNode corresponding to token GROUPING
/// Returns `None` if there is no child corresponding to token GROUPING
fn GROUPING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GROUPING, 0)
}
/// Retrieves first TerminalNode corresponding to token GROUPS
/// Returns `None` if there is no child corresponding to token GROUPS
fn GROUPS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GROUPS, 0)
}
/// Retrieves first TerminalNode corresponding to token GZIP
/// Returns `None` if there is no child corresponding to token GZIP
fn GZIP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GZIP, 0)
}
/// Retrieves first TerminalNode corresponding to token HAVING
/// Returns `None` if there is no child corresponding to token HAVING
fn HAVING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(HAVING, 0)
}
/// Retrieves first TerminalNode corresponding to token HEADER
/// Returns `None` if there is no child corresponding to token HEADER
fn HEADER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(HEADER, 0)
}
/// Retrieves first TerminalNode corresponding to token HOUR
/// Returns `None` if there is no child corresponding to token HOUR
fn HOUR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(HOUR, 0)
}
/// Retrieves first TerminalNode corresponding to token ICEBERG
/// Returns `None` if there is no child corresponding to token ICEBERG
fn ICEBERG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ICEBERG, 0)
}
/// Retrieves first TerminalNode corresponding to token IDENTITY
/// Returns `None` if there is no child corresponding to token IDENTITY
fn IDENTITY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IDENTITY, 0)
}
/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token IGNORE
/// Returns `None` if there is no child corresponding to token IGNORE
fn IGNORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IGNORE, 0)
}
/// Retrieves first TerminalNode corresponding to token IMMEDIATE
/// Returns `None` if there is no child corresponding to token IMMEDIATE
fn IMMEDIATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IMMEDIATE, 0)
}
/// Retrieves first TerminalNode corresponding to token IMMUTABLE
/// Returns `None` if there is no child corresponding to token IMMUTABLE
fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IMMUTABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token IN
/// Returns `None` if there is no child corresponding to token IN
fn IN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IN, 0)
}
/// Retrieves first TerminalNode corresponding to token INCLUDE
/// Returns `None` if there is no child corresponding to token INCLUDE
fn INCLUDE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INCLUDE, 0)
}
/// Retrieves first TerminalNode corresponding to token INCLUDING
/// Returns `None` if there is no child corresponding to token INCLUDING
fn INCLUDING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INCLUDING, 0)
}
/// Retrieves first TerminalNode corresponding to token INCREMENT
/// Returns `None` if there is no child corresponding to token INCREMENT
fn INCREMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INCREMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token INFORMATION
/// Returns `None` if there is no child corresponding to token INFORMATION
fn INFORMATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INFORMATION, 0)
}
/// Retrieves first TerminalNode corresponding to token INITIAL
/// Returns `None` if there is no child corresponding to token INITIAL
fn INITIAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INITIAL, 0)
}
/// Retrieves first TerminalNode corresponding to token INITIALLY
/// Returns `None` if there is no child corresponding to token INITIALLY
fn INITIALLY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INITIALLY, 0)
}
/// Retrieves first TerminalNode corresponding to token INNER
/// Returns `None` if there is no child corresponding to token INNER
fn INNER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INNER, 0)
}
/// Retrieves first TerminalNode corresponding to token INPUT
/// Returns `None` if there is no child corresponding to token INPUT
fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INPUT, 0)
}
/// Retrieves first TerminalNode corresponding to token INPUTFORMAT
/// Returns `None` if there is no child corresponding to token INPUTFORMAT
fn INPUTFORMAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INPUTFORMAT, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERLEAVED
/// Returns `None` if there is no child corresponding to token INTERLEAVED
fn INTERLEAVED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTERLEAVED, 0)
}
/// Retrieves first TerminalNode corresponding to token INSERT
/// Returns `None` if there is no child corresponding to token INSERT
fn INSERT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INSERT, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERSECT
/// Returns `None` if there is no child corresponding to token INTERSECT
fn INTERSECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTERSECT, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERVAL
/// Returns `None` if there is no child corresponding to token INTERVAL
fn INTERVAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTERVAL, 0)
}
/// Retrieves first TerminalNode corresponding to token INTO
/// Returns `None` if there is no child corresponding to token INTO
fn INTO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTO, 0)
}
/// Retrieves first TerminalNode corresponding to token INVOKER
/// Returns `None` if there is no child corresponding to token INVOKER
fn INVOKER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INVOKER, 0)
}
/// Retrieves first TerminalNode corresponding to token IO
/// Returns `None` if there is no child corresponding to token IO
fn IO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IO, 0)
}
/// Retrieves first TerminalNode corresponding to token IS
/// Returns `None` if there is no child corresponding to token IS
fn IS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IS, 0)
}
/// Retrieves first TerminalNode corresponding to token ISOLATION
/// Returns `None` if there is no child corresponding to token ISOLATION
fn ISOLATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ISOLATION, 0)
}
/// Retrieves first TerminalNode corresponding to token ILIKE
/// Returns `None` if there is no child corresponding to token ILIKE
fn ILIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ILIKE, 0)
}
/// Retrieves first TerminalNode corresponding to token JAVA
/// Returns `None` if there is no child corresponding to token JAVA
fn JAVA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JAVA, 0)
}
/// Retrieves first TerminalNode corresponding to token JAVASCRIPT
/// Returns `None` if there is no child corresponding to token JAVASCRIPT
fn JAVASCRIPT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JAVASCRIPT, 0)
}
/// Retrieves first TerminalNode corresponding to token JOIN
/// Returns `None` if there is no child corresponding to token JOIN
fn JOIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JOIN, 0)
}
/// Retrieves first TerminalNode corresponding to token JSON
/// Returns `None` if there is no child corresponding to token JSON
fn JSON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JSON, 0)
}
/// Retrieves first TerminalNode corresponding to token KEEP
/// Returns `None` if there is no child corresponding to token KEEP
fn KEEP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(KEEP, 0)
}
/// Retrieves first TerminalNode corresponding to token KEY
/// Returns `None` if there is no child corresponding to token KEY
fn KEY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(KEY, 0)
}
/// Retrieves first TerminalNode corresponding to token KEYS
/// Returns `None` if there is no child corresponding to token KEYS
fn KEYS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(KEYS, 0)
}
/// Retrieves first TerminalNode corresponding to token LAMBDA
/// Returns `None` if there is no child corresponding to token LAMBDA
fn LAMBDA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LAMBDA, 0)
}
/// Retrieves first TerminalNode corresponding to token LANGUAGE
/// Returns `None` if there is no child corresponding to token LANGUAGE
fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LANGUAGE, 0)
}
/// Retrieves first TerminalNode corresponding to token LAST
/// Returns `None` if there is no child corresponding to token LAST
fn LAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LAST, 0)
}
/// Retrieves first TerminalNode corresponding to token LATERAL
/// Returns `None` if there is no child corresponding to token LATERAL
fn LATERAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LATERAL, 0)
}
/// Retrieves first TerminalNode corresponding to token LEADING
/// Returns `None` if there is no child corresponding to token LEADING
fn LEADING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LEADING, 0)
}
/// Retrieves first TerminalNode corresponding to token LEFT
/// Returns `None` if there is no child corresponding to token LEFT
fn LEFT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LEFT, 0)
}
/// Retrieves first TerminalNode corresponding to token LEVEL
/// Returns `None` if there is no child corresponding to token LEVEL
fn LEVEL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LEVEL, 0)
}
/// Retrieves first TerminalNode corresponding to token LIBRARY
/// Returns `None` if there is no child corresponding to token LIBRARY
fn LIBRARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LIBRARY, 0)
}
/// Retrieves first TerminalNode corresponding to token LIKE
/// Returns `None` if there is no child corresponding to token LIKE
fn LIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LIKE, 0)
}
/// Retrieves first TerminalNode corresponding to token LIMIT
/// Returns `None` if there is no child corresponding to token LIMIT
fn LIMIT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LIMIT, 0)
}
/// Retrieves first TerminalNode corresponding to token LINES
/// Returns `None` if there is no child corresponding to token LINES
fn LINES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LINES, 0)
}
/// Retrieves first TerminalNode corresponding to token LISTAGG
/// Returns `None` if there is no child corresponding to token LISTAGG
fn LISTAGG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LISTAGG, 0)
}
/// Retrieves first TerminalNode corresponding to token LOCAL
/// Returns `None` if there is no child corresponding to token LOCAL
fn LOCAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LOCAL, 0)
}
/// Retrieves first TerminalNode corresponding to token LOCATION
/// Returns `None` if there is no child corresponding to token LOCATION
fn LOCATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LOCATION, 0)
}
/// Retrieves first TerminalNode corresponding to token LOCK
/// Returns `None` if there is no child corresponding to token LOCK
fn LOCK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LOCK, 0)
}
/// Retrieves first TerminalNode corresponding to token LOGICAL
/// Returns `None` if there is no child corresponding to token LOGICAL
fn LOGICAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LOGICAL, 0)
}
/// Retrieves first TerminalNode corresponding to token MAP
/// Returns `None` if there is no child corresponding to token MAP
fn MAP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MAP, 0)
}
/// Retrieves first TerminalNode corresponding to token MASKING
/// Returns `None` if there is no child corresponding to token MASKING
fn MASKING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MASKING, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCH
/// Returns `None` if there is no child corresponding to token MATCH
fn MATCH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCH, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCHED
/// Returns `None` if there is no child corresponding to token MATCHED
fn MATCHED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCHED, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCHES
/// Returns `None` if there is no child corresponding to token MATCHES
fn MATCHES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCHES, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCH_CONDITION
/// Returns `None` if there is no child corresponding to token MATCH_CONDITION
fn MATCH_CONDITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCH_CONDITION, 0)
}
/// Retrieves first TerminalNode corresponding to token MATERIALIZED
/// Returns `None` if there is no child corresponding to token MATERIALIZED
fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATERIALIZED, 0)
}
/// Retrieves first TerminalNode corresponding to token MAX
/// Returns `None` if there is no child corresponding to token MAX
fn MAX(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MAX, 0)
}
/// Retrieves first TerminalNode corresponding to token MEASURES
/// Returns `None` if there is no child corresponding to token MEASURES
fn MEASURES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MEASURES, 0)
}
/// Retrieves first TerminalNode corresponding to token MEMORIZABLE
/// Returns `None` if there is no child corresponding to token MEMORIZABLE
fn MEMORIZABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MEMORIZABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token MERGE
/// Returns `None` if there is no child corresponding to token MERGE
fn MERGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MERGE, 0)
}
/// Retrieves first TerminalNode corresponding to token MINHASH
/// Returns `None` if there is no child corresponding to token MINHASH
fn MINHASH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MINHASH, 0)
}
/// Retrieves first TerminalNode corresponding to token MINUS_KW
/// Returns `None` if there is no child corresponding to token MINUS_KW
fn MINUS_KW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MINUS_KW, 0)
}
/// Retrieves first TerminalNode corresponding to token MINUTE
/// Returns `None` if there is no child corresponding to token MINUTE
fn MINUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MINUTE, 0)
}
/// Retrieves first TerminalNode corresponding to token MODEL
/// Returns `None` if there is no child corresponding to token MODEL
fn MODEL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MODEL, 0)
}
/// Retrieves first TerminalNode corresponding to token MONTH
/// Returns `None` if there is no child corresponding to token MONTH
fn MONTH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MONTH, 0)
}
/// Retrieves first TerminalNode corresponding to token NATURAL
/// Returns `None` if there is no child corresponding to token NATURAL
fn NATURAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NATURAL, 0)
}
/// Retrieves first TerminalNode corresponding to token NCHAR
/// Returns `None` if there is no child corresponding to token NCHAR
fn NCHAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NCHAR, 0)
}
/// Retrieves first TerminalNode corresponding to token NEXT
/// Returns `None` if there is no child corresponding to token NEXT
fn NEXT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NEXT, 0)
}
/// Retrieves first TerminalNode corresponding to token NO
/// Returns `None` if there is no child corresponding to token NO
fn NO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NO, 0)
}
/// Retrieves first TerminalNode corresponding to token NONE
/// Returns `None` if there is no child corresponding to token NONE
fn NONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NONE, 0)
}
/// Retrieves first TerminalNode corresponding to token NOORDER
/// Returns `None` if there is no child corresponding to token NOORDER
fn NOORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOORDER, 0)
}
/// Retrieves first TerminalNode corresponding to token NORELY
/// Returns `None` if there is no child corresponding to token NORELY
fn NORELY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NORELY, 0)
}
/// Retrieves first TerminalNode corresponding to token NORMALIZE
/// Returns `None` if there is no child corresponding to token NORMALIZE
fn NORMALIZE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NORMALIZE, 0)
}
/// Retrieves first TerminalNode corresponding to token NOT
/// Returns `None` if there is no child corresponding to token NOT
fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOT, 0)
}
/// Retrieves first TerminalNode corresponding to token NOVALIDATE
/// Returns `None` if there is no child corresponding to token NOVALIDATE
fn NOVALIDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOVALIDATE, 0)
}
/// Retrieves first TerminalNode corresponding to token NULL
/// Returns `None` if there is no child corresponding to token NULL
fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULL, 0)
}
/// Retrieves first TerminalNode corresponding to token NULLS
/// Returns `None` if there is no child corresponding to token NULLS
fn NULLS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULLS, 0)
}
/// Retrieves first TerminalNode corresponding to token OBJECT
/// Returns `None` if there is no child corresponding to token OBJECT
fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OBJECT, 0)
}
/// Retrieves first TerminalNode corresponding to token OF
/// Returns `None` if there is no child corresponding to token OF
fn OF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OF, 0)
}
/// Retrieves first TerminalNode corresponding to token OFFSET
/// Returns `None` if there is no child corresponding to token OFFSET
fn OFFSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OFFSET, 0)
}
/// Retrieves first TerminalNode corresponding to token OMIT
/// Returns `None` if there is no child corresponding to token OMIT
fn OMIT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OMIT, 0)
}
/// Retrieves first TerminalNode corresponding to token ON
/// Returns `None` if there is no child corresponding to token ON
fn ON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ON, 0)
}
/// Retrieves first TerminalNode corresponding to token ONE
/// Returns `None` if there is no child corresponding to token ONE
fn ONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ONE, 0)
}
/// Retrieves first TerminalNode corresponding to token ONLY
/// Returns `None` if there is no child corresponding to token ONLY
fn ONLY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ONLY, 0)
}
/// Retrieves first TerminalNode corresponding to token OPTION
/// Returns `None` if there is no child corresponding to token OPTION
fn OPTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OPTION, 0)
}
/// Retrieves first TerminalNode corresponding to token OPTIONS
/// Returns `None` if there is no child corresponding to token OPTIONS
fn OPTIONS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OPTIONS, 0)
}
/// Retrieves first TerminalNode corresponding to token OR
/// Returns `None` if there is no child corresponding to token OR
fn OR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OR, 0)
}
/// Retrieves first TerminalNode corresponding to token ORDER
/// Returns `None` if there is no child corresponding to token ORDER
fn ORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ORDER, 0)
}
/// Retrieves first TerminalNode corresponding to token ORDINALITY
/// Returns `None` if there is no child corresponding to token ORDINALITY
fn ORDINALITY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ORDINALITY, 0)
}
/// Retrieves first TerminalNode corresponding to token OUTER
/// Returns `None` if there is no child corresponding to token OUTER
fn OUTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OUTER, 0)
}
/// Retrieves first TerminalNode corresponding to token OUTPUT
/// Returns `None` if there is no child corresponding to token OUTPUT
fn OUTPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OUTPUT, 0)
}
/// Retrieves first TerminalNode corresponding to token OUTPUTFORMAT
/// Returns `None` if there is no child corresponding to token OUTPUTFORMAT
fn OUTPUTFORMAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OUTPUTFORMAT, 0)
}
/// Retrieves first TerminalNode corresponding to token OVER
/// Returns `None` if there is no child corresponding to token OVER
fn OVER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OVER, 0)
}
/// Retrieves first TerminalNode corresponding to token OVERFLOW
/// Returns `None` if there is no child corresponding to token OVERFLOW
fn OVERFLOW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OVERFLOW, 0)
}
/// Retrieves first TerminalNode corresponding to token PARTITION
/// Returns `None` if there is no child corresponding to token PARTITION
fn PARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITION, 0)
}
/// Retrieves first TerminalNode corresponding to token PARTITIONED
/// Returns `None` if there is no child corresponding to token PARTITIONED
fn PARTITIONED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITIONED, 0)
}
/// Retrieves first TerminalNode corresponding to token PARTITIONS
/// Returns `None` if there is no child corresponding to token PARTITIONS
fn PARTITIONS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITIONS, 0)
}
/// Retrieves first TerminalNode corresponding to token PASSING
/// Returns `None` if there is no child corresponding to token PASSING
fn PASSING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PASSING, 0)
}
/// Retrieves first TerminalNode corresponding to token PAST
/// Returns `None` if there is no child corresponding to token PAST
fn PAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PAST, 0)
}
/// Retrieves first TerminalNode corresponding to token PATH
/// Returns `None` if there is no child corresponding to token PATH
fn PATH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PATH, 0)
}
/// Retrieves first TerminalNode corresponding to token PATTERN
/// Returns `None` if there is no child corresponding to token PATTERN
fn PATTERN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PATTERN, 0)
}
/// Retrieves first TerminalNode corresponding to token PER
/// Returns `None` if there is no child corresponding to token PER
fn PER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PER, 0)
}
/// Retrieves first TerminalNode corresponding to token PERIOD
/// Returns `None` if there is no child corresponding to token PERIOD
fn PERIOD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PERIOD, 0)
}
/// Retrieves first TerminalNode corresponding to token PERMUTE
/// Returns `None` if there is no child corresponding to token PERMUTE
fn PERMUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PERMUTE, 0)
}
/// Retrieves first TerminalNode corresponding to token PIVOT
/// Returns `None` if there is no child corresponding to token PIVOT
fn PIVOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PIVOT, 0)
}
/// Retrieves first TerminalNode corresponding to token PLACING
/// Returns `None` if there is no child corresponding to token PLACING
fn PLACING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PLACING, 0)
}
/// Retrieves first TerminalNode corresponding to token POLICY
/// Returns `None` if there is no child corresponding to token POLICY
fn POLICY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(POLICY, 0)
}
/// Retrieves first TerminalNode corresponding to token POSITION
/// Returns `None` if there is no child corresponding to token POSITION
fn POSITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(POSITION, 0)
}
/// Retrieves first TerminalNode corresponding to token PRECEDING
/// Returns `None` if there is no child corresponding to token PRECEDING
fn PRECEDING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRECEDING, 0)
}
/// Retrieves first TerminalNode corresponding to token PRECISION
/// Returns `None` if there is no child corresponding to token PRECISION
fn PRECISION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRECISION, 0)
}
/// Retrieves first TerminalNode corresponding to token PREPARE
/// Returns `None` if there is no child corresponding to token PREPARE
fn PREPARE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PREPARE, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIOR
/// Returns `None` if there is no child corresponding to token PRIOR
fn PRIOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRIOR, 0)
}
/// Retrieves first TerminalNode corresponding to token PROCEDURE
/// Returns `None` if there is no child corresponding to token PROCEDURE
fn PROCEDURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PROCEDURE, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIMARY
/// Returns `None` if there is no child corresponding to token PRIMARY
fn PRIMARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRIMARY, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVILEGES
/// Returns `None` if there is no child corresponding to token PRIVILEGES
fn PRIVILEGES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRIVILEGES, 0)
}
/// Retrieves first TerminalNode corresponding to token PROPERTIES
/// Returns `None` if there is no child corresponding to token PROPERTIES
fn PROPERTIES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PROPERTIES, 0)
}
/// Retrieves first TerminalNode corresponding to token PRUNE
/// Returns `None` if there is no child corresponding to token PRUNE
fn PRUNE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRUNE, 0)
}
/// Retrieves first TerminalNode corresponding to token PYTHON
/// Returns `None` if there is no child corresponding to token PYTHON
fn PYTHON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PYTHON, 0)
}
/// Retrieves first TerminalNode corresponding to token QUALIFY
/// Returns `None` if there is no child corresponding to token QUALIFY
fn QUALIFY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(QUALIFY, 0)
}
/// Retrieves first TerminalNode corresponding to token QUOTES
/// Returns `None` if there is no child corresponding to token QUOTES
fn QUOTES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(QUOTES, 0)
}
/// Retrieves first TerminalNode corresponding to token RANGE
/// Returns `None` if there is no child corresponding to token RANGE
fn RANGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RANGE, 0)
}
/// Retrieves first TerminalNode corresponding to token READ
/// Returns `None` if there is no child corresponding to token READ
fn READ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(READ, 0)
}
/// Retrieves first TerminalNode corresponding to token RECURSIVE
/// Returns `None` if there is no child corresponding to token RECURSIVE
fn RECURSIVE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RECURSIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token REGEXP
/// Returns `None` if there is no child corresponding to token REGEXP
fn REGEXP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REGEXP, 0)
}
/// Retrieves first TerminalNode corresponding to token REFERENCE
/// Returns `None` if there is no child corresponding to token REFERENCE
fn REFERENCE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REFERENCE, 0)
}
/// Retrieves first TerminalNode corresponding to token REFERENCES
/// Returns `None` if there is no child corresponding to token REFERENCES
fn REFERENCES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REFERENCES, 0)
}
/// Retrieves first TerminalNode corresponding to token REFRESH
/// Returns `None` if there is no child corresponding to token REFRESH
fn REFRESH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REFRESH, 0)
}
/// Retrieves first TerminalNode corresponding to token RELY
/// Returns `None` if there is no child corresponding to token RELY
fn RELY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RELY, 0)
}
/// Retrieves first TerminalNode corresponding to token RENAME
/// Returns `None` if there is no child corresponding to token RENAME
fn RENAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RENAME, 0)
}
/// Retrieves first TerminalNode corresponding to token REPEATABLE
/// Returns `None` if there is no child corresponding to token REPEATABLE
fn REPEATABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REPEATABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token REPLACE
/// Returns `None` if there is no child corresponding to token REPLACE
fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REPLACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RESET
/// Returns `None` if there is no child corresponding to token RESET
fn RESET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RESET, 0)
}
/// Retrieves first TerminalNode corresponding to token RESPECT
/// Returns `None` if there is no child corresponding to token RESPECT
fn RESPECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RESPECT, 0)
}
/// Retrieves first TerminalNode corresponding to token RESTRICT
/// Returns `None` if there is no child corresponding to token RESTRICT
fn RESTRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RESTRICT, 0)
}
/// Retrieves first TerminalNode corresponding to token RETURN
/// Returns `None` if there is no child corresponding to token RETURN
fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RETURN, 0)
}
/// Retrieves first TerminalNode corresponding to token RETURNING
/// Returns `None` if there is no child corresponding to token RETURNING
fn RETURNING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RETURNING, 0)
}
/// Retrieves first TerminalNode corresponding to token RETURNS
/// Returns `None` if there is no child corresponding to token RETURNS
fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RETURNS, 0)
}
/// Retrieves first TerminalNode corresponding to token REVOKE
/// Returns `None` if there is no child corresponding to token REVOKE
fn REVOKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REVOKE, 0)
}
/// Retrieves first TerminalNode corresponding to token RIGHT
/// Returns `None` if there is no child corresponding to token RIGHT
fn RIGHT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RIGHT, 0)
}
/// Retrieves first TerminalNode corresponding to token RLIKE
/// Returns `None` if there is no child corresponding to token RLIKE
fn RLIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RLIKE, 0)
}
/// Retrieves first TerminalNode corresponding to token RLS
/// Returns `None` if there is no child corresponding to token RLS
fn RLS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RLS, 0)
}
/// Retrieves first TerminalNode corresponding to token ROLE
/// Returns `None` if there is no child corresponding to token ROLE
fn ROLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROLE, 0)
}
/// Retrieves first TerminalNode corresponding to token ROLES
/// Returns `None` if there is no child corresponding to token ROLES
fn ROLES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROLES, 0)
}
/// Retrieves first TerminalNode corresponding to token ROLLBACK
/// Returns `None` if there is no child corresponding to token ROLLBACK
fn ROLLBACK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROLLBACK, 0)
}
/// Retrieves first TerminalNode corresponding to token ROLLUP
/// Returns `None` if there is no child corresponding to token ROLLUP
fn ROLLUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROLLUP, 0)
}
/// Retrieves first TerminalNode corresponding to token ROW
/// Returns `None` if there is no child corresponding to token ROW
fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROW, 0)
}
/// Retrieves first TerminalNode corresponding to token ROWS
/// Returns `None` if there is no child corresponding to token ROWS
fn ROWS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROWS, 0)
}
/// Retrieves first TerminalNode corresponding to token RUNNING
/// Returns `None` if there is no child corresponding to token RUNNING
fn RUNNING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RUNNING, 0)
}
/// Retrieves first TerminalNode corresponding to token SAMPLE
/// Returns `None` if there is no child corresponding to token SAMPLE
fn SAMPLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SAMPLE, 0)
}
/// Retrieves first TerminalNode corresponding to token SCALA
/// Returns `None` if there is no child corresponding to token SCALA
fn SCALA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SCALA, 0)
}
/// Retrieves first TerminalNode corresponding to token SCALAR
/// Returns `None` if there is no child corresponding to token SCALAR
fn SCALAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SCALAR, 0)
}
/// Retrieves first TerminalNode corresponding to token SECOND
/// Returns `None` if there is no child corresponding to token SECOND
fn SECOND(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SECOND, 0)
}
/// Retrieves first TerminalNode corresponding to token SCHEMA
/// Returns `None` if there is no child corresponding to token SCHEMA
fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SCHEMA, 0)
}
/// Retrieves first TerminalNode corresponding to token SCHEMAS
/// Returns `None` if there is no child corresponding to token SCHEMAS
fn SCHEMAS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SCHEMAS, 0)
}
/// Retrieves first TerminalNode corresponding to token SECURE
/// Returns `None` if there is no child corresponding to token SECURE
fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SECURE, 0)
}
/// Retrieves first TerminalNode corresponding to token SECURITY
/// Returns `None` if there is no child corresponding to token SECURITY
fn SECURITY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SECURITY, 0)
}
/// Retrieves first TerminalNode corresponding to token SEED
/// Returns `None` if there is no child corresponding to token SEED
fn SEED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEED, 0)
}
/// Retrieves first TerminalNode corresponding to token SEEK
/// Returns `None` if there is no child corresponding to token SEEK
fn SEEK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEEK, 0)
}
/// Retrieves first TerminalNode corresponding to token SELECT
/// Returns `None` if there is no child corresponding to token SELECT
fn SELECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SELECT, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
/// Retrieves first TerminalNode corresponding to token SEQUENCE
/// Returns `None` if there is no child corresponding to token SEQUENCE
fn SEQUENCE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEQUENCE, 0)
}
/// Retrieves first TerminalNode corresponding to token SERDE
/// Returns `None` if there is no child corresponding to token SERDE
fn SERDE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SERDE, 0)
}
/// Retrieves first TerminalNode corresponding to token SERDEPROPERTIES
/// Returns `None` if there is no child corresponding to token SERDEPROPERTIES
fn SERDEPROPERTIES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SERDEPROPERTIES, 0)
}
/// Retrieves first TerminalNode corresponding to token SERIALIZABLE
/// Returns `None` if there is no child corresponding to token SERIALIZABLE
fn SERIALIZABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SERIALIZABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token SESSION
/// Returns `None` if there is no child corresponding to token SESSION
fn SESSION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SESSION, 0)
}
/// Retrieves first TerminalNode corresponding to token SET
/// Returns `None` if there is no child corresponding to token SET
fn SET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SET, 0)
}
/// Retrieves first TerminalNode corresponding to token SETS
/// Returns `None` if there is no child corresponding to token SETS
fn SETS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SETS, 0)
}
/// Retrieves first TerminalNode corresponding to token SHOW
/// Returns `None` if there is no child corresponding to token SHOW
fn SHOW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SHOW, 0)
}
/// Retrieves first TerminalNode corresponding to token SIMILAR
/// Returns `None` if there is no child corresponding to token SIMILAR
fn SIMILAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SIMILAR, 0)
}
/// Retrieves first TerminalNode corresponding to token SNAPSHOT
/// Returns `None` if there is no child corresponding to token SNAPSHOT
fn SNAPSHOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SNAPSHOT, 0)
}
/// Retrieves first TerminalNode corresponding to token SOME
/// Returns `None` if there is no child corresponding to token SOME
fn SOME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SOME, 0)
}
/// Retrieves first TerminalNode corresponding to token SORTKEY
/// Returns `None` if there is no child corresponding to token SORTKEY
fn SORTKEY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SORTKEY, 0)
}
/// Retrieves first TerminalNode corresponding to token SQL
/// Returns `None` if there is no child corresponding to token SQL
fn SQL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SQL, 0)
}
/// Retrieves first TerminalNode corresponding to token STAGE
/// Returns `None` if there is no child corresponding to token STAGE
fn STAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STAGE, 0)
}
/// Retrieves first TerminalNode corresponding to token START
/// Returns `None` if there is no child corresponding to token START
fn START(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(START, 0)
}
/// Retrieves first TerminalNode corresponding to token STATEMENT
/// Returns `None` if there is no child corresponding to token STATEMENT
fn STATEMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STATEMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATS
/// Returns `None` if there is no child corresponding to token STATS
fn STATS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STATS, 0)
}
/// Retrieves first TerminalNode corresponding to token STORED
/// Returns `None` if there is no child corresponding to token STORED
fn STORED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STORED, 0)
}
/// Retrieves first TerminalNode corresponding to token STREAM
/// Returns `None` if there is no child corresponding to token STREAM
fn STREAM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STREAM, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICT
/// Returns `None` if there is no child corresponding to token STRICT
fn STRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STRICT, 0)
}
/// Retrieves first TerminalNode corresponding to token STRUCT
/// Returns `None` if there is no child corresponding to token STRUCT
fn STRUCT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STRUCT, 0)
}
/// Retrieves first TerminalNode corresponding to token SUBSET
/// Returns `None` if there is no child corresponding to token SUBSET
fn SUBSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SUBSET, 0)
}
/// Retrieves first TerminalNode corresponding to token SUBSTRING
/// Returns `None` if there is no child corresponding to token SUBSTRING
fn SUBSTRING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SUBSTRING, 0)
}
/// Retrieves first TerminalNode corresponding to token SYSTEM
/// Returns `None` if there is no child corresponding to token SYSTEM
fn SYSTEM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SYSTEM, 0)
}
/// Retrieves first TerminalNode corresponding to token TABLE
/// Returns `None` if there is no child corresponding to token TABLE
fn TABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token TABLES
/// Returns `None` if there is no child corresponding to token TABLES
fn TABLES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TABLES, 0)
}
/// Retrieves first TerminalNode corresponding to token TABLESAMPLE
/// Returns `None` if there is no child corresponding to token TABLESAMPLE
fn TABLESAMPLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TABLESAMPLE, 0)
}
/// Retrieves first TerminalNode corresponding to token TAG
/// Returns `None` if there is no child corresponding to token TAG
fn TAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TAG, 0)
}
/// Retrieves first TerminalNode corresponding to token TEMP
/// Returns `None` if there is no child corresponding to token TEMP
fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TEMP, 0)
}
/// Retrieves first TerminalNode corresponding to token TEMPLATE
/// Returns `None` if there is no child corresponding to token TEMPLATE
fn TEMPLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TEMPLATE, 0)
}
/// Retrieves first TerminalNode corresponding to token TEMPORARY
/// Returns `None` if there is no child corresponding to token TEMPORARY
fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TEMPORARY, 0)
}
/// Retrieves first TerminalNode corresponding to token TERMINATED
/// Returns `None` if there is no child corresponding to token TERMINATED
fn TERMINATED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TERMINATED, 0)
}
/// Retrieves first TerminalNode corresponding to token TEXT
/// Returns `None` if there is no child corresponding to token TEXT
fn TEXT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TEXT, 0)
}
/// Retrieves first TerminalNode corresponding to token THEN
/// Returns `None` if there is no child corresponding to token THEN
fn THEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(THEN, 0)
}
/// Retrieves first TerminalNode corresponding to token TIES
/// Returns `None` if there is no child corresponding to token TIES
fn TIES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIES, 0)
}
/// Retrieves first TerminalNode corresponding to token TIME
/// Returns `None` if there is no child corresponding to token TIME
fn TIME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIME, 0)
}
/// Retrieves first TerminalNode corresponding to token TIMESTAMP
/// Returns `None` if there is no child corresponding to token TIMESTAMP
fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIMESTAMP, 0)
}
/// Retrieves first TerminalNode corresponding to token TO
/// Returns `None` if there is no child corresponding to token TO
fn TO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TO, 0)
}
/// Retrieves first TerminalNode corresponding to token TOP
/// Returns `None` if there is no child corresponding to token TOP
fn TOP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TOP, 0)
}
/// Retrieves first TerminalNode corresponding to token TRAILING
/// Returns `None` if there is no child corresponding to token TRAILING
fn TRAILING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRAILING, 0)
}
/// Retrieves first TerminalNode corresponding to token TRANSACTION
/// Returns `None` if there is no child corresponding to token TRANSACTION
fn TRANSACTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRANSACTION, 0)
}
/// Retrieves first TerminalNode corresponding to token TRANSIENT
/// Returns `None` if there is no child corresponding to token TRANSIENT
fn TRANSIENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRANSIENT, 0)
}
/// Retrieves first TerminalNode corresponding to token TRIM
/// Returns `None` if there is no child corresponding to token TRIM
fn TRIM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRIM, 0)
}
/// Retrieves first TerminalNode corresponding to token TRUE
/// Returns `None` if there is no child corresponding to token TRUE
fn TRUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRUE, 0)
}
/// Retrieves first TerminalNode corresponding to token TRUNCATE
/// Returns `None` if there is no child corresponding to token TRUNCATE
fn TRUNCATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRUNCATE, 0)
}
/// Retrieves first TerminalNode corresponding to token TUPLE
/// Returns `None` if there is no child corresponding to token TUPLE
fn TUPLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TUPLE, 0)
}
/// Retrieves first TerminalNode corresponding to token TYPE
/// Returns `None` if there is no child corresponding to token TYPE
fn TYPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TYPE, 0)
}
/// Retrieves first TerminalNode corresponding to token UESCAPE
/// Returns `None` if there is no child corresponding to token UESCAPE
fn UESCAPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UESCAPE, 0)
}
/// Retrieves first TerminalNode corresponding to token UNBOUNDED
/// Returns `None` if there is no child corresponding to token UNBOUNDED
fn UNBOUNDED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNBOUNDED, 0)
}
/// Retrieves first TerminalNode corresponding to token UNCOMMITTED
/// Returns `None` if there is no child corresponding to token UNCOMMITTED
fn UNCOMMITTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNCOMMITTED, 0)
}
/// Retrieves first TerminalNode corresponding to token UNCONDITIONAL
/// Returns `None` if there is no child corresponding to token UNCONDITIONAL
fn UNCONDITIONAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNCONDITIONAL, 0)
}
/// Retrieves first TerminalNode corresponding to token UNION
/// Returns `None` if there is no child corresponding to token UNION
fn UNION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNION, 0)
}
/// Retrieves first TerminalNode corresponding to token UNIQUE
/// Returns `None` if there is no child corresponding to token UNIQUE
fn UNIQUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNIQUE, 0)
}
/// Retrieves first TerminalNode corresponding to token UNKNOWN
/// Returns `None` if there is no child corresponding to token UNKNOWN
fn UNKNOWN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNKNOWN, 0)
}
/// Retrieves first TerminalNode corresponding to token UNLOAD
/// Returns `None` if there is no child corresponding to token UNLOAD
fn UNLOAD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNLOAD, 0)
}
/// Retrieves first TerminalNode corresponding to token UNMATCHED
/// Returns `None` if there is no child corresponding to token UNMATCHED
fn UNMATCHED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNMATCHED, 0)
}
/// Retrieves first TerminalNode corresponding to token UNNEST
/// Returns `None` if there is no child corresponding to token UNNEST
fn UNNEST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNNEST, 0)
}
/// Retrieves first TerminalNode corresponding to token UNPIVOT
/// Returns `None` if there is no child corresponding to token UNPIVOT
fn UNPIVOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNPIVOT, 0)
}
/// Retrieves first TerminalNode corresponding to token UNSET
/// Returns `None` if there is no child corresponding to token UNSET
fn UNSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNSET, 0)
}
/// Retrieves first TerminalNode corresponding to token UNSIGNED
/// Returns `None` if there is no child corresponding to token UNSIGNED
fn UNSIGNED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNSIGNED, 0)
}
/// Retrieves first TerminalNode corresponding to token UPDATE
/// Returns `None` if there is no child corresponding to token UPDATE
fn UPDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UPDATE, 0)
}
/// Retrieves first TerminalNode corresponding to token USE
/// Returns `None` if there is no child corresponding to token USE
fn USE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(USE, 0)
}
/// Retrieves first TerminalNode corresponding to token USER
/// Returns `None` if there is no child corresponding to token USER
fn USER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(USER, 0)
}
/// Retrieves first TerminalNode corresponding to token USING
/// Returns `None` if there is no child corresponding to token USING
fn USING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(USING, 0)
}
/// Retrieves first TerminalNode corresponding to token VACUUM
/// Returns `None` if there is no child corresponding to token VACUUM
fn VACUUM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VACUUM, 0)
}
/// Retrieves first TerminalNode corresponding to token VALIDATE
/// Returns `None` if there is no child corresponding to token VALIDATE
fn VALIDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VALIDATE, 0)
}
/// Retrieves first TerminalNode corresponding to token VALUE
/// Returns `None` if there is no child corresponding to token VALUE
fn VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VALUE, 0)
}
/// Retrieves first TerminalNode corresponding to token VALUES
/// Returns `None` if there is no child corresponding to token VALUES
fn VALUES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VALUES, 0)
}
/// Retrieves first TerminalNode corresponding to token VARYING
/// Returns `None` if there is no child corresponding to token VARYING
fn VARYING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VARYING, 0)
}
/// Retrieves first TerminalNode corresponding to token VECTOR
/// Returns `None` if there is no child corresponding to token VECTOR
fn VECTOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VECTOR, 0)
}
/// Retrieves first TerminalNode corresponding to token VERBOSE
/// Returns `None` if there is no child corresponding to token VERBOSE
fn VERBOSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VERBOSE, 0)
}
/// Retrieves first TerminalNode corresponding to token VERSION
/// Returns `None` if there is no child corresponding to token VERSION
fn VERSION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VERSION, 0)
}
/// Retrieves first TerminalNode corresponding to token VIEW
/// Returns `None` if there is no child corresponding to token VIEW
fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VIEW, 0)
}
/// Retrieves first TerminalNode corresponding to token VOLATILE
/// Returns `None` if there is no child corresponding to token VOLATILE
fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VOLATILE, 0)
}
/// Retrieves first TerminalNode corresponding to token WAREHOUSE
/// Returns `None` if there is no child corresponding to token WAREHOUSE
fn WAREHOUSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WAREHOUSE, 0)
}
/// Retrieves first TerminalNode corresponding to token WHEN
/// Returns `None` if there is no child corresponding to token WHEN
fn WHEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WHEN, 0)
}
/// Retrieves first TerminalNode corresponding to token WHERE
/// Returns `None` if there is no child corresponding to token WHERE
fn WHERE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WHERE, 0)
}
/// Retrieves first TerminalNode corresponding to token WINDOW
/// Returns `None` if there is no child corresponding to token WINDOW
fn WINDOW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WINDOW, 0)
}
/// Retrieves first TerminalNode corresponding to token WITH
/// Returns `None` if there is no child corresponding to token WITH
fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITH, 0)
}
/// Retrieves first TerminalNode corresponding to token WITHIN
/// Returns `None` if there is no child corresponding to token WITHIN
fn WITHIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITHIN, 0)
}
/// Retrieves first TerminalNode corresponding to token WITHOUT
/// Returns `None` if there is no child corresponding to token WITHOUT
fn WITHOUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITHOUT, 0)
}
/// Retrieves first TerminalNode corresponding to token WORK
/// Returns `None` if there is no child corresponding to token WORK
fn WORK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WORK, 0)
}
/// Retrieves first TerminalNode corresponding to token WRAPPER
/// Returns `None` if there is no child corresponding to token WRAPPER
fn WRAPPER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WRAPPER, 0)
}
/// Retrieves first TerminalNode corresponding to token WRITE
/// Returns `None` if there is no child corresponding to token WRITE
fn WRITE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WRITE, 0)
}
/// Retrieves first TerminalNode corresponding to token XZ
/// Returns `None` if there is no child corresponding to token XZ
fn XZ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(XZ, 0)
}
/// Retrieves first TerminalNode corresponding to token YEAR
/// Returns `None` if there is no child corresponding to token YEAR
fn YEAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(YEAR, 0)
}
/// Retrieves first TerminalNode corresponding to token YES
/// Returns `None` if there is no child corresponding to token YES
fn YES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(YES, 0)
}
/// Retrieves first TerminalNode corresponding to token ZONE
/// Returns `None` if there is no child corresponding to token ZONE
fn ZONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ZONE, 0)
}
/// Retrieves first TerminalNode corresponding to token ZSTD
/// Returns `None` if there is no child corresponding to token ZSTD
fn ZSTD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ZSTD, 0)
}

}

impl<'input> DereferenceKeyTextContextAttrs<'input> for DereferenceKeyTextContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn dereferenceKeyText(&mut self,)
	-> Result<Rc<DereferenceKeyTextContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = DereferenceKeyTextContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 274, RULE_dereferenceKeyText);
        let mut _localctx: Rc<DereferenceKeyTextContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(4989);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(690,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule quotedIdentifier*/
					recog.base.set_state(4595);
					recog.quotedIdentifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(4596);
					recog.base.match_token(IDENTIFIER,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(4597);
					recog.base.match_token(BACKQUOTED_IDENTIFIER,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					/*InvokeRule nonReserved*/
					recog.base.set_state(4598);
					recog.nonReserved()?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(4599);
					recog.base.match_token(ABORT,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(4600);
					recog.base.match_token(ABSENT,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(4601);
					recog.base.match_token(ACCESS,&mut recog.err_handler)?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(4602);
					recog.base.match_token(ADD,&mut recog.err_handler)?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					recog.base.set_state(4603);
					recog.base.match_token(ADMIN,&mut recog.err_handler)?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					recog.base.set_state(4604);
					recog.base.match_token(AFTER,&mut recog.err_handler)?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					recog.base.set_state(4605);
					recog.base.match_token(ALL,&mut recog.err_handler)?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					recog.base.set_state(4606);
					recog.base.match_token(ALTER,&mut recog.err_handler)?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					recog.base.set_state(4607);
					recog.base.match_token(ANALYZE,&mut recog.err_handler)?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					recog.base.set_state(4608);
					recog.base.match_token(AND,&mut recog.err_handler)?;

					}
				}
			,
				15 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					recog.base.set_state(4609);
					recog.base.match_token(ANTI,&mut recog.err_handler)?;

					}
				}
			,
				16 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					recog.base.set_state(4610);
					recog.base.match_token(ANY,&mut recog.err_handler)?;

					}
				}
			,
				17 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 17);
					recog.base.enter_outer_alt(None, 17);
					{
					recog.base.set_state(4611);
					recog.base.match_token(ARRAY,&mut recog.err_handler)?;

					}
				}
			,
				18 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 18);
					recog.base.enter_outer_alt(None, 18);
					{
					recog.base.set_state(4612);
					recog.base.match_token(AS,&mut recog.err_handler)?;

					}
				}
			,
				19 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 19);
					recog.base.enter_outer_alt(None, 19);
					{
					recog.base.set_state(4613);
					recog.base.match_token(ASC,&mut recog.err_handler)?;

					}
				}
			,
				20 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 20);
					recog.base.enter_outer_alt(None, 20);
					{
					recog.base.set_state(4614);
					recog.base.match_token(ASOF,&mut recog.err_handler)?;

					}
				}
			,
				21 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 21);
					recog.base.enter_outer_alt(None, 21);
					{
					recog.base.set_state(4615);
					recog.base.match_token(AT,&mut recog.err_handler)?;

					}
				}
			,
				22 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 22);
					recog.base.enter_outer_alt(None, 22);
					{
					recog.base.set_state(4616);
					recog.base.match_token(ATTACH,&mut recog.err_handler)?;

					}
				}
			,
				23 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 23);
					recog.base.enter_outer_alt(None, 23);
					{
					recog.base.set_state(4617);
					recog.base.match_token(AUTHORIZATION,&mut recog.err_handler)?;

					}
				}
			,
				24 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 24);
					recog.base.enter_outer_alt(None, 24);
					{
					recog.base.set_state(4618);
					recog.base.match_token(AUTO,&mut recog.err_handler)?;

					}
				}
			,
				25 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 25);
					recog.base.enter_outer_alt(None, 25);
					{
					recog.base.set_state(4619);
					recog.base.match_token(AUTOINCREMENT,&mut recog.err_handler)?;

					}
				}
			,
				26 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 26);
					recog.base.enter_outer_alt(None, 26);
					{
					recog.base.set_state(4620);
					recog.base.match_token(BACKUP,&mut recog.err_handler)?;

					}
				}
			,
				27 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 27);
					recog.base.enter_outer_alt(None, 27);
					{
					recog.base.set_state(4621);
					recog.base.match_token(BEFORE,&mut recog.err_handler)?;

					}
				}
			,
				28 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 28);
					recog.base.enter_outer_alt(None, 28);
					{
					recog.base.set_state(4622);
					recog.base.match_token(BEGIN,&mut recog.err_handler)?;

					}
				}
			,
				29 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 29);
					recog.base.enter_outer_alt(None, 29);
					{
					recog.base.set_state(4623);
					recog.base.match_token(BERNOULLI,&mut recog.err_handler)?;

					}
				}
			,
				30 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 30);
					recog.base.enter_outer_alt(None, 30);
					{
					recog.base.set_state(4624);
					recog.base.match_token(BETWEEN,&mut recog.err_handler)?;

					}
				}
			,
				31 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 31);
					recog.base.enter_outer_alt(None, 31);
					{
					recog.base.set_state(4625);
					recog.base.match_token(BLOCK,&mut recog.err_handler)?;

					}
				}
			,
				32 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 32);
					recog.base.enter_outer_alt(None, 32);
					{
					recog.base.set_state(4626);
					recog.base.match_token(BOTH,&mut recog.err_handler)?;

					}
				}
			,
				33 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 33);
					recog.base.enter_outer_alt(None, 33);
					{
					recog.base.set_state(4627);
					recog.base.match_token(BY,&mut recog.err_handler)?;

					}
				}
			,
				34 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 34);
					recog.base.enter_outer_alt(None, 34);
					{
					recog.base.set_state(4628);
					recog.base.match_token(CALL,&mut recog.err_handler)?;

					}
				}
			,
				35 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 35);
					recog.base.enter_outer_alt(None, 35);
					{
					recog.base.set_state(4629);
					recog.base.match_token(CALLED,&mut recog.err_handler)?;

					}
				}
			,
				36 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 36);
					recog.base.enter_outer_alt(None, 36);
					{
					recog.base.set_state(4630);
					recog.base.match_token(CANCEL,&mut recog.err_handler)?;

					}
				}
			,
				37 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 37);
					recog.base.enter_outer_alt(None, 37);
					{
					recog.base.set_state(4631);
					recog.base.match_token(CASCADE,&mut recog.err_handler)?;

					}
				}
			,
				38 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 38);
					recog.base.enter_outer_alt(None, 38);
					{
					recog.base.set_state(4632);
					recog.base.match_token(CASE,&mut recog.err_handler)?;

					}
				}
			,
				39 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 39);
					recog.base.enter_outer_alt(None, 39);
					{
					recog.base.set_state(4633);
					recog.base.match_token(CAST,&mut recog.err_handler)?;

					}
				}
			,
				40 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 40);
					recog.base.enter_outer_alt(None, 40);
					{
					recog.base.set_state(4634);
					recog.base.match_token(CATALOGS,&mut recog.err_handler)?;

					}
				}
			,
				41 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 41);
					recog.base.enter_outer_alt(None, 41);
					{
					recog.base.set_state(4635);
					recog.base.match_token(CHANGES,&mut recog.err_handler)?;

					}
				}
			,
				42 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 42);
					recog.base.enter_outer_alt(None, 42);
					{
					recog.base.set_state(4636);
					recog.base.match_token(CHAR,&mut recog.err_handler)?;

					}
				}
			,
				43 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 43);
					recog.base.enter_outer_alt(None, 43);
					{
					recog.base.set_state(4637);
					recog.base.match_token(CHARACTER,&mut recog.err_handler)?;

					}
				}
			,
				44 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 44);
					recog.base.enter_outer_alt(None, 44);
					{
					recog.base.set_state(4638);
					recog.base.match_token(CLONE,&mut recog.err_handler)?;

					}
				}
			,
				45 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 45);
					recog.base.enter_outer_alt(None, 45);
					{
					recog.base.set_state(4639);
					recog.base.match_token(CLOSE,&mut recog.err_handler)?;

					}
				}
			,
				46 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 46);
					recog.base.enter_outer_alt(None, 46);
					{
					recog.base.set_state(4640);
					recog.base.match_token(CLUSTER,&mut recog.err_handler)?;

					}
				}
			,
				47 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 47);
					recog.base.enter_outer_alt(None, 47);
					{
					recog.base.set_state(4641);
					recog.base.match_token(COLLATE,&mut recog.err_handler)?;

					}
				}
			,
				48 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 48);
					recog.base.enter_outer_alt(None, 48);
					{
					recog.base.set_state(4642);
					recog.base.match_token(COLUMN,&mut recog.err_handler)?;

					}
				}
			,
				49 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 49);
					recog.base.enter_outer_alt(None, 49);
					{
					recog.base.set_state(4643);
					recog.base.match_token(COLUMNS,&mut recog.err_handler)?;

					}
				}
			,
				50 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 50);
					recog.base.enter_outer_alt(None, 50);
					{
					recog.base.set_state(4644);
					recog.base.match_token(COMMENT,&mut recog.err_handler)?;

					}
				}
			,
				51 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 51);
					recog.base.enter_outer_alt(None, 51);
					{
					recog.base.set_state(4645);
					recog.base.match_token(COMMIT,&mut recog.err_handler)?;

					}
				}
			,
				52 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 52);
					recog.base.enter_outer_alt(None, 52);
					{
					recog.base.set_state(4646);
					recog.base.match_token(COMMITTED,&mut recog.err_handler)?;

					}
				}
			,
				53 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 53);
					recog.base.enter_outer_alt(None, 53);
					{
					recog.base.set_state(4647);
					recog.base.match_token(COMPOUND,&mut recog.err_handler)?;

					}
				}
			,
				54 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 54);
					recog.base.enter_outer_alt(None, 54);
					{
					recog.base.set_state(4648);
					recog.base.match_token(COMPRESSION,&mut recog.err_handler)?;

					}
				}
			,
				55 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 55);
					recog.base.enter_outer_alt(None, 55);
					{
					recog.base.set_state(4649);
					recog.base.match_token(CONDITIONAL,&mut recog.err_handler)?;

					}
				}
			,
				56 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 56);
					recog.base.enter_outer_alt(None, 56);
					{
					recog.base.set_state(4650);
					recog.base.match_token(CONNECT,&mut recog.err_handler)?;

					}
				}
			,
				57 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 57);
					recog.base.enter_outer_alt(None, 57);
					{
					recog.base.set_state(4651);
					recog.base.match_token(CONNECTION,&mut recog.err_handler)?;

					}
				}
			,
				58 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 58);
					recog.base.enter_outer_alt(None, 58);
					{
					recog.base.set_state(4652);
					recog.base.match_token(CONSTRAINT,&mut recog.err_handler)?;

					}
				}
			,
				59 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 59);
					recog.base.enter_outer_alt(None, 59);
					{
					recog.base.set_state(4653);
					recog.base.match_token(COPARTITION,&mut recog.err_handler)?;

					}
				}
			,
				60 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 60);
					recog.base.enter_outer_alt(None, 60);
					{
					recog.base.set_state(4654);
					recog.base.match_token(COPY,&mut recog.err_handler)?;

					}
				}
			,
				61 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 61);
					recog.base.enter_outer_alt(None, 61);
					{
					recog.base.set_state(4655);
					recog.base.match_token(COUNT,&mut recog.err_handler)?;

					}
				}
			,
				62 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 62);
					recog.base.enter_outer_alt(None, 62);
					{
					recog.base.set_state(4656);
					recog.base.match_token(CREATE,&mut recog.err_handler)?;

					}
				}
			,
				63 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 63);
					recog.base.enter_outer_alt(None, 63);
					{
					recog.base.set_state(4657);
					recog.base.match_token(CROSS,&mut recog.err_handler)?;

					}
				}
			,
				64 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 64);
					recog.base.enter_outer_alt(None, 64);
					{
					recog.base.set_state(4658);
					recog.base.match_token(CUBE,&mut recog.err_handler)?;

					}
				}
			,
				65 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 65);
					recog.base.enter_outer_alt(None, 65);
					{
					recog.base.set_state(4659);
					recog.base.match_token(CURRENT,&mut recog.err_handler)?;

					}
				}
			,
				66 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 66);
					recog.base.enter_outer_alt(None, 66);
					{
					recog.base.set_state(4660);
					recog.base.match_token(DATA,&mut recog.err_handler)?;

					}
				}
			,
				67 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 67);
					recog.base.enter_outer_alt(None, 67);
					{
					recog.base.set_state(4661);
					recog.base.match_token(DATABASE,&mut recog.err_handler)?;

					}
				}
			,
				68 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 68);
					recog.base.enter_outer_alt(None, 68);
					{
					recog.base.set_state(4662);
					recog.base.match_token(DATASHARE,&mut recog.err_handler)?;

					}
				}
			,
				69 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 69);
					recog.base.enter_outer_alt(None, 69);
					{
					recog.base.set_state(4663);
					recog.base.match_token(DAY,&mut recog.err_handler)?;

					}
				}
			,
				70 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 70);
					recog.base.enter_outer_alt(None, 70);
					{
					recog.base.set_state(4664);
					recog.base.match_token(DEALLOCATE,&mut recog.err_handler)?;

					}
				}
			,
				71 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 71);
					recog.base.enter_outer_alt(None, 71);
					{
					recog.base.set_state(4665);
					recog.base.match_token(DECLARE,&mut recog.err_handler)?;

					}
				}
			,
				72 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 72);
					recog.base.enter_outer_alt(None, 72);
					{
					recog.base.set_state(4666);
					recog.base.match_token(DECODE,&mut recog.err_handler)?;

					}
				}
			,
				73 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 73);
					recog.base.enter_outer_alt(None, 73);
					{
					recog.base.set_state(4667);
					recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

					}
				}
			,
				74 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 74);
					recog.base.enter_outer_alt(None, 74);
					{
					recog.base.set_state(4668);
					recog.base.match_token(DEFAULTS,&mut recog.err_handler)?;

					}
				}
			,
				75 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 75);
					recog.base.enter_outer_alt(None, 75);
					{
					recog.base.set_state(4669);
					recog.base.match_token(DEFINE,&mut recog.err_handler)?;

					}
				}
			,
				76 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 76);
					recog.base.enter_outer_alt(None, 76);
					{
					recog.base.set_state(4670);
					recog.base.match_token(DEFINER,&mut recog.err_handler)?;

					}
				}
			,
				77 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 77);
					recog.base.enter_outer_alt(None, 77);
					{
					recog.base.set_state(4671);
					recog.base.match_token(DELETE,&mut recog.err_handler)?;

					}
				}
			,
				78 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 78);
					recog.base.enter_outer_alt(None, 78);
					{
					recog.base.set_state(4672);
					recog.base.match_token(DELIMITED,&mut recog.err_handler)?;

					}
				}
			,
				79 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 79);
					recog.base.enter_outer_alt(None, 79);
					{
					recog.base.set_state(4673);
					recog.base.match_token(DELIMITER,&mut recog.err_handler)?;

					}
				}
			,
				80 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 80);
					recog.base.enter_outer_alt(None, 80);
					{
					recog.base.set_state(4674);
					recog.base.match_token(DENY,&mut recog.err_handler)?;

					}
				}
			,
				81 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 81);
					recog.base.enter_outer_alt(None, 81);
					{
					recog.base.set_state(4675);
					recog.base.match_token(DEFERRABLE,&mut recog.err_handler)?;

					}
				}
			,
				82 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 82);
					recog.base.enter_outer_alt(None, 82);
					{
					recog.base.set_state(4676);
					recog.base.match_token(DEFERRED,&mut recog.err_handler)?;

					}
				}
			,
				83 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 83);
					recog.base.enter_outer_alt(None, 83);
					{
					recog.base.set_state(4677);
					recog.base.match_token(DESC,&mut recog.err_handler)?;

					}
				}
			,
				84 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 84);
					recog.base.enter_outer_alt(None, 84);
					{
					recog.base.set_state(4678);
					recog.base.match_token(DESCRIBE,&mut recog.err_handler)?;

					}
				}
			,
				85 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 85);
					recog.base.enter_outer_alt(None, 85);
					{
					recog.base.set_state(4679);
					recog.base.match_token(DESCRIPTOR,&mut recog.err_handler)?;

					}
				}
			,
				86 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 86);
					recog.base.enter_outer_alt(None, 86);
					{
					recog.base.set_state(4680);
					recog.base.match_token(DIRECTORY,&mut recog.err_handler)?;

					}
				}
			,
				87 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 87);
					recog.base.enter_outer_alt(None, 87);
					{
					recog.base.set_state(4681);
					recog.base.match_token(DISABLE,&mut recog.err_handler)?;

					}
				}
			,
				88 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 88);
					recog.base.enter_outer_alt(None, 88);
					{
					recog.base.set_state(4682);
					recog.base.match_token(DISTINCT,&mut recog.err_handler)?;

					}
				}
			,
				89 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 89);
					recog.base.enter_outer_alt(None, 89);
					{
					recog.base.set_state(4683);
					recog.base.match_token(DISTKEY,&mut recog.err_handler)?;

					}
				}
			,
				90 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 90);
					recog.base.enter_outer_alt(None, 90);
					{
					recog.base.set_state(4684);
					recog.base.match_token(DISTRIBUTED,&mut recog.err_handler)?;

					}
				}
			,
				91 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 91);
					recog.base.enter_outer_alt(None, 91);
					{
					recog.base.set_state(4685);
					recog.base.match_token(DISTSTYLE,&mut recog.err_handler)?;

					}
				}
			,
				92 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 92);
					recog.base.enter_outer_alt(None, 92);
					{
					recog.base.set_state(4686);
					recog.base.match_token(DETACH,&mut recog.err_handler)?;

					}
				}
			,
				93 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 93);
					recog.base.enter_outer_alt(None, 93);
					{
					recog.base.set_state(4687);
					recog.base.match_token(DOWNSTREAM,&mut recog.err_handler)?;

					}
				}
			,
				94 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 94);
					recog.base.enter_outer_alt(None, 94);
					{
					recog.base.set_state(4688);
					recog.base.match_token(DOUBLE,&mut recog.err_handler)?;

					}
				}
			,
				95 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 95);
					recog.base.enter_outer_alt(None, 95);
					{
					recog.base.set_state(4689);
					recog.base.match_token(DROP,&mut recog.err_handler)?;

					}
				}
			,
				96 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 96);
					recog.base.enter_outer_alt(None, 96);
					{
					recog.base.set_state(4690);
					recog.base.match_token(DYNAMIC,&mut recog.err_handler)?;

					}
				}
			,
				97 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 97);
					recog.base.enter_outer_alt(None, 97);
					{
					recog.base.set_state(4691);
					recog.base.match_token(ELSE,&mut recog.err_handler)?;

					}
				}
			,
				98 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 98);
					recog.base.enter_outer_alt(None, 98);
					{
					recog.base.set_state(4692);
					recog.base.match_token(EMPTY,&mut recog.err_handler)?;

					}
				}
			,
				99 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 99);
					recog.base.enter_outer_alt(None, 99);
					{
					recog.base.set_state(4693);
					recog.base.match_token(ENABLE,&mut recog.err_handler)?;

					}
				}
			,
				100 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 100);
					recog.base.enter_outer_alt(None, 100);
					{
					recog.base.set_state(4694);
					recog.base.match_token(ENCODE,&mut recog.err_handler)?;

					}
				}
			,
				101 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 101);
					recog.base.enter_outer_alt(None, 101);
					{
					recog.base.set_state(4695);
					recog.base.match_token(ENCODING,&mut recog.err_handler)?;

					}
				}
			,
				102 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 102);
					recog.base.enter_outer_alt(None, 102);
					{
					recog.base.set_state(4696);
					recog.base.match_token(END,&mut recog.err_handler)?;

					}
				}
			,
				103 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 103);
					recog.base.enter_outer_alt(None, 103);
					{
					recog.base.set_state(4697);
					recog.base.match_token(ENFORCED,&mut recog.err_handler)?;

					}
				}
			,
				104 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 104);
					recog.base.enter_outer_alt(None, 104);
					{
					recog.base.set_state(4698);
					recog.base.match_token(ERROR,&mut recog.err_handler)?;

					}
				}
			,
				105 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 105);
					recog.base.enter_outer_alt(None, 105);
					{
					recog.base.set_state(4699);
					recog.base.match_token(ESCAPE,&mut recog.err_handler)?;

					}
				}
			,
				106 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 106);
					recog.base.enter_outer_alt(None, 106);
					{
					recog.base.set_state(4700);
					recog.base.match_token(EVEN,&mut recog.err_handler)?;

					}
				}
			,
				107 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 107);
					recog.base.enter_outer_alt(None, 107);
					{
					recog.base.set_state(4701);
					recog.base.match_token(EVENT,&mut recog.err_handler)?;

					}
				}
			,
				108 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 108);
					recog.base.enter_outer_alt(None, 108);
					{
					recog.base.set_state(4702);
					recog.base.match_token(EXCEPT,&mut recog.err_handler)?;

					}
				}
			,
				109 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 109);
					recog.base.enter_outer_alt(None, 109);
					{
					recog.base.set_state(4703);
					recog.base.match_token(EXCLUDE,&mut recog.err_handler)?;

					}
				}
			,
				110 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 110);
					recog.base.enter_outer_alt(None, 110);
					{
					recog.base.set_state(4704);
					recog.base.match_token(EXCLUDING,&mut recog.err_handler)?;

					}
				}
			,
				111 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 111);
					recog.base.enter_outer_alt(None, 111);
					{
					recog.base.set_state(4705);
					recog.base.match_token(EXECUTE,&mut recog.err_handler)?;

					}
				}
			,
				112 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 112);
					recog.base.enter_outer_alt(None, 112);
					{
					recog.base.set_state(4706);
					recog.base.match_token(EXISTS,&mut recog.err_handler)?;

					}
				}
			,
				113 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 113);
					recog.base.enter_outer_alt(None, 113);
					{
					recog.base.set_state(4707);
					recog.base.match_token(EXPLAIN,&mut recog.err_handler)?;

					}
				}
			,
				114 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 114);
					recog.base.enter_outer_alt(None, 114);
					{
					recog.base.set_state(4708);
					recog.base.match_token(EXTERNAL,&mut recog.err_handler)?;

					}
				}
			,
				115 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 115);
					recog.base.enter_outer_alt(None, 115);
					{
					recog.base.set_state(4709);
					recog.base.match_token(EXTRACT,&mut recog.err_handler)?;

					}
				}
			,
				116 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 116);
					recog.base.enter_outer_alt(None, 116);
					{
					recog.base.set_state(4710);
					recog.base.match_token(FALSE,&mut recog.err_handler)?;

					}
				}
			,
				117 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 117);
					recog.base.enter_outer_alt(None, 117);
					{
					recog.base.set_state(4711);
					recog.base.match_token(FETCH,&mut recog.err_handler)?;

					}
				}
			,
				118 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 118);
					recog.base.enter_outer_alt(None, 118);
					{
					recog.base.set_state(4712);
					recog.base.match_token(FIELDS,&mut recog.err_handler)?;

					}
				}
			,
				119 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 119);
					recog.base.enter_outer_alt(None, 119);
					{
					recog.base.set_state(4713);
					recog.base.match_token(FILES,&mut recog.err_handler)?;

					}
				}
			,
				120 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 120);
					recog.base.enter_outer_alt(None, 120);
					{
					recog.base.set_state(4714);
					recog.base.match_token(FILTER,&mut recog.err_handler)?;

					}
				}
			,
				121 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 121);
					recog.base.enter_outer_alt(None, 121);
					{
					recog.base.set_state(4715);
					recog.base.match_token(FINAL,&mut recog.err_handler)?;

					}
				}
			,
				122 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 122);
					recog.base.enter_outer_alt(None, 122);
					{
					recog.base.set_state(4716);
					recog.base.match_token(FIRST,&mut recog.err_handler)?;

					}
				}
			,
				123 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 123);
					recog.base.enter_outer_alt(None, 123);
					{
					recog.base.set_state(4717);
					recog.base.match_token(FLOAT,&mut recog.err_handler)?;

					}
				}
			,
				124 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 124);
					recog.base.enter_outer_alt(None, 124);
					{
					recog.base.set_state(4718);
					recog.base.match_token(FOLLOWING,&mut recog.err_handler)?;

					}
				}
			,
				125 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 125);
					recog.base.enter_outer_alt(None, 125);
					{
					recog.base.set_state(4719);
					recog.base.match_token(FOR,&mut recog.err_handler)?;

					}
				}
			,
				126 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 126);
					recog.base.enter_outer_alt(None, 126);
					{
					recog.base.set_state(4720);
					recog.base.match_token(FOREIGN,&mut recog.err_handler)?;

					}
				}
			,
				127 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 127);
					recog.base.enter_outer_alt(None, 127);
					{
					recog.base.set_state(4721);
					recog.base.match_token(FORMAT,&mut recog.err_handler)?;

					}
				}
			,
				128 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 128);
					recog.base.enter_outer_alt(None, 128);
					{
					recog.base.set_state(4722);
					recog.base.match_token(FROM,&mut recog.err_handler)?;

					}
				}
			,
				129 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 129);
					recog.base.enter_outer_alt(None, 129);
					{
					recog.base.set_state(4723);
					recog.base.match_token(FULL,&mut recog.err_handler)?;

					}
				}
			,
				130 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 130);
					recog.base.enter_outer_alt(None, 130);
					{
					recog.base.set_state(4724);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					}
				}
			,
				131 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 131);
					recog.base.enter_outer_alt(None, 131);
					{
					recog.base.set_state(4725);
					recog.base.match_token(FUNCTIONS,&mut recog.err_handler)?;

					}
				}
			,
				132 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 132);
					recog.base.enter_outer_alt(None, 132);
					{
					recog.base.set_state(4726);
					recog.base.match_token(GENERATED,&mut recog.err_handler)?;

					}
				}
			,
				133 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 133);
					recog.base.enter_outer_alt(None, 133);
					{
					recog.base.set_state(4727);
					recog.base.match_token(GLOBAL,&mut recog.err_handler)?;

					}
				}
			,
				134 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 134);
					recog.base.enter_outer_alt(None, 134);
					{
					recog.base.set_state(4728);
					recog.base.match_token(GRACE,&mut recog.err_handler)?;

					}
				}
			,
				135 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 135);
					recog.base.enter_outer_alt(None, 135);
					{
					recog.base.set_state(4729);
					recog.base.match_token(GRANT,&mut recog.err_handler)?;

					}
				}
			,
				136 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 136);
					recog.base.enter_outer_alt(None, 136);
					{
					recog.base.set_state(4730);
					recog.base.match_token(GRANTED,&mut recog.err_handler)?;

					}
				}
			,
				137 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 137);
					recog.base.enter_outer_alt(None, 137);
					{
					recog.base.set_state(4731);
					recog.base.match_token(GRANTS,&mut recog.err_handler)?;

					}
				}
			,
				138 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 138);
					recog.base.enter_outer_alt(None, 138);
					{
					recog.base.set_state(4732);
					recog.base.match_token(GRAPHVIZ,&mut recog.err_handler)?;

					}
				}
			,
				139 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 139);
					recog.base.enter_outer_alt(None, 139);
					{
					recog.base.set_state(4733);
					recog.base.match_token(GROUP,&mut recog.err_handler)?;

					}
				}
			,
				140 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 140);
					recog.base.enter_outer_alt(None, 140);
					{
					recog.base.set_state(4734);
					recog.base.match_token(GROUPING,&mut recog.err_handler)?;

					}
				}
			,
				141 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 141);
					recog.base.enter_outer_alt(None, 141);
					{
					recog.base.set_state(4735);
					recog.base.match_token(GROUPS,&mut recog.err_handler)?;

					}
				}
			,
				142 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 142);
					recog.base.enter_outer_alt(None, 142);
					{
					recog.base.set_state(4736);
					recog.base.match_token(GZIP,&mut recog.err_handler)?;

					}
				}
			,
				143 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 143);
					recog.base.enter_outer_alt(None, 143);
					{
					recog.base.set_state(4737);
					recog.base.match_token(HAVING,&mut recog.err_handler)?;

					}
				}
			,
				144 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 144);
					recog.base.enter_outer_alt(None, 144);
					{
					recog.base.set_state(4738);
					recog.base.match_token(HEADER,&mut recog.err_handler)?;

					}
				}
			,
				145 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 145);
					recog.base.enter_outer_alt(None, 145);
					{
					recog.base.set_state(4739);
					recog.base.match_token(HOUR,&mut recog.err_handler)?;

					}
				}
			,
				146 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 146);
					recog.base.enter_outer_alt(None, 146);
					{
					recog.base.set_state(4740);
					recog.base.match_token(ICEBERG,&mut recog.err_handler)?;

					}
				}
			,
				147 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 147);
					recog.base.enter_outer_alt(None, 147);
					{
					recog.base.set_state(4741);
					recog.base.match_token(IDENTITY,&mut recog.err_handler)?;

					}
				}
			,
				148 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 148);
					recog.base.enter_outer_alt(None, 148);
					{
					recog.base.set_state(4742);
					recog.base.match_token(IF,&mut recog.err_handler)?;

					}
				}
			,
				149 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 149);
					recog.base.enter_outer_alt(None, 149);
					{
					recog.base.set_state(4743);
					recog.base.match_token(IGNORE,&mut recog.err_handler)?;

					}
				}
			,
				150 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 150);
					recog.base.enter_outer_alt(None, 150);
					{
					recog.base.set_state(4744);
					recog.base.match_token(IMMEDIATE,&mut recog.err_handler)?;

					}
				}
			,
				151 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 151);
					recog.base.enter_outer_alt(None, 151);
					{
					recog.base.set_state(4745);
					recog.base.match_token(IMMUTABLE,&mut recog.err_handler)?;

					}
				}
			,
				152 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 152);
					recog.base.enter_outer_alt(None, 152);
					{
					recog.base.set_state(4746);
					recog.base.match_token(IN,&mut recog.err_handler)?;

					}
				}
			,
				153 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 153);
					recog.base.enter_outer_alt(None, 153);
					{
					recog.base.set_state(4747);
					recog.base.match_token(INCLUDE,&mut recog.err_handler)?;

					}
				}
			,
				154 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 154);
					recog.base.enter_outer_alt(None, 154);
					{
					recog.base.set_state(4748);
					recog.base.match_token(INCLUDING,&mut recog.err_handler)?;

					}
				}
			,
				155 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 155);
					recog.base.enter_outer_alt(None, 155);
					{
					recog.base.set_state(4749);
					recog.base.match_token(INCREMENT,&mut recog.err_handler)?;

					}
				}
			,
				156 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 156);
					recog.base.enter_outer_alt(None, 156);
					{
					recog.base.set_state(4750);
					recog.base.match_token(INFORMATION,&mut recog.err_handler)?;

					}
				}
			,
				157 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 157);
					recog.base.enter_outer_alt(None, 157);
					{
					recog.base.set_state(4751);
					recog.base.match_token(INITIAL,&mut recog.err_handler)?;

					}
				}
			,
				158 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 158);
					recog.base.enter_outer_alt(None, 158);
					{
					recog.base.set_state(4752);
					recog.base.match_token(INITIALLY,&mut recog.err_handler)?;

					}
				}
			,
				159 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 159);
					recog.base.enter_outer_alt(None, 159);
					{
					recog.base.set_state(4753);
					recog.base.match_token(INNER,&mut recog.err_handler)?;

					}
				}
			,
				160 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 160);
					recog.base.enter_outer_alt(None, 160);
					{
					recog.base.set_state(4754);
					recog.base.match_token(INPUT,&mut recog.err_handler)?;

					}
				}
			,
				161 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 161);
					recog.base.enter_outer_alt(None, 161);
					{
					recog.base.set_state(4755);
					recog.base.match_token(INPUTFORMAT,&mut recog.err_handler)?;

					}
				}
			,
				162 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 162);
					recog.base.enter_outer_alt(None, 162);
					{
					recog.base.set_state(4756);
					recog.base.match_token(INTERLEAVED,&mut recog.err_handler)?;

					}
				}
			,
				163 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 163);
					recog.base.enter_outer_alt(None, 163);
					{
					recog.base.set_state(4757);
					recog.base.match_token(INSERT,&mut recog.err_handler)?;

					}
				}
			,
				164 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 164);
					recog.base.enter_outer_alt(None, 164);
					{
					recog.base.set_state(4758);
					recog.base.match_token(INTERSECT,&mut recog.err_handler)?;

					}
				}
			,
				165 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 165);
					recog.base.enter_outer_alt(None, 165);
					{
					recog.base.set_state(4759);
					recog.base.match_token(INTERVAL,&mut recog.err_handler)?;

					}
				}
			,
				166 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 166);
					recog.base.enter_outer_alt(None, 166);
					{
					recog.base.set_state(4760);
					recog.base.match_token(INTO,&mut recog.err_handler)?;

					}
				}
			,
				167 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 167);
					recog.base.enter_outer_alt(None, 167);
					{
					recog.base.set_state(4761);
					recog.base.match_token(INVOKER,&mut recog.err_handler)?;

					}
				}
			,
				168 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 168);
					recog.base.enter_outer_alt(None, 168);
					{
					recog.base.set_state(4762);
					recog.base.match_token(IO,&mut recog.err_handler)?;

					}
				}
			,
				169 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 169);
					recog.base.enter_outer_alt(None, 169);
					{
					recog.base.set_state(4763);
					recog.base.match_token(IS,&mut recog.err_handler)?;

					}
				}
			,
				170 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 170);
					recog.base.enter_outer_alt(None, 170);
					{
					recog.base.set_state(4764);
					recog.base.match_token(ISOLATION,&mut recog.err_handler)?;

					}
				}
			,
				171 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 171);
					recog.base.enter_outer_alt(None, 171);
					{
					recog.base.set_state(4765);
					recog.base.match_token(ILIKE,&mut recog.err_handler)?;

					}
				}
			,
				172 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 172);
					recog.base.enter_outer_alt(None, 172);
					{
					recog.base.set_state(4766);
					recog.base.match_token(JAVA,&mut recog.err_handler)?;

					}
				}
			,
				173 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 173);
					recog.base.enter_outer_alt(None, 173);
					{
					recog.base.set_state(4767);
					recog.base.match_token(JAVASCRIPT,&mut recog.err_handler)?;

					}
				}
			,
				174 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 174);
					recog.base.enter_outer_alt(None, 174);
					{
					recog.base.set_state(4768);
					recog.base.match_token(JOIN,&mut recog.err_handler)?;

					}
				}
			,
				175 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 175);
					recog.base.enter_outer_alt(None, 175);
					{
					recog.base.set_state(4769);
					recog.base.match_token(JSON,&mut recog.err_handler)?;

					}
				}
			,
				176 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 176);
					recog.base.enter_outer_alt(None, 176);
					{
					recog.base.set_state(4770);
					recog.base.match_token(KEEP,&mut recog.err_handler)?;

					}
				}
			,
				177 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 177);
					recog.base.enter_outer_alt(None, 177);
					{
					recog.base.set_state(4771);
					recog.base.match_token(KEY,&mut recog.err_handler)?;

					}
				}
			,
				178 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 178);
					recog.base.enter_outer_alt(None, 178);
					{
					recog.base.set_state(4772);
					recog.base.match_token(KEYS,&mut recog.err_handler)?;

					}
				}
			,
				179 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 179);
					recog.base.enter_outer_alt(None, 179);
					{
					recog.base.set_state(4773);
					recog.base.match_token(LAMBDA,&mut recog.err_handler)?;

					}
				}
			,
				180 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 180);
					recog.base.enter_outer_alt(None, 180);
					{
					recog.base.set_state(4774);
					recog.base.match_token(LANGUAGE,&mut recog.err_handler)?;

					}
				}
			,
				181 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 181);
					recog.base.enter_outer_alt(None, 181);
					{
					recog.base.set_state(4775);
					recog.base.match_token(LAST,&mut recog.err_handler)?;

					}
				}
			,
				182 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 182);
					recog.base.enter_outer_alt(None, 182);
					{
					recog.base.set_state(4776);
					recog.base.match_token(LATERAL,&mut recog.err_handler)?;

					}
				}
			,
				183 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 183);
					recog.base.enter_outer_alt(None, 183);
					{
					recog.base.set_state(4777);
					recog.base.match_token(LEADING,&mut recog.err_handler)?;

					}
				}
			,
				184 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 184);
					recog.base.enter_outer_alt(None, 184);
					{
					recog.base.set_state(4778);
					recog.base.match_token(LEFT,&mut recog.err_handler)?;

					}
				}
			,
				185 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 185);
					recog.base.enter_outer_alt(None, 185);
					{
					recog.base.set_state(4779);
					recog.base.match_token(LEVEL,&mut recog.err_handler)?;

					}
				}
			,
				186 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 186);
					recog.base.enter_outer_alt(None, 186);
					{
					recog.base.set_state(4780);
					recog.base.match_token(LIBRARY,&mut recog.err_handler)?;

					}
				}
			,
				187 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 187);
					recog.base.enter_outer_alt(None, 187);
					{
					recog.base.set_state(4781);
					recog.base.match_token(LIKE,&mut recog.err_handler)?;

					}
				}
			,
				188 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 188);
					recog.base.enter_outer_alt(None, 188);
					{
					recog.base.set_state(4782);
					recog.base.match_token(LIMIT,&mut recog.err_handler)?;

					}
				}
			,
				189 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 189);
					recog.base.enter_outer_alt(None, 189);
					{
					recog.base.set_state(4783);
					recog.base.match_token(LINES,&mut recog.err_handler)?;

					}
				}
			,
				190 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 190);
					recog.base.enter_outer_alt(None, 190);
					{
					recog.base.set_state(4784);
					recog.base.match_token(LISTAGG,&mut recog.err_handler)?;

					}
				}
			,
				191 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 191);
					recog.base.enter_outer_alt(None, 191);
					{
					recog.base.set_state(4785);
					recog.base.match_token(LOCAL,&mut recog.err_handler)?;

					}
				}
			,
				192 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 192);
					recog.base.enter_outer_alt(None, 192);
					{
					recog.base.set_state(4786);
					recog.base.match_token(LOCATION,&mut recog.err_handler)?;

					}
				}
			,
				193 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 193);
					recog.base.enter_outer_alt(None, 193);
					{
					recog.base.set_state(4787);
					recog.base.match_token(LOCK,&mut recog.err_handler)?;

					}
				}
			,
				194 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 194);
					recog.base.enter_outer_alt(None, 194);
					{
					recog.base.set_state(4788);
					recog.base.match_token(LOGICAL,&mut recog.err_handler)?;

					}
				}
			,
				195 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 195);
					recog.base.enter_outer_alt(None, 195);
					{
					recog.base.set_state(4789);
					recog.base.match_token(MAP,&mut recog.err_handler)?;

					}
				}
			,
				196 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 196);
					recog.base.enter_outer_alt(None, 196);
					{
					recog.base.set_state(4790);
					recog.base.match_token(MASKING,&mut recog.err_handler)?;

					}
				}
			,
				197 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 197);
					recog.base.enter_outer_alt(None, 197);
					{
					recog.base.set_state(4791);
					recog.base.match_token(MATCH,&mut recog.err_handler)?;

					}
				}
			,
				198 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 198);
					recog.base.enter_outer_alt(None, 198);
					{
					recog.base.set_state(4792);
					recog.base.match_token(MATCHED,&mut recog.err_handler)?;

					}
				}
			,
				199 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 199);
					recog.base.enter_outer_alt(None, 199);
					{
					recog.base.set_state(4793);
					recog.base.match_token(MATCHES,&mut recog.err_handler)?;

					}
				}
			,
				200 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 200);
					recog.base.enter_outer_alt(None, 200);
					{
					recog.base.set_state(4794);
					recog.base.match_token(MATCH_CONDITION,&mut recog.err_handler)?;

					}
				}
			,
				201 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 201);
					recog.base.enter_outer_alt(None, 201);
					{
					recog.base.set_state(4795);
					recog.base.match_token(MATERIALIZED,&mut recog.err_handler)?;

					}
				}
			,
				202 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 202);
					recog.base.enter_outer_alt(None, 202);
					{
					recog.base.set_state(4796);
					recog.base.match_token(MAX,&mut recog.err_handler)?;

					}
				}
			,
				203 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 203);
					recog.base.enter_outer_alt(None, 203);
					{
					recog.base.set_state(4797);
					recog.base.match_token(MEASURES,&mut recog.err_handler)?;

					}
				}
			,
				204 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 204);
					recog.base.enter_outer_alt(None, 204);
					{
					recog.base.set_state(4798);
					recog.base.match_token(MEMORIZABLE,&mut recog.err_handler)?;

					}
				}
			,
				205 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 205);
					recog.base.enter_outer_alt(None, 205);
					{
					recog.base.set_state(4799);
					recog.base.match_token(MERGE,&mut recog.err_handler)?;

					}
				}
			,
				206 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 206);
					recog.base.enter_outer_alt(None, 206);
					{
					recog.base.set_state(4800);
					recog.base.match_token(MINHASH,&mut recog.err_handler)?;

					}
				}
			,
				207 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 207);
					recog.base.enter_outer_alt(None, 207);
					{
					recog.base.set_state(4801);
					recog.base.match_token(MINUS_KW,&mut recog.err_handler)?;

					}
				}
			,
				208 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 208);
					recog.base.enter_outer_alt(None, 208);
					{
					recog.base.set_state(4802);
					recog.base.match_token(MINUTE,&mut recog.err_handler)?;

					}
				}
			,
				209 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 209);
					recog.base.enter_outer_alt(None, 209);
					{
					recog.base.set_state(4803);
					recog.base.match_token(MODEL,&mut recog.err_handler)?;

					}
				}
			,
				210 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 210);
					recog.base.enter_outer_alt(None, 210);
					{
					recog.base.set_state(4804);
					recog.base.match_token(MONTH,&mut recog.err_handler)?;

					}
				}
			,
				211 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 211);
					recog.base.enter_outer_alt(None, 211);
					{
					recog.base.set_state(4805);
					recog.base.match_token(NATURAL,&mut recog.err_handler)?;

					}
				}
			,
				212 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 212);
					recog.base.enter_outer_alt(None, 212);
					{
					recog.base.set_state(4806);
					recog.base.match_token(NCHAR,&mut recog.err_handler)?;

					}
				}
			,
				213 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 213);
					recog.base.enter_outer_alt(None, 213);
					{
					recog.base.set_state(4807);
					recog.base.match_token(NEXT,&mut recog.err_handler)?;

					}
				}
			,
				214 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 214);
					recog.base.enter_outer_alt(None, 214);
					{
					recog.base.set_state(4808);
					recog.base.match_token(NO,&mut recog.err_handler)?;

					}
				}
			,
				215 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 215);
					recog.base.enter_outer_alt(None, 215);
					{
					recog.base.set_state(4809);
					recog.base.match_token(NONE,&mut recog.err_handler)?;

					}
				}
			,
				216 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 216);
					recog.base.enter_outer_alt(None, 216);
					{
					recog.base.set_state(4810);
					recog.base.match_token(NOORDER,&mut recog.err_handler)?;

					}
				}
			,
				217 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 217);
					recog.base.enter_outer_alt(None, 217);
					{
					recog.base.set_state(4811);
					recog.base.match_token(NORELY,&mut recog.err_handler)?;

					}
				}
			,
				218 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 218);
					recog.base.enter_outer_alt(None, 218);
					{
					recog.base.set_state(4812);
					recog.base.match_token(NORMALIZE,&mut recog.err_handler)?;

					}
				}
			,
				219 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 219);
					recog.base.enter_outer_alt(None, 219);
					{
					recog.base.set_state(4813);
					recog.base.match_token(NOT,&mut recog.err_handler)?;

					}
				}
			,
				220 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 220);
					recog.base.enter_outer_alt(None, 220);
					{
					recog.base.set_state(4814);
					recog.base.match_token(NOVALIDATE,&mut recog.err_handler)?;

					}
				}
			,
				221 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 221);
					recog.base.enter_outer_alt(None, 221);
					{
					recog.base.set_state(4815);
					recog.base.match_token(NULL,&mut recog.err_handler)?;

					}
				}
			,
				222 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 222);
					recog.base.enter_outer_alt(None, 222);
					{
					recog.base.set_state(4816);
					recog.base.match_token(NULLS,&mut recog.err_handler)?;

					}
				}
			,
				223 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 223);
					recog.base.enter_outer_alt(None, 223);
					{
					recog.base.set_state(4817);
					recog.base.match_token(OBJECT,&mut recog.err_handler)?;

					}
				}
			,
				224 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 224);
					recog.base.enter_outer_alt(None, 224);
					{
					recog.base.set_state(4818);
					recog.base.match_token(OF,&mut recog.err_handler)?;

					}
				}
			,
				225 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 225);
					recog.base.enter_outer_alt(None, 225);
					{
					recog.base.set_state(4819);
					recog.base.match_token(OFFSET,&mut recog.err_handler)?;

					}
				}
			,
				226 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 226);
					recog.base.enter_outer_alt(None, 226);
					{
					recog.base.set_state(4820);
					recog.base.match_token(OMIT,&mut recog.err_handler)?;

					}
				}
			,
				227 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 227);
					recog.base.enter_outer_alt(None, 227);
					{
					recog.base.set_state(4821);
					recog.base.match_token(ON,&mut recog.err_handler)?;

					}
				}
			,
				228 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 228);
					recog.base.enter_outer_alt(None, 228);
					{
					recog.base.set_state(4822);
					recog.base.match_token(ONE,&mut recog.err_handler)?;

					}
				}
			,
				229 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 229);
					recog.base.enter_outer_alt(None, 229);
					{
					recog.base.set_state(4823);
					recog.base.match_token(ONLY,&mut recog.err_handler)?;

					}
				}
			,
				230 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 230);
					recog.base.enter_outer_alt(None, 230);
					{
					recog.base.set_state(4824);
					recog.base.match_token(OPTION,&mut recog.err_handler)?;

					}
				}
			,
				231 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 231);
					recog.base.enter_outer_alt(None, 231);
					{
					recog.base.set_state(4825);
					recog.base.match_token(OPTIONS,&mut recog.err_handler)?;

					}
				}
			,
				232 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 232);
					recog.base.enter_outer_alt(None, 232);
					{
					recog.base.set_state(4826);
					recog.base.match_token(OR,&mut recog.err_handler)?;

					}
				}
			,
				233 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 233);
					recog.base.enter_outer_alt(None, 233);
					{
					recog.base.set_state(4827);
					recog.base.match_token(ORDER,&mut recog.err_handler)?;

					}
				}
			,
				234 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 234);
					recog.base.enter_outer_alt(None, 234);
					{
					recog.base.set_state(4828);
					recog.base.match_token(ORDINALITY,&mut recog.err_handler)?;

					}
				}
			,
				235 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 235);
					recog.base.enter_outer_alt(None, 235);
					{
					recog.base.set_state(4829);
					recog.base.match_token(OUTER,&mut recog.err_handler)?;

					}
				}
			,
				236 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 236);
					recog.base.enter_outer_alt(None, 236);
					{
					recog.base.set_state(4830);
					recog.base.match_token(OUTPUT,&mut recog.err_handler)?;

					}
				}
			,
				237 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 237);
					recog.base.enter_outer_alt(None, 237);
					{
					recog.base.set_state(4831);
					recog.base.match_token(OUTPUTFORMAT,&mut recog.err_handler)?;

					}
				}
			,
				238 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 238);
					recog.base.enter_outer_alt(None, 238);
					{
					recog.base.set_state(4832);
					recog.base.match_token(OVER,&mut recog.err_handler)?;

					}
				}
			,
				239 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 239);
					recog.base.enter_outer_alt(None, 239);
					{
					recog.base.set_state(4833);
					recog.base.match_token(OVERFLOW,&mut recog.err_handler)?;

					}
				}
			,
				240 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 240);
					recog.base.enter_outer_alt(None, 240);
					{
					recog.base.set_state(4834);
					recog.base.match_token(PARTITION,&mut recog.err_handler)?;

					}
				}
			,
				241 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 241);
					recog.base.enter_outer_alt(None, 241);
					{
					recog.base.set_state(4835);
					recog.base.match_token(PARTITIONED,&mut recog.err_handler)?;

					}
				}
			,
				242 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 242);
					recog.base.enter_outer_alt(None, 242);
					{
					recog.base.set_state(4836);
					recog.base.match_token(PARTITIONS,&mut recog.err_handler)?;

					}
				}
			,
				243 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 243);
					recog.base.enter_outer_alt(None, 243);
					{
					recog.base.set_state(4837);
					recog.base.match_token(PASSING,&mut recog.err_handler)?;

					}
				}
			,
				244 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 244);
					recog.base.enter_outer_alt(None, 244);
					{
					recog.base.set_state(4838);
					recog.base.match_token(PAST,&mut recog.err_handler)?;

					}
				}
			,
				245 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 245);
					recog.base.enter_outer_alt(None, 245);
					{
					recog.base.set_state(4839);
					recog.base.match_token(PATH,&mut recog.err_handler)?;

					}
				}
			,
				246 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 246);
					recog.base.enter_outer_alt(None, 246);
					{
					recog.base.set_state(4840);
					recog.base.match_token(PATTERN,&mut recog.err_handler)?;

					}
				}
			,
				247 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 247);
					recog.base.enter_outer_alt(None, 247);
					{
					recog.base.set_state(4841);
					recog.base.match_token(PER,&mut recog.err_handler)?;

					}
				}
			,
				248 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 248);
					recog.base.enter_outer_alt(None, 248);
					{
					recog.base.set_state(4842);
					recog.base.match_token(PERIOD,&mut recog.err_handler)?;

					}
				}
			,
				249 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 249);
					recog.base.enter_outer_alt(None, 249);
					{
					recog.base.set_state(4843);
					recog.base.match_token(PERMUTE,&mut recog.err_handler)?;

					}
				}
			,
				250 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 250);
					recog.base.enter_outer_alt(None, 250);
					{
					recog.base.set_state(4844);
					recog.base.match_token(PIVOT,&mut recog.err_handler)?;

					}
				}
			,
				251 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 251);
					recog.base.enter_outer_alt(None, 251);
					{
					recog.base.set_state(4845);
					recog.base.match_token(PLACING,&mut recog.err_handler)?;

					}
				}
			,
				252 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 252);
					recog.base.enter_outer_alt(None, 252);
					{
					recog.base.set_state(4846);
					recog.base.match_token(POLICY,&mut recog.err_handler)?;

					}
				}
			,
				253 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 253);
					recog.base.enter_outer_alt(None, 253);
					{
					recog.base.set_state(4847);
					recog.base.match_token(POSITION,&mut recog.err_handler)?;

					}
				}
			,
				254 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 254);
					recog.base.enter_outer_alt(None, 254);
					{
					recog.base.set_state(4848);
					recog.base.match_token(PRECEDING,&mut recog.err_handler)?;

					}
				}
			,
				255 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 255);
					recog.base.enter_outer_alt(None, 255);
					{
					recog.base.set_state(4849);
					recog.base.match_token(PRECISION,&mut recog.err_handler)?;

					}
				}
			,
				256 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 256);
					recog.base.enter_outer_alt(None, 256);
					{
					recog.base.set_state(4850);
					recog.base.match_token(PREPARE,&mut recog.err_handler)?;

					}
				}
			,
				257 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 257);
					recog.base.enter_outer_alt(None, 257);
					{
					recog.base.set_state(4851);
					recog.base.match_token(PRIOR,&mut recog.err_handler)?;

					}
				}
			,
				258 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 258);
					recog.base.enter_outer_alt(None, 258);
					{
					recog.base.set_state(4852);
					recog.base.match_token(PROCEDURE,&mut recog.err_handler)?;

					}
				}
			,
				259 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 259);
					recog.base.enter_outer_alt(None, 259);
					{
					recog.base.set_state(4853);
					recog.base.match_token(PRIMARY,&mut recog.err_handler)?;

					}
				}
			,
				260 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 260);
					recog.base.enter_outer_alt(None, 260);
					{
					recog.base.set_state(4854);
					recog.base.match_token(PRIVILEGES,&mut recog.err_handler)?;

					}
				}
			,
				261 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 261);
					recog.base.enter_outer_alt(None, 261);
					{
					recog.base.set_state(4855);
					recog.base.match_token(PROPERTIES,&mut recog.err_handler)?;

					}
				}
			,
				262 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 262);
					recog.base.enter_outer_alt(None, 262);
					{
					recog.base.set_state(4856);
					recog.base.match_token(PRUNE,&mut recog.err_handler)?;

					}
				}
			,
				263 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 263);
					recog.base.enter_outer_alt(None, 263);
					{
					recog.base.set_state(4857);
					recog.base.match_token(PYTHON,&mut recog.err_handler)?;

					}
				}
			,
				264 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 264);
					recog.base.enter_outer_alt(None, 264);
					{
					recog.base.set_state(4858);
					recog.base.match_token(QUALIFY,&mut recog.err_handler)?;

					}
				}
			,
				265 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 265);
					recog.base.enter_outer_alt(None, 265);
					{
					recog.base.set_state(4859);
					recog.base.match_token(QUOTES,&mut recog.err_handler)?;

					}
				}
			,
				266 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 266);
					recog.base.enter_outer_alt(None, 266);
					{
					recog.base.set_state(4860);
					recog.base.match_token(RANGE,&mut recog.err_handler)?;

					}
				}
			,
				267 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 267);
					recog.base.enter_outer_alt(None, 267);
					{
					recog.base.set_state(4861);
					recog.base.match_token(READ,&mut recog.err_handler)?;

					}
				}
			,
				268 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 268);
					recog.base.enter_outer_alt(None, 268);
					{
					recog.base.set_state(4862);
					recog.base.match_token(RECURSIVE,&mut recog.err_handler)?;

					}
				}
			,
				269 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 269);
					recog.base.enter_outer_alt(None, 269);
					{
					recog.base.set_state(4863);
					recog.base.match_token(REGEXP,&mut recog.err_handler)?;

					}
				}
			,
				270 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 270);
					recog.base.enter_outer_alt(None, 270);
					{
					recog.base.set_state(4864);
					recog.base.match_token(REFERENCE,&mut recog.err_handler)?;

					}
				}
			,
				271 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 271);
					recog.base.enter_outer_alt(None, 271);
					{
					recog.base.set_state(4865);
					recog.base.match_token(REFERENCES,&mut recog.err_handler)?;

					}
				}
			,
				272 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 272);
					recog.base.enter_outer_alt(None, 272);
					{
					recog.base.set_state(4866);
					recog.base.match_token(REFRESH,&mut recog.err_handler)?;

					}
				}
			,
				273 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 273);
					recog.base.enter_outer_alt(None, 273);
					{
					recog.base.set_state(4867);
					recog.base.match_token(RELY,&mut recog.err_handler)?;

					}
				}
			,
				274 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 274);
					recog.base.enter_outer_alt(None, 274);
					{
					recog.base.set_state(4868);
					recog.base.match_token(RENAME,&mut recog.err_handler)?;

					}
				}
			,
				275 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 275);
					recog.base.enter_outer_alt(None, 275);
					{
					recog.base.set_state(4869);
					recog.base.match_token(REPEATABLE,&mut recog.err_handler)?;

					}
				}
			,
				276 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 276);
					recog.base.enter_outer_alt(None, 276);
					{
					recog.base.set_state(4870);
					recog.base.match_token(REPLACE,&mut recog.err_handler)?;

					}
				}
			,
				277 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 277);
					recog.base.enter_outer_alt(None, 277);
					{
					recog.base.set_state(4871);
					recog.base.match_token(RESET,&mut recog.err_handler)?;

					}
				}
			,
				278 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 278);
					recog.base.enter_outer_alt(None, 278);
					{
					recog.base.set_state(4872);
					recog.base.match_token(RESPECT,&mut recog.err_handler)?;

					}
				}
			,
				279 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 279);
					recog.base.enter_outer_alt(None, 279);
					{
					recog.base.set_state(4873);
					recog.base.match_token(RESTRICT,&mut recog.err_handler)?;

					}
				}
			,
				280 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 280);
					recog.base.enter_outer_alt(None, 280);
					{
					recog.base.set_state(4874);
					recog.base.match_token(RETURN,&mut recog.err_handler)?;

					}
				}
			,
				281 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 281);
					recog.base.enter_outer_alt(None, 281);
					{
					recog.base.set_state(4875);
					recog.base.match_token(RETURNING,&mut recog.err_handler)?;

					}
				}
			,
				282 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 282);
					recog.base.enter_outer_alt(None, 282);
					{
					recog.base.set_state(4876);
					recog.base.match_token(RETURNS,&mut recog.err_handler)?;

					}
				}
			,
				283 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 283);
					recog.base.enter_outer_alt(None, 283);
					{
					recog.base.set_state(4877);
					recog.base.match_token(REVOKE,&mut recog.err_handler)?;

					}
				}
			,
				284 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 284);
					recog.base.enter_outer_alt(None, 284);
					{
					recog.base.set_state(4878);
					recog.base.match_token(RIGHT,&mut recog.err_handler)?;

					}
				}
			,
				285 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 285);
					recog.base.enter_outer_alt(None, 285);
					{
					recog.base.set_state(4879);
					recog.base.match_token(RLIKE,&mut recog.err_handler)?;

					}
				}
			,
				286 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 286);
					recog.base.enter_outer_alt(None, 286);
					{
					recog.base.set_state(4880);
					recog.base.match_token(RLS,&mut recog.err_handler)?;

					}
				}
			,
				287 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 287);
					recog.base.enter_outer_alt(None, 287);
					{
					recog.base.set_state(4881);
					recog.base.match_token(ROLE,&mut recog.err_handler)?;

					}
				}
			,
				288 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 288);
					recog.base.enter_outer_alt(None, 288);
					{
					recog.base.set_state(4882);
					recog.base.match_token(ROLES,&mut recog.err_handler)?;

					}
				}
			,
				289 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 289);
					recog.base.enter_outer_alt(None, 289);
					{
					recog.base.set_state(4883);
					recog.base.match_token(ROLLBACK,&mut recog.err_handler)?;

					}
				}
			,
				290 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 290);
					recog.base.enter_outer_alt(None, 290);
					{
					recog.base.set_state(4884);
					recog.base.match_token(ROLLUP,&mut recog.err_handler)?;

					}
				}
			,
				291 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 291);
					recog.base.enter_outer_alt(None, 291);
					{
					recog.base.set_state(4885);
					recog.base.match_token(ROW,&mut recog.err_handler)?;

					}
				}
			,
				292 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 292);
					recog.base.enter_outer_alt(None, 292);
					{
					recog.base.set_state(4886);
					recog.base.match_token(ROWS,&mut recog.err_handler)?;

					}
				}
			,
				293 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 293);
					recog.base.enter_outer_alt(None, 293);
					{
					recog.base.set_state(4887);
					recog.base.match_token(RUNNING,&mut recog.err_handler)?;

					}
				}
			,
				294 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 294);
					recog.base.enter_outer_alt(None, 294);
					{
					recog.base.set_state(4888);
					recog.base.match_token(SAMPLE,&mut recog.err_handler)?;

					}
				}
			,
				295 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 295);
					recog.base.enter_outer_alt(None, 295);
					{
					recog.base.set_state(4889);
					recog.base.match_token(SCALA,&mut recog.err_handler)?;

					}
				}
			,
				296 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 296);
					recog.base.enter_outer_alt(None, 296);
					{
					recog.base.set_state(4890);
					recog.base.match_token(SCALAR,&mut recog.err_handler)?;

					}
				}
			,
				297 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 297);
					recog.base.enter_outer_alt(None, 297);
					{
					recog.base.set_state(4891);
					recog.base.match_token(SECOND,&mut recog.err_handler)?;

					}
				}
			,
				298 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 298);
					recog.base.enter_outer_alt(None, 298);
					{
					recog.base.set_state(4892);
					recog.base.match_token(SCHEMA,&mut recog.err_handler)?;

					}
				}
			,
				299 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 299);
					recog.base.enter_outer_alt(None, 299);
					{
					recog.base.set_state(4893);
					recog.base.match_token(SCHEMAS,&mut recog.err_handler)?;

					}
				}
			,
				300 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 300);
					recog.base.enter_outer_alt(None, 300);
					{
					recog.base.set_state(4894);
					recog.base.match_token(SECURE,&mut recog.err_handler)?;

					}
				}
			,
				301 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 301);
					recog.base.enter_outer_alt(None, 301);
					{
					recog.base.set_state(4895);
					recog.base.match_token(SECURITY,&mut recog.err_handler)?;

					}
				}
			,
				302 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 302);
					recog.base.enter_outer_alt(None, 302);
					{
					recog.base.set_state(4896);
					recog.base.match_token(SEED,&mut recog.err_handler)?;

					}
				}
			,
				303 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 303);
					recog.base.enter_outer_alt(None, 303);
					{
					recog.base.set_state(4897);
					recog.base.match_token(SEEK,&mut recog.err_handler)?;

					}
				}
			,
				304 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 304);
					recog.base.enter_outer_alt(None, 304);
					{
					recog.base.set_state(4898);
					recog.base.match_token(SELECT,&mut recog.err_handler)?;

					}
				}
			,
				305 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 305);
					recog.base.enter_outer_alt(None, 305);
					{
					recog.base.set_state(4899);
					recog.base.match_token(SEMI,&mut recog.err_handler)?;

					}
				}
			,
				306 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 306);
					recog.base.enter_outer_alt(None, 306);
					{
					recog.base.set_state(4900);
					recog.base.match_token(SEQUENCE,&mut recog.err_handler)?;

					}
				}
			,
				307 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 307);
					recog.base.enter_outer_alt(None, 307);
					{
					recog.base.set_state(4901);
					recog.base.match_token(SERDE,&mut recog.err_handler)?;

					}
				}
			,
				308 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 308);
					recog.base.enter_outer_alt(None, 308);
					{
					recog.base.set_state(4902);
					recog.base.match_token(SERDEPROPERTIES,&mut recog.err_handler)?;

					}
				}
			,
				309 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 309);
					recog.base.enter_outer_alt(None, 309);
					{
					recog.base.set_state(4903);
					recog.base.match_token(SERIALIZABLE,&mut recog.err_handler)?;

					}
				}
			,
				310 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 310);
					recog.base.enter_outer_alt(None, 310);
					{
					recog.base.set_state(4904);
					recog.base.match_token(SESSION,&mut recog.err_handler)?;

					}
				}
			,
				311 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 311);
					recog.base.enter_outer_alt(None, 311);
					{
					recog.base.set_state(4905);
					recog.base.match_token(SET,&mut recog.err_handler)?;

					}
				}
			,
				312 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 312);
					recog.base.enter_outer_alt(None, 312);
					{
					recog.base.set_state(4906);
					recog.base.match_token(SETS,&mut recog.err_handler)?;

					}
				}
			,
				313 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 313);
					recog.base.enter_outer_alt(None, 313);
					{
					recog.base.set_state(4907);
					recog.base.match_token(SHOW,&mut recog.err_handler)?;

					}
				}
			,
				314 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 314);
					recog.base.enter_outer_alt(None, 314);
					{
					recog.base.set_state(4908);
					recog.base.match_token(SIMILAR,&mut recog.err_handler)?;

					}
				}
			,
				315 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 315);
					recog.base.enter_outer_alt(None, 315);
					{
					recog.base.set_state(4909);
					recog.base.match_token(SNAPSHOT,&mut recog.err_handler)?;

					}
				}
			,
				316 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 316);
					recog.base.enter_outer_alt(None, 316);
					{
					recog.base.set_state(4910);
					recog.base.match_token(SOME,&mut recog.err_handler)?;

					}
				}
			,
				317 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 317);
					recog.base.enter_outer_alt(None, 317);
					{
					recog.base.set_state(4911);
					recog.base.match_token(SORTKEY,&mut recog.err_handler)?;

					}
				}
			,
				318 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 318);
					recog.base.enter_outer_alt(None, 318);
					{
					recog.base.set_state(4912);
					recog.base.match_token(SQL,&mut recog.err_handler)?;

					}
				}
			,
				319 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 319);
					recog.base.enter_outer_alt(None, 319);
					{
					recog.base.set_state(4913);
					recog.base.match_token(STAGE,&mut recog.err_handler)?;

					}
				}
			,
				320 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 320);
					recog.base.enter_outer_alt(None, 320);
					{
					recog.base.set_state(4914);
					recog.base.match_token(START,&mut recog.err_handler)?;

					}
				}
			,
				321 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 321);
					recog.base.enter_outer_alt(None, 321);
					{
					recog.base.set_state(4915);
					recog.base.match_token(STATEMENT,&mut recog.err_handler)?;

					}
				}
			,
				322 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 322);
					recog.base.enter_outer_alt(None, 322);
					{
					recog.base.set_state(4916);
					recog.base.match_token(STATS,&mut recog.err_handler)?;

					}
				}
			,
				323 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 323);
					recog.base.enter_outer_alt(None, 323);
					{
					recog.base.set_state(4917);
					recog.base.match_token(STORED,&mut recog.err_handler)?;

					}
				}
			,
				324 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 324);
					recog.base.enter_outer_alt(None, 324);
					{
					recog.base.set_state(4918);
					recog.base.match_token(STREAM,&mut recog.err_handler)?;

					}
				}
			,
				325 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 325);
					recog.base.enter_outer_alt(None, 325);
					{
					recog.base.set_state(4919);
					recog.base.match_token(STRICT,&mut recog.err_handler)?;

					}
				}
			,
				326 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 326);
					recog.base.enter_outer_alt(None, 326);
					{
					recog.base.set_state(4920);
					recog.base.match_token(STRUCT,&mut recog.err_handler)?;

					}
				}
			,
				327 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 327);
					recog.base.enter_outer_alt(None, 327);
					{
					recog.base.set_state(4921);
					recog.base.match_token(SUBSET,&mut recog.err_handler)?;

					}
				}
			,
				328 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 328);
					recog.base.enter_outer_alt(None, 328);
					{
					recog.base.set_state(4922);
					recog.base.match_token(SUBSTRING,&mut recog.err_handler)?;

					}
				}
			,
				329 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 329);
					recog.base.enter_outer_alt(None, 329);
					{
					recog.base.set_state(4923);
					recog.base.match_token(SYSTEM,&mut recog.err_handler)?;

					}
				}
			,
				330 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 330);
					recog.base.enter_outer_alt(None, 330);
					{
					recog.base.set_state(4924);
					recog.base.match_token(TABLE,&mut recog.err_handler)?;

					}
				}
			,
				331 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 331);
					recog.base.enter_outer_alt(None, 331);
					{
					recog.base.set_state(4925);
					recog.base.match_token(TABLES,&mut recog.err_handler)?;

					}
				}
			,
				332 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 332);
					recog.base.enter_outer_alt(None, 332);
					{
					recog.base.set_state(4926);
					recog.base.match_token(TABLESAMPLE,&mut recog.err_handler)?;

					}
				}
			,
				333 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 333);
					recog.base.enter_outer_alt(None, 333);
					{
					recog.base.set_state(4927);
					recog.base.match_token(TAG,&mut recog.err_handler)?;

					}
				}
			,
				334 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 334);
					recog.base.enter_outer_alt(None, 334);
					{
					recog.base.set_state(4928);
					recog.base.match_token(TEMP,&mut recog.err_handler)?;

					}
				}
			,
				335 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 335);
					recog.base.enter_outer_alt(None, 335);
					{
					recog.base.set_state(4929);
					recog.base.match_token(TEMPLATE,&mut recog.err_handler)?;

					}
				}
			,
				336 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 336);
					recog.base.enter_outer_alt(None, 336);
					{
					recog.base.set_state(4930);
					recog.base.match_token(TEMPORARY,&mut recog.err_handler)?;

					}
				}
			,
				337 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 337);
					recog.base.enter_outer_alt(None, 337);
					{
					recog.base.set_state(4931);
					recog.base.match_token(TERMINATED,&mut recog.err_handler)?;

					}
				}
			,
				338 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 338);
					recog.base.enter_outer_alt(None, 338);
					{
					recog.base.set_state(4932);
					recog.base.match_token(TEXT,&mut recog.err_handler)?;

					}
				}
			,
				339 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 339);
					recog.base.enter_outer_alt(None, 339);
					{
					recog.base.set_state(4933);
					recog.base.match_token(THEN,&mut recog.err_handler)?;

					}
				}
			,
				340 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 340);
					recog.base.enter_outer_alt(None, 340);
					{
					recog.base.set_state(4934);
					recog.base.match_token(TIES,&mut recog.err_handler)?;

					}
				}
			,
				341 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 341);
					recog.base.enter_outer_alt(None, 341);
					{
					recog.base.set_state(4935);
					recog.base.match_token(TIME,&mut recog.err_handler)?;

					}
				}
			,
				342 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 342);
					recog.base.enter_outer_alt(None, 342);
					{
					recog.base.set_state(4936);
					recog.base.match_token(TIMESTAMP,&mut recog.err_handler)?;

					}
				}
			,
				343 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 343);
					recog.base.enter_outer_alt(None, 343);
					{
					recog.base.set_state(4937);
					recog.base.match_token(TO,&mut recog.err_handler)?;

					}
				}
			,
				344 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 344);
					recog.base.enter_outer_alt(None, 344);
					{
					recog.base.set_state(4938);
					recog.base.match_token(TOP,&mut recog.err_handler)?;

					}
				}
			,
				345 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 345);
					recog.base.enter_outer_alt(None, 345);
					{
					recog.base.set_state(4939);
					recog.base.match_token(TRAILING,&mut recog.err_handler)?;

					}
				}
			,
				346 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 346);
					recog.base.enter_outer_alt(None, 346);
					{
					recog.base.set_state(4940);
					recog.base.match_token(TRANSACTION,&mut recog.err_handler)?;

					}
				}
			,
				347 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 347);
					recog.base.enter_outer_alt(None, 347);
					{
					recog.base.set_state(4941);
					recog.base.match_token(TRANSIENT,&mut recog.err_handler)?;

					}
				}
			,
				348 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 348);
					recog.base.enter_outer_alt(None, 348);
					{
					recog.base.set_state(4942);
					recog.base.match_token(TRIM,&mut recog.err_handler)?;

					}
				}
			,
				349 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 349);
					recog.base.enter_outer_alt(None, 349);
					{
					recog.base.set_state(4943);
					recog.base.match_token(TRUE,&mut recog.err_handler)?;

					}
				}
			,
				350 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 350);
					recog.base.enter_outer_alt(None, 350);
					{
					recog.base.set_state(4944);
					recog.base.match_token(TRUNCATE,&mut recog.err_handler)?;

					}
				}
			,
				351 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 351);
					recog.base.enter_outer_alt(None, 351);
					{
					recog.base.set_state(4945);
					recog.base.match_token(TUPLE,&mut recog.err_handler)?;

					}
				}
			,
				352 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 352);
					recog.base.enter_outer_alt(None, 352);
					{
					recog.base.set_state(4946);
					recog.base.match_token(TYPE,&mut recog.err_handler)?;

					}
				}
			,
				353 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 353);
					recog.base.enter_outer_alt(None, 353);
					{
					recog.base.set_state(4947);
					recog.base.match_token(UESCAPE,&mut recog.err_handler)?;

					}
				}
			,
				354 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 354);
					recog.base.enter_outer_alt(None, 354);
					{
					recog.base.set_state(4948);
					recog.base.match_token(UNBOUNDED,&mut recog.err_handler)?;

					}
				}
			,
				355 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 355);
					recog.base.enter_outer_alt(None, 355);
					{
					recog.base.set_state(4949);
					recog.base.match_token(UNCOMMITTED,&mut recog.err_handler)?;

					}
				}
			,
				356 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 356);
					recog.base.enter_outer_alt(None, 356);
					{
					recog.base.set_state(4950);
					recog.base.match_token(UNCONDITIONAL,&mut recog.err_handler)?;

					}
				}
			,
				357 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 357);
					recog.base.enter_outer_alt(None, 357);
					{
					recog.base.set_state(4951);
					recog.base.match_token(UNION,&mut recog.err_handler)?;

					}
				}
			,
				358 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 358);
					recog.base.enter_outer_alt(None, 358);
					{
					recog.base.set_state(4952);
					recog.base.match_token(UNIQUE,&mut recog.err_handler)?;

					}
				}
			,
				359 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 359);
					recog.base.enter_outer_alt(None, 359);
					{
					recog.base.set_state(4953);
					recog.base.match_token(UNKNOWN,&mut recog.err_handler)?;

					}
				}
			,
				360 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 360);
					recog.base.enter_outer_alt(None, 360);
					{
					recog.base.set_state(4954);
					recog.base.match_token(UNLOAD,&mut recog.err_handler)?;

					}
				}
			,
				361 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 361);
					recog.base.enter_outer_alt(None, 361);
					{
					recog.base.set_state(4955);
					recog.base.match_token(UNMATCHED,&mut recog.err_handler)?;

					}
				}
			,
				362 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 362);
					recog.base.enter_outer_alt(None, 362);
					{
					recog.base.set_state(4956);
					recog.base.match_token(UNNEST,&mut recog.err_handler)?;

					}
				}
			,
				363 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 363);
					recog.base.enter_outer_alt(None, 363);
					{
					recog.base.set_state(4957);
					recog.base.match_token(UNPIVOT,&mut recog.err_handler)?;

					}
				}
			,
				364 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 364);
					recog.base.enter_outer_alt(None, 364);
					{
					recog.base.set_state(4958);
					recog.base.match_token(UNSET,&mut recog.err_handler)?;

					}
				}
			,
				365 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 365);
					recog.base.enter_outer_alt(None, 365);
					{
					recog.base.set_state(4959);
					recog.base.match_token(UNSIGNED,&mut recog.err_handler)?;

					}
				}
			,
				366 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 366);
					recog.base.enter_outer_alt(None, 366);
					{
					recog.base.set_state(4960);
					recog.base.match_token(UPDATE,&mut recog.err_handler)?;

					}
				}
			,
				367 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 367);
					recog.base.enter_outer_alt(None, 367);
					{
					recog.base.set_state(4961);
					recog.base.match_token(USE,&mut recog.err_handler)?;

					}
				}
			,
				368 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 368);
					recog.base.enter_outer_alt(None, 368);
					{
					recog.base.set_state(4962);
					recog.base.match_token(USER,&mut recog.err_handler)?;

					}
				}
			,
				369 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 369);
					recog.base.enter_outer_alt(None, 369);
					{
					recog.base.set_state(4963);
					recog.base.match_token(USING,&mut recog.err_handler)?;

					}
				}
			,
				370 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 370);
					recog.base.enter_outer_alt(None, 370);
					{
					recog.base.set_state(4964);
					recog.base.match_token(VACUUM,&mut recog.err_handler)?;

					}
				}
			,
				371 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 371);
					recog.base.enter_outer_alt(None, 371);
					{
					recog.base.set_state(4965);
					recog.base.match_token(VALIDATE,&mut recog.err_handler)?;

					}
				}
			,
				372 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 372);
					recog.base.enter_outer_alt(None, 372);
					{
					recog.base.set_state(4966);
					recog.base.match_token(VALUE,&mut recog.err_handler)?;

					}
				}
			,
				373 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 373);
					recog.base.enter_outer_alt(None, 373);
					{
					recog.base.set_state(4967);
					recog.base.match_token(VALUES,&mut recog.err_handler)?;

					}
				}
			,
				374 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 374);
					recog.base.enter_outer_alt(None, 374);
					{
					recog.base.set_state(4968);
					recog.base.match_token(VARYING,&mut recog.err_handler)?;

					}
				}
			,
				375 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 375);
					recog.base.enter_outer_alt(None, 375);
					{
					recog.base.set_state(4969);
					recog.base.match_token(VECTOR,&mut recog.err_handler)?;

					}
				}
			,
				376 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 376);
					recog.base.enter_outer_alt(None, 376);
					{
					recog.base.set_state(4970);
					recog.base.match_token(VERBOSE,&mut recog.err_handler)?;

					}
				}
			,
				377 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 377);
					recog.base.enter_outer_alt(None, 377);
					{
					recog.base.set_state(4971);
					recog.base.match_token(VERSION,&mut recog.err_handler)?;

					}
				}
			,
				378 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 378);
					recog.base.enter_outer_alt(None, 378);
					{
					recog.base.set_state(4972);
					recog.base.match_token(VIEW,&mut recog.err_handler)?;

					}
				}
			,
				379 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 379);
					recog.base.enter_outer_alt(None, 379);
					{
					recog.base.set_state(4973);
					recog.base.match_token(VOLATILE,&mut recog.err_handler)?;

					}
				}
			,
				380 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 380);
					recog.base.enter_outer_alt(None, 380);
					{
					recog.base.set_state(4974);
					recog.base.match_token(WAREHOUSE,&mut recog.err_handler)?;

					}
				}
			,
				381 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 381);
					recog.base.enter_outer_alt(None, 381);
					{
					recog.base.set_state(4975);
					recog.base.match_token(WHEN,&mut recog.err_handler)?;

					}
				}
			,
				382 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 382);
					recog.base.enter_outer_alt(None, 382);
					{
					recog.base.set_state(4976);
					recog.base.match_token(WHERE,&mut recog.err_handler)?;

					}
				}
			,
				383 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 383);
					recog.base.enter_outer_alt(None, 383);
					{
					recog.base.set_state(4977);
					recog.base.match_token(WINDOW,&mut recog.err_handler)?;

					}
				}
			,
				384 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 384);
					recog.base.enter_outer_alt(None, 384);
					{
					recog.base.set_state(4978);
					recog.base.match_token(WITH,&mut recog.err_handler)?;

					}
				}
			,
				385 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 385);
					recog.base.enter_outer_alt(None, 385);
					{
					recog.base.set_state(4979);
					recog.base.match_token(WITHIN,&mut recog.err_handler)?;

					}
				}
			,
				386 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 386);
					recog.base.enter_outer_alt(None, 386);
					{
					recog.base.set_state(4980);
					recog.base.match_token(WITHOUT,&mut recog.err_handler)?;

					}
				}
			,
				387 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 387);
					recog.base.enter_outer_alt(None, 387);
					{
					recog.base.set_state(4981);
					recog.base.match_token(WORK,&mut recog.err_handler)?;

					}
				}
			,
				388 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 388);
					recog.base.enter_outer_alt(None, 388);
					{
					recog.base.set_state(4982);
					recog.base.match_token(WRAPPER,&mut recog.err_handler)?;

					}
				}
			,
				389 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 389);
					recog.base.enter_outer_alt(None, 389);
					{
					recog.base.set_state(4983);
					recog.base.match_token(WRITE,&mut recog.err_handler)?;

					}
				}
			,
				390 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 390);
					recog.base.enter_outer_alt(None, 390);
					{
					recog.base.set_state(4984);
					recog.base.match_token(XZ,&mut recog.err_handler)?;

					}
				}
			,
				391 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 391);
					recog.base.enter_outer_alt(None, 391);
					{
					recog.base.set_state(4985);
					recog.base.match_token(YEAR,&mut recog.err_handler)?;

					}
				}
			,
				392 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 392);
					recog.base.enter_outer_alt(None, 392);
					{
					recog.base.set_state(4986);
					recog.base.match_token(YES,&mut recog.err_handler)?;

					}
				}
			,
				393 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 393);
					recog.base.enter_outer_alt(None, 393);
					{
					recog.base.set_state(4987);
					recog.base.match_token(ZONE,&mut recog.err_handler)?;

					}
				}
			,
				394 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 394);
					recog.base.enter_outer_alt(None, 394);
					{
					recog.base.set_state(4988);
					recog.base.match_token(ZSTD,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- functionName ----------------
pub type FunctionNameContextAll<'input> = FunctionNameContext<'input>;


pub type FunctionNameContext<'input> = BaseParserRuleContext<'input,FunctionNameContextExt<'input>>;

#[derive(Clone)]
pub struct FunctionNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for FunctionNameContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FunctionNameContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_functionName(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_functionName(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FunctionNameContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_functionName(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_functionName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_functionName }
}
antlr_rust::tid!{FunctionNameContextExt<'a>}

impl<'input> FunctionNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FunctionNameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FunctionNameContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FunctionNameContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<FunctionNameContextExt<'input>>{

fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LEFT
/// Returns `None` if there is no child corresponding to token LEFT
fn LEFT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LEFT, 0)
}
/// Retrieves first TerminalNode corresponding to token RIGHT
/// Returns `None` if there is no child corresponding to token RIGHT
fn RIGHT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RIGHT, 0)
}
/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token REPLACE
/// Returns `None` if there is no child corresponding to token REPLACE
fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REPLACE, 0)
}
/// Retrieves first TerminalNode corresponding to token ILIKE
/// Returns `None` if there is no child corresponding to token ILIKE
fn ILIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ILIKE, 0)
}
/// Retrieves first TerminalNode corresponding to token INSERT
/// Returns `None` if there is no child corresponding to token INSERT
fn INSERT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INSERT, 0)
}
/// Retrieves first TerminalNode corresponding to token LIKE
/// Returns `None` if there is no child corresponding to token LIKE
fn LIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LIKE, 0)
}
/// Retrieves first TerminalNode corresponding to token LISTAGG
/// Returns `None` if there is no child corresponding to token LISTAGG
fn LISTAGG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LISTAGG, 0)
}
/// Retrieves first TerminalNode corresponding to token NORMALIZE
/// Returns `None` if there is no child corresponding to token NORMALIZE
fn NORMALIZE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NORMALIZE, 0)
}
/// Retrieves first TerminalNode corresponding to token TRIM
/// Returns `None` if there is no child corresponding to token TRIM
fn TRIM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRIM, 0)
}
/// Retrieves first TerminalNode corresponding to token COLLATE
/// Returns `None` if there is no child corresponding to token COLLATE
fn COLLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COLLATE, 0)
}
/// Retrieves first TerminalNode corresponding to token PERCENTILE_CONT
/// Returns `None` if there is no child corresponding to token PERCENTILE_CONT
fn PERCENTILE_CONT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PERCENTILE_CONT, 0)
}
/// Retrieves first TerminalNode corresponding to token PERCENTILE_DISC
/// Returns `None` if there is no child corresponding to token PERCENTILE_DISC
fn PERCENTILE_DISC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PERCENTILE_DISC, 0)
}
/// Retrieves first TerminalNode corresponding to token REGEXP
/// Returns `None` if there is no child corresponding to token REGEXP
fn REGEXP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REGEXP, 0)
}
/// Retrieves first TerminalNode corresponding to token RLIKE
/// Returns `None` if there is no child corresponding to token RLIKE
fn RLIKE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RLIKE, 0)
}
/// Retrieves first TerminalNode corresponding to token GROUPING
/// Returns `None` if there is no child corresponding to token GROUPING
fn GROUPING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GROUPING, 0)
}

}

impl<'input> FunctionNameContextAttrs<'input> for FunctionNameContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn functionName(&mut self,)
	-> Result<Rc<FunctionNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FunctionNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 276, RULE_functionName);
        let mut _localctx: Rc<FunctionNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5008);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(691,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule qualifiedName*/
					recog.base.set_state(4991);
					recog.qualifiedName()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(4992);
					recog.base.match_token(LEFT,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(4993);
					recog.base.match_token(RIGHT,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(4994);
					recog.base.match_token(IF,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(4995);
					recog.base.match_token(REPLACE,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(4996);
					recog.base.match_token(ILIKE,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 7);
					recog.base.enter_outer_alt(None, 7);
					{
					recog.base.set_state(4997);
					recog.base.match_token(INSERT,&mut recog.err_handler)?;

					}
				}
			,
				8 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 8);
					recog.base.enter_outer_alt(None, 8);
					{
					recog.base.set_state(4998);
					recog.base.match_token(LIKE,&mut recog.err_handler)?;

					}
				}
			,
				9 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 9);
					recog.base.enter_outer_alt(None, 9);
					{
					recog.base.set_state(4999);
					recog.base.match_token(LISTAGG,&mut recog.err_handler)?;

					}
				}
			,
				10 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 10);
					recog.base.enter_outer_alt(None, 10);
					{
					recog.base.set_state(5000);
					recog.base.match_token(NORMALIZE,&mut recog.err_handler)?;

					}
				}
			,
				11 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 11);
					recog.base.enter_outer_alt(None, 11);
					{
					recog.base.set_state(5001);
					recog.base.match_token(TRIM,&mut recog.err_handler)?;

					}
				}
			,
				12 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 12);
					recog.base.enter_outer_alt(None, 12);
					{
					recog.base.set_state(5002);
					recog.base.match_token(COLLATE,&mut recog.err_handler)?;

					}
				}
			,
				13 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 13);
					recog.base.enter_outer_alt(None, 13);
					{
					recog.base.set_state(5003);
					recog.base.match_token(PERCENTILE_CONT,&mut recog.err_handler)?;

					}
				}
			,
				14 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 14);
					recog.base.enter_outer_alt(None, 14);
					{
					recog.base.set_state(5004);
					recog.base.match_token(PERCENTILE_DISC,&mut recog.err_handler)?;

					}
				}
			,
				15 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 15);
					recog.base.enter_outer_alt(None, 15);
					{
					recog.base.set_state(5005);
					recog.base.match_token(REGEXP,&mut recog.err_handler)?;

					}
				}
			,
				16 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 16);
					recog.base.enter_outer_alt(None, 16);
					{
					recog.base.set_state(5006);
					recog.base.match_token(RLIKE,&mut recog.err_handler)?;

					}
				}
			,
				17 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 17);
					recog.base.enter_outer_alt(None, 17);
					{
					recog.base.set_state(5007);
					recog.base.match_token(GROUPING,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- namedParameter ----------------
pub type NamedParameterContextAll<'input> = NamedParameterContext<'input>;


pub type NamedParameterContext<'input> = BaseParserRuleContext<'input,NamedParameterContextExt<'input>>;

#[derive(Clone)]
pub struct NamedParameterContextExt<'input>{
	pub name: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NamedParameterContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NamedParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_namedParameter(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_namedParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NamedParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_namedParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for NamedParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_namedParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_namedParameter }
}
antlr_rust::tid!{NamedParameterContextExt<'a>}

impl<'input> NamedParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NamedParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NamedParameterContextExt{
				name: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait NamedParameterContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NamedParameterContextExt<'input>>{

fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NamedParameterContextAttrs<'input> for NamedParameterContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn namedParameter(&mut self,)
	-> Result<Rc<NamedParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NamedParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 278, RULE_namedParameter);
        let mut _localctx: Rc<NamedParameterContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(5010);
			let tmp = recog.identifier()?;
			 cast_mut::<_,NamedParameterContext >(&mut _localctx).name = Some(tmp.clone());
			  

			/*InvokeRule type_*/
			recog.base.set_state(5011);
			recog.type_()?;

			recog.base.set_state(5014);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==DEFAULT {
				{
				recog.base.set_state(5012);
				recog.base.match_token(DEFAULT,&mut recog.err_handler)?;

				/*InvokeRule expression*/
				recog.base.set_state(5013);
				recog.expression()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- stageFileSpec ----------------
pub type StageFileSpecContextAll<'input> = StageFileSpecContext<'input>;


pub type StageFileSpecContext<'input> = BaseParserRuleContext<'input,StageFileSpecContextExt<'input>>;

#[derive(Clone)]
pub struct StageFileSpecContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for StageFileSpecContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StageFileSpecContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_stageFileSpec(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_stageFileSpec(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StageFileSpecContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_stageFileSpec(self);
	}
}

impl<'input> CustomRuleContext<'input> for StageFileSpecContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_stageFileSpec }
	//fn type_rule_index() -> usize where Self: Sized { RULE_stageFileSpec }
}
antlr_rust::tid!{StageFileSpecContextExt<'a>}

impl<'input> StageFileSpecContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StageFileSpecContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StageFileSpecContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StageFileSpecContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<StageFileSpecContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FILE_FORMAT
/// Returns `None` if there is no child corresponding to token FILE_FORMAT
fn FILE_FORMAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FILE_FORMAT, 0)
}
fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PATTERN
/// Returns `None` if there is no child corresponding to token PATTERN
fn PATTERN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PATTERN, 0)
}

}

impl<'input> StageFileSpecContextAttrs<'input> for StageFileSpecContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn stageFileSpec(&mut self,)
	-> Result<Rc<StageFileSpecContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StageFileSpecContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 280, RULE_stageFileSpec);
        let mut _localctx: Rc<StageFileSpecContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5025);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 FILE_FORMAT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(5016);
					recog.base.match_token(FILE_FORMAT,&mut recog.err_handler)?;

					recog.base.set_state(5017);
					recog.base.match_token(T__0,&mut recog.err_handler)?;

					recog.base.set_state(5020);
					recog.err_handler.sync(&mut recog.base)?;
					match recog.base.input.la(1) {
					 STRING | UNICODE_STRING | DOLLAR_QUOTED_STRING 
						=> {
							{
							/*InvokeRule string*/
							recog.base.set_state(5018);
							recog.string()?;

							}
						}

					 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
					 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
					 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
					 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
					 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
					 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
					 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
					 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
					 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE |
					 DEFAULT | DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY |
					 DEFERRABLE | DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY |
					 DISABLE | DISTKEY | DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM |
					 DOUBLE | DYNAMIC | EMPTY | ENABLE | ENCODE | ENCODING | END | ENFORCED |
					 ERROR | ESCAPE | EVEN | EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE |
					 EXPLAIN | EXTERNAL | EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT |
					 FILES | FILTER | FINAL | FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT |
					 FORMAT_NAME | FULL | FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE |
					 GRANTED | GRANTS | GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR |
					 ICEBERG | IDENTIFIER_KW | IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE |
					 INCLUDE | INCLUDING | INFORMATION | INITIAL | INITIALLY | INNER | INPUT |
					 INPUTFORMAT | INTERLEAVED | INTERVAL | INVOKER | IO | ISOLATION | JAVA |
					 JAVASCRIPT | JOIN | JSON | JSON_ARRAY | JSON_EXISTS | JSON_OBJECT |
					 JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS | LAG | LAMBDA | LANGUAGE |
					 LAST | LAST_VALUE | LATERAL | LEADING | LEFT | LEVEL | LIBRARY | LIMIT |
					 LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
					 MATCH | MATCHED | MATCHES | MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED |
					 MAX | MEASURES | MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL |
					 MONTH | NAME | NATURAL | NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO |
					 NONE | NOORDER | NORELY | NORMALIZE | NOVALIDATE | NULLS | OBJECT |
					 OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS | ORDINALITY | OUTER |
					 OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER | PARTITION | PARTITIONED |
					 PARTITIONS | PASSING | PAST | PATH | PATTERN | PER | PERCENTILE_CONT |
					 PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT | PLACING | POLICY | POSITION |
					 PRECEDING | PRECISION | PREPARE | PRIOR | PROCEDURE | PRIMARY | PRIVILEGES |
					 PROPERTIES | PRUNE | PYTHON | QUOTES | RANGE | READ | RECURSIVE | REFERENCE |
					 REFERENCES | REFRESH | RELY | RENAME | REPEATABLE | REPLACE | RESET |
					 RESPECT | RESTRICT | RESTRICTED | RETURN | RETURNING | RETURNS | RIGHT |
					 RLS | ROLE | ROLES | ROLLBACK | ROLLUP | RUNNING | SCALA | SCALAR |
					 SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY | SEED | SEEK | SEMI |
					 SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE | SESSION | SETS |
					 SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL | STAGE | STATEMENT |
					 STATS | STORED | STREAM | STRICT | STRUCT | SUBSET | SUBSTRING | SYSTEM |
					 SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY | TERMINATED |
					 TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING | TARGET_LAG |
					 TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST | TUPLE |
					 TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
					 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
					 USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING |
					 VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW |
					 WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE |
					 ZSTD | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
						=> {
							{
							/*InvokeRule qualifiedName*/
							recog.base.set_state(5019);
							recog.qualifiedName()?;

							}
						}

						_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
					}
					}
				}

			 PATTERN 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(5022);
					recog.base.match_token(PATTERN,&mut recog.err_handler)?;

					recog.base.set_state(5023);
					recog.base.match_token(T__0,&mut recog.err_handler)?;

					/*InvokeRule string*/
					recog.base.set_state(5024);
					recog.string()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- field ----------------
pub type FieldContextAll<'input> = FieldContext<'input>;


pub type FieldContext<'input> = BaseParserRuleContext<'input,FieldContextExt<'input>>;

#[derive(Clone)]
pub struct FieldContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for FieldContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FieldContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_field(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_field(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FieldContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_field(self);
	}
}

impl<'input> CustomRuleContext<'input> for FieldContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_field }
	//fn type_rule_index() -> usize where Self: Sized { RULE_field }
}
antlr_rust::tid!{FieldContextExt<'a>}

impl<'input> FieldContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FieldContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FieldContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FieldContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<FieldContextExt<'input>>{

fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> FieldContextAttrs<'input> for FieldContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn field(&mut self,)
	-> Result<Rc<FieldContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 282, RULE_field);
        let mut _localctx: Rc<FieldContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule expression*/
			recog.base.set_state(5027);
			recog.expression()?;

			recog.base.set_state(5030);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AS {
				{
				recog.base.set_state(5028);
				recog.base.match_token(AS,&mut recog.err_handler)?;

				/*InvokeRule identifier*/
				recog.base.set_state(5029);
				recog.identifier()?;

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- processingMode ----------------
pub type ProcessingModeContextAll<'input> = ProcessingModeContext<'input>;


pub type ProcessingModeContext<'input> = BaseParserRuleContext<'input,ProcessingModeContextExt<'input>>;

#[derive(Clone)]
pub struct ProcessingModeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ProcessingModeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ProcessingModeContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_processingMode(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_processingMode(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ProcessingModeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_processingMode(self);
	}
}

impl<'input> CustomRuleContext<'input> for ProcessingModeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_processingMode }
	//fn type_rule_index() -> usize where Self: Sized { RULE_processingMode }
}
antlr_rust::tid!{ProcessingModeContextExt<'a>}

impl<'input> ProcessingModeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ProcessingModeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ProcessingModeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ProcessingModeContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ProcessingModeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token RUNNING
/// Returns `None` if there is no child corresponding to token RUNNING
fn RUNNING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RUNNING, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}

}

impl<'input> ProcessingModeContextAttrs<'input> for ProcessingModeContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn processingMode(&mut self,)
	-> Result<Rc<ProcessingModeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ProcessingModeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 284, RULE_processingMode);
        let mut _localctx: Rc<ProcessingModeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5032);
			_la = recog.base.input.la(1);
			if { !(_la==FINAL || _la==RUNNING) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nullTreatment ----------------
pub type NullTreatmentContextAll<'input> = NullTreatmentContext<'input>;


pub type NullTreatmentContext<'input> = BaseParserRuleContext<'input,NullTreatmentContextExt<'input>>;

#[derive(Clone)]
pub struct NullTreatmentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NullTreatmentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NullTreatmentContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nullTreatment(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_nullTreatment(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NullTreatmentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_nullTreatment(self);
	}
}

impl<'input> CustomRuleContext<'input> for NullTreatmentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nullTreatment }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nullTreatment }
}
antlr_rust::tid!{NullTreatmentContextExt<'a>}

impl<'input> NullTreatmentContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NullTreatmentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NullTreatmentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NullTreatmentContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NullTreatmentContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IGNORE
/// Returns `None` if there is no child corresponding to token IGNORE
fn IGNORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IGNORE, 0)
}
/// Retrieves first TerminalNode corresponding to token NULLS
/// Returns `None` if there is no child corresponding to token NULLS
fn NULLS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULLS, 0)
}
/// Retrieves first TerminalNode corresponding to token RESPECT
/// Returns `None` if there is no child corresponding to token RESPECT
fn RESPECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RESPECT, 0)
}

}

impl<'input> NullTreatmentContextAttrs<'input> for NullTreatmentContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nullTreatment(&mut self,)
	-> Result<Rc<NullTreatmentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NullTreatmentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 286, RULE_nullTreatment);
        let mut _localctx: Rc<NullTreatmentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5038);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 IGNORE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(5034);
					recog.base.match_token(IGNORE,&mut recog.err_handler)?;

					recog.base.set_state(5035);
					recog.base.match_token(NULLS,&mut recog.err_handler)?;

					}
				}

			 RESPECT 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(5036);
					recog.base.match_token(RESPECT,&mut recog.err_handler)?;

					recog.base.set_state(5037);
					recog.base.match_token(NULLS,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- string ----------------
#[derive(Debug)]
pub enum StringContextAll<'input>{
	UnicodeStringLiteralContext(UnicodeStringLiteralContext<'input>),
	DollarQuotedStringLiteralContext(DollarQuotedStringLiteralContext<'input>),
	BasicStringLiteralContext(BasicStringLiteralContext<'input>),
Error(StringContext<'input>)
}
antlr_rust::tid!{StringContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for StringContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for StringContextAll<'input>{}

impl<'input> Deref for StringContextAll<'input>{
	type Target = dyn StringContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use StringContextAll::*;
		match self{
			UnicodeStringLiteralContext(inner) => inner,
			DollarQuotedStringLiteralContext(inner) => inner,
			BasicStringLiteralContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StringContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StringContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type StringContext<'input> = BaseParserRuleContext<'input,StringContextExt<'input>>;

#[derive(Clone)]
pub struct StringContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for StringContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StringContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StringContext<'input>{
}

impl<'input> CustomRuleContext<'input> for StringContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_string }
	//fn type_rule_index() -> usize where Self: Sized { RULE_string }
}
antlr_rust::tid!{StringContextExt<'a>}

impl<'input> StringContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StringContextAll<'input>> {
		Rc::new(
		StringContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StringContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait StringContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<StringContextExt<'input>>{


}

impl<'input> StringContextAttrs<'input> for StringContext<'input>{}

pub type UnicodeStringLiteralContext<'input> = BaseParserRuleContext<'input,UnicodeStringLiteralContextExt<'input>>;

pub trait UnicodeStringLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token UNICODE_STRING
	/// Returns `None` if there is no child corresponding to token UNICODE_STRING
	fn UNICODE_STRING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(UNICODE_STRING, 0)
	}
	/// Retrieves first TerminalNode corresponding to token UESCAPE
	/// Returns `None` if there is no child corresponding to token UESCAPE
	fn UESCAPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(UESCAPE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token STRING
	/// Returns `None` if there is no child corresponding to token STRING
	fn STRING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRING, 0)
	}
}

impl<'input> UnicodeStringLiteralContextAttrs<'input> for UnicodeStringLiteralContext<'input>{}

pub struct UnicodeStringLiteralContextExt<'input>{
	base:StringContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UnicodeStringLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UnicodeStringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UnicodeStringLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unicodeStringLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_unicodeStringLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UnicodeStringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_unicodeStringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnicodeStringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_string }
	//fn type_rule_index() -> usize where Self: Sized { RULE_string }
}

impl<'input> Borrow<StringContextExt<'input>> for UnicodeStringLiteralContext<'input>{
	fn borrow(&self) -> &StringContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StringContextExt<'input>> for UnicodeStringLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut StringContextExt<'input> { &mut self.base }
}

impl<'input> StringContextAttrs<'input> for UnicodeStringLiteralContext<'input> {}

impl<'input> UnicodeStringLiteralContextExt<'input>{
	fn new(ctx: &dyn StringContextAttrs<'input>) -> Rc<StringContextAll<'input>>  {
		Rc::new(
			StringContextAll::UnicodeStringLiteralContext(
				BaseParserRuleContext::copy_from(ctx,UnicodeStringLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DollarQuotedStringLiteralContext<'input> = BaseParserRuleContext<'input,DollarQuotedStringLiteralContextExt<'input>>;

pub trait DollarQuotedStringLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DOLLAR_QUOTED_STRING
	/// Returns `None` if there is no child corresponding to token DOLLAR_QUOTED_STRING
	fn DOLLAR_QUOTED_STRING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOLLAR_QUOTED_STRING, 0)
	}
}

impl<'input> DollarQuotedStringLiteralContextAttrs<'input> for DollarQuotedStringLiteralContext<'input>{}

pub struct DollarQuotedStringLiteralContextExt<'input>{
	base:StringContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DollarQuotedStringLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DollarQuotedStringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DollarQuotedStringLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dollarQuotedStringLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_dollarQuotedStringLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DollarQuotedStringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dollarQuotedStringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for DollarQuotedStringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_string }
	//fn type_rule_index() -> usize where Self: Sized { RULE_string }
}

impl<'input> Borrow<StringContextExt<'input>> for DollarQuotedStringLiteralContext<'input>{
	fn borrow(&self) -> &StringContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StringContextExt<'input>> for DollarQuotedStringLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut StringContextExt<'input> { &mut self.base }
}

impl<'input> StringContextAttrs<'input> for DollarQuotedStringLiteralContext<'input> {}

impl<'input> DollarQuotedStringLiteralContextExt<'input>{
	fn new(ctx: &dyn StringContextAttrs<'input>) -> Rc<StringContextAll<'input>>  {
		Rc::new(
			StringContextAll::DollarQuotedStringLiteralContext(
				BaseParserRuleContext::copy_from(ctx,DollarQuotedStringLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type BasicStringLiteralContext<'input> = BaseParserRuleContext<'input,BasicStringLiteralContextExt<'input>>;

pub trait BasicStringLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token STRING
	/// Returns `None` if there is no child corresponding to token STRING
	fn STRING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRING, 0)
	}
}

impl<'input> BasicStringLiteralContextAttrs<'input> for BasicStringLiteralContext<'input>{}

pub struct BasicStringLiteralContextExt<'input>{
	base:StringContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{BasicStringLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for BasicStringLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for BasicStringLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_basicStringLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_basicStringLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for BasicStringLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_basicStringLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for BasicStringLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_string }
	//fn type_rule_index() -> usize where Self: Sized { RULE_string }
}

impl<'input> Borrow<StringContextExt<'input>> for BasicStringLiteralContext<'input>{
	fn borrow(&self) -> &StringContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StringContextExt<'input>> for BasicStringLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut StringContextExt<'input> { &mut self.base }
}

impl<'input> StringContextAttrs<'input> for BasicStringLiteralContext<'input> {}

impl<'input> BasicStringLiteralContextExt<'input>{
	fn new(ctx: &dyn StringContextAttrs<'input>) -> Rc<StringContextAll<'input>>  {
		Rc::new(
			StringContextAll::BasicStringLiteralContext(
				BaseParserRuleContext::copy_from(ctx,BasicStringLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn string(&mut self,)
	-> Result<Rc<StringContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StringContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 288, RULE_string);
        let mut _localctx: Rc<StringContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5047);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 STRING 
				=> {
					let tmp = BasicStringLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(5040);
					recog.base.match_token(STRING,&mut recog.err_handler)?;

					}
				}

			 UNICODE_STRING 
				=> {
					let tmp = UnicodeStringLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5041);
					recog.base.match_token(UNICODE_STRING,&mut recog.err_handler)?;

					recog.base.set_state(5044);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(697,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5042);
							recog.base.match_token(UESCAPE,&mut recog.err_handler)?;

							recog.base.set_state(5043);
							recog.base.match_token(STRING,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}

			 DOLLAR_QUOTED_STRING 
				=> {
					let tmp = DollarQuotedStringLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(5046);
					recog.base.match_token(DOLLAR_QUOTED_STRING,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- timeZoneSpecifier ----------------
pub type TimeZoneSpecifierContextAll<'input> = TimeZoneSpecifierContext<'input>;


pub type TimeZoneSpecifierContext<'input> = BaseParserRuleContext<'input,TimeZoneSpecifierContextExt<'input>>;

#[derive(Clone)]
pub struct TimeZoneSpecifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TimeZoneSpecifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TimeZoneSpecifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_timeZoneSpecifier(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_timeZoneSpecifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TimeZoneSpecifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_timeZoneSpecifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TimeZoneSpecifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_timeZoneSpecifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_timeZoneSpecifier }
}
antlr_rust::tid!{TimeZoneSpecifierContextExt<'a>}

impl<'input> TimeZoneSpecifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TimeZoneSpecifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TimeZoneSpecifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TimeZoneSpecifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TimeZoneSpecifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TIME
/// Returns `None` if there is no child corresponding to token TIME
fn TIME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIME, 0)
}
/// Retrieves first TerminalNode corresponding to token ZONE
/// Returns `None` if there is no child corresponding to token ZONE
fn ZONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ZONE, 0)
}
fn interval(&self) -> Option<Rc<IntervalContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TimeZoneSpecifierContextAttrs<'input> for TimeZoneSpecifierContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn timeZoneSpecifier(&mut self,)
	-> Result<Rc<TimeZoneSpecifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TimeZoneSpecifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 290, RULE_timeZoneSpecifier);
        let mut _localctx: Rc<TimeZoneSpecifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5055);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(699,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(5049);
					recog.base.match_token(TIME,&mut recog.err_handler)?;

					recog.base.set_state(5050);
					recog.base.match_token(ZONE,&mut recog.err_handler)?;

					/*InvokeRule interval*/
					recog.base.set_state(5051);
					recog.interval()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(5052);
					recog.base.match_token(TIME,&mut recog.err_handler)?;

					recog.base.set_state(5053);
					recog.base.match_token(ZONE,&mut recog.err_handler)?;

					/*InvokeRule string*/
					recog.base.set_state(5054);
					recog.string()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- comparisonOperator ----------------
pub type ComparisonOperatorContextAll<'input> = ComparisonOperatorContext<'input>;


pub type ComparisonOperatorContext<'input> = BaseParserRuleContext<'input,ComparisonOperatorContextExt<'input>>;

#[derive(Clone)]
pub struct ComparisonOperatorContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ComparisonOperatorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ComparisonOperatorContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_comparisonOperator(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_comparisonOperator(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ComparisonOperatorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_comparisonOperator(self);
	}
}

impl<'input> CustomRuleContext<'input> for ComparisonOperatorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_comparisonOperator }
	//fn type_rule_index() -> usize where Self: Sized { RULE_comparisonOperator }
}
antlr_rust::tid!{ComparisonOperatorContextExt<'a>}

impl<'input> ComparisonOperatorContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ComparisonOperatorContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ComparisonOperatorContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ComparisonOperatorContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ComparisonOperatorContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token EQ
/// Returns `None` if there is no child corresponding to token EQ
fn EQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EQ, 0)
}
/// Retrieves first TerminalNode corresponding to token NEQ
/// Returns `None` if there is no child corresponding to token NEQ
fn NEQ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NEQ, 0)
}
/// Retrieves first TerminalNode corresponding to token LT
/// Returns `None` if there is no child corresponding to token LT
fn LT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LT, 0)
}
/// Retrieves first TerminalNode corresponding to token LTE
/// Returns `None` if there is no child corresponding to token LTE
fn LTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LTE, 0)
}
/// Retrieves first TerminalNode corresponding to token GT
/// Returns `None` if there is no child corresponding to token GT
fn GT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GT, 0)
}
/// Retrieves first TerminalNode corresponding to token GTE
/// Returns `None` if there is no child corresponding to token GTE
fn GTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GTE, 0)
}

}

impl<'input> ComparisonOperatorContextAttrs<'input> for ComparisonOperatorContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn comparisonOperator(&mut self,)
	-> Result<Rc<ComparisonOperatorContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ComparisonOperatorContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 292, RULE_comparisonOperator);
        let mut _localctx: Rc<ComparisonOperatorContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5057);
			_la = recog.base.input.la(1);
			if { !(((((_la - 447)) & !0x3f) == 0 && ((1usize << (_la - 447)) & ((1usize << (EQ - 447)) | (1usize << (NEQ - 447)) | (1usize << (LT - 447)) | (1usize << (LTE - 447)) | (1usize << (GT - 447)) | (1usize << (GTE - 447)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- comparisonQuantifier ----------------
pub type ComparisonQuantifierContextAll<'input> = ComparisonQuantifierContext<'input>;


pub type ComparisonQuantifierContext<'input> = BaseParserRuleContext<'input,ComparisonQuantifierContextExt<'input>>;

#[derive(Clone)]
pub struct ComparisonQuantifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for ComparisonQuantifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ComparisonQuantifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_comparisonQuantifier(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_comparisonQuantifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ComparisonQuantifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_comparisonQuantifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ComparisonQuantifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_comparisonQuantifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_comparisonQuantifier }
}
antlr_rust::tid!{ComparisonQuantifierContextExt<'a>}

impl<'input> ComparisonQuantifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<ComparisonQuantifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,ComparisonQuantifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait ComparisonQuantifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<ComparisonQuantifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ALL
/// Returns `None` if there is no child corresponding to token ALL
fn ALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ALL, 0)
}
/// Retrieves first TerminalNode corresponding to token SOME
/// Returns `None` if there is no child corresponding to token SOME
fn SOME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SOME, 0)
}
/// Retrieves first TerminalNode corresponding to token ANY
/// Returns `None` if there is no child corresponding to token ANY
fn ANY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ANY, 0)
}

}

impl<'input> ComparisonQuantifierContextAttrs<'input> for ComparisonQuantifierContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn comparisonQuantifier(&mut self,)
	-> Result<Rc<ComparisonQuantifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = ComparisonQuantifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 294, RULE_comparisonQuantifier);
        let mut _localctx: Rc<ComparisonQuantifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5059);
			_la = recog.base.input.la(1);
			if { !(_la==ALL || _la==ANY || _la==SOME) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- booleanValue ----------------
pub type BooleanValueContextAll<'input> = BooleanValueContext<'input>;


pub type BooleanValueContext<'input> = BaseParserRuleContext<'input,BooleanValueContextExt<'input>>;

#[derive(Clone)]
pub struct BooleanValueContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for BooleanValueContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for BooleanValueContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_booleanValue(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_booleanValue(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for BooleanValueContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_booleanValue(self);
	}
}

impl<'input> CustomRuleContext<'input> for BooleanValueContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_booleanValue }
	//fn type_rule_index() -> usize where Self: Sized { RULE_booleanValue }
}
antlr_rust::tid!{BooleanValueContextExt<'a>}

impl<'input> BooleanValueContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<BooleanValueContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,BooleanValueContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait BooleanValueContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<BooleanValueContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TRUE
/// Returns `None` if there is no child corresponding to token TRUE
fn TRUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRUE, 0)
}
/// Retrieves first TerminalNode corresponding to token FALSE
/// Returns `None` if there is no child corresponding to token FALSE
fn FALSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FALSE, 0)
}

}

impl<'input> BooleanValueContextAttrs<'input> for BooleanValueContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn booleanValue(&mut self,)
	-> Result<Rc<BooleanValueContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = BooleanValueContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 296, RULE_booleanValue);
        let mut _localctx: Rc<BooleanValueContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5061);
			_la = recog.base.input.la(1);
			if { !(_la==FALSE || _la==TRUE) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- interval ----------------
pub type IntervalContextAll<'input> = IntervalContext<'input>;


pub type IntervalContext<'input> = BaseParserRuleContext<'input,IntervalContextExt<'input>>;

#[derive(Clone)]
pub struct IntervalContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for IntervalContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IntervalContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_interval(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_interval(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IntervalContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_interval(self);
	}
}

impl<'input> CustomRuleContext<'input> for IntervalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_interval }
	//fn type_rule_index() -> usize where Self: Sized { RULE_interval }
}
antlr_rust::tid!{IntervalContextExt<'a>}

impl<'input> IntervalContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntervalContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntervalContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntervalContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<IntervalContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INTERVAL
/// Returns `None` if there is no child corresponding to token INTERVAL
fn INTERVAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTERVAL, 0)
}
fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn intervalField(&self) -> Option<Rc<IntervalFieldContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> IntervalContextAttrs<'input> for IntervalContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn interval(&mut self,)
	-> Result<Rc<IntervalContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntervalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 298, RULE_interval);
        let mut _localctx: Rc<IntervalContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5063);
			recog.base.match_token(INTERVAL,&mut recog.err_handler)?;

			/*InvokeRule string*/
			recog.base.set_state(5064);
			recog.string()?;

			recog.base.set_state(5066);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(700,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule intervalField*/
					recog.base.set_state(5065);
					recog.intervalField()?;

					}
				}

				_ => {}
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- intervalField ----------------
pub type IntervalFieldContextAll<'input> = IntervalFieldContext<'input>;


pub type IntervalFieldContext<'input> = BaseParserRuleContext<'input,IntervalFieldContextExt<'input>>;

#[derive(Clone)]
pub struct IntervalFieldContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for IntervalFieldContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IntervalFieldContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_intervalField(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_intervalField(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IntervalFieldContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_intervalField(self);
	}
}

impl<'input> CustomRuleContext<'input> for IntervalFieldContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_intervalField }
	//fn type_rule_index() -> usize where Self: Sized { RULE_intervalField }
}
antlr_rust::tid!{IntervalFieldContextExt<'a>}

impl<'input> IntervalFieldContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IntervalFieldContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IntervalFieldContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IntervalFieldContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<IntervalFieldContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token YEAR
/// Returns `None` if there is no child corresponding to token YEAR
fn YEAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(YEAR, 0)
}
/// Retrieves first TerminalNode corresponding to token MONTH
/// Returns `None` if there is no child corresponding to token MONTH
fn MONTH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MONTH, 0)
}
/// Retrieves first TerminalNode corresponding to token DAY
/// Returns `None` if there is no child corresponding to token DAY
fn DAY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DAY, 0)
}
/// Retrieves first TerminalNode corresponding to token HOUR
/// Returns `None` if there is no child corresponding to token HOUR
fn HOUR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(HOUR, 0)
}
/// Retrieves first TerminalNode corresponding to token MINUTE
/// Returns `None` if there is no child corresponding to token MINUTE
fn MINUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MINUTE, 0)
}
/// Retrieves first TerminalNode corresponding to token SECOND
/// Returns `None` if there is no child corresponding to token SECOND
fn SECOND(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SECOND, 0)
}

}

impl<'input> IntervalFieldContextAttrs<'input> for IntervalFieldContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn intervalField(&mut self,)
	-> Result<Rc<IntervalFieldContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IntervalFieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 300, RULE_intervalField);
        let mut _localctx: Rc<IntervalFieldContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5068);
			_la = recog.base.input.la(1);
			if { !(_la==DAY || _la==HOUR || _la==MINUTE || _la==MONTH || _la==SECOND || _la==YEAR) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- normalForm ----------------
pub type NormalFormContextAll<'input> = NormalFormContext<'input>;


pub type NormalFormContext<'input> = BaseParserRuleContext<'input,NormalFormContextExt<'input>>;

#[derive(Clone)]
pub struct NormalFormContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NormalFormContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NormalFormContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_normalForm(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_normalForm(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NormalFormContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_normalForm(self);
	}
}

impl<'input> CustomRuleContext<'input> for NormalFormContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_normalForm }
	//fn type_rule_index() -> usize where Self: Sized { RULE_normalForm }
}
antlr_rust::tid!{NormalFormContextExt<'a>}

impl<'input> NormalFormContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NormalFormContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NormalFormContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NormalFormContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NormalFormContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token NFD
/// Returns `None` if there is no child corresponding to token NFD
fn NFD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NFD, 0)
}
/// Retrieves first TerminalNode corresponding to token NFC
/// Returns `None` if there is no child corresponding to token NFC
fn NFC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NFC, 0)
}
/// Retrieves first TerminalNode corresponding to token NFKD
/// Returns `None` if there is no child corresponding to token NFKD
fn NFKD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NFKD, 0)
}
/// Retrieves first TerminalNode corresponding to token NFKC
/// Returns `None` if there is no child corresponding to token NFKC
fn NFKC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NFKC, 0)
}

}

impl<'input> NormalFormContextAttrs<'input> for NormalFormContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn normalForm(&mut self,)
	-> Result<Rc<NormalFormContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NormalFormContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 302, RULE_normalForm);
        let mut _localctx: Rc<NormalFormContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5070);
			_la = recog.base.input.la(1);
			if { !(((((_la - 245)) & !0x3f) == 0 && ((1usize << (_la - 245)) & ((1usize << (NFC - 245)) | (1usize << (NFD - 245)) | (1usize << (NFKC - 245)) | (1usize << (NFKD - 245)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeIdentifier ----------------
pub type TypeIdentifierContextAll<'input> = TypeIdentifierContext<'input>;


pub type TypeIdentifierContext<'input> = BaseParserRuleContext<'input,TypeIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct TypeIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TypeIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TypeIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeIdentifier(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_typeIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TypeIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_typeIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeIdentifier }
}
antlr_rust::tid!{TypeIdentifierContextExt<'a>}

impl<'input> TypeIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeIdentifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TypeIdentifierContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeIdentifierContextAttrs<'input> for TypeIdentifierContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeIdentifier(&mut self,)
	-> Result<Rc<TypeIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 304, RULE_typeIdentifier);
        let mut _localctx: Rc<TypeIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(5072);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- type_ ----------------
#[derive(Debug)]
pub enum Type_ContextAll<'input>{
	TypeNotNullContext(TypeNotNullContext<'input>),
	TypeNullContext(TypeNullContext<'input>),
Error(Type_Context<'input>)
}
antlr_rust::tid!{Type_ContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for Type_ContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for Type_ContextAll<'input>{}

impl<'input> Deref for Type_ContextAll<'input>{
	type Target = dyn Type_ContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use Type_ContextAll::*;
		match self{
			TypeNotNullContext(inner) => inner,
			TypeNullContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for Type_ContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for Type_ContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type Type_Context<'input> = BaseParserRuleContext<'input,Type_ContextExt<'input>>;

#[derive(Clone)]
pub struct Type_ContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for Type_Context<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for Type_Context<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for Type_Context<'input>{
}

impl<'input> CustomRuleContext<'input> for Type_ContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_type_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}
antlr_rust::tid!{Type_ContextExt<'a>}

impl<'input> Type_ContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<Type_ContextAll<'input>> {
		Rc::new(
		Type_ContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,Type_ContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait Type_ContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<Type_ContextExt<'input>>{


}

impl<'input> Type_ContextAttrs<'input> for Type_Context<'input>{}

pub type TypeNotNullContext<'input> = BaseParserRuleContext<'input,TypeNotNullContextExt<'input>>;

pub trait TypeNotNullContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn nonnullableType(&self) -> Option<Rc<NonnullableTypeContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token NOT
	/// Returns `None` if there is no child corresponding to token NOT
	fn NOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NOT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NULL
	/// Returns `None` if there is no child corresponding to token NULL
	fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, 0)
	}
}

impl<'input> TypeNotNullContextAttrs<'input> for TypeNotNullContext<'input>{}

pub struct TypeNotNullContextExt<'input>{
	base:Type_ContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TypeNotNullContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TypeNotNullContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TypeNotNullContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeNotNull(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_typeNotNull(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TypeNotNullContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_typeNotNull(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeNotNullContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_type_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for TypeNotNullContext<'input>{
	fn borrow(&self) -> &Type_ContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for TypeNotNullContext<'input>{
	fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> { &mut self.base }
}

impl<'input> Type_ContextAttrs<'input> for TypeNotNullContext<'input> {}

impl<'input> TypeNotNullContextExt<'input>{
	fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>>  {
		Rc::new(
			Type_ContextAll::TypeNotNullContext(
				BaseParserRuleContext::copy_from(ctx,TypeNotNullContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type TypeNullContext<'input> = BaseParserRuleContext<'input,TypeNullContextExt<'input>>;

pub trait TypeNullContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token NULL
	/// Returns `None` if there is no child corresponding to token NULL
	fn NULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NULL, 0)
	}
}

impl<'input> TypeNullContextAttrs<'input> for TypeNullContext<'input>{}

pub struct TypeNullContextExt<'input>{
	base:Type_ContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TypeNullContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TypeNullContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TypeNullContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_typeNull(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_typeNull(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TypeNullContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_typeNull(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeNullContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_type_ }
	//fn type_rule_index() -> usize where Self: Sized { RULE_type_ }
}

impl<'input> Borrow<Type_ContextExt<'input>> for TypeNullContext<'input>{
	fn borrow(&self) -> &Type_ContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<Type_ContextExt<'input>> for TypeNullContext<'input>{
	fn borrow_mut(&mut self) -> &mut Type_ContextExt<'input> { &mut self.base }
}

impl<'input> Type_ContextAttrs<'input> for TypeNullContext<'input> {}

impl<'input> TypeNullContextExt<'input>{
	fn new(ctx: &dyn Type_ContextAttrs<'input>) -> Rc<Type_ContextAll<'input>>  {
		Rc::new(
			Type_ContextAll::TypeNullContext(
				BaseParserRuleContext::copy_from(ctx,TypeNullContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn type_(&mut self,)
	-> Result<Rc<Type_ContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = Type_ContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 306, RULE_type_);
        let mut _localctx: Rc<Type_ContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5080);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
			 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
			 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
			 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
			 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
			 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
			 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
			 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
			 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
			 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
			 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
			 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC | EMPTY |
			 ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE | EVEN |
			 EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
			 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
			 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FULL |
			 FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS |
			 GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
			 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
			 INFORMATION | INITIAL | INITIALLY | INNER | INPUT | INPUTFORMAT | INTERLEAVED |
			 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JOIN | JSON |
			 JSON_ARRAY | JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP |
			 KEY | KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LATERAL |
			 LEADING | LEFT | LEVEL | LIBRARY | LIMIT | LINES | LISTAGG | LOCAL |
			 LOCATION | LOCK | LOGICAL | MAP | MASKING | MATCH | MATCHED | MATCHES |
			 MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES | MEMORIZABLE |
			 MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME | NATURAL | NCHAR |
			 NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER | NORELY | NORMALIZE |
			 NOVALIDATE | NULLS | OBJECT | OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS |
			 ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER |
			 PARTITION | PARTITIONED | PARTITIONS | PASSING | PAST | PATH | PATTERN |
			 PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT |
			 PLACING | POLICY | POSITION | PRECEDING | PRECISION | PREPARE | PRIOR |
			 PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON | QUOTES |
			 RANGE | READ | RECURSIVE | REFERENCE | REFERENCES | REFRESH | RELY |
			 RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT | RESTRICTED |
			 RETURN | RETURNING | RETURNS | RIGHT | RLS | ROLE | ROLES | ROLLBACK |
			 ROLLUP | RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS | SECURE |
			 SECURITY | SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES |
			 SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT |
			 SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED | STREAM | STRICT |
			 STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG | TEMP |
			 TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW | TIES | TIME |
			 TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION | TRANSIENT | TRIM |
			 TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED |
			 UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET |
			 UNSIGNED | USE | USER | USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE |
			 VALUE | VARYING | VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE |
			 WHEN | WINDOW | WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR |
			 YES | ZONE | ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
				=> {
					let tmp = TypeNotNullContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule nonnullableType*/
					recog.base.set_state(5074);
					recog.nonnullableType()?;

					recog.base.set_state(5077);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(701,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5075);
							recog.base.match_token(NOT,&mut recog.err_handler)?;

							recog.base.set_state(5076);
							recog.base.match_token(NULL,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}

			 NULL 
				=> {
					let tmp = TypeNullContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5079);
					recog.base.match_token(NULL,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nonnullableType ----------------
#[derive(Debug)]
pub enum NonnullableTypeContextAll<'input>{
	LambdaTypeContext(LambdaTypeContext<'input>),
	FunctionSignatureGenericTypeContext(FunctionSignatureGenericTypeContext<'input>),
	DoublePrecisionTypeContext(DoublePrecisionTypeContext<'input>),
	StructuredObjectTypeContext(StructuredObjectTypeContext<'input>),
	LegacyStructTypeContext(LegacyStructTypeContext<'input>),
	PrimitiveTypeContext(PrimitiveTypeContext<'input>),
	CharacterVaryingContext(CharacterVaryingContext<'input>),
	DateTimeTypeContext(DateTimeTypeContext<'input>),
	LegacyMapTypeContext(LegacyMapTypeContext<'input>),
Error(NonnullableTypeContext<'input>)
}
antlr_rust::tid!{NonnullableTypeContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for NonnullableTypeContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for NonnullableTypeContextAll<'input>{}

impl<'input> Deref for NonnullableTypeContextAll<'input>{
	type Target = dyn NonnullableTypeContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use NonnullableTypeContextAll::*;
		match self{
			LambdaTypeContext(inner) => inner,
			FunctionSignatureGenericTypeContext(inner) => inner,
			DoublePrecisionTypeContext(inner) => inner,
			StructuredObjectTypeContext(inner) => inner,
			LegacyStructTypeContext(inner) => inner,
			PrimitiveTypeContext(inner) => inner,
			CharacterVaryingContext(inner) => inner,
			DateTimeTypeContext(inner) => inner,
			LegacyMapTypeContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NonnullableTypeContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NonnullableTypeContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type NonnullableTypeContext<'input> = BaseParserRuleContext<'input,NonnullableTypeContextExt<'input>>;

#[derive(Clone)]
pub struct NonnullableTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NonnullableTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NonnullableTypeContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NonnullableTypeContext<'input>{
}

impl<'input> CustomRuleContext<'input> for NonnullableTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}
antlr_rust::tid!{NonnullableTypeContextExt<'a>}

impl<'input> NonnullableTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NonnullableTypeContextAll<'input>> {
		Rc::new(
		NonnullableTypeContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NonnullableTypeContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait NonnullableTypeContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NonnullableTypeContextExt<'input>>{


}

impl<'input> NonnullableTypeContextAttrs<'input> for NonnullableTypeContext<'input>{}

pub type LambdaTypeContext<'input> = BaseParserRuleContext<'input,LambdaTypeContextExt<'input>>;

pub trait LambdaTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token FUNCTION
	/// Returns `None` if there is no child corresponding to token FUNCTION
	fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FUNCTION, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> LambdaTypeContextAttrs<'input> for LambdaTypeContext<'input>{}

pub struct LambdaTypeContextExt<'input>{
	base:NonnullableTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{LambdaTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for LambdaTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LambdaTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_lambdaType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_lambdaType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LambdaTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_lambdaType(self);
	}
}

impl<'input> CustomRuleContext<'input> for LambdaTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}

impl<'input> Borrow<NonnullableTypeContextExt<'input>> for LambdaTypeContext<'input>{
	fn borrow(&self) -> &NonnullableTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NonnullableTypeContextExt<'input>> for LambdaTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut NonnullableTypeContextExt<'input> { &mut self.base }
}

impl<'input> NonnullableTypeContextAttrs<'input> for LambdaTypeContext<'input> {}

impl<'input> LambdaTypeContextExt<'input>{
	fn new(ctx: &dyn NonnullableTypeContextAttrs<'input>) -> Rc<NonnullableTypeContextAll<'input>>  {
		Rc::new(
			NonnullableTypeContextAll::LambdaTypeContext(
				BaseParserRuleContext::copy_from(ctx,LambdaTypeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type FunctionSignatureGenericTypeContext<'input> = BaseParserRuleContext<'input,FunctionSignatureGenericTypeContextExt<'input>>;

pub trait FunctionSignatureGenericTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DOLLAR
	/// Returns `None` if there is no child corresponding to token DOLLAR
	fn DOLLAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOLLAR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
	/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
	fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INTEGER_VALUE, 0)
	}
}

impl<'input> FunctionSignatureGenericTypeContextAttrs<'input> for FunctionSignatureGenericTypeContext<'input>{}

pub struct FunctionSignatureGenericTypeContextExt<'input>{
	base:NonnullableTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{FunctionSignatureGenericTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for FunctionSignatureGenericTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FunctionSignatureGenericTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_functionSignatureGenericType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_functionSignatureGenericType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FunctionSignatureGenericTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_functionSignatureGenericType(self);
	}
}

impl<'input> CustomRuleContext<'input> for FunctionSignatureGenericTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}

impl<'input> Borrow<NonnullableTypeContextExt<'input>> for FunctionSignatureGenericTypeContext<'input>{
	fn borrow(&self) -> &NonnullableTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NonnullableTypeContextExt<'input>> for FunctionSignatureGenericTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut NonnullableTypeContextExt<'input> { &mut self.base }
}

impl<'input> NonnullableTypeContextAttrs<'input> for FunctionSignatureGenericTypeContext<'input> {}

impl<'input> FunctionSignatureGenericTypeContextExt<'input>{
	fn new(ctx: &dyn NonnullableTypeContextAttrs<'input>) -> Rc<NonnullableTypeContextAll<'input>>  {
		Rc::new(
			NonnullableTypeContextAll::FunctionSignatureGenericTypeContext(
				BaseParserRuleContext::copy_from(ctx,FunctionSignatureGenericTypeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DoublePrecisionTypeContext<'input> = BaseParserRuleContext<'input,DoublePrecisionTypeContextExt<'input>>;

pub trait DoublePrecisionTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DOUBLE
	/// Returns `None` if there is no child corresponding to token DOUBLE
	fn DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOUBLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PRECISION
	/// Returns `None` if there is no child corresponding to token PRECISION
	fn PRECISION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PRECISION, 0)
	}
}

impl<'input> DoublePrecisionTypeContextAttrs<'input> for DoublePrecisionTypeContext<'input>{}

pub struct DoublePrecisionTypeContextExt<'input>{
	base:NonnullableTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DoublePrecisionTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DoublePrecisionTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DoublePrecisionTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_doublePrecisionType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_doublePrecisionType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DoublePrecisionTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_doublePrecisionType(self);
	}
}

impl<'input> CustomRuleContext<'input> for DoublePrecisionTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}

impl<'input> Borrow<NonnullableTypeContextExt<'input>> for DoublePrecisionTypeContext<'input>{
	fn borrow(&self) -> &NonnullableTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NonnullableTypeContextExt<'input>> for DoublePrecisionTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut NonnullableTypeContextExt<'input> { &mut self.base }
}

impl<'input> NonnullableTypeContextAttrs<'input> for DoublePrecisionTypeContext<'input> {}

impl<'input> DoublePrecisionTypeContextExt<'input>{
	fn new(ctx: &dyn NonnullableTypeContextAttrs<'input>) -> Rc<NonnullableTypeContextAll<'input>>  {
		Rc::new(
			NonnullableTypeContextAll::DoublePrecisionTypeContext(
				BaseParserRuleContext::copy_from(ctx,DoublePrecisionTypeContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type StructuredObjectTypeContext<'input> = BaseParserRuleContext<'input,StructuredObjectTypeContextExt<'input>>;

pub trait StructuredObjectTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token OBJECT
	/// Returns `None` if there is no child corresponding to token OBJECT
	fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OBJECT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn rowField_all(&self) ->  Vec<Rc<RowFieldContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn rowField(&self, i: usize) -> Option<Rc<RowFieldContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> StructuredObjectTypeContextAttrs<'input> for StructuredObjectTypeContext<'input>{}

pub struct StructuredObjectTypeContextExt<'input>{
	base:NonnullableTypeContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{StructuredObjectTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for StructuredObjectTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StructuredObjectTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_structuredObjectType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_structuredObjectType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StructuredObjectTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_structuredObjectType(self);
	}
}

impl<'input> CustomRuleContext<'input> for StructuredObjectTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}

impl<'input> Borrow<NonnullableTypeContextExt<'input>> for StructuredObjectTypeContext<'input>{
	fn borrow(&self) -> &NonnullableTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NonnullableTypeContextExt<'input>> for StructuredObjectTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut NonnullableTypeContextExt<'input> { &mut self.base }
}

impl<'input> NonnullableTypeContextAttrs<'input> for StructuredObjectTypeContext<'input> {}

impl<'input> StructuredObjectTypeContextExt<'input>{
	fn new(ctx: &dyn NonnullableTypeContextAttrs<'input>) -> Rc<NonnullableTypeContextAll<'input>>  {
		Rc::new(
			NonnullableTypeContextAll::StructuredObjectTypeContext(
				BaseParserRuleContext::copy_from(ctx,StructuredObjectTypeContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type LegacyStructTypeContext<'input> = BaseParserRuleContext<'input,LegacyStructTypeContextExt<'input>>;

pub trait LegacyStructTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token STRUCT
	/// Returns `None` if there is no child corresponding to token STRUCT
	fn STRUCT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(STRUCT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LT
	/// Returns `None` if there is no child corresponding to token LT
	fn LT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LT, 0)
	}
	fn rowField_all(&self) ->  Vec<Rc<RowFieldContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn rowField(&self, i: usize) -> Option<Rc<RowFieldContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token GT
	/// Returns `None` if there is no child corresponding to token GT
	fn GT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(GT, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> LegacyStructTypeContextAttrs<'input> for LegacyStructTypeContext<'input>{}

pub struct LegacyStructTypeContextExt<'input>{
	base:NonnullableTypeContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{LegacyStructTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for LegacyStructTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LegacyStructTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_legacyStructType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_legacyStructType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LegacyStructTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_legacyStructType(self);
	}
}

impl<'input> CustomRuleContext<'input> for LegacyStructTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}

impl<'input> Borrow<NonnullableTypeContextExt<'input>> for LegacyStructTypeContext<'input>{
	fn borrow(&self) -> &NonnullableTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NonnullableTypeContextExt<'input>> for LegacyStructTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut NonnullableTypeContextExt<'input> { &mut self.base }
}

impl<'input> NonnullableTypeContextAttrs<'input> for LegacyStructTypeContext<'input> {}

impl<'input> LegacyStructTypeContextExt<'input>{
	fn new(ctx: &dyn NonnullableTypeContextAttrs<'input>) -> Rc<NonnullableTypeContextAll<'input>>  {
		Rc::new(
			NonnullableTypeContextAll::LegacyStructTypeContext(
				BaseParserRuleContext::copy_from(ctx,LegacyStructTypeContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PrimitiveTypeContext<'input> = BaseParserRuleContext<'input,PrimitiveTypeContextExt<'input>>;

pub trait PrimitiveTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn typeIdentifier(&self) -> Option<Rc<TypeIdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn typeParameter_all(&self) ->  Vec<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn typeParameter(&self, i: usize) -> Option<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> PrimitiveTypeContextAttrs<'input> for PrimitiveTypeContext<'input>{}

pub struct PrimitiveTypeContextExt<'input>{
	base:NonnullableTypeContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PrimitiveTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PrimitiveTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PrimitiveTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_primitiveType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_primitiveType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PrimitiveTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_primitiveType(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrimitiveTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}

impl<'input> Borrow<NonnullableTypeContextExt<'input>> for PrimitiveTypeContext<'input>{
	fn borrow(&self) -> &NonnullableTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NonnullableTypeContextExt<'input>> for PrimitiveTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut NonnullableTypeContextExt<'input> { &mut self.base }
}

impl<'input> NonnullableTypeContextAttrs<'input> for PrimitiveTypeContext<'input> {}

impl<'input> PrimitiveTypeContextExt<'input>{
	fn new(ctx: &dyn NonnullableTypeContextAttrs<'input>) -> Rc<NonnullableTypeContextAll<'input>>  {
		Rc::new(
			NonnullableTypeContextAll::PrimitiveTypeContext(
				BaseParserRuleContext::copy_from(ctx,PrimitiveTypeContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CharacterVaryingContext<'input> = BaseParserRuleContext<'input,CharacterVaryingContextExt<'input>>;

pub trait CharacterVaryingContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token VARYING
	/// Returns `None` if there is no child corresponding to token VARYING
	fn VARYING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VARYING, 0)
	}
	/// Retrieves first TerminalNode corresponding to token CHARACTER
	/// Returns `None` if there is no child corresponding to token CHARACTER
	fn CHARACTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CHARACTER, 0)
	}
	/// Retrieves first TerminalNode corresponding to token CHAR
	/// Returns `None` if there is no child corresponding to token CHAR
	fn CHAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CHAR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token NCHAR
	/// Returns `None` if there is no child corresponding to token NCHAR
	fn NCHAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(NCHAR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
	/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
	fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INTEGER_VALUE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> CharacterVaryingContextAttrs<'input> for CharacterVaryingContext<'input>{}

pub struct CharacterVaryingContextExt<'input>{
	base:NonnullableTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CharacterVaryingContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CharacterVaryingContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CharacterVaryingContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_characterVarying(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_characterVarying(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CharacterVaryingContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_characterVarying(self);
	}
}

impl<'input> CustomRuleContext<'input> for CharacterVaryingContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}

impl<'input> Borrow<NonnullableTypeContextExt<'input>> for CharacterVaryingContext<'input>{
	fn borrow(&self) -> &NonnullableTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NonnullableTypeContextExt<'input>> for CharacterVaryingContext<'input>{
	fn borrow_mut(&mut self) -> &mut NonnullableTypeContextExt<'input> { &mut self.base }
}

impl<'input> NonnullableTypeContextAttrs<'input> for CharacterVaryingContext<'input> {}

impl<'input> CharacterVaryingContextExt<'input>{
	fn new(ctx: &dyn NonnullableTypeContextAttrs<'input>) -> Rc<NonnullableTypeContextAll<'input>>  {
		Rc::new(
			NonnullableTypeContextAll::CharacterVaryingContext(
				BaseParserRuleContext::copy_from(ctx,CharacterVaryingContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DateTimeTypeContext<'input> = BaseParserRuleContext<'input,DateTimeTypeContextExt<'input>>;

pub trait DateTimeTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token TIMESTAMP
	/// Returns `None` if there is no child corresponding to token TIMESTAMP
	fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TIMESTAMP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token TIME
	/// Returns `None` if there is no child corresponding to token TIME
	fn TIME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(TIME, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ZONE
	/// Returns `None` if there is no child corresponding to token ZONE
	fn ZONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ZONE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn typeParameter(&self) -> Option<Rc<TypeParameterContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token WITHOUT
	/// Returns `None` if there is no child corresponding to token WITHOUT
	fn WITHOUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITHOUT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token WITH
	/// Returns `None` if there is no child corresponding to token WITH
	fn WITH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WITH, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LOCAL
	/// Returns `None` if there is no child corresponding to token LOCAL
	fn LOCAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LOCAL, 0)
	}
}

impl<'input> DateTimeTypeContextAttrs<'input> for DateTimeTypeContext<'input>{}

pub struct DateTimeTypeContextExt<'input>{
	base:NonnullableTypeContextExt<'input>,
	pub base_: Option<TokenType<'input>>,
	pub precision: Option<Rc<TypeParameterContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DateTimeTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DateTimeTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DateTimeTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_dateTimeType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_dateTimeType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DateTimeTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dateTimeType(self);
	}
}

impl<'input> CustomRuleContext<'input> for DateTimeTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}

impl<'input> Borrow<NonnullableTypeContextExt<'input>> for DateTimeTypeContext<'input>{
	fn borrow(&self) -> &NonnullableTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NonnullableTypeContextExt<'input>> for DateTimeTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut NonnullableTypeContextExt<'input> { &mut self.base }
}

impl<'input> NonnullableTypeContextAttrs<'input> for DateTimeTypeContext<'input> {}

impl<'input> DateTimeTypeContextExt<'input>{
	fn new(ctx: &dyn NonnullableTypeContextAttrs<'input>) -> Rc<NonnullableTypeContextAll<'input>>  {
		Rc::new(
			NonnullableTypeContextAll::DateTimeTypeContext(
				BaseParserRuleContext::copy_from(ctx,DateTimeTypeContextExt{
					base_:None, 
        			precision:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type LegacyMapTypeContext<'input> = BaseParserRuleContext<'input,LegacyMapTypeContextExt<'input>>;

pub trait LegacyMapTypeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token MAP
	/// Returns `None` if there is no child corresponding to token MAP
	fn MAP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MAP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn type__all(&self) ->  Vec<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn type_(&self, i: usize) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> LegacyMapTypeContextAttrs<'input> for LegacyMapTypeContext<'input>{}

pub struct LegacyMapTypeContextExt<'input>{
	base:NonnullableTypeContextExt<'input>,
	pub keyType: Option<Rc<Type_ContextAll<'input>>>,
	pub valueType: Option<Rc<Type_ContextAll<'input>>>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{LegacyMapTypeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for LegacyMapTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LegacyMapTypeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_legacyMapType(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_legacyMapType(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LegacyMapTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_legacyMapType(self);
	}
}

impl<'input> CustomRuleContext<'input> for LegacyMapTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonnullableType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonnullableType }
}

impl<'input> Borrow<NonnullableTypeContextExt<'input>> for LegacyMapTypeContext<'input>{
	fn borrow(&self) -> &NonnullableTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NonnullableTypeContextExt<'input>> for LegacyMapTypeContext<'input>{
	fn borrow_mut(&mut self) -> &mut NonnullableTypeContextExt<'input> { &mut self.base }
}

impl<'input> NonnullableTypeContextAttrs<'input> for LegacyMapTypeContext<'input> {}

impl<'input> LegacyMapTypeContextExt<'input>{
	fn new(ctx: &dyn NonnullableTypeContextAttrs<'input>) -> Rc<NonnullableTypeContextAll<'input>>  {
		Rc::new(
			NonnullableTypeContextAll::LegacyMapTypeContext(
				BaseParserRuleContext::copy_from(ctx,LegacyMapTypeContextExt{
					tail:None, 
        			keyType:None, valueType:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nonnullableType(&mut self,)
	-> Result<Rc<NonnullableTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NonnullableTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 308, RULE_nonnullableType);
        let mut _localctx: Rc<NonnullableTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(5187);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(718,&mut recog.base)? {
				1 =>{
					let tmp = FunctionSignatureGenericTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(5082);
					recog.base.match_token(DOLLAR,&mut recog.err_handler)?;

					recog.base.set_state(5083);
					recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = DoublePrecisionTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5084);
					recog.base.match_token(DOUBLE,&mut recog.err_handler)?;

					recog.base.set_state(5085);
					recog.base.match_token(PRECISION,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					let tmp = CharacterVaryingContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(5086);
					_la = recog.base.input.la(1);
					if { !(_la==CHAR || _la==CHARACTER || _la==NCHAR) } {
						recog.err_handler.recover_inline(&mut recog.base)?;

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					recog.base.set_state(5087);
					recog.base.match_token(VARYING,&mut recog.err_handler)?;

					recog.base.set_state(5091);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(703,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5088);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							recog.base.set_state(5089);
							recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;

							recog.base.set_state(5090);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				4 =>{
					let tmp = DateTimeTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					recog.base.set_state(5093);
					let tmp = recog.base.match_token(TIMESTAMP,&mut recog.err_handler)?;
					if let NonnullableTypeContextAll::DateTimeTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
					ctx.base_ = Some(tmp); } else {unreachable!("cant cast");}  

					recog.base.set_state(5103);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(706,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5099);
							recog.err_handler.sync(&mut recog.base)?;
							match recog.base.input.la(1) {
							 WITHOUT 
								=> {
									{
									recog.base.set_state(5094);
									recog.base.match_token(WITHOUT,&mut recog.err_handler)?;

									}
								}

							 WITH 
								=> {
									{
									recog.base.set_state(5095);
									recog.base.match_token(WITH,&mut recog.err_handler)?;

									recog.base.set_state(5097);
									recog.err_handler.sync(&mut recog.base)?;
									_la = recog.base.input.la(1);
									if _la==LOCAL {
										{
										recog.base.set_state(5096);
										recog.base.match_token(LOCAL,&mut recog.err_handler)?;

										}
									}

									}
								}

								_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
							}
							recog.base.set_state(5101);
							recog.base.match_token(TIME,&mut recog.err_handler)?;

							recog.base.set_state(5102);
							recog.base.match_token(ZONE,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					recog.base.set_state(5109);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(707,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5105);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule typeParameter*/
							recog.base.set_state(5106);
							let tmp = recog.typeParameter()?;
							if let NonnullableTypeContextAll::DateTimeTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
							ctx.precision = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							recog.base.set_state(5107);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				5 =>{
					let tmp = DateTimeTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 5);
					_localctx = tmp;
					{
					recog.base.set_state(5111);
					let tmp = recog.base.match_token(TIME,&mut recog.err_handler)?;
					if let NonnullableTypeContextAll::DateTimeTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
					ctx.base_ = Some(tmp); } else {unreachable!("cant cast");}  

					recog.base.set_state(5116);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(708,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5112);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule typeParameter*/
							recog.base.set_state(5113);
							let tmp = recog.typeParameter()?;
							if let NonnullableTypeContextAll::DateTimeTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
							ctx.precision = Some(tmp.clone()); } else {unreachable!("cant cast");}  

							recog.base.set_state(5114);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}
			,
				6 =>{
					let tmp = LambdaTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 6);
					_localctx = tmp;
					{
					recog.base.set_state(5118);
					recog.base.match_token(FUNCTION,&mut recog.err_handler)?;

					recog.base.set_state(5119);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule type_*/
					recog.base.set_state(5120);
					recog.type_()?;

					recog.base.set_state(5125);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					while _la==COMMA {
						{
						{
						recog.base.set_state(5121);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule type_*/
						recog.base.set_state(5122);
						recog.type_()?;

						}
						}
						recog.base.set_state(5127);
						recog.err_handler.sync(&mut recog.base)?;
						_la = recog.base.input.la(1);
					}
					recog.base.set_state(5128);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					let tmp = LegacyStructTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 7);
					_localctx = tmp;
					{
					recog.base.set_state(5130);
					recog.base.match_token(STRUCT,&mut recog.err_handler)?;

					recog.base.set_state(5131);
					recog.base.match_token(LT,&mut recog.err_handler)?;

					/*InvokeRule rowField*/
					recog.base.set_state(5132);
					recog.rowField()?;

					recog.base.set_state(5137);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(710,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(5133);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule rowField*/
							recog.base.set_state(5134);
							recog.rowField()?;

							}
							} 
						}
						recog.base.set_state(5139);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(710,&mut recog.base)?;
					}
					recog.base.set_state(5141);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(5140);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let NonnullableTypeContextAll::LegacyStructTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(5143);
					recog.base.match_token(GT,&mut recog.err_handler)?;

					}
				}
			,
				8 =>{
					let tmp = StructuredObjectTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 8);
					_localctx = tmp;
					{
					recog.base.set_state(5145);
					recog.base.match_token(OBJECT,&mut recog.err_handler)?;

					recog.base.set_state(5146);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule rowField*/
					recog.base.set_state(5147);
					recog.rowField()?;

					recog.base.set_state(5152);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(712,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(5148);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule rowField*/
							recog.base.set_state(5149);
							recog.rowField()?;

							}
							} 
						}
						recog.base.set_state(5154);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(712,&mut recog.base)?;
					}
					recog.base.set_state(5156);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(5155);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let NonnullableTypeContextAll::StructuredObjectTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(5158);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				9 =>{
					let tmp = LegacyMapTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 9);
					_localctx = tmp;
					{
					recog.base.set_state(5160);
					recog.base.match_token(MAP,&mut recog.err_handler)?;

					recog.base.set_state(5161);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule type_*/
					recog.base.set_state(5162);
					let tmp = recog.type_()?;
					if let NonnullableTypeContextAll::LegacyMapTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
					ctx.keyType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(5163);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule type_*/
					recog.base.set_state(5164);
					let tmp = recog.type_()?;
					if let NonnullableTypeContextAll::LegacyMapTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
					ctx.valueType = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(5166);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(5165);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let NonnullableTypeContextAll::LegacyMapTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(5168);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				10 =>{
					let tmp = PrimitiveTypeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 10);
					_localctx = tmp;
					{
					/*InvokeRule typeIdentifier*/
					recog.base.set_state(5170);
					recog.typeIdentifier()?;

					recog.base.set_state(5185);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(717,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5171);
							recog.base.match_token(LPAREN,&mut recog.err_handler)?;

							/*InvokeRule typeParameter*/
							recog.base.set_state(5172);
							recog.typeParameter()?;

							recog.base.set_state(5177);
							recog.err_handler.sync(&mut recog.base)?;
							_alt = recog.interpreter.adaptive_predict(715,&mut recog.base)?;
							while { _alt!=2 && _alt!=INVALID_ALT } {
								if _alt==1 {
									{
									{
									recog.base.set_state(5173);
									recog.base.match_token(COMMA,&mut recog.err_handler)?;

									/*InvokeRule typeParameter*/
									recog.base.set_state(5174);
									recog.typeParameter()?;

									}
									} 
								}
								recog.base.set_state(5179);
								recog.err_handler.sync(&mut recog.base)?;
								_alt = recog.interpreter.adaptive_predict(715,&mut recog.base)?;
							}
							recog.base.set_state(5181);
							recog.err_handler.sync(&mut recog.base)?;
							_la = recog.base.input.la(1);
							if _la==COMMA {
								{
								recog.base.set_state(5180);
								let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
								if let NonnullableTypeContextAll::PrimitiveTypeContext(ctx) = cast_mut::<_,NonnullableTypeContextAll >(&mut _localctx){
								ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

								}
							}

							recog.base.set_state(5183);
							recog.base.match_token(RPAREN,&mut recog.err_handler)?;

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rowField ----------------
pub type RowFieldContextAll<'input> = RowFieldContext<'input>;


pub type RowFieldContext<'input> = BaseParserRuleContext<'input,RowFieldContextExt<'input>>;

#[derive(Clone)]
pub struct RowFieldContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for RowFieldContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RowFieldContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rowField(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_rowField(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RowFieldContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rowField(self);
	}
}

impl<'input> CustomRuleContext<'input> for RowFieldContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rowField }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rowField }
}
antlr_rust::tid!{RowFieldContextExt<'a>}

impl<'input> RowFieldContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RowFieldContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RowFieldContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RowFieldContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<RowFieldContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> RowFieldContextAttrs<'input> for RowFieldContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rowField(&mut self,)
	-> Result<Rc<RowFieldContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RowFieldContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 310, RULE_rowField);
        let mut _localctx: Rc<RowFieldContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(5189);
			recog.identifier()?;

			/*InvokeRule type_*/
			recog.base.set_state(5190);
			recog.type_()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- typeParameter ----------------
pub type TypeParameterContextAll<'input> = TypeParameterContext<'input>;


pub type TypeParameterContext<'input> = BaseParserRuleContext<'input,TypeParameterContextExt<'input>>;

#[derive(Clone)]
pub struct TypeParameterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TypeParameterContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TypeParameterContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_typeParameter(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_typeParameter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TypeParameterContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_typeParameter(self);
	}
}

impl<'input> CustomRuleContext<'input> for TypeParameterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_typeParameter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_typeParameter }
}
antlr_rust::tid!{TypeParameterContextExt<'a>}

impl<'input> TypeParameterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TypeParameterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TypeParameterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait TypeParameterContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TypeParameterContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTEGER_VALUE, 0)
}
fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> TypeParameterContextAttrs<'input> for TypeParameterContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn typeParameter(&mut self,)
	-> Result<Rc<TypeParameterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TypeParameterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 312, RULE_typeParameter);
        let mut _localctx: Rc<TypeParameterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5194);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 INTEGER_VALUE 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(5192);
					recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;

					}
				}

			 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
			 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
			 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
			 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
			 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
			 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
			 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
			 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
			 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
			 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
			 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
			 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC | EMPTY |
			 ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE | EVEN |
			 EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
			 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
			 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FULL |
			 FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS |
			 GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
			 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
			 INFORMATION | INITIAL | INITIALLY | INNER | INPUT | INPUTFORMAT | INTERLEAVED |
			 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JOIN | JSON |
			 JSON_ARRAY | JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP |
			 KEY | KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LATERAL |
			 LEADING | LEFT | LEVEL | LIBRARY | LIMIT | LINES | LISTAGG | LOCAL |
			 LOCATION | LOCK | LOGICAL | MAP | MASKING | MATCH | MATCHED | MATCHES |
			 MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES | MEMORIZABLE |
			 MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME | NATURAL | NCHAR |
			 NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER | NORELY | NORMALIZE |
			 NOVALIDATE | NULL | NULLS | OBJECT | OFFSET | OMIT | ONE | ONLY | OPTION |
			 OPTIONS | ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW |
			 OWNER | PARTITION | PARTITIONED | PARTITIONS | PASSING | PAST | PATH |
			 PATTERN | PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE |
			 PIVOT | PLACING | POLICY | POSITION | PRECEDING | PRECISION | PREPARE |
			 PRIOR | PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON |
			 QUOTES | RANGE | READ | RECURSIVE | REFERENCE | REFERENCES | REFRESH |
			 RELY | RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT | RESTRICTED |
			 RETURN | RETURNING | RETURNS | RIGHT | RLS | ROLE | ROLES | ROLLBACK |
			 ROLLUP | RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS | SECURE |
			 SECURITY | SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES |
			 SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT |
			 SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED | STREAM | STRICT |
			 STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG | TEMP |
			 TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW | TIES | TIME |
			 TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION | TRANSIENT | TRIM |
			 TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED |
			 UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET |
			 UNSIGNED | USE | USER | USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE |
			 VALUE | VARYING | VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE |
			 WHEN | WINDOW | WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR |
			 YES | ZONE | ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule type_*/
					recog.base.set_state(5193);
					recog.type_()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- whenClause ----------------
pub type WhenClauseContextAll<'input> = WhenClauseContext<'input>;


pub type WhenClauseContext<'input> = BaseParserRuleContext<'input,WhenClauseContextExt<'input>>;

#[derive(Clone)]
pub struct WhenClauseContextExt<'input>{
	pub condition: Option<Rc<ExpressionContextAll<'input>>>,
	pub result: Option<Rc<ExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for WhenClauseContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for WhenClauseContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_whenClause(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_whenClause(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for WhenClauseContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_whenClause(self);
	}
}

impl<'input> CustomRuleContext<'input> for WhenClauseContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_whenClause }
	//fn type_rule_index() -> usize where Self: Sized { RULE_whenClause }
}
antlr_rust::tid!{WhenClauseContextExt<'a>}

impl<'input> WhenClauseContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WhenClauseContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WhenClauseContextExt{
				condition: None, result: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait WhenClauseContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<WhenClauseContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token WHEN
/// Returns `None` if there is no child corresponding to token WHEN
fn WHEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WHEN, 0)
}
/// Retrieves first TerminalNode corresponding to token THEN
/// Returns `None` if there is no child corresponding to token THEN
fn THEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(THEN, 0)
}
fn expression_all(&self) ->  Vec<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn expression(&self, i: usize) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}

}

impl<'input> WhenClauseContextAttrs<'input> for WhenClauseContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn whenClause(&mut self,)
	-> Result<Rc<WhenClauseContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WhenClauseContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 314, RULE_whenClause);
        let mut _localctx: Rc<WhenClauseContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5196);
			recog.base.match_token(WHEN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(5197);
			let tmp = recog.expression()?;
			 cast_mut::<_,WhenClauseContext >(&mut _localctx).condition = Some(tmp.clone());
			  

			recog.base.set_state(5198);
			recog.base.match_token(THEN,&mut recog.err_handler)?;

			/*InvokeRule expression*/
			recog.base.set_state(5199);
			let tmp = recog.expression()?;
			 cast_mut::<_,WhenClauseContext >(&mut _localctx).result = Some(tmp.clone());
			  

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- filter ----------------
pub type FilterContextAll<'input> = FilterContext<'input>;


pub type FilterContext<'input> = BaseParserRuleContext<'input,FilterContextExt<'input>>;

#[derive(Clone)]
pub struct FilterContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for FilterContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FilterContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_filter(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_filter(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FilterContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_filter(self);
	}
}

impl<'input> CustomRuleContext<'input> for FilterContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_filter }
	//fn type_rule_index() -> usize where Self: Sized { RULE_filter }
}
antlr_rust::tid!{FilterContextExt<'a>}

impl<'input> FilterContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FilterContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FilterContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait FilterContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<FilterContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FILTER
/// Returns `None` if there is no child corresponding to token FILTER
fn FILTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FILTER, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token WHERE
/// Returns `None` if there is no child corresponding to token WHERE
fn WHERE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WHERE, 0)
}
fn booleanExpression(&self) -> Option<Rc<BooleanExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}

}

impl<'input> FilterContextAttrs<'input> for FilterContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn filter(&mut self,)
	-> Result<Rc<FilterContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FilterContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 316, RULE_filter);
        let mut _localctx: Rc<FilterContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5201);
			recog.base.match_token(FILTER,&mut recog.err_handler)?;

			recog.base.set_state(5202);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(5203);
			recog.base.match_token(WHERE,&mut recog.err_handler)?;

			/*InvokeRule booleanExpression*/
			recog.base.set_state(5204);
			recog.booleanExpression_rec(0)?;

			recog.base.set_state(5205);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- over ----------------
pub type OverContextAll<'input> = OverContext<'input>;


pub type OverContext<'input> = BaseParserRuleContext<'input,OverContextExt<'input>>;

#[derive(Clone)]
pub struct OverContextExt<'input>{
	pub windowName: Option<Rc<IdentifierContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for OverContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for OverContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_over(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_over(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for OverContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_over(self);
	}
}

impl<'input> CustomRuleContext<'input> for OverContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_over }
	//fn type_rule_index() -> usize where Self: Sized { RULE_over }
}
antlr_rust::tid!{OverContextExt<'a>}

impl<'input> OverContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<OverContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,OverContextExt{
				windowName: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait OverContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<OverContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token OVER
/// Returns `None` if there is no child corresponding to token OVER
fn OVER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OVER, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn windowSpecification(&self) -> Option<Rc<WindowSpecificationContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> OverContextAttrs<'input> for OverContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn over(&mut self,)
	-> Result<Rc<OverContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = OverContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 318, RULE_over);
        let mut _localctx: Rc<OverContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5207);
			recog.base.match_token(OVER,&mut recog.err_handler)?;

			recog.base.set_state(5213);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
			 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH | AUTHORIZATION |
			 AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK |
			 BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
			 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
			 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
			 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
			 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
			 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
			 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
			 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
			 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC | EMPTY |
			 ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE | EVEN |
			 EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
			 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
			 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FULL |
			 FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS |
			 GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
			 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
			 INFORMATION | INITIAL | INITIALLY | INNER | INPUT | INPUTFORMAT | INTERLEAVED |
			 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JOIN | JSON |
			 JSON_ARRAY | JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP |
			 KEY | KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LATERAL |
			 LEADING | LEFT | LEVEL | LIBRARY | LIMIT | LINES | LISTAGG | LOCAL |
			 LOCATION | LOCK | LOGICAL | MAP | MASKING | MATCH | MATCHED | MATCHES |
			 MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES | MEMORIZABLE |
			 MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME | NATURAL | NCHAR |
			 NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER | NORELY | NORMALIZE |
			 NOVALIDATE | NULLS | OBJECT | OFFSET | OMIT | ONE | ONLY | OPTION | OPTIONS |
			 ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW | OWNER |
			 PARTITION | PARTITIONED | PARTITIONS | PASSING | PAST | PATH | PATTERN |
			 PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE | PIVOT |
			 PLACING | POLICY | POSITION | PRECEDING | PRECISION | PREPARE | PRIOR |
			 PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON | QUOTES |
			 RANGE | READ | RECURSIVE | REFERENCE | REFERENCES | REFRESH | RELY |
			 RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT | RESTRICTED |
			 RETURN | RETURNING | RETURNS | RIGHT | RLS | ROLE | ROLES | ROLLBACK |
			 ROLLUP | RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS | SECURE |
			 SECURITY | SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES |
			 SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT |
			 SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED | STREAM | STRICT |
			 STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG | TEMP |
			 TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW | TIES | TIME |
			 TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION | TRANSIENT | TRIM |
			 TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED |
			 UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET |
			 UNSIGNED | USE | USER | USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE |
			 VALUE | VARYING | VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE |
			 WHEN | WINDOW | WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR |
			 YES | ZONE | ZSTD | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
				=> {
					{
					/*InvokeRule identifier*/
					recog.base.set_state(5208);
					let tmp = recog.identifier()?;
					 cast_mut::<_,OverContext >(&mut _localctx).windowName = Some(tmp.clone());
					  

					}
				}

			 LPAREN 
				=> {
					{
					recog.base.set_state(5209);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule windowSpecification*/
					recog.base.set_state(5210);
					recog.windowSpecification()?;

					recog.base.set_state(5211);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- windowFrame ----------------
pub type WindowFrameContextAll<'input> = WindowFrameContext<'input>;


pub type WindowFrameContext<'input> = BaseParserRuleContext<'input,WindowFrameContextExt<'input>>;

#[derive(Clone)]
pub struct WindowFrameContextExt<'input>{
	pub COMMA: Option<TokenType<'input>>,
	pub tail:Vec<TokenType<'input>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for WindowFrameContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for WindowFrameContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_windowFrame(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_windowFrame(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for WindowFrameContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_windowFrame(self);
	}
}

impl<'input> CustomRuleContext<'input> for WindowFrameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_windowFrame }
	//fn type_rule_index() -> usize where Self: Sized { RULE_windowFrame }
}
antlr_rust::tid!{WindowFrameContextExt<'a>}

impl<'input> WindowFrameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<WindowFrameContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,WindowFrameContextExt{
				COMMA: None, 
				tail: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait WindowFrameContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<WindowFrameContextExt<'input>>{

fn frameExtent(&self) -> Option<Rc<FrameExtentContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token MEASURES
/// Returns `None` if there is no child corresponding to token MEASURES
fn MEASURES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MEASURES, 0)
}
fn measureDefinition_all(&self) ->  Vec<Rc<MeasureDefinitionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn measureDefinition(&self, i: usize) -> Option<Rc<MeasureDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token AFTER
/// Returns `None` if there is no child corresponding to token AFTER
fn AFTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AFTER, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCH
/// Returns `None` if there is no child corresponding to token MATCH
fn MATCH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCH, 0)
}
fn skipTo(&self) -> Option<Rc<SkipToContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token PATTERN
/// Returns `None` if there is no child corresponding to token PATTERN
fn PATTERN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PATTERN, 0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn rowPattern(&self) -> Option<Rc<RowPatternContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token SUBSET
/// Returns `None` if there is no child corresponding to token SUBSET
fn SUBSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SUBSET, 0)
}
fn subsetDefinition_all(&self) ->  Vec<Rc<SubsetDefinitionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn subsetDefinition(&self, i: usize) -> Option<Rc<SubsetDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token DEFINE
/// Returns `None` if there is no child corresponding to token DEFINE
fn DEFINE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFINE, 0)
}
fn variableDefinition_all(&self) ->  Vec<Rc<VariableDefinitionContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn variableDefinition(&self, i: usize) -> Option<Rc<VariableDefinitionContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token INITIAL
/// Returns `None` if there is no child corresponding to token INITIAL
fn INITIAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INITIAL, 0)
}
/// Retrieves first TerminalNode corresponding to token SEEK
/// Returns `None` if there is no child corresponding to token SEEK
fn SEEK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEEK, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> WindowFrameContextAttrs<'input> for WindowFrameContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn windowFrame(&mut self,)
	-> Result<Rc<WindowFrameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = WindowFrameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 320, RULE_windowFrame);
        let mut _localctx: Rc<WindowFrameContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5227);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==MEASURES {
				{
				recog.base.set_state(5215);
				recog.base.match_token(MEASURES,&mut recog.err_handler)?;

				/*InvokeRule measureDefinition*/
				recog.base.set_state(5216);
				recog.measureDefinition()?;

				recog.base.set_state(5221);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(721,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(5217);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule measureDefinition*/
						recog.base.set_state(5218);
						recog.measureDefinition()?;

						}
						} 
					}
					recog.base.set_state(5223);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(721,&mut recog.base)?;
				}
				recog.base.set_state(5225);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==COMMA {
					{
					recog.base.set_state(5224);
					let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
					 cast_mut::<_,WindowFrameContext >(&mut _localctx).COMMA = Some(tmp);
					  

					let temp =  cast_mut::<_,WindowFrameContext >(&mut _localctx).COMMA.clone().unwrap()
					 ;
					 cast_mut::<_,WindowFrameContext >(&mut _localctx).tail.push(temp);
					  
					}
				}

				}
			}

			/*InvokeRule frameExtent*/
			recog.base.set_state(5229);
			recog.frameExtent()?;

			recog.base.set_state(5233);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==AFTER {
				{
				recog.base.set_state(5230);
				recog.base.match_token(AFTER,&mut recog.err_handler)?;

				recog.base.set_state(5231);
				recog.base.match_token(MATCH,&mut recog.err_handler)?;

				/*InvokeRule skipTo*/
				recog.base.set_state(5232);
				recog.skipTo()?;

				}
			}

			recog.base.set_state(5236);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==INITIAL || _la==SEEK {
				{
				recog.base.set_state(5235);
				_la = recog.base.input.la(1);
				if { !(_la==INITIAL || _la==SEEK) } {
					recog.err_handler.recover_inline(&mut recog.base)?;

				}
				else {
					if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
					recog.err_handler.report_match(&mut recog.base);
					recog.base.consume(&mut recog.err_handler);
				}
				}
			}

			recog.base.set_state(5243);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==PATTERN {
				{
				recog.base.set_state(5238);
				recog.base.match_token(PATTERN,&mut recog.err_handler)?;

				recog.base.set_state(5239);
				recog.base.match_token(LPAREN,&mut recog.err_handler)?;

				/*InvokeRule rowPattern*/
				recog.base.set_state(5240);
				recog.rowPattern_rec(0)?;

				recog.base.set_state(5241);
				recog.base.match_token(RPAREN,&mut recog.err_handler)?;

				}
			}

			recog.base.set_state(5257);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==SUBSET {
				{
				recog.base.set_state(5245);
				recog.base.match_token(SUBSET,&mut recog.err_handler)?;

				/*InvokeRule subsetDefinition*/
				recog.base.set_state(5246);
				recog.subsetDefinition()?;

				recog.base.set_state(5251);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(727,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(5247);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule subsetDefinition*/
						recog.base.set_state(5248);
						recog.subsetDefinition()?;

						}
						} 
					}
					recog.base.set_state(5253);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(727,&mut recog.base)?;
				}
				recog.base.set_state(5255);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==COMMA {
					{
					recog.base.set_state(5254);
					let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
					 cast_mut::<_,WindowFrameContext >(&mut _localctx).COMMA = Some(tmp);
					  

					let temp =  cast_mut::<_,WindowFrameContext >(&mut _localctx).COMMA.clone().unwrap()
					 ;
					 cast_mut::<_,WindowFrameContext >(&mut _localctx).tail.push(temp);
					  
					}
				}

				}
			}

			recog.base.set_state(5271);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			if _la==DEFINE {
				{
				recog.base.set_state(5259);
				recog.base.match_token(DEFINE,&mut recog.err_handler)?;

				/*InvokeRule variableDefinition*/
				recog.base.set_state(5260);
				recog.variableDefinition()?;

				recog.base.set_state(5265);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(730,&mut recog.base)?;
				while { _alt!=2 && _alt!=INVALID_ALT } {
					if _alt==1 {
						{
						{
						recog.base.set_state(5261);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule variableDefinition*/
						recog.base.set_state(5262);
						recog.variableDefinition()?;

						}
						} 
					}
					recog.base.set_state(5267);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(730,&mut recog.base)?;
				}
				recog.base.set_state(5269);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
				if _la==COMMA {
					{
					recog.base.set_state(5268);
					let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
					 cast_mut::<_,WindowFrameContext >(&mut _localctx).COMMA = Some(tmp);
					  

					let temp =  cast_mut::<_,WindowFrameContext >(&mut _localctx).COMMA.clone().unwrap()
					 ;
					 cast_mut::<_,WindowFrameContext >(&mut _localctx).tail.push(temp);
					  
					}
				}

				}
			}

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- frameExtent ----------------
pub type FrameExtentContextAll<'input> = FrameExtentContext<'input>;


pub type FrameExtentContext<'input> = BaseParserRuleContext<'input,FrameExtentContextExt<'input>>;

#[derive(Clone)]
pub struct FrameExtentContextExt<'input>{
	pub frameType: Option<TokenType<'input>>,
	pub start: Option<Rc<FrameBoundContextAll<'input>>>,
	pub end: Option<Rc<FrameBoundContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for FrameExtentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FrameExtentContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_frameExtent(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_frameExtent(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FrameExtentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_frameExtent(self);
	}
}

impl<'input> CustomRuleContext<'input> for FrameExtentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_frameExtent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_frameExtent }
}
antlr_rust::tid!{FrameExtentContextExt<'a>}

impl<'input> FrameExtentContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FrameExtentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FrameExtentContextExt{
				frameType: None, 
				start: None, end: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait FrameExtentContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<FrameExtentContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token RANGE
/// Returns `None` if there is no child corresponding to token RANGE
fn RANGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RANGE, 0)
}
fn frameBound_all(&self) ->  Vec<Rc<FrameBoundContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn frameBound(&self, i: usize) -> Option<Rc<FrameBoundContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token ROWS
/// Returns `None` if there is no child corresponding to token ROWS
fn ROWS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROWS, 0)
}
/// Retrieves first TerminalNode corresponding to token GROUPS
/// Returns `None` if there is no child corresponding to token GROUPS
fn GROUPS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GROUPS, 0)
}
/// Retrieves first TerminalNode corresponding to token BETWEEN
/// Returns `None` if there is no child corresponding to token BETWEEN
fn BETWEEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BETWEEN, 0)
}
/// Retrieves first TerminalNode corresponding to token AND
/// Returns `None` if there is no child corresponding to token AND
fn AND(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AND, 0)
}

}

impl<'input> FrameExtentContextAttrs<'input> for FrameExtentContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn frameExtent(&mut self,)
	-> Result<Rc<FrameExtentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FrameExtentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 322, RULE_frameExtent);
        let mut _localctx: Rc<FrameExtentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5297);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(733,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(5273);
					let tmp = recog.base.match_token(RANGE,&mut recog.err_handler)?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).frameType = Some(tmp);
					  

					/*InvokeRule frameBound*/
					recog.base.set_state(5274);
					let tmp = recog.frameBound()?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).start = Some(tmp.clone());
					  

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					recog.base.set_state(5275);
					let tmp = recog.base.match_token(ROWS,&mut recog.err_handler)?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).frameType = Some(tmp);
					  

					/*InvokeRule frameBound*/
					recog.base.set_state(5276);
					let tmp = recog.frameBound()?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).start = Some(tmp.clone());
					  

					}
				}
			,
				3 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 3);
					recog.base.enter_outer_alt(None, 3);
					{
					recog.base.set_state(5277);
					let tmp = recog.base.match_token(GROUPS,&mut recog.err_handler)?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).frameType = Some(tmp);
					  

					/*InvokeRule frameBound*/
					recog.base.set_state(5278);
					let tmp = recog.frameBound()?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).start = Some(tmp.clone());
					  

					}
				}
			,
				4 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 4);
					recog.base.enter_outer_alt(None, 4);
					{
					recog.base.set_state(5279);
					let tmp = recog.base.match_token(RANGE,&mut recog.err_handler)?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).frameType = Some(tmp);
					  

					recog.base.set_state(5280);
					recog.base.match_token(BETWEEN,&mut recog.err_handler)?;

					/*InvokeRule frameBound*/
					recog.base.set_state(5281);
					let tmp = recog.frameBound()?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).start = Some(tmp.clone());
					  

					recog.base.set_state(5282);
					recog.base.match_token(AND,&mut recog.err_handler)?;

					/*InvokeRule frameBound*/
					recog.base.set_state(5283);
					let tmp = recog.frameBound()?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).end = Some(tmp.clone());
					  

					}
				}
			,
				5 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 5);
					recog.base.enter_outer_alt(None, 5);
					{
					recog.base.set_state(5285);
					let tmp = recog.base.match_token(ROWS,&mut recog.err_handler)?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).frameType = Some(tmp);
					  

					recog.base.set_state(5286);
					recog.base.match_token(BETWEEN,&mut recog.err_handler)?;

					/*InvokeRule frameBound*/
					recog.base.set_state(5287);
					let tmp = recog.frameBound()?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).start = Some(tmp.clone());
					  

					recog.base.set_state(5288);
					recog.base.match_token(AND,&mut recog.err_handler)?;

					/*InvokeRule frameBound*/
					recog.base.set_state(5289);
					let tmp = recog.frameBound()?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).end = Some(tmp.clone());
					  

					}
				}
			,
				6 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 6);
					recog.base.enter_outer_alt(None, 6);
					{
					recog.base.set_state(5291);
					let tmp = recog.base.match_token(GROUPS,&mut recog.err_handler)?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).frameType = Some(tmp);
					  

					recog.base.set_state(5292);
					recog.base.match_token(BETWEEN,&mut recog.err_handler)?;

					/*InvokeRule frameBound*/
					recog.base.set_state(5293);
					let tmp = recog.frameBound()?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).start = Some(tmp.clone());
					  

					recog.base.set_state(5294);
					recog.base.match_token(AND,&mut recog.err_handler)?;

					/*InvokeRule frameBound*/
					recog.base.set_state(5295);
					let tmp = recog.frameBound()?;
					 cast_mut::<_,FrameExtentContext >(&mut _localctx).end = Some(tmp.clone());
					  

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- frameBound ----------------
#[derive(Debug)]
pub enum FrameBoundContextAll<'input>{
	BoundedFrameContext(BoundedFrameContext<'input>),
	UnboundedFrameContext(UnboundedFrameContext<'input>),
	CurrentRowBoundContext(CurrentRowBoundContext<'input>),
Error(FrameBoundContext<'input>)
}
antlr_rust::tid!{FrameBoundContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for FrameBoundContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for FrameBoundContextAll<'input>{}

impl<'input> Deref for FrameBoundContextAll<'input>{
	type Target = dyn FrameBoundContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use FrameBoundContextAll::*;
		match self{
			BoundedFrameContext(inner) => inner,
			UnboundedFrameContext(inner) => inner,
			CurrentRowBoundContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FrameBoundContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FrameBoundContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type FrameBoundContext<'input> = BaseParserRuleContext<'input,FrameBoundContextExt<'input>>;

#[derive(Clone)]
pub struct FrameBoundContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for FrameBoundContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for FrameBoundContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for FrameBoundContext<'input>{
}

impl<'input> CustomRuleContext<'input> for FrameBoundContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_frameBound }
	//fn type_rule_index() -> usize where Self: Sized { RULE_frameBound }
}
antlr_rust::tid!{FrameBoundContextExt<'a>}

impl<'input> FrameBoundContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<FrameBoundContextAll<'input>> {
		Rc::new(
		FrameBoundContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,FrameBoundContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait FrameBoundContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<FrameBoundContextExt<'input>>{


}

impl<'input> FrameBoundContextAttrs<'input> for FrameBoundContext<'input>{}

pub type BoundedFrameContext<'input> = BaseParserRuleContext<'input,BoundedFrameContextExt<'input>>;

pub trait BoundedFrameContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn expression(&self) -> Option<Rc<ExpressionContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token PRECEDING
	/// Returns `None` if there is no child corresponding to token PRECEDING
	fn PRECEDING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PRECEDING, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FOLLOWING
	/// Returns `None` if there is no child corresponding to token FOLLOWING
	fn FOLLOWING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FOLLOWING, 0)
	}
}

impl<'input> BoundedFrameContextAttrs<'input> for BoundedFrameContext<'input>{}

pub struct BoundedFrameContextExt<'input>{
	base:FrameBoundContextExt<'input>,
	pub boundType: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{BoundedFrameContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for BoundedFrameContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for BoundedFrameContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_boundedFrame(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_boundedFrame(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for BoundedFrameContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_boundedFrame(self);
	}
}

impl<'input> CustomRuleContext<'input> for BoundedFrameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_frameBound }
	//fn type_rule_index() -> usize where Self: Sized { RULE_frameBound }
}

impl<'input> Borrow<FrameBoundContextExt<'input>> for BoundedFrameContext<'input>{
	fn borrow(&self) -> &FrameBoundContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<FrameBoundContextExt<'input>> for BoundedFrameContext<'input>{
	fn borrow_mut(&mut self) -> &mut FrameBoundContextExt<'input> { &mut self.base }
}

impl<'input> FrameBoundContextAttrs<'input> for BoundedFrameContext<'input> {}

impl<'input> BoundedFrameContextExt<'input>{
	fn new(ctx: &dyn FrameBoundContextAttrs<'input>) -> Rc<FrameBoundContextAll<'input>>  {
		Rc::new(
			FrameBoundContextAll::BoundedFrameContext(
				BaseParserRuleContext::copy_from(ctx,BoundedFrameContextExt{
					boundType:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type UnboundedFrameContext<'input> = BaseParserRuleContext<'input,UnboundedFrameContextExt<'input>>;

pub trait UnboundedFrameContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token UNBOUNDED
	/// Returns `None` if there is no child corresponding to token UNBOUNDED
	fn UNBOUNDED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(UNBOUNDED, 0)
	}
	/// Retrieves first TerminalNode corresponding to token PRECEDING
	/// Returns `None` if there is no child corresponding to token PRECEDING
	fn PRECEDING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PRECEDING, 0)
	}
	/// Retrieves first TerminalNode corresponding to token FOLLOWING
	/// Returns `None` if there is no child corresponding to token FOLLOWING
	fn FOLLOWING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FOLLOWING, 0)
	}
}

impl<'input> UnboundedFrameContextAttrs<'input> for UnboundedFrameContext<'input>{}

pub struct UnboundedFrameContextExt<'input>{
	base:FrameBoundContextExt<'input>,
	pub boundType: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UnboundedFrameContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UnboundedFrameContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UnboundedFrameContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unboundedFrame(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_unboundedFrame(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UnboundedFrameContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_unboundedFrame(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnboundedFrameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_frameBound }
	//fn type_rule_index() -> usize where Self: Sized { RULE_frameBound }
}

impl<'input> Borrow<FrameBoundContextExt<'input>> for UnboundedFrameContext<'input>{
	fn borrow(&self) -> &FrameBoundContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<FrameBoundContextExt<'input>> for UnboundedFrameContext<'input>{
	fn borrow_mut(&mut self) -> &mut FrameBoundContextExt<'input> { &mut self.base }
}

impl<'input> FrameBoundContextAttrs<'input> for UnboundedFrameContext<'input> {}

impl<'input> UnboundedFrameContextExt<'input>{
	fn new(ctx: &dyn FrameBoundContextAttrs<'input>) -> Rc<FrameBoundContextAll<'input>>  {
		Rc::new(
			FrameBoundContextAll::UnboundedFrameContext(
				BaseParserRuleContext::copy_from(ctx,UnboundedFrameContextExt{
					boundType:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type CurrentRowBoundContext<'input> = BaseParserRuleContext<'input,CurrentRowBoundContextExt<'input>>;

pub trait CurrentRowBoundContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token CURRENT
	/// Returns `None` if there is no child corresponding to token CURRENT
	fn CURRENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(CURRENT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ROW
	/// Returns `None` if there is no child corresponding to token ROW
	fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ROW, 0)
	}
}

impl<'input> CurrentRowBoundContextAttrs<'input> for CurrentRowBoundContext<'input>{}

pub struct CurrentRowBoundContextExt<'input>{
	base:FrameBoundContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{CurrentRowBoundContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for CurrentRowBoundContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for CurrentRowBoundContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_currentRowBound(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_currentRowBound(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for CurrentRowBoundContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_currentRowBound(self);
	}
}

impl<'input> CustomRuleContext<'input> for CurrentRowBoundContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_frameBound }
	//fn type_rule_index() -> usize where Self: Sized { RULE_frameBound }
}

impl<'input> Borrow<FrameBoundContextExt<'input>> for CurrentRowBoundContext<'input>{
	fn borrow(&self) -> &FrameBoundContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<FrameBoundContextExt<'input>> for CurrentRowBoundContext<'input>{
	fn borrow_mut(&mut self) -> &mut FrameBoundContextExt<'input> { &mut self.base }
}

impl<'input> FrameBoundContextAttrs<'input> for CurrentRowBoundContext<'input> {}

impl<'input> CurrentRowBoundContextExt<'input>{
	fn new(ctx: &dyn FrameBoundContextAttrs<'input>) -> Rc<FrameBoundContextAll<'input>>  {
		Rc::new(
			FrameBoundContextAll::CurrentRowBoundContext(
				BaseParserRuleContext::copy_from(ctx,CurrentRowBoundContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn frameBound(&mut self,)
	-> Result<Rc<FrameBoundContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = FrameBoundContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 324, RULE_frameBound);
        let mut _localctx: Rc<FrameBoundContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5308);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(734,&mut recog.base)? {
				1 =>{
					let tmp = UnboundedFrameContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(5299);
					recog.base.match_token(UNBOUNDED,&mut recog.err_handler)?;

					recog.base.set_state(5300);
					let tmp = recog.base.match_token(PRECEDING,&mut recog.err_handler)?;
					if let FrameBoundContextAll::UnboundedFrameContext(ctx) = cast_mut::<_,FrameBoundContextAll >(&mut _localctx){
					ctx.boundType = Some(tmp); } else {unreachable!("cant cast");}  

					}
				}
			,
				2 =>{
					let tmp = UnboundedFrameContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5301);
					recog.base.match_token(UNBOUNDED,&mut recog.err_handler)?;

					recog.base.set_state(5302);
					let tmp = recog.base.match_token(FOLLOWING,&mut recog.err_handler)?;
					if let FrameBoundContextAll::UnboundedFrameContext(ctx) = cast_mut::<_,FrameBoundContextAll >(&mut _localctx){
					ctx.boundType = Some(tmp); } else {unreachable!("cant cast");}  

					}
				}
			,
				3 =>{
					let tmp = CurrentRowBoundContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(5303);
					recog.base.match_token(CURRENT,&mut recog.err_handler)?;

					recog.base.set_state(5304);
					recog.base.match_token(ROW,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					let tmp = BoundedFrameContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					/*InvokeRule expression*/
					recog.base.set_state(5305);
					recog.expression()?;

					recog.base.set_state(5306);
					if let FrameBoundContextAll::BoundedFrameContext(ctx) = cast_mut::<_,FrameBoundContextAll >(&mut _localctx){
					ctx.boundType = recog.base.input.lt(1).cloned(); } else {unreachable!("cant cast");} 
					_la = recog.base.input.la(1);
					if { !(_la==FOLLOWING || _la==PRECEDING) } {
						let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
						if let FrameBoundContextAll::BoundedFrameContext(ctx) = cast_mut::<_,FrameBoundContextAll >(&mut _localctx){
						ctx.boundType = Some(tmp); } else {unreachable!("cant cast");}  

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rowPattern ----------------
#[derive(Debug)]
pub enum RowPatternContextAll<'input>{
	QuantifiedPrimaryContext(QuantifiedPrimaryContext<'input>),
	PatternConcatenationContext(PatternConcatenationContext<'input>),
	PatternAlternationContext(PatternAlternationContext<'input>),
Error(RowPatternContext<'input>)
}
antlr_rust::tid!{RowPatternContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for RowPatternContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for RowPatternContextAll<'input>{}

impl<'input> Deref for RowPatternContextAll<'input>{
	type Target = dyn RowPatternContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use RowPatternContextAll::*;
		match self{
			QuantifiedPrimaryContext(inner) => inner,
			PatternConcatenationContext(inner) => inner,
			PatternAlternationContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RowPatternContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RowPatternContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type RowPatternContext<'input> = BaseParserRuleContext<'input,RowPatternContextExt<'input>>;

#[derive(Clone)]
pub struct RowPatternContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for RowPatternContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RowPatternContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RowPatternContext<'input>{
}

impl<'input> CustomRuleContext<'input> for RowPatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rowPattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rowPattern }
}
antlr_rust::tid!{RowPatternContextExt<'a>}

impl<'input> RowPatternContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RowPatternContextAll<'input>> {
		Rc::new(
		RowPatternContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RowPatternContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait RowPatternContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<RowPatternContextExt<'input>>{


}

impl<'input> RowPatternContextAttrs<'input> for RowPatternContext<'input>{}

pub type QuantifiedPrimaryContext<'input> = BaseParserRuleContext<'input,QuantifiedPrimaryContextExt<'input>>;

pub trait QuantifiedPrimaryContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn patternPrimary(&self) -> Option<Rc<PatternPrimaryContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn patternQuantifier(&self) -> Option<Rc<PatternQuantifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> QuantifiedPrimaryContextAttrs<'input> for QuantifiedPrimaryContext<'input>{}

pub struct QuantifiedPrimaryContextExt<'input>{
	base:RowPatternContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{QuantifiedPrimaryContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for QuantifiedPrimaryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QuantifiedPrimaryContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_quantifiedPrimary(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_quantifiedPrimary(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QuantifiedPrimaryContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_quantifiedPrimary(self);
	}
}

impl<'input> CustomRuleContext<'input> for QuantifiedPrimaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rowPattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rowPattern }
}

impl<'input> Borrow<RowPatternContextExt<'input>> for QuantifiedPrimaryContext<'input>{
	fn borrow(&self) -> &RowPatternContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<RowPatternContextExt<'input>> for QuantifiedPrimaryContext<'input>{
	fn borrow_mut(&mut self) -> &mut RowPatternContextExt<'input> { &mut self.base }
}

impl<'input> RowPatternContextAttrs<'input> for QuantifiedPrimaryContext<'input> {}

impl<'input> QuantifiedPrimaryContextExt<'input>{
	fn new(ctx: &dyn RowPatternContextAttrs<'input>) -> Rc<RowPatternContextAll<'input>>  {
		Rc::new(
			RowPatternContextAll::QuantifiedPrimaryContext(
				BaseParserRuleContext::copy_from(ctx,QuantifiedPrimaryContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PatternConcatenationContext<'input> = BaseParserRuleContext<'input,PatternConcatenationContextExt<'input>>;

pub trait PatternConcatenationContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn rowPattern_all(&self) ->  Vec<Rc<RowPatternContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn rowPattern(&self, i: usize) -> Option<Rc<RowPatternContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> PatternConcatenationContextAttrs<'input> for PatternConcatenationContext<'input>{}

pub struct PatternConcatenationContextExt<'input>{
	base:RowPatternContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PatternConcatenationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PatternConcatenationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternConcatenationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_patternConcatenation(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_patternConcatenation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternConcatenationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_patternConcatenation(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternConcatenationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rowPattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rowPattern }
}

impl<'input> Borrow<RowPatternContextExt<'input>> for PatternConcatenationContext<'input>{
	fn borrow(&self) -> &RowPatternContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<RowPatternContextExt<'input>> for PatternConcatenationContext<'input>{
	fn borrow_mut(&mut self) -> &mut RowPatternContextExt<'input> { &mut self.base }
}

impl<'input> RowPatternContextAttrs<'input> for PatternConcatenationContext<'input> {}

impl<'input> PatternConcatenationContextExt<'input>{
	fn new(ctx: &dyn RowPatternContextAttrs<'input>) -> Rc<RowPatternContextAll<'input>>  {
		Rc::new(
			RowPatternContextAll::PatternConcatenationContext(
				BaseParserRuleContext::copy_from(ctx,PatternConcatenationContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PatternAlternationContext<'input> = BaseParserRuleContext<'input,PatternAlternationContextExt<'input>>;

pub trait PatternAlternationContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn rowPattern_all(&self) ->  Vec<Rc<RowPatternContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn rowPattern(&self, i: usize) -> Option<Rc<RowPatternContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> PatternAlternationContextAttrs<'input> for PatternAlternationContext<'input>{}

pub struct PatternAlternationContextExt<'input>{
	base:RowPatternContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PatternAlternationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PatternAlternationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternAlternationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_patternAlternation(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_patternAlternation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternAlternationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_patternAlternation(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternAlternationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rowPattern }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rowPattern }
}

impl<'input> Borrow<RowPatternContextExt<'input>> for PatternAlternationContext<'input>{
	fn borrow(&self) -> &RowPatternContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<RowPatternContextExt<'input>> for PatternAlternationContext<'input>{
	fn borrow_mut(&mut self) -> &mut RowPatternContextExt<'input> { &mut self.base }
}

impl<'input> RowPatternContextAttrs<'input> for PatternAlternationContext<'input> {}

impl<'input> PatternAlternationContextExt<'input>{
	fn new(ctx: &dyn RowPatternContextAttrs<'input>) -> Rc<RowPatternContextAll<'input>>  {
		Rc::new(
			RowPatternContextAll::PatternAlternationContext(
				BaseParserRuleContext::copy_from(ctx,PatternAlternationContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  rowPattern(&mut self,)
	-> Result<Rc<RowPatternContextAll<'input>>,ANTLRError> {
		self.rowPattern_rec(0)
	}

	fn rowPattern_rec(&mut self, _p: isize)
	-> Result<Rc<RowPatternContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = RowPatternContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 326, RULE_rowPattern, _p);
	    let mut _localctx: Rc<RowPatternContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 326;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			{
			let mut tmp = QuantifiedPrimaryContextExt::new(&**_localctx);
			recog.ctx = Some(tmp.clone());
			_localctx = tmp;
			_prevctx = _localctx.clone();


			/*InvokeRule patternPrimary*/
			recog.base.set_state(5311);
			recog.patternPrimary()?;

			recog.base.set_state(5313);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(735,&mut recog.base)? {
				x if x == 1=>{
					{
					/*InvokeRule patternQuantifier*/
					recog.base.set_state(5312);
					recog.patternQuantifier()?;

					}
				}

				_ => {}
			}
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(5322);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(737,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(5320);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(736,&mut recog.base)? {
						1 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = PatternConcatenationContextExt::new(&**RowPatternContextExt::new(_parentctx.clone(), _parentState));
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_rowPattern);
							_localctx = tmp;
							recog.base.set_state(5315);
							if !({recog.precpred(None, 2)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 2)".to_owned()), None))?;
							}
							/*InvokeRule rowPattern*/
							recog.base.set_state(5316);
							recog.rowPattern_rec(3)?;

							}
						}
					,
						2 =>{
							{
							/*recRuleLabeledAltStartAction*/
							let mut tmp = PatternAlternationContextExt::new(&**RowPatternContextExt::new(_parentctx.clone(), _parentState));
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_rowPattern);
							_localctx = tmp;
							recog.base.set_state(5317);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(5318);
							recog.base.match_token(T__6,&mut recog.err_handler)?;

							/*InvokeRule rowPattern*/
							recog.base.set_state(5319);
							recog.rowPattern_rec(2)?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(5324);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(737,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- patternPrimary ----------------
#[derive(Debug)]
pub enum PatternPrimaryContextAll<'input>{
	PatternPermutationContext(PatternPermutationContext<'input>),
	PartitionEndAnchorContext(PartitionEndAnchorContext<'input>),
	PatternVariableContext(PatternVariableContext<'input>),
	ExcludedPatternContext(ExcludedPatternContext<'input>),
	PartitionStartAnchorContext(PartitionStartAnchorContext<'input>),
	EmptyPatternContext(EmptyPatternContext<'input>),
	GroupedPatternContext(GroupedPatternContext<'input>),
Error(PatternPrimaryContext<'input>)
}
antlr_rust::tid!{PatternPrimaryContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PatternPrimaryContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PatternPrimaryContextAll<'input>{}

impl<'input> Deref for PatternPrimaryContextAll<'input>{
	type Target = dyn PatternPrimaryContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PatternPrimaryContextAll::*;
		match self{
			PatternPermutationContext(inner) => inner,
			PartitionEndAnchorContext(inner) => inner,
			PatternVariableContext(inner) => inner,
			ExcludedPatternContext(inner) => inner,
			PartitionStartAnchorContext(inner) => inner,
			EmptyPatternContext(inner) => inner,
			GroupedPatternContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternPrimaryContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternPrimaryContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PatternPrimaryContext<'input> = BaseParserRuleContext<'input,PatternPrimaryContextExt<'input>>;

#[derive(Clone)]
pub struct PatternPrimaryContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PatternPrimaryContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternPrimaryContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternPrimaryContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PatternPrimaryContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}
antlr_rust::tid!{PatternPrimaryContextExt<'a>}

impl<'input> PatternPrimaryContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PatternPrimaryContextAll<'input>> {
		Rc::new(
		PatternPrimaryContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PatternPrimaryContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PatternPrimaryContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PatternPrimaryContextExt<'input>>{


}

impl<'input> PatternPrimaryContextAttrs<'input> for PatternPrimaryContext<'input>{}

pub type PatternPermutationContext<'input> = BaseParserRuleContext<'input,PatternPermutationContextExt<'input>>;

pub trait PatternPermutationContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token PERMUTE
	/// Returns `None` if there is no child corresponding to token PERMUTE
	fn PERMUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PERMUTE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn rowPattern_all(&self) ->  Vec<Rc<RowPatternContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn rowPattern(&self, i: usize) -> Option<Rc<RowPatternContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> PatternPermutationContextAttrs<'input> for PatternPermutationContext<'input>{}

pub struct PatternPermutationContextExt<'input>{
	base:PatternPrimaryContextExt<'input>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PatternPermutationContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PatternPermutationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternPermutationContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_patternPermutation(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_patternPermutation(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternPermutationContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_patternPermutation(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternPermutationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for PatternPermutationContext<'input>{
	fn borrow(&self) -> &PatternPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>> for PatternPermutationContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> PatternPrimaryContextAttrs<'input> for PatternPermutationContext<'input> {}

impl<'input> PatternPermutationContextExt<'input>{
	fn new(ctx: &dyn PatternPrimaryContextAttrs<'input>) -> Rc<PatternPrimaryContextAll<'input>>  {
		Rc::new(
			PatternPrimaryContextAll::PatternPermutationContext(
				BaseParserRuleContext::copy_from(ctx,PatternPermutationContextExt{
					tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PartitionEndAnchorContext<'input> = BaseParserRuleContext<'input,PartitionEndAnchorContextExt<'input>>;

pub trait PartitionEndAnchorContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DOLLAR
	/// Returns `None` if there is no child corresponding to token DOLLAR
	fn DOLLAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOLLAR, 0)
	}
}

impl<'input> PartitionEndAnchorContextAttrs<'input> for PartitionEndAnchorContext<'input>{}

pub struct PartitionEndAnchorContextExt<'input>{
	base:PatternPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PartitionEndAnchorContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PartitionEndAnchorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PartitionEndAnchorContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_partitionEndAnchor(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_partitionEndAnchor(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PartitionEndAnchorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_partitionEndAnchor(self);
	}
}

impl<'input> CustomRuleContext<'input> for PartitionEndAnchorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for PartitionEndAnchorContext<'input>{
	fn borrow(&self) -> &PatternPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>> for PartitionEndAnchorContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> PatternPrimaryContextAttrs<'input> for PartitionEndAnchorContext<'input> {}

impl<'input> PartitionEndAnchorContextExt<'input>{
	fn new(ctx: &dyn PatternPrimaryContextAttrs<'input>) -> Rc<PatternPrimaryContextAll<'input>>  {
		Rc::new(
			PatternPrimaryContextAll::PartitionEndAnchorContext(
				BaseParserRuleContext::copy_from(ctx,PartitionEndAnchorContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PatternVariableContext<'input> = BaseParserRuleContext<'input,PatternVariableContextExt<'input>>;

pub trait PatternVariableContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> PatternVariableContextAttrs<'input> for PatternVariableContext<'input>{}

pub struct PatternVariableContextExt<'input>{
	base:PatternPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PatternVariableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PatternVariableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternVariableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_patternVariable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_patternVariable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternVariableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_patternVariable(self);
	}
}

impl<'input> CustomRuleContext<'input> for PatternVariableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for PatternVariableContext<'input>{
	fn borrow(&self) -> &PatternPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>> for PatternVariableContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> PatternPrimaryContextAttrs<'input> for PatternVariableContext<'input> {}

impl<'input> PatternVariableContextExt<'input>{
	fn new(ctx: &dyn PatternPrimaryContextAttrs<'input>) -> Rc<PatternPrimaryContextAll<'input>>  {
		Rc::new(
			PatternPrimaryContextAll::PatternVariableContext(
				BaseParserRuleContext::copy_from(ctx,PatternVariableContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ExcludedPatternContext<'input> = BaseParserRuleContext<'input,ExcludedPatternContextExt<'input>>;

pub trait ExcludedPatternContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn rowPattern(&self) -> Option<Rc<RowPatternContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> ExcludedPatternContextAttrs<'input> for ExcludedPatternContext<'input>{}

pub struct ExcludedPatternContextExt<'input>{
	base:PatternPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ExcludedPatternContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ExcludedPatternContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ExcludedPatternContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_excludedPattern(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_excludedPattern(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ExcludedPatternContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_excludedPattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for ExcludedPatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for ExcludedPatternContext<'input>{
	fn borrow(&self) -> &PatternPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>> for ExcludedPatternContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> PatternPrimaryContextAttrs<'input> for ExcludedPatternContext<'input> {}

impl<'input> ExcludedPatternContextExt<'input>{
	fn new(ctx: &dyn PatternPrimaryContextAttrs<'input>) -> Rc<PatternPrimaryContextAll<'input>>  {
		Rc::new(
			PatternPrimaryContextAll::ExcludedPatternContext(
				BaseParserRuleContext::copy_from(ctx,ExcludedPatternContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type PartitionStartAnchorContext<'input> = BaseParserRuleContext<'input,PartitionStartAnchorContextExt<'input>>;

pub trait PartitionStartAnchorContextAttrs<'input>: SnowflakeParserContext<'input>{
}

impl<'input> PartitionStartAnchorContextAttrs<'input> for PartitionStartAnchorContext<'input>{}

pub struct PartitionStartAnchorContextExt<'input>{
	base:PatternPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{PartitionStartAnchorContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for PartitionStartAnchorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PartitionStartAnchorContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_partitionStartAnchor(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_partitionStartAnchor(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PartitionStartAnchorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_partitionStartAnchor(self);
	}
}

impl<'input> CustomRuleContext<'input> for PartitionStartAnchorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for PartitionStartAnchorContext<'input>{
	fn borrow(&self) -> &PatternPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>> for PartitionStartAnchorContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> PatternPrimaryContextAttrs<'input> for PartitionStartAnchorContext<'input> {}

impl<'input> PartitionStartAnchorContextExt<'input>{
	fn new(ctx: &dyn PatternPrimaryContextAttrs<'input>) -> Rc<PatternPrimaryContextAll<'input>>  {
		Rc::new(
			PatternPrimaryContextAll::PartitionStartAnchorContext(
				BaseParserRuleContext::copy_from(ctx,PartitionStartAnchorContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type EmptyPatternContext<'input> = BaseParserRuleContext<'input,EmptyPatternContextExt<'input>>;

pub trait EmptyPatternContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> EmptyPatternContextAttrs<'input> for EmptyPatternContext<'input>{}

pub struct EmptyPatternContextExt<'input>{
	base:PatternPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{EmptyPatternContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for EmptyPatternContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for EmptyPatternContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_emptyPattern(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_emptyPattern(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for EmptyPatternContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_emptyPattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for EmptyPatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for EmptyPatternContext<'input>{
	fn borrow(&self) -> &PatternPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>> for EmptyPatternContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> PatternPrimaryContextAttrs<'input> for EmptyPatternContext<'input> {}

impl<'input> EmptyPatternContextExt<'input>{
	fn new(ctx: &dyn PatternPrimaryContextAttrs<'input>) -> Rc<PatternPrimaryContextAll<'input>>  {
		Rc::new(
			PatternPrimaryContextAll::EmptyPatternContext(
				BaseParserRuleContext::copy_from(ctx,EmptyPatternContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type GroupedPatternContext<'input> = BaseParserRuleContext<'input,GroupedPatternContextExt<'input>>;

pub trait GroupedPatternContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn rowPattern(&self) -> Option<Rc<RowPatternContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> GroupedPatternContextAttrs<'input> for GroupedPatternContext<'input>{}

pub struct GroupedPatternContextExt<'input>{
	base:PatternPrimaryContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{GroupedPatternContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for GroupedPatternContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for GroupedPatternContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_groupedPattern(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_groupedPattern(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for GroupedPatternContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_groupedPattern(self);
	}
}

impl<'input> CustomRuleContext<'input> for GroupedPatternContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternPrimary }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternPrimary }
}

impl<'input> Borrow<PatternPrimaryContextExt<'input>> for GroupedPatternContext<'input>{
	fn borrow(&self) -> &PatternPrimaryContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternPrimaryContextExt<'input>> for GroupedPatternContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternPrimaryContextExt<'input> { &mut self.base }
}

impl<'input> PatternPrimaryContextAttrs<'input> for GroupedPatternContext<'input> {}

impl<'input> GroupedPatternContextExt<'input>{
	fn new(ctx: &dyn PatternPrimaryContextAttrs<'input>) -> Rc<PatternPrimaryContextAll<'input>>  {
		Rc::new(
			PatternPrimaryContextAll::GroupedPatternContext(
				BaseParserRuleContext::copy_from(ctx,GroupedPatternContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn patternPrimary(&mut self,)
	-> Result<Rc<PatternPrimaryContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PatternPrimaryContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 328, RULE_patternPrimary);
        let mut _localctx: Rc<PatternPrimaryContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(5353);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(740,&mut recog.base)? {
				1 =>{
					let tmp = PatternVariableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule identifier*/
					recog.base.set_state(5325);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					let tmp = EmptyPatternContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5326);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					recog.base.set_state(5327);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					let tmp = PatternPermutationContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(5328);
					recog.base.match_token(PERMUTE,&mut recog.err_handler)?;

					recog.base.set_state(5329);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule rowPattern*/
					recog.base.set_state(5330);
					recog.rowPattern_rec(0)?;

					recog.base.set_state(5335);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(738,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(5331);
							recog.base.match_token(COMMA,&mut recog.err_handler)?;

							/*InvokeRule rowPattern*/
							recog.base.set_state(5332);
							recog.rowPattern_rec(0)?;

							}
							} 
						}
						recog.base.set_state(5337);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(738,&mut recog.base)?;
					}
					recog.base.set_state(5339);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(5338);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let PatternPrimaryContextAll::PatternPermutationContext(ctx) = cast_mut::<_,PatternPrimaryContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(5341);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					let tmp = GroupedPatternContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					recog.base.set_state(5343);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule rowPattern*/
					recog.base.set_state(5344);
					recog.rowPattern_rec(0)?;

					recog.base.set_state(5345);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					let tmp = PartitionStartAnchorContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 5);
					_localctx = tmp;
					{
					recog.base.set_state(5347);
					recog.base.match_token(T__7,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					let tmp = PartitionEndAnchorContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 6);
					_localctx = tmp;
					{
					recog.base.set_state(5348);
					recog.base.match_token(DOLLAR,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					let tmp = ExcludedPatternContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 7);
					_localctx = tmp;
					{
					recog.base.set_state(5349);
					recog.base.match_token(T__8,&mut recog.err_handler)?;

					/*InvokeRule rowPattern*/
					recog.base.set_state(5350);
					recog.rowPattern_rec(0)?;

					recog.base.set_state(5351);
					recog.base.match_token(T__9,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- patternQuantifier ----------------
#[derive(Debug)]
pub enum PatternQuantifierContextAll<'input>{
	ZeroOrMoreQuantifierContext(ZeroOrMoreQuantifierContext<'input>),
	OneOrMoreQuantifierContext(OneOrMoreQuantifierContext<'input>),
	ZeroOrOneQuantifierContext(ZeroOrOneQuantifierContext<'input>),
	RangeQuantifierContext(RangeQuantifierContext<'input>),
Error(PatternQuantifierContext<'input>)
}
antlr_rust::tid!{PatternQuantifierContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PatternQuantifierContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PatternQuantifierContextAll<'input>{}

impl<'input> Deref for PatternQuantifierContextAll<'input>{
	type Target = dyn PatternQuantifierContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PatternQuantifierContextAll::*;
		match self{
			ZeroOrMoreQuantifierContext(inner) => inner,
			OneOrMoreQuantifierContext(inner) => inner,
			ZeroOrOneQuantifierContext(inner) => inner,
			RangeQuantifierContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternQuantifierContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternQuantifierContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PatternQuantifierContext<'input> = BaseParserRuleContext<'input,PatternQuantifierContextExt<'input>>;

#[derive(Clone)]
pub struct PatternQuantifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PatternQuantifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PatternQuantifierContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PatternQuantifierContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PatternQuantifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternQuantifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}
antlr_rust::tid!{PatternQuantifierContextExt<'a>}

impl<'input> PatternQuantifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PatternQuantifierContextAll<'input>> {
		Rc::new(
		PatternQuantifierContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PatternQuantifierContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PatternQuantifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PatternQuantifierContextExt<'input>>{


}

impl<'input> PatternQuantifierContextAttrs<'input> for PatternQuantifierContext<'input>{}

pub type ZeroOrMoreQuantifierContext<'input> = BaseParserRuleContext<'input,ZeroOrMoreQuantifierContextExt<'input>>;

pub trait ZeroOrMoreQuantifierContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ASTERISK
	/// Returns `None` if there is no child corresponding to token ASTERISK
	fn ASTERISK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ASTERISK, 0)
	}
	/// Retrieves first TerminalNode corresponding to token QUESTION_MARK
	/// Returns `None` if there is no child corresponding to token QUESTION_MARK
	fn QUESTION_MARK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(QUESTION_MARK, 0)
	}
}

impl<'input> ZeroOrMoreQuantifierContextAttrs<'input> for ZeroOrMoreQuantifierContext<'input>{}

pub struct ZeroOrMoreQuantifierContextExt<'input>{
	base:PatternQuantifierContextExt<'input>,
	pub reluctant: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ZeroOrMoreQuantifierContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ZeroOrMoreQuantifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ZeroOrMoreQuantifierContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_zeroOrMoreQuantifier(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_zeroOrMoreQuantifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ZeroOrMoreQuantifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_zeroOrMoreQuantifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ZeroOrMoreQuantifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternQuantifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}

impl<'input> Borrow<PatternQuantifierContextExt<'input>> for ZeroOrMoreQuantifierContext<'input>{
	fn borrow(&self) -> &PatternQuantifierContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternQuantifierContextExt<'input>> for ZeroOrMoreQuantifierContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternQuantifierContextExt<'input> { &mut self.base }
}

impl<'input> PatternQuantifierContextAttrs<'input> for ZeroOrMoreQuantifierContext<'input> {}

impl<'input> ZeroOrMoreQuantifierContextExt<'input>{
	fn new(ctx: &dyn PatternQuantifierContextAttrs<'input>) -> Rc<PatternQuantifierContextAll<'input>>  {
		Rc::new(
			PatternQuantifierContextAll::ZeroOrMoreQuantifierContext(
				BaseParserRuleContext::copy_from(ctx,ZeroOrMoreQuantifierContextExt{
					reluctant:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type OneOrMoreQuantifierContext<'input> = BaseParserRuleContext<'input,OneOrMoreQuantifierContextExt<'input>>;

pub trait OneOrMoreQuantifierContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token PLUS
	/// Returns `None` if there is no child corresponding to token PLUS
	fn PLUS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(PLUS, 0)
	}
	/// Retrieves first TerminalNode corresponding to token QUESTION_MARK
	/// Returns `None` if there is no child corresponding to token QUESTION_MARK
	fn QUESTION_MARK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(QUESTION_MARK, 0)
	}
}

impl<'input> OneOrMoreQuantifierContextAttrs<'input> for OneOrMoreQuantifierContext<'input>{}

pub struct OneOrMoreQuantifierContextExt<'input>{
	base:PatternQuantifierContextExt<'input>,
	pub reluctant: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{OneOrMoreQuantifierContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for OneOrMoreQuantifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for OneOrMoreQuantifierContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_oneOrMoreQuantifier(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_oneOrMoreQuantifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for OneOrMoreQuantifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_oneOrMoreQuantifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for OneOrMoreQuantifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternQuantifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}

impl<'input> Borrow<PatternQuantifierContextExt<'input>> for OneOrMoreQuantifierContext<'input>{
	fn borrow(&self) -> &PatternQuantifierContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternQuantifierContextExt<'input>> for OneOrMoreQuantifierContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternQuantifierContextExt<'input> { &mut self.base }
}

impl<'input> PatternQuantifierContextAttrs<'input> for OneOrMoreQuantifierContext<'input> {}

impl<'input> OneOrMoreQuantifierContextExt<'input>{
	fn new(ctx: &dyn PatternQuantifierContextAttrs<'input>) -> Rc<PatternQuantifierContextAll<'input>>  {
		Rc::new(
			PatternQuantifierContextAll::OneOrMoreQuantifierContext(
				BaseParserRuleContext::copy_from(ctx,OneOrMoreQuantifierContextExt{
					reluctant:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ZeroOrOneQuantifierContext<'input> = BaseParserRuleContext<'input,ZeroOrOneQuantifierContextExt<'input>>;

pub trait ZeroOrOneQuantifierContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves all `TerminalNode`s corresponding to token QUESTION_MARK in current rule
	fn QUESTION_MARK_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token QUESTION_MARK, starting from 0.
	/// Returns `None` if number of children corresponding to token QUESTION_MARK is less or equal than `i`.
	fn QUESTION_MARK(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(QUESTION_MARK, i)
	}
}

impl<'input> ZeroOrOneQuantifierContextAttrs<'input> for ZeroOrOneQuantifierContext<'input>{}

pub struct ZeroOrOneQuantifierContextExt<'input>{
	base:PatternQuantifierContextExt<'input>,
	pub reluctant: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ZeroOrOneQuantifierContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ZeroOrOneQuantifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ZeroOrOneQuantifierContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_zeroOrOneQuantifier(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_zeroOrOneQuantifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ZeroOrOneQuantifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_zeroOrOneQuantifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for ZeroOrOneQuantifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternQuantifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}

impl<'input> Borrow<PatternQuantifierContextExt<'input>> for ZeroOrOneQuantifierContext<'input>{
	fn borrow(&self) -> &PatternQuantifierContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternQuantifierContextExt<'input>> for ZeroOrOneQuantifierContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternQuantifierContextExt<'input> { &mut self.base }
}

impl<'input> PatternQuantifierContextAttrs<'input> for ZeroOrOneQuantifierContext<'input> {}

impl<'input> ZeroOrOneQuantifierContextExt<'input>{
	fn new(ctx: &dyn PatternQuantifierContextAttrs<'input>) -> Rc<PatternQuantifierContextAll<'input>>  {
		Rc::new(
			PatternQuantifierContextAll::ZeroOrOneQuantifierContext(
				BaseParserRuleContext::copy_from(ctx,ZeroOrOneQuantifierContextExt{
					reluctant:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RangeQuantifierContext<'input> = BaseParserRuleContext<'input,RangeQuantifierContextExt<'input>>;

pub trait RangeQuantifierContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves all `TerminalNode`s corresponding to token INTEGER_VALUE in current rule
	fn INTEGER_VALUE_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token INTEGER_VALUE, starting from 0.
	/// Returns `None` if number of children corresponding to token INTEGER_VALUE is less or equal than `i`.
	fn INTEGER_VALUE(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INTEGER_VALUE, i)
	}
	/// Retrieves first TerminalNode corresponding to token QUESTION_MARK
	/// Returns `None` if there is no child corresponding to token QUESTION_MARK
	fn QUESTION_MARK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(QUESTION_MARK, 0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
	fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
	/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
	fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, i)
	}
}

impl<'input> RangeQuantifierContextAttrs<'input> for RangeQuantifierContext<'input>{}

pub struct RangeQuantifierContextExt<'input>{
	base:PatternQuantifierContextExt<'input>,
	pub exactly: Option<TokenType<'input>>,
	pub reluctant: Option<TokenType<'input>>,
	pub atLeast: Option<TokenType<'input>>,
	pub atMost: Option<TokenType<'input>>,
	pub tail: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RangeQuantifierContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RangeQuantifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RangeQuantifierContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rangeQuantifier(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_rangeQuantifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RangeQuantifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rangeQuantifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for RangeQuantifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_patternQuantifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_patternQuantifier }
}

impl<'input> Borrow<PatternQuantifierContextExt<'input>> for RangeQuantifierContext<'input>{
	fn borrow(&self) -> &PatternQuantifierContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PatternQuantifierContextExt<'input>> for RangeQuantifierContext<'input>{
	fn borrow_mut(&mut self) -> &mut PatternQuantifierContextExt<'input> { &mut self.base }
}

impl<'input> PatternQuantifierContextAttrs<'input> for RangeQuantifierContext<'input> {}

impl<'input> RangeQuantifierContextExt<'input>{
	fn new(ctx: &dyn PatternQuantifierContextAttrs<'input>) -> Rc<PatternQuantifierContextAll<'input>>  {
		Rc::new(
			PatternQuantifierContextAll::RangeQuantifierContext(
				BaseParserRuleContext::copy_from(ctx,RangeQuantifierContextExt{
					exactly:None, reluctant:None, atLeast:None, atMost:None, tail:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn patternQuantifier(&mut self,)
	-> Result<Rc<PatternQuantifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PatternQuantifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 330, RULE_patternQuantifier);
        let mut _localctx: Rc<PatternQuantifierContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5388);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(749,&mut recog.base)? {
				1 =>{
					let tmp = ZeroOrMoreQuantifierContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(5355);
					recog.base.match_token(ASTERISK,&mut recog.err_handler)?;

					recog.base.set_state(5357);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(741,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5356);
							let tmp = recog.base.match_token(QUESTION_MARK,&mut recog.err_handler)?;
							if let PatternQuantifierContextAll::ZeroOrMoreQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					}
				}
			,
				2 =>{
					let tmp = OneOrMoreQuantifierContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5359);
					recog.base.match_token(PLUS,&mut recog.err_handler)?;

					recog.base.set_state(5361);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(742,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5360);
							let tmp = recog.base.match_token(QUESTION_MARK,&mut recog.err_handler)?;
							if let PatternQuantifierContextAll::OneOrMoreQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					}
				}
			,
				3 =>{
					let tmp = ZeroOrOneQuantifierContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(5363);
					recog.base.match_token(QUESTION_MARK,&mut recog.err_handler)?;

					recog.base.set_state(5365);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(743,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5364);
							let tmp = recog.base.match_token(QUESTION_MARK,&mut recog.err_handler)?;
							if let PatternQuantifierContextAll::ZeroOrOneQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					}
				}
			,
				4 =>{
					let tmp = RangeQuantifierContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					recog.base.set_state(5367);
					recog.base.match_token(T__2,&mut recog.err_handler)?;

					recog.base.set_state(5368);
					let tmp = recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;
					if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
					ctx.exactly = Some(tmp); } else {unreachable!("cant cast");}  

					recog.base.set_state(5369);
					recog.base.match_token(T__3,&mut recog.err_handler)?;

					recog.base.set_state(5371);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(744,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5370);
							let tmp = recog.base.match_token(QUESTION_MARK,&mut recog.err_handler)?;
							if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					}
				}
			,
				5 =>{
					let tmp = RangeQuantifierContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 5);
					_localctx = tmp;
					{
					recog.base.set_state(5373);
					recog.base.match_token(T__2,&mut recog.err_handler)?;

					recog.base.set_state(5375);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==INTEGER_VALUE {
						{
						recog.base.set_state(5374);
						let tmp = recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;
						if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
						ctx.atLeast = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(5377);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					recog.base.set_state(5379);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==INTEGER_VALUE {
						{
						recog.base.set_state(5378);
						let tmp = recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;
						if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
						ctx.atMost = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(5382);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==COMMA {
						{
						recog.base.set_state(5381);
						let tmp = recog.base.match_token(COMMA,&mut recog.err_handler)?;
						if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
						ctx.tail = Some(tmp); } else {unreachable!("cant cast");}  

						}
					}

					recog.base.set_state(5384);
					recog.base.match_token(T__3,&mut recog.err_handler)?;

					recog.base.set_state(5386);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(748,&mut recog.base)? {
						x if x == 1=>{
							{
							recog.base.set_state(5385);
							let tmp = recog.base.match_token(QUESTION_MARK,&mut recog.err_handler)?;
							if let PatternQuantifierContextAll::RangeQuantifierContext(ctx) = cast_mut::<_,PatternQuantifierContextAll >(&mut _localctx){
							ctx.reluctant = Some(tmp); } else {unreachable!("cant cast");}  

							}
						}

						_ => {}
					}
					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- transactionMode ----------------
#[derive(Debug)]
pub enum TransactionModeContextAll<'input>{
	TransactionAccessModeContext(TransactionAccessModeContext<'input>),
	IsolationLevelContext(IsolationLevelContext<'input>),
Error(TransactionModeContext<'input>)
}
antlr_rust::tid!{TransactionModeContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for TransactionModeContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for TransactionModeContextAll<'input>{}

impl<'input> Deref for TransactionModeContextAll<'input>{
	type Target = dyn TransactionModeContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use TransactionModeContextAll::*;
		match self{
			TransactionAccessModeContext(inner) => inner,
			IsolationLevelContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TransactionModeContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TransactionModeContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type TransactionModeContext<'input> = BaseParserRuleContext<'input,TransactionModeContextExt<'input>>;

#[derive(Clone)]
pub struct TransactionModeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for TransactionModeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TransactionModeContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TransactionModeContext<'input>{
}

impl<'input> CustomRuleContext<'input> for TransactionModeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_transactionMode }
	//fn type_rule_index() -> usize where Self: Sized { RULE_transactionMode }
}
antlr_rust::tid!{TransactionModeContextExt<'a>}

impl<'input> TransactionModeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<TransactionModeContextAll<'input>> {
		Rc::new(
		TransactionModeContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,TransactionModeContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait TransactionModeContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<TransactionModeContextExt<'input>>{


}

impl<'input> TransactionModeContextAttrs<'input> for TransactionModeContext<'input>{}

pub type TransactionAccessModeContext<'input> = BaseParserRuleContext<'input,TransactionAccessModeContextExt<'input>>;

pub trait TransactionAccessModeContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token READ
	/// Returns `None` if there is no child corresponding to token READ
	fn READ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(READ, 0)
	}
	/// Retrieves first TerminalNode corresponding to token ONLY
	/// Returns `None` if there is no child corresponding to token ONLY
	fn ONLY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ONLY, 0)
	}
	/// Retrieves first TerminalNode corresponding to token WRITE
	/// Returns `None` if there is no child corresponding to token WRITE
	fn WRITE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(WRITE, 0)
	}
}

impl<'input> TransactionAccessModeContextAttrs<'input> for TransactionAccessModeContext<'input>{}

pub struct TransactionAccessModeContextExt<'input>{
	base:TransactionModeContextExt<'input>,
	pub accessMode: Option<TokenType<'input>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{TransactionAccessModeContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for TransactionAccessModeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for TransactionAccessModeContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_transactionAccessMode(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_transactionAccessMode(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for TransactionAccessModeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_transactionAccessMode(self);
	}
}

impl<'input> CustomRuleContext<'input> for TransactionAccessModeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_transactionMode }
	//fn type_rule_index() -> usize where Self: Sized { RULE_transactionMode }
}

impl<'input> Borrow<TransactionModeContextExt<'input>> for TransactionAccessModeContext<'input>{
	fn borrow(&self) -> &TransactionModeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<TransactionModeContextExt<'input>> for TransactionAccessModeContext<'input>{
	fn borrow_mut(&mut self) -> &mut TransactionModeContextExt<'input> { &mut self.base }
}

impl<'input> TransactionModeContextAttrs<'input> for TransactionAccessModeContext<'input> {}

impl<'input> TransactionAccessModeContextExt<'input>{
	fn new(ctx: &dyn TransactionModeContextAttrs<'input>) -> Rc<TransactionModeContextAll<'input>>  {
		Rc::new(
			TransactionModeContextAll::TransactionAccessModeContext(
				BaseParserRuleContext::copy_from(ctx,TransactionAccessModeContextExt{
					accessMode:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type IsolationLevelContext<'input> = BaseParserRuleContext<'input,IsolationLevelContextExt<'input>>;

pub trait IsolationLevelContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ISOLATION
	/// Returns `None` if there is no child corresponding to token ISOLATION
	fn ISOLATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ISOLATION, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LEVEL
	/// Returns `None` if there is no child corresponding to token LEVEL
	fn LEVEL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LEVEL, 0)
	}
	fn levelOfIsolation(&self) -> Option<Rc<LevelOfIsolationContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> IsolationLevelContextAttrs<'input> for IsolationLevelContext<'input>{}

pub struct IsolationLevelContextExt<'input>{
	base:TransactionModeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{IsolationLevelContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for IsolationLevelContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IsolationLevelContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_isolationLevel(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_isolationLevel(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IsolationLevelContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_isolationLevel(self);
	}
}

impl<'input> CustomRuleContext<'input> for IsolationLevelContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_transactionMode }
	//fn type_rule_index() -> usize where Self: Sized { RULE_transactionMode }
}

impl<'input> Borrow<TransactionModeContextExt<'input>> for IsolationLevelContext<'input>{
	fn borrow(&self) -> &TransactionModeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<TransactionModeContextExt<'input>> for IsolationLevelContext<'input>{
	fn borrow_mut(&mut self) -> &mut TransactionModeContextExt<'input> { &mut self.base }
}

impl<'input> TransactionModeContextAttrs<'input> for IsolationLevelContext<'input> {}

impl<'input> IsolationLevelContextExt<'input>{
	fn new(ctx: &dyn TransactionModeContextAttrs<'input>) -> Rc<TransactionModeContextAll<'input>>  {
		Rc::new(
			TransactionModeContextAll::IsolationLevelContext(
				BaseParserRuleContext::copy_from(ctx,IsolationLevelContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn transactionMode(&mut self,)
	-> Result<Rc<TransactionModeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = TransactionModeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 332, RULE_transactionMode);
        let mut _localctx: Rc<TransactionModeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5395);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ISOLATION 
				=> {
					let tmp = IsolationLevelContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(5390);
					recog.base.match_token(ISOLATION,&mut recog.err_handler)?;

					recog.base.set_state(5391);
					recog.base.match_token(LEVEL,&mut recog.err_handler)?;

					/*InvokeRule levelOfIsolation*/
					recog.base.set_state(5392);
					recog.levelOfIsolation()?;

					}
				}

			 READ 
				=> {
					let tmp = TransactionAccessModeContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5393);
					recog.base.match_token(READ,&mut recog.err_handler)?;

					recog.base.set_state(5394);
					if let TransactionModeContextAll::TransactionAccessModeContext(ctx) = cast_mut::<_,TransactionModeContextAll >(&mut _localctx){
					ctx.accessMode = recog.base.input.lt(1).cloned(); } else {unreachable!("cant cast");} 
					_la = recog.base.input.la(1);
					if { !(_la==ONLY || _la==WRITE) } {
						let tmp = recog.err_handler.recover_inline(&mut recog.base)?;
						if let TransactionModeContextAll::TransactionAccessModeContext(ctx) = cast_mut::<_,TransactionModeContextAll >(&mut _localctx){
						ctx.accessMode = Some(tmp); } else {unreachable!("cant cast");}  

					}
					else {
						if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
						recog.err_handler.report_match(&mut recog.base);
						recog.base.consume(&mut recog.err_handler);
					}
					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- levelOfIsolation ----------------
#[derive(Debug)]
pub enum LevelOfIsolationContextAll<'input>{
	ReadUncommittedContext(ReadUncommittedContext<'input>),
	SerializableContext(SerializableContext<'input>),
	ReadCommittedContext(ReadCommittedContext<'input>),
	RepeatableReadContext(RepeatableReadContext<'input>),
Error(LevelOfIsolationContext<'input>)
}
antlr_rust::tid!{LevelOfIsolationContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for LevelOfIsolationContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for LevelOfIsolationContextAll<'input>{}

impl<'input> Deref for LevelOfIsolationContextAll<'input>{
	type Target = dyn LevelOfIsolationContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use LevelOfIsolationContextAll::*;
		match self{
			ReadUncommittedContext(inner) => inner,
			SerializableContext(inner) => inner,
			ReadCommittedContext(inner) => inner,
			RepeatableReadContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LevelOfIsolationContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LevelOfIsolationContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type LevelOfIsolationContext<'input> = BaseParserRuleContext<'input,LevelOfIsolationContextExt<'input>>;

#[derive(Clone)]
pub struct LevelOfIsolationContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for LevelOfIsolationContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for LevelOfIsolationContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for LevelOfIsolationContext<'input>{
}

impl<'input> CustomRuleContext<'input> for LevelOfIsolationContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_levelOfIsolation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}
antlr_rust::tid!{LevelOfIsolationContextExt<'a>}

impl<'input> LevelOfIsolationContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<LevelOfIsolationContextAll<'input>> {
		Rc::new(
		LevelOfIsolationContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,LevelOfIsolationContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait LevelOfIsolationContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<LevelOfIsolationContextExt<'input>>{


}

impl<'input> LevelOfIsolationContextAttrs<'input> for LevelOfIsolationContext<'input>{}

pub type ReadUncommittedContext<'input> = BaseParserRuleContext<'input,ReadUncommittedContextExt<'input>>;

pub trait ReadUncommittedContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token READ
	/// Returns `None` if there is no child corresponding to token READ
	fn READ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(READ, 0)
	}
	/// Retrieves first TerminalNode corresponding to token UNCOMMITTED
	/// Returns `None` if there is no child corresponding to token UNCOMMITTED
	fn UNCOMMITTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(UNCOMMITTED, 0)
	}
}

impl<'input> ReadUncommittedContextAttrs<'input> for ReadUncommittedContext<'input>{}

pub struct ReadUncommittedContextExt<'input>{
	base:LevelOfIsolationContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ReadUncommittedContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ReadUncommittedContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ReadUncommittedContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_readUncommitted(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_readUncommitted(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ReadUncommittedContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_readUncommitted(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReadUncommittedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_levelOfIsolation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}

impl<'input> Borrow<LevelOfIsolationContextExt<'input>> for ReadUncommittedContext<'input>{
	fn borrow(&self) -> &LevelOfIsolationContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<LevelOfIsolationContextExt<'input>> for ReadUncommittedContext<'input>{
	fn borrow_mut(&mut self) -> &mut LevelOfIsolationContextExt<'input> { &mut self.base }
}

impl<'input> LevelOfIsolationContextAttrs<'input> for ReadUncommittedContext<'input> {}

impl<'input> ReadUncommittedContextExt<'input>{
	fn new(ctx: &dyn LevelOfIsolationContextAttrs<'input>) -> Rc<LevelOfIsolationContextAll<'input>>  {
		Rc::new(
			LevelOfIsolationContextAll::ReadUncommittedContext(
				BaseParserRuleContext::copy_from(ctx,ReadUncommittedContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SerializableContext<'input> = BaseParserRuleContext<'input,SerializableContextExt<'input>>;

pub trait SerializableContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token SERIALIZABLE
	/// Returns `None` if there is no child corresponding to token SERIALIZABLE
	fn SERIALIZABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(SERIALIZABLE, 0)
	}
}

impl<'input> SerializableContextAttrs<'input> for SerializableContext<'input>{}

pub struct SerializableContextExt<'input>{
	base:LevelOfIsolationContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SerializableContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SerializableContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SerializableContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_serializable(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_serializable(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SerializableContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_serializable(self);
	}
}

impl<'input> CustomRuleContext<'input> for SerializableContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_levelOfIsolation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}

impl<'input> Borrow<LevelOfIsolationContextExt<'input>> for SerializableContext<'input>{
	fn borrow(&self) -> &LevelOfIsolationContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<LevelOfIsolationContextExt<'input>> for SerializableContext<'input>{
	fn borrow_mut(&mut self) -> &mut LevelOfIsolationContextExt<'input> { &mut self.base }
}

impl<'input> LevelOfIsolationContextAttrs<'input> for SerializableContext<'input> {}

impl<'input> SerializableContextExt<'input>{
	fn new(ctx: &dyn LevelOfIsolationContextAttrs<'input>) -> Rc<LevelOfIsolationContextAll<'input>>  {
		Rc::new(
			LevelOfIsolationContextAll::SerializableContext(
				BaseParserRuleContext::copy_from(ctx,SerializableContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type ReadCommittedContext<'input> = BaseParserRuleContext<'input,ReadCommittedContextExt<'input>>;

pub trait ReadCommittedContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token READ
	/// Returns `None` if there is no child corresponding to token READ
	fn READ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(READ, 0)
	}
	/// Retrieves first TerminalNode corresponding to token COMMITTED
	/// Returns `None` if there is no child corresponding to token COMMITTED
	fn COMMITTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMITTED, 0)
	}
}

impl<'input> ReadCommittedContextAttrs<'input> for ReadCommittedContext<'input>{}

pub struct ReadCommittedContextExt<'input>{
	base:LevelOfIsolationContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{ReadCommittedContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for ReadCommittedContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for ReadCommittedContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_readCommitted(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_readCommitted(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for ReadCommittedContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_readCommitted(self);
	}
}

impl<'input> CustomRuleContext<'input> for ReadCommittedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_levelOfIsolation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}

impl<'input> Borrow<LevelOfIsolationContextExt<'input>> for ReadCommittedContext<'input>{
	fn borrow(&self) -> &LevelOfIsolationContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<LevelOfIsolationContextExt<'input>> for ReadCommittedContext<'input>{
	fn borrow_mut(&mut self) -> &mut LevelOfIsolationContextExt<'input> { &mut self.base }
}

impl<'input> LevelOfIsolationContextAttrs<'input> for ReadCommittedContext<'input> {}

impl<'input> ReadCommittedContextExt<'input>{
	fn new(ctx: &dyn LevelOfIsolationContextAttrs<'input>) -> Rc<LevelOfIsolationContextAll<'input>>  {
		Rc::new(
			LevelOfIsolationContextAll::ReadCommittedContext(
				BaseParserRuleContext::copy_from(ctx,ReadCommittedContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RepeatableReadContext<'input> = BaseParserRuleContext<'input,RepeatableReadContextExt<'input>>;

pub trait RepeatableReadContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token REPEATABLE
	/// Returns `None` if there is no child corresponding to token REPEATABLE
	fn REPEATABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(REPEATABLE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token READ
	/// Returns `None` if there is no child corresponding to token READ
	fn READ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(READ, 0)
	}
}

impl<'input> RepeatableReadContextAttrs<'input> for RepeatableReadContext<'input>{}

pub struct RepeatableReadContextExt<'input>{
	base:LevelOfIsolationContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RepeatableReadContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RepeatableReadContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RepeatableReadContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_repeatableRead(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_repeatableRead(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RepeatableReadContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_repeatableRead(self);
	}
}

impl<'input> CustomRuleContext<'input> for RepeatableReadContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_levelOfIsolation }
	//fn type_rule_index() -> usize where Self: Sized { RULE_levelOfIsolation }
}

impl<'input> Borrow<LevelOfIsolationContextExt<'input>> for RepeatableReadContext<'input>{
	fn borrow(&self) -> &LevelOfIsolationContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<LevelOfIsolationContextExt<'input>> for RepeatableReadContext<'input>{
	fn borrow_mut(&mut self) -> &mut LevelOfIsolationContextExt<'input> { &mut self.base }
}

impl<'input> LevelOfIsolationContextAttrs<'input> for RepeatableReadContext<'input> {}

impl<'input> RepeatableReadContextExt<'input>{
	fn new(ctx: &dyn LevelOfIsolationContextAttrs<'input>) -> Rc<LevelOfIsolationContextAll<'input>>  {
		Rc::new(
			LevelOfIsolationContextAll::RepeatableReadContext(
				BaseParserRuleContext::copy_from(ctx,RepeatableReadContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn levelOfIsolation(&mut self,)
	-> Result<Rc<LevelOfIsolationContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = LevelOfIsolationContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 334, RULE_levelOfIsolation);
        let mut _localctx: Rc<LevelOfIsolationContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5404);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(751,&mut recog.base)? {
				1 =>{
					let tmp = ReadUncommittedContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(5397);
					recog.base.match_token(READ,&mut recog.err_handler)?;

					recog.base.set_state(5398);
					recog.base.match_token(UNCOMMITTED,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = ReadCommittedContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5399);
					recog.base.match_token(READ,&mut recog.err_handler)?;

					recog.base.set_state(5400);
					recog.base.match_token(COMMITTED,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					let tmp = RepeatableReadContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(5401);
					recog.base.match_token(REPEATABLE,&mut recog.err_handler)?;

					recog.base.set_state(5402);
					recog.base.match_token(READ,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					let tmp = SerializableContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					recog.base.set_state(5403);
					recog.base.match_token(SERIALIZABLE,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- privilege ----------------
pub type PrivilegeContextAll<'input> = PrivilegeContext<'input>;


pub type PrivilegeContext<'input> = BaseParserRuleContext<'input,PrivilegeContextExt<'input>>;

#[derive(Clone)]
pub struct PrivilegeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PrivilegeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PrivilegeContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_privilege(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_privilege(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PrivilegeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_privilege(self);
	}
}

impl<'input> CustomRuleContext<'input> for PrivilegeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_privilege }
	//fn type_rule_index() -> usize where Self: Sized { RULE_privilege }
}
antlr_rust::tid!{PrivilegeContextExt<'a>}

impl<'input> PrivilegeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrivilegeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrivilegeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PrivilegeContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PrivilegeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token CREATE
/// Returns `None` if there is no child corresponding to token CREATE
fn CREATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CREATE, 0)
}
/// Retrieves first TerminalNode corresponding to token SELECT
/// Returns `None` if there is no child corresponding to token SELECT
fn SELECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SELECT, 0)
}
/// Retrieves first TerminalNode corresponding to token DELETE
/// Returns `None` if there is no child corresponding to token DELETE
fn DELETE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DELETE, 0)
}
/// Retrieves first TerminalNode corresponding to token INSERT
/// Returns `None` if there is no child corresponding to token INSERT
fn INSERT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INSERT, 0)
}
/// Retrieves first TerminalNode corresponding to token UPDATE
/// Returns `None` if there is no child corresponding to token UPDATE
fn UPDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UPDATE, 0)
}

}

impl<'input> PrivilegeContextAttrs<'input> for PrivilegeContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn privilege(&mut self,)
	-> Result<Rc<PrivilegeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrivilegeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 336, RULE_privilege);
        let mut _localctx: Rc<PrivilegeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5406);
			_la = recog.base.input.la(1);
			if { !(_la==CREATE || _la==DELETE || _la==INSERT || _la==SELECT || _la==UPDATE) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- qualifiedName ----------------
#[derive(Debug)]
pub enum QualifiedNameContextAll<'input>{
	IdentifierFunctionContext(IdentifierFunctionContext<'input>),
	QualifiedNameDefaultContext(QualifiedNameDefaultContext<'input>),
Error(QualifiedNameContext<'input>)
}
antlr_rust::tid!{QualifiedNameContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for QualifiedNameContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for QualifiedNameContextAll<'input>{}

impl<'input> Deref for QualifiedNameContextAll<'input>{
	type Target = dyn QualifiedNameContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use QualifiedNameContextAll::*;
		match self{
			IdentifierFunctionContext(inner) => inner,
			QualifiedNameDefaultContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QualifiedNameContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QualifiedNameContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type QualifiedNameContext<'input> = BaseParserRuleContext<'input,QualifiedNameContextExt<'input>>;

#[derive(Clone)]
pub struct QualifiedNameContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QualifiedNameContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QualifiedNameContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QualifiedNameContext<'input>{
}

impl<'input> CustomRuleContext<'input> for QualifiedNameContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_qualifiedName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_qualifiedName }
}
antlr_rust::tid!{QualifiedNameContextExt<'a>}

impl<'input> QualifiedNameContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QualifiedNameContextAll<'input>> {
		Rc::new(
		QualifiedNameContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QualifiedNameContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait QualifiedNameContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QualifiedNameContextExt<'input>>{


}

impl<'input> QualifiedNameContextAttrs<'input> for QualifiedNameContext<'input>{}

pub type IdentifierFunctionContext<'input> = BaseParserRuleContext<'input,IdentifierFunctionContextExt<'input>>;

pub trait IdentifierFunctionContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token IDENTIFIER_KW
	/// Returns `None` if there is no child corresponding to token IDENTIFIER_KW
	fn IDENTIFIER_KW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IDENTIFIER_KW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
	fn string(&self) -> Option<Rc<StringContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> IdentifierFunctionContextAttrs<'input> for IdentifierFunctionContext<'input>{}

pub struct IdentifierFunctionContextExt<'input>{
	base:QualifiedNameContextExt<'input>,
	pub stringifiedQualifiedName: Option<Rc<StringContextAll<'input>>>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{IdentifierFunctionContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for IdentifierFunctionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IdentifierFunctionContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_identifierFunction(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_identifierFunction(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IdentifierFunctionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_identifierFunction(self);
	}
}

impl<'input> CustomRuleContext<'input> for IdentifierFunctionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_qualifiedName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_qualifiedName }
}

impl<'input> Borrow<QualifiedNameContextExt<'input>> for IdentifierFunctionContext<'input>{
	fn borrow(&self) -> &QualifiedNameContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<QualifiedNameContextExt<'input>> for IdentifierFunctionContext<'input>{
	fn borrow_mut(&mut self) -> &mut QualifiedNameContextExt<'input> { &mut self.base }
}

impl<'input> QualifiedNameContextAttrs<'input> for IdentifierFunctionContext<'input> {}

impl<'input> IdentifierFunctionContextExt<'input>{
	fn new(ctx: &dyn QualifiedNameContextAttrs<'input>) -> Rc<QualifiedNameContextAll<'input>>  {
		Rc::new(
			QualifiedNameContextAll::IdentifierFunctionContext(
				BaseParserRuleContext::copy_from(ctx,IdentifierFunctionContextExt{
        			stringifiedQualifiedName:None, 
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type QualifiedNameDefaultContext<'input> = BaseParserRuleContext<'input,QualifiedNameDefaultContextExt<'input>>;

pub trait QualifiedNameDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves all `TerminalNode`s corresponding to token DOT in current rule
	fn DOT_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
		self.children_of_type()
	}
	/// Retrieves 'i's TerminalNode corresponding to token DOT, starting from 0.
	/// Returns `None` if number of children corresponding to token DOT is less or equal than `i`.
	fn DOT(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOT, i)
	}
	fn pathComponent_all(&self) ->  Vec<Rc<PathComponentContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn pathComponent(&self, i: usize) -> Option<Rc<PathComponentContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
}

impl<'input> QualifiedNameDefaultContextAttrs<'input> for QualifiedNameDefaultContext<'input>{}

pub struct QualifiedNameDefaultContextExt<'input>{
	base:QualifiedNameContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{QualifiedNameDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for QualifiedNameDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QualifiedNameDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_qualifiedNameDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_qualifiedNameDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QualifiedNameDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_qualifiedNameDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for QualifiedNameDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_qualifiedName }
	//fn type_rule_index() -> usize where Self: Sized { RULE_qualifiedName }
}

impl<'input> Borrow<QualifiedNameContextExt<'input>> for QualifiedNameDefaultContext<'input>{
	fn borrow(&self) -> &QualifiedNameContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<QualifiedNameContextExt<'input>> for QualifiedNameDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut QualifiedNameContextExt<'input> { &mut self.base }
}

impl<'input> QualifiedNameContextAttrs<'input> for QualifiedNameDefaultContext<'input> {}

impl<'input> QualifiedNameDefaultContextExt<'input>{
	fn new(ctx: &dyn QualifiedNameContextAttrs<'input>) -> Rc<QualifiedNameContextAll<'input>>  {
		Rc::new(
			QualifiedNameContextAll::QualifiedNameDefaultContext(
				BaseParserRuleContext::copy_from(ctx,QualifiedNameDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn qualifiedName(&mut self,)
	-> Result<Rc<QualifiedNameContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QualifiedNameContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 338, RULE_qualifiedName);
        let mut _localctx: Rc<QualifiedNameContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			recog.base.set_state(5421);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(753,&mut recog.base)? {
				1 =>{
					let tmp = QualifiedNameDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule identifier*/
					recog.base.set_state(5408);
					recog.identifier()?;

					recog.base.set_state(5413);
					recog.err_handler.sync(&mut recog.base)?;
					_alt = recog.interpreter.adaptive_predict(752,&mut recog.base)?;
					while { _alt!=2 && _alt!=INVALID_ALT } {
						if _alt==1 {
							{
							{
							recog.base.set_state(5409);
							recog.base.match_token(DOT,&mut recog.err_handler)?;

							/*InvokeRule pathComponent*/
							recog.base.set_state(5410);
							recog.pathComponent()?;

							}
							} 
						}
						recog.base.set_state(5415);
						recog.err_handler.sync(&mut recog.base)?;
						_alt = recog.interpreter.adaptive_predict(752,&mut recog.base)?;
					}
					}
				}
			,
				2 =>{
					let tmp = IdentifierFunctionContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5416);
					recog.base.match_token(IDENTIFIER_KW,&mut recog.err_handler)?;

					recog.base.set_state(5417);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule string*/
					recog.base.set_state(5418);
					let tmp = recog.string()?;
					if let QualifiedNameContextAll::IdentifierFunctionContext(ctx) = cast_mut::<_,QualifiedNameContextAll >(&mut _localctx){
					ctx.stringifiedQualifiedName = Some(tmp.clone()); } else {unreachable!("cant cast");}  

					recog.base.set_state(5419);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pathExpression ----------------
pub type PathExpressionContextAll<'input> = PathExpressionContext<'input>;


pub type PathExpressionContext<'input> = BaseParserRuleContext<'input,PathExpressionContextExt<'input>>;

#[derive(Clone)]
pub struct PathExpressionContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PathExpressionContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PathExpressionContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pathExpression(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_pathExpression(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PathExpressionContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pathExpression(self);
	}
}

impl<'input> CustomRuleContext<'input> for PathExpressionContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pathExpression }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pathExpression }
}
antlr_rust::tid!{PathExpressionContextExt<'a>}

impl<'input> PathExpressionContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PathExpressionContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PathExpressionContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PathExpressionContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PathExpressionContextExt<'input>>{

fn qualifiedName(&self) -> Option<Rc<QualifiedNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PathExpressionContextAttrs<'input> for PathExpressionContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pathExpression(&mut self,)
	-> Result<Rc<PathExpressionContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PathExpressionContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 340, RULE_pathExpression);
        let mut _localctx: Rc<PathExpressionContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule qualifiedName*/
			recog.base.set_state(5423);
			recog.qualifiedName()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nonquotedIdentifier ----------------
pub type NonquotedIdentifierContextAll<'input> = NonquotedIdentifierContext<'input>;


pub type NonquotedIdentifierContext<'input> = BaseParserRuleContext<'input,NonquotedIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct NonquotedIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NonquotedIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NonquotedIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nonquotedIdentifier(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_nonquotedIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NonquotedIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_nonquotedIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for NonquotedIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonquotedIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonquotedIdentifier }
}
antlr_rust::tid!{NonquotedIdentifierContextExt<'a>}

impl<'input> NonquotedIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NonquotedIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NonquotedIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NonquotedIdentifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NonquotedIdentifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token IDENTIFIER
/// Returns `None` if there is no child corresponding to token IDENTIFIER
fn IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IDENTIFIER, 0)
}
fn nonReserved(&self) -> Option<Rc<NonReservedContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> NonquotedIdentifierContextAttrs<'input> for NonquotedIdentifierContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nonquotedIdentifier(&mut self,)
	-> Result<Rc<NonquotedIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NonquotedIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 342, RULE_nonquotedIdentifier);
        let mut _localctx: Rc<NonquotedIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5427);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 IDENTIFIER 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					recog.base.set_state(5425);
					recog.base.match_token(IDENTIFIER,&mut recog.err_handler)?;

					}
				}

			 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
			 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | AT | ATTACH | AUTHORIZATION | AUTO |
			 AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK | BOTH |
			 BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
			 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
			 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
			 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
			 CONSTRAINT | COPARTITION | COPY | COUNT | CUBE | CURRENT_ROLE | DATA |
			 DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
			 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
			 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
			 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC | EMPTY |
			 ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE | EVEN |
			 EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
			 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
			 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FUNCTION |
			 FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS | GRAPHVIZ |
			 GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
			 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
			 INFORMATION | INITIAL | INITIALLY | INPUT | INPUTFORMAT | INTERLEAVED |
			 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JSON | JSON_ARRAY |
			 JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS |
			 LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LEADING | LEVEL | LIBRARY |
			 LIMIT | LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
			 MATCH | MATCHED | MATCHES | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES |
			 MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME |
			 NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER | NORELY |
			 NORMALIZE | NOVALIDATE | NULLS | OBJECT | OFFSET | OMIT | ONE | ONLY |
			 OPTION | OPTIONS | ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT | OVER |
			 OVERFLOW | OWNER | PARTITION | PARTITIONED | PARTITIONS | PASSING | PAST |
			 PATH | PATTERN | PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE |
			 PIVOT | PLACING | POLICY | POSITION | PRECEDING | PRECISION | PREPARE |
			 PRIOR | PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON |
			 QUOTES | RANGE | READ | RECURSIVE | REFERENCE | REFERENCES | REFRESH |
			 RELY | RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT | RESTRICTED |
			 RETURN | RETURNING | RETURNS | RLS | ROLE | ROLES | ROLLBACK | ROLLUP |
			 RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY |
			 SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE |
			 SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL |
			 STAGE | STATEMENT | STATS | STORED | STREAM | STRICT | STRUCT | SUBSET |
			 SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY |
			 TERMINATED | TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING |
			 TARGET_LAG | TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST |
			 TUPLE | TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
			 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
			 UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING | VECTOR |
			 VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN |
			 WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE | ZSTD 
				=> {
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule nonReserved*/
					recog.base.set_state(5426);
					recog.nonReserved()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- dashedIdentifier ----------------
pub type DashedIdentifierContextAll<'input> = DashedIdentifierContext<'input>;


pub type DashedIdentifierContext<'input> = BaseParserRuleContext<'input,DashedIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct DashedIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for DashedIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DashedIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_dashedIdentifier(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_dashedIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DashedIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_dashedIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for DashedIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_dashedIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_dashedIdentifier }
}
antlr_rust::tid!{DashedIdentifierContextExt<'a>}

impl<'input> DashedIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<DashedIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,DashedIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait DashedIdentifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<DashedIdentifierContextExt<'input>>{

fn nonquotedIdentifier_all(&self) ->  Vec<Rc<NonquotedIdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn nonquotedIdentifier(&self, i: usize) -> Option<Rc<NonquotedIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token MINUS
/// Returns `None` if there is no child corresponding to token MINUS
fn MINUS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MINUS, 0)
}
/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTEGER_VALUE, 0)
}
/// Retrieves first TerminalNode corresponding to token DECIMAL_VALUE
/// Returns `None` if there is no child corresponding to token DECIMAL_VALUE
fn DECIMAL_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DECIMAL_VALUE, 0)
}
fn dashedIdentifier(&self) -> Option<Rc<DashedIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> DashedIdentifierContextAttrs<'input> for DashedIdentifierContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn  dashedIdentifier(&mut self,)
	-> Result<Rc<DashedIdentifierContextAll<'input>>,ANTLRError> {
		self.dashedIdentifier_rec(0)
	}

	fn dashedIdentifier_rec(&mut self, _p: isize)
	-> Result<Rc<DashedIdentifierContextAll<'input>>,ANTLRError> {
		let recog = self;
		let _parentctx = recog.ctx.take();
		let _parentState = recog.base.get_state();
		let mut _localctx = DashedIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
		recog.base.enter_recursion_rule(_localctx.clone(), 344, RULE_dashedIdentifier, _p);
	    let mut _localctx: Rc<DashedIdentifierContextAll> = _localctx;
        let mut _prevctx = _localctx.clone();
		let _startState = 344;
		let result: Result<(), ANTLRError> = (|| {
			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5443);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(755,&mut recog.base)? {
				1 =>{
					{
					/*InvokeRule nonquotedIdentifier*/
					recog.base.set_state(5430);
					recog.nonquotedIdentifier()?;

					recog.base.set_state(5431);
					recog.base.match_token(MINUS,&mut recog.err_handler)?;

					/*InvokeRule nonquotedIdentifier*/
					recog.base.set_state(5432);
					recog.nonquotedIdentifier()?;

					}
				}
			,
				2 =>{
					{
					/*InvokeRule nonquotedIdentifier*/
					recog.base.set_state(5434);
					recog.nonquotedIdentifier()?;

					recog.base.set_state(5435);
					recog.base.match_token(MINUS,&mut recog.err_handler)?;

					recog.base.set_state(5436);
					recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					{
					/*InvokeRule nonquotedIdentifier*/
					recog.base.set_state(5438);
					recog.nonquotedIdentifier()?;

					recog.base.set_state(5439);
					recog.base.match_token(MINUS,&mut recog.err_handler)?;

					recog.base.set_state(5440);
					recog.base.match_token(DECIMAL_VALUE,&mut recog.err_handler)?;

					/*InvokeRule nonquotedIdentifier*/
					recog.base.set_state(5441);
					recog.nonquotedIdentifier()?;

					}
				}

				_ => {}
			}

			let tmp = recog.input.lt(-1).cloned();
			recog.ctx.as_ref().unwrap().set_stop(tmp);
			recog.base.set_state(5457);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(757,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					recog.trigger_exit_rule_event();
					_prevctx = _localctx.clone();
					{
					recog.base.set_state(5455);
					recog.err_handler.sync(&mut recog.base)?;
					match  recog.interpreter.adaptive_predict(756,&mut recog.base)? {
						1 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = DashedIdentifierContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_dashedIdentifier);
							_localctx = tmp;
							recog.base.set_state(5445);
							if !({recog.precpred(None, 5)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 5)".to_owned()), None))?;
							}
							recog.base.set_state(5446);
							recog.base.match_token(MINUS,&mut recog.err_handler)?;

							/*InvokeRule nonquotedIdentifier*/
							recog.base.set_state(5447);
							recog.nonquotedIdentifier()?;

							}
						}
					,
						2 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = DashedIdentifierContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_dashedIdentifier);
							_localctx = tmp;
							recog.base.set_state(5448);
							if !({recog.precpred(None, 3)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 3)".to_owned()), None))?;
							}
							recog.base.set_state(5449);
							recog.base.match_token(MINUS,&mut recog.err_handler)?;

							recog.base.set_state(5450);
							recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;

							}
						}
					,
						3 =>{
							{
							/*recRuleAltStartAction*/
							let mut tmp = DashedIdentifierContextExt::new(_parentctx.clone(), _parentState);
							recog.push_new_recursion_context(tmp.clone(), _startState, RULE_dashedIdentifier);
							_localctx = tmp;
							recog.base.set_state(5451);
							if !({recog.precpred(None, 1)}) {
								Err(FailedPredicateError::new(&mut recog.base, Some("recog.precpred(None, 1)".to_owned()), None))?;
							}
							recog.base.set_state(5452);
							recog.base.match_token(MINUS,&mut recog.err_handler)?;

							recog.base.set_state(5453);
							recog.base.match_token(DECIMAL_VALUE,&mut recog.err_handler)?;

							/*InvokeRule nonquotedIdentifier*/
							recog.base.set_state(5454);
							recog.nonquotedIdentifier()?;

							}
						}

						_ => {}
					}
					} 
				}
				recog.base.set_state(5459);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(757,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_) => {},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re)=>{
			//_localctx.exception = re;
			recog.err_handler.report_error(&mut recog.base, re);
	        recog.err_handler.recover(&mut recog.base, re)?;}
		}
		recog.base.unroll_recursion_context(_parentctx);

		Ok(_localctx)
	}
}
//------------------- maybeDashedIdentifier ----------------
pub type MaybeDashedIdentifierContextAll<'input> = MaybeDashedIdentifierContext<'input>;


pub type MaybeDashedIdentifierContext<'input> = BaseParserRuleContext<'input,MaybeDashedIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct MaybeDashedIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for MaybeDashedIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for MaybeDashedIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_maybeDashedIdentifier(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_maybeDashedIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for MaybeDashedIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_maybeDashedIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for MaybeDashedIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_maybeDashedIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_maybeDashedIdentifier }
}
antlr_rust::tid!{MaybeDashedIdentifierContextExt<'a>}

impl<'input> MaybeDashedIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<MaybeDashedIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,MaybeDashedIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait MaybeDashedIdentifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<MaybeDashedIdentifierContextExt<'input>>{

fn nonquotedIdentifier(&self) -> Option<Rc<NonquotedIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
fn dashedIdentifier(&self) -> Option<Rc<DashedIdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> MaybeDashedIdentifierContextAttrs<'input> for MaybeDashedIdentifierContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn maybeDashedIdentifier(&mut self,)
	-> Result<Rc<MaybeDashedIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = MaybeDashedIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 346, RULE_maybeDashedIdentifier);
        let mut _localctx: Rc<MaybeDashedIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5462);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(758,&mut recog.base)? {
				1 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 1);
					recog.base.enter_outer_alt(None, 1);
					{
					/*InvokeRule nonquotedIdentifier*/
					recog.base.set_state(5460);
					recog.nonquotedIdentifier()?;

					}
				}
			,
				2 =>{
					//recog.base.enter_outer_alt(_localctx.clone(), 2);
					recog.base.enter_outer_alt(None, 2);
					{
					/*InvokeRule dashedIdentifier*/
					recog.base.set_state(5461);
					recog.dashedIdentifier_rec(0)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- queryPeriod ----------------
pub type QueryPeriodContextAll<'input> = QueryPeriodContext<'input>;


pub type QueryPeriodContext<'input> = BaseParserRuleContext<'input,QueryPeriodContextExt<'input>>;

#[derive(Clone)]
pub struct QueryPeriodContextExt<'input>{
	pub end: Option<Rc<ValueExpressionContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QueryPeriodContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QueryPeriodContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_queryPeriod(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_queryPeriod(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QueryPeriodContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_queryPeriod(self);
	}
}

impl<'input> CustomRuleContext<'input> for QueryPeriodContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_queryPeriod }
	//fn type_rule_index() -> usize where Self: Sized { RULE_queryPeriod }
}
antlr_rust::tid!{QueryPeriodContextExt<'a>}

impl<'input> QueryPeriodContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QueryPeriodContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QueryPeriodContextExt{
				end: None, 
				ph:PhantomData
			}),
		)
	}
}

pub trait QueryPeriodContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QueryPeriodContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token FOR
/// Returns `None` if there is no child corresponding to token FOR
fn FOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FOR, 0)
}
fn rangeType(&self) -> Option<Rc<RangeTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token AS
/// Returns `None` if there is no child corresponding to token AS
fn AS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AS, 0)
}
/// Retrieves first TerminalNode corresponding to token OF
/// Returns `None` if there is no child corresponding to token OF
fn OF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OF, 0)
}
fn valueExpression(&self) -> Option<Rc<ValueExpressionContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> QueryPeriodContextAttrs<'input> for QueryPeriodContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn queryPeriod(&mut self,)
	-> Result<Rc<QueryPeriodContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QueryPeriodContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 348, RULE_queryPeriod);
        let mut _localctx: Rc<QueryPeriodContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5464);
			recog.base.match_token(FOR,&mut recog.err_handler)?;

			/*InvokeRule rangeType*/
			recog.base.set_state(5465);
			recog.rangeType()?;

			recog.base.set_state(5466);
			recog.base.match_token(AS,&mut recog.err_handler)?;

			recog.base.set_state(5467);
			recog.base.match_token(OF,&mut recog.err_handler)?;

			/*InvokeRule valueExpression*/
			recog.base.set_state(5468);
			let tmp = recog.valueExpression_rec(0)?;
			 cast_mut::<_,QueryPeriodContext >(&mut _localctx).end = Some(tmp.clone());
			  

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- rangeType ----------------
pub type RangeTypeContextAll<'input> = RangeTypeContext<'input>;


pub type RangeTypeContext<'input> = BaseParserRuleContext<'input,RangeTypeContextExt<'input>>;

#[derive(Clone)]
pub struct RangeTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for RangeTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RangeTypeContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_rangeType(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_rangeType(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RangeTypeContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rangeType(self);
	}
}

impl<'input> CustomRuleContext<'input> for RangeTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_rangeType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_rangeType }
}
antlr_rust::tid!{RangeTypeContextExt<'a>}

impl<'input> RangeTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<RangeTypeContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,RangeTypeContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait RangeTypeContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<RangeTypeContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token TIMESTAMP
/// Returns `None` if there is no child corresponding to token TIMESTAMP
fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIMESTAMP, 0)
}
/// Retrieves first TerminalNode corresponding to token VERSION
/// Returns `None` if there is no child corresponding to token VERSION
fn VERSION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VERSION, 0)
}

}

impl<'input> RangeTypeContextAttrs<'input> for RangeTypeContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn rangeType(&mut self,)
	-> Result<Rc<RangeTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = RangeTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 350, RULE_rangeType);
        let mut _localctx: Rc<RangeTypeContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5470);
			_la = recog.base.input.la(1);
			if { !(_la==TIMESTAMP || _la==VERSION) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- principal ----------------
#[derive(Debug)]
pub enum PrincipalContextAll<'input>{
	UnspecifiedPrincipalContext(UnspecifiedPrincipalContext<'input>),
	UserPrincipalContext(UserPrincipalContext<'input>),
	RolePrincipalContext(RolePrincipalContext<'input>),
Error(PrincipalContext<'input>)
}
antlr_rust::tid!{PrincipalContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for PrincipalContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for PrincipalContextAll<'input>{}

impl<'input> Deref for PrincipalContextAll<'input>{
	type Target = dyn PrincipalContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use PrincipalContextAll::*;
		match self{
			UnspecifiedPrincipalContext(inner) => inner,
			UserPrincipalContext(inner) => inner,
			RolePrincipalContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PrincipalContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PrincipalContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type PrincipalContext<'input> = BaseParserRuleContext<'input,PrincipalContextExt<'input>>;

#[derive(Clone)]
pub struct PrincipalContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PrincipalContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PrincipalContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PrincipalContext<'input>{
}

impl<'input> CustomRuleContext<'input> for PrincipalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_principal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_principal }
}
antlr_rust::tid!{PrincipalContextExt<'a>}

impl<'input> PrincipalContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PrincipalContextAll<'input>> {
		Rc::new(
		PrincipalContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PrincipalContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait PrincipalContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PrincipalContextExt<'input>>{


}

impl<'input> PrincipalContextAttrs<'input> for PrincipalContext<'input>{}

pub type UnspecifiedPrincipalContext<'input> = BaseParserRuleContext<'input,UnspecifiedPrincipalContextExt<'input>>;

pub trait UnspecifiedPrincipalContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> UnspecifiedPrincipalContextAttrs<'input> for UnspecifiedPrincipalContext<'input>{}

pub struct UnspecifiedPrincipalContextExt<'input>{
	base:PrincipalContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UnspecifiedPrincipalContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UnspecifiedPrincipalContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UnspecifiedPrincipalContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unspecifiedPrincipal(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_unspecifiedPrincipal(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UnspecifiedPrincipalContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_unspecifiedPrincipal(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnspecifiedPrincipalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_principal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_principal }
}

impl<'input> Borrow<PrincipalContextExt<'input>> for UnspecifiedPrincipalContext<'input>{
	fn borrow(&self) -> &PrincipalContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrincipalContextExt<'input>> for UnspecifiedPrincipalContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrincipalContextExt<'input> { &mut self.base }
}

impl<'input> PrincipalContextAttrs<'input> for UnspecifiedPrincipalContext<'input> {}

impl<'input> UnspecifiedPrincipalContextExt<'input>{
	fn new(ctx: &dyn PrincipalContextAttrs<'input>) -> Rc<PrincipalContextAll<'input>>  {
		Rc::new(
			PrincipalContextAll::UnspecifiedPrincipalContext(
				BaseParserRuleContext::copy_from(ctx,UnspecifiedPrincipalContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type UserPrincipalContext<'input> = BaseParserRuleContext<'input,UserPrincipalContextExt<'input>>;

pub trait UserPrincipalContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token USER
	/// Returns `None` if there is no child corresponding to token USER
	fn USER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(USER, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> UserPrincipalContextAttrs<'input> for UserPrincipalContext<'input>{}

pub struct UserPrincipalContextExt<'input>{
	base:PrincipalContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UserPrincipalContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UserPrincipalContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UserPrincipalContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_userPrincipal(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_userPrincipal(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UserPrincipalContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_userPrincipal(self);
	}
}

impl<'input> CustomRuleContext<'input> for UserPrincipalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_principal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_principal }
}

impl<'input> Borrow<PrincipalContextExt<'input>> for UserPrincipalContext<'input>{
	fn borrow(&self) -> &PrincipalContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrincipalContextExt<'input>> for UserPrincipalContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrincipalContextExt<'input> { &mut self.base }
}

impl<'input> PrincipalContextAttrs<'input> for UserPrincipalContext<'input> {}

impl<'input> UserPrincipalContextExt<'input>{
	fn new(ctx: &dyn PrincipalContextAttrs<'input>) -> Rc<PrincipalContextAll<'input>>  {
		Rc::new(
			PrincipalContextAll::UserPrincipalContext(
				BaseParserRuleContext::copy_from(ctx,UserPrincipalContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type RolePrincipalContext<'input> = BaseParserRuleContext<'input,RolePrincipalContextExt<'input>>;

pub trait RolePrincipalContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ROLE
	/// Returns `None` if there is no child corresponding to token ROLE
	fn ROLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ROLE, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> RolePrincipalContextAttrs<'input> for RolePrincipalContext<'input>{}

pub struct RolePrincipalContextExt<'input>{
	base:PrincipalContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{RolePrincipalContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for RolePrincipalContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for RolePrincipalContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_rolePrincipal(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_rolePrincipal(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for RolePrincipalContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_rolePrincipal(self);
	}
}

impl<'input> CustomRuleContext<'input> for RolePrincipalContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_principal }
	//fn type_rule_index() -> usize where Self: Sized { RULE_principal }
}

impl<'input> Borrow<PrincipalContextExt<'input>> for RolePrincipalContext<'input>{
	fn borrow(&self) -> &PrincipalContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<PrincipalContextExt<'input>> for RolePrincipalContext<'input>{
	fn borrow_mut(&mut self) -> &mut PrincipalContextExt<'input> { &mut self.base }
}

impl<'input> PrincipalContextAttrs<'input> for RolePrincipalContext<'input> {}

impl<'input> RolePrincipalContextExt<'input>{
	fn new(ctx: &dyn PrincipalContextAttrs<'input>) -> Rc<PrincipalContextAll<'input>>  {
		Rc::new(
			PrincipalContextAll::RolePrincipalContext(
				BaseParserRuleContext::copy_from(ctx,RolePrincipalContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn principal(&mut self,)
	-> Result<Rc<PrincipalContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PrincipalContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 352, RULE_principal);
        let mut _localctx: Rc<PrincipalContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5477);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(759,&mut recog.base)? {
				1 =>{
					let tmp = UnspecifiedPrincipalContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule identifier*/
					recog.base.set_state(5472);
					recog.identifier()?;

					}
				}
			,
				2 =>{
					let tmp = UserPrincipalContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5473);
					recog.base.match_token(USER,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(5474);
					recog.identifier()?;

					}
				}
			,
				3 =>{
					let tmp = RolePrincipalContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(5475);
					recog.base.match_token(ROLE,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(5476);
					recog.identifier()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- identifier ----------------
#[derive(Debug)]
pub enum IdentifierContextAll<'input>{
	StrictNonReservedIdentifierContext(StrictNonReservedIdentifierContext<'input>),
	StrictIdentifierDefaultContext(StrictIdentifierDefaultContext<'input>),
Error(IdentifierContext<'input>)
}
antlr_rust::tid!{IdentifierContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for IdentifierContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for IdentifierContextAll<'input>{}

impl<'input> Deref for IdentifierContextAll<'input>{
	type Target = dyn IdentifierContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use IdentifierContextAll::*;
		match self{
			StrictNonReservedIdentifierContext(inner) => inner,
			StrictIdentifierDefaultContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IdentifierContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IdentifierContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type IdentifierContext<'input> = BaseParserRuleContext<'input,IdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for IdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IdentifierContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IdentifierContext<'input>{
}

impl<'input> CustomRuleContext<'input> for IdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}
antlr_rust::tid!{IdentifierContextExt<'a>}

impl<'input> IdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IdentifierContextAll<'input>> {
		Rc::new(
		IdentifierContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IdentifierContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait IdentifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<IdentifierContextExt<'input>>{


}

impl<'input> IdentifierContextAttrs<'input> for IdentifierContext<'input>{}

pub type StrictNonReservedIdentifierContext<'input> = BaseParserRuleContext<'input,StrictNonReservedIdentifierContextExt<'input>>;

pub trait StrictNonReservedIdentifierContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn strictNonReserved(&self) -> Option<Rc<StrictNonReservedContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> StrictNonReservedIdentifierContextAttrs<'input> for StrictNonReservedIdentifierContext<'input>{}

pub struct StrictNonReservedIdentifierContextExt<'input>{
	base:IdentifierContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{StrictNonReservedIdentifierContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for StrictNonReservedIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StrictNonReservedIdentifierContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_strictNonReservedIdentifier(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_strictNonReservedIdentifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StrictNonReservedIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_strictNonReservedIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for StrictNonReservedIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}

impl<'input> Borrow<IdentifierContextExt<'input>> for StrictNonReservedIdentifierContext<'input>{
	fn borrow(&self) -> &IdentifierContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<IdentifierContextExt<'input>> for StrictNonReservedIdentifierContext<'input>{
	fn borrow_mut(&mut self) -> &mut IdentifierContextExt<'input> { &mut self.base }
}

impl<'input> IdentifierContextAttrs<'input> for StrictNonReservedIdentifierContext<'input> {}

impl<'input> StrictNonReservedIdentifierContextExt<'input>{
	fn new(ctx: &dyn IdentifierContextAttrs<'input>) -> Rc<IdentifierContextAll<'input>>  {
		Rc::new(
			IdentifierContextAll::StrictNonReservedIdentifierContext(
				BaseParserRuleContext::copy_from(ctx,StrictNonReservedIdentifierContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type StrictIdentifierDefaultContext<'input> = BaseParserRuleContext<'input,StrictIdentifierDefaultContextExt<'input>>;

pub trait StrictIdentifierDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn strictIdentifier(&self) -> Option<Rc<StrictIdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> StrictIdentifierDefaultContextAttrs<'input> for StrictIdentifierDefaultContext<'input>{}

pub struct StrictIdentifierDefaultContextExt<'input>{
	base:IdentifierContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{StrictIdentifierDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for StrictIdentifierDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StrictIdentifierDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_strictIdentifierDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_strictIdentifierDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StrictIdentifierDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_strictIdentifierDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for StrictIdentifierDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifier }
}

impl<'input> Borrow<IdentifierContextExt<'input>> for StrictIdentifierDefaultContext<'input>{
	fn borrow(&self) -> &IdentifierContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<IdentifierContextExt<'input>> for StrictIdentifierDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut IdentifierContextExt<'input> { &mut self.base }
}

impl<'input> IdentifierContextAttrs<'input> for StrictIdentifierDefaultContext<'input> {}

impl<'input> StrictIdentifierDefaultContextExt<'input>{
	fn new(ctx: &dyn IdentifierContextAttrs<'input>) -> Rc<IdentifierContextAll<'input>>  {
		Rc::new(
			IdentifierContextAll::StrictIdentifierDefaultContext(
				BaseParserRuleContext::copy_from(ctx,StrictIdentifierDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn identifier(&mut self,)
	-> Result<Rc<IdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 354, RULE_identifier);
        let mut _localctx: Rc<IdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5481);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
			 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | AT | ATTACH | AUTHORIZATION | AUTO |
			 AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK | BOTH |
			 BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
			 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
			 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
			 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
			 CONSTRAINT | COPARTITION | COPY | COUNT | CUBE | CURRENT_ROLE | DATA |
			 DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
			 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
			 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
			 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC | EMPTY |
			 ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE | EVEN |
			 EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
			 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
			 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FUNCTION |
			 FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS | GRAPHVIZ |
			 GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
			 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
			 INFORMATION | INITIAL | INITIALLY | INPUT | INPUTFORMAT | INTERLEAVED |
			 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JSON | JSON_ARRAY |
			 JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS |
			 LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LEADING | LEVEL | LIBRARY |
			 LIMIT | LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
			 MATCH | MATCHED | MATCHES | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES |
			 MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME |
			 NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER | NORELY |
			 NORMALIZE | NOVALIDATE | NULLS | OBJECT | OFFSET | OMIT | ONE | ONLY |
			 OPTION | OPTIONS | ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT | OVER |
			 OVERFLOW | OWNER | PARTITION | PARTITIONED | PARTITIONS | PASSING | PAST |
			 PATH | PATTERN | PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE |
			 PIVOT | PLACING | POLICY | POSITION | PRECEDING | PRECISION | PREPARE |
			 PRIOR | PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON |
			 QUOTES | RANGE | READ | RECURSIVE | REFERENCE | REFERENCES | REFRESH |
			 RELY | RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT | RESTRICTED |
			 RETURN | RETURNING | RETURNS | RLS | ROLE | ROLES | ROLLBACK | ROLLUP |
			 RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY |
			 SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE |
			 SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL |
			 STAGE | STATEMENT | STATS | STORED | STREAM | STRICT | STRUCT | SUBSET |
			 SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY |
			 TERMINATED | TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING |
			 TARGET_LAG | TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST |
			 TUPLE | TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
			 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
			 UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING | VECTOR |
			 VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN |
			 WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE | ZSTD | IDENTIFIER |
			 QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
				=> {
					let tmp = StrictIdentifierDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					/*InvokeRule strictIdentifier*/
					recog.base.set_state(5479);
					recog.strictIdentifier()?;

					}
				}

			 ASOF | CROSS | FULL | INNER | JOIN | LATERAL | LEFT | MATCH_CONDITION |
			 NATURAL | RIGHT | USING 
				=> {
					let tmp = StrictNonReservedIdentifierContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule strictNonReserved*/
					recog.base.set_state(5480);
					recog.strictNonReserved()?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- strictIdentifier ----------------
#[derive(Debug)]
pub enum StrictIdentifierContextAll<'input>{
	QuotedIdentifierDefaultContext(QuotedIdentifierDefaultContext<'input>),
	UnquotedIdentifierContext(UnquotedIdentifierContext<'input>),
Error(StrictIdentifierContext<'input>)
}
antlr_rust::tid!{StrictIdentifierContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for StrictIdentifierContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for StrictIdentifierContextAll<'input>{}

impl<'input> Deref for StrictIdentifierContextAll<'input>{
	type Target = dyn StrictIdentifierContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use StrictIdentifierContextAll::*;
		match self{
			QuotedIdentifierDefaultContext(inner) => inner,
			UnquotedIdentifierContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StrictIdentifierContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StrictIdentifierContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type StrictIdentifierContext<'input> = BaseParserRuleContext<'input,StrictIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct StrictIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for StrictIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StrictIdentifierContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StrictIdentifierContext<'input>{
}

impl<'input> CustomRuleContext<'input> for StrictIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_strictIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_strictIdentifier }
}
antlr_rust::tid!{StrictIdentifierContextExt<'a>}

impl<'input> StrictIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StrictIdentifierContextAll<'input>> {
		Rc::new(
		StrictIdentifierContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StrictIdentifierContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait StrictIdentifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<StrictIdentifierContextExt<'input>>{


}

impl<'input> StrictIdentifierContextAttrs<'input> for StrictIdentifierContext<'input>{}

pub type QuotedIdentifierDefaultContext<'input> = BaseParserRuleContext<'input,QuotedIdentifierDefaultContextExt<'input>>;

pub trait QuotedIdentifierDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn quotedIdentifier(&self) -> Option<Rc<QuotedIdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> QuotedIdentifierDefaultContextAttrs<'input> for QuotedIdentifierDefaultContext<'input>{}

pub struct QuotedIdentifierDefaultContextExt<'input>{
	base:StrictIdentifierContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{QuotedIdentifierDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for QuotedIdentifierDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QuotedIdentifierDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_quotedIdentifierDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_quotedIdentifierDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QuotedIdentifierDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_quotedIdentifierDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for QuotedIdentifierDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_strictIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_strictIdentifier }
}

impl<'input> Borrow<StrictIdentifierContextExt<'input>> for QuotedIdentifierDefaultContext<'input>{
	fn borrow(&self) -> &StrictIdentifierContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StrictIdentifierContextExt<'input>> for QuotedIdentifierDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut StrictIdentifierContextExt<'input> { &mut self.base }
}

impl<'input> StrictIdentifierContextAttrs<'input> for QuotedIdentifierDefaultContext<'input> {}

impl<'input> QuotedIdentifierDefaultContextExt<'input>{
	fn new(ctx: &dyn StrictIdentifierContextAttrs<'input>) -> Rc<StrictIdentifierContextAll<'input>>  {
		Rc::new(
			StrictIdentifierContextAll::QuotedIdentifierDefaultContext(
				BaseParserRuleContext::copy_from(ctx,QuotedIdentifierDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type UnquotedIdentifierContext<'input> = BaseParserRuleContext<'input,UnquotedIdentifierContextExt<'input>>;

pub trait UnquotedIdentifierContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token IDENTIFIER
	/// Returns `None` if there is no child corresponding to token IDENTIFIER
	fn IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(IDENTIFIER, 0)
	}
	fn nonReserved(&self) -> Option<Rc<NonReservedContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token BACKQUOTED_IDENTIFIER
	/// Returns `None` if there is no child corresponding to token BACKQUOTED_IDENTIFIER
	fn BACKQUOTED_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(BACKQUOTED_IDENTIFIER, 0)
	}
}

impl<'input> UnquotedIdentifierContextAttrs<'input> for UnquotedIdentifierContext<'input>{}

pub struct UnquotedIdentifierContextExt<'input>{
	base:StrictIdentifierContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{UnquotedIdentifierContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for UnquotedIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for UnquotedIdentifierContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_unquotedIdentifier(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_unquotedIdentifier(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for UnquotedIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_unquotedIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for UnquotedIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_strictIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_strictIdentifier }
}

impl<'input> Borrow<StrictIdentifierContextExt<'input>> for UnquotedIdentifierContext<'input>{
	fn borrow(&self) -> &StrictIdentifierContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<StrictIdentifierContextExt<'input>> for UnquotedIdentifierContext<'input>{
	fn borrow_mut(&mut self) -> &mut StrictIdentifierContextExt<'input> { &mut self.base }
}

impl<'input> StrictIdentifierContextAttrs<'input> for UnquotedIdentifierContext<'input> {}

impl<'input> UnquotedIdentifierContextExt<'input>{
	fn new(ctx: &dyn StrictIdentifierContextAttrs<'input>) -> Rc<StrictIdentifierContextAll<'input>>  {
		Rc::new(
			StrictIdentifierContextAll::UnquotedIdentifierContext(
				BaseParserRuleContext::copy_from(ctx,UnquotedIdentifierContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn strictIdentifier(&mut self,)
	-> Result<Rc<StrictIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StrictIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 356, RULE_strictIdentifier);
        let mut _localctx: Rc<StrictIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5487);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 IDENTIFIER 
				=> {
					let tmp = UnquotedIdentifierContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(5483);
					recog.base.match_token(IDENTIFIER,&mut recog.err_handler)?;

					}
				}

			 QUOTED_IDENTIFIER 
				=> {
					let tmp = QuotedIdentifierDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					/*InvokeRule quotedIdentifier*/
					recog.base.set_state(5484);
					recog.quotedIdentifier()?;

					}
				}

			 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | APPEND_ONLY |
			 ARRAY | ARRAYAGG | ARRAY_AGG | ASC | AT | ATTACH | AUTHORIZATION | AUTO |
			 AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI | BLOCK | BOTH |
			 BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE | CASE_SENSITIVE |
			 CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR | CHARACTER | CLONE |
			 CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT | COMMITTED |
			 COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
			 CONSTRAINT | COPARTITION | COPY | COUNT | CUBE | CURRENT_ROLE | DATA |
			 DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
			 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
			 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
			 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC | EMPTY |
			 ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE | EVEN |
			 EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
			 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
			 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FUNCTION |
			 FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS | GRAPHVIZ |
			 GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
			 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
			 INFORMATION | INITIAL | INITIALLY | INPUT | INPUTFORMAT | INTERLEAVED |
			 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JSON | JSON_ARRAY |
			 JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP | KEY | KEYS |
			 LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LEADING | LEVEL | LIBRARY |
			 LIMIT | LINES | LISTAGG | LOCAL | LOCATION | LOCK | LOGICAL | MAP | MASKING |
			 MATCH | MATCHED | MATCHES | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES |
			 MEMORIZABLE | MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME |
			 NCHAR | NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER | NORELY |
			 NORMALIZE | NOVALIDATE | NULLS | OBJECT | OFFSET | OMIT | ONE | ONLY |
			 OPTION | OPTIONS | ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT | OVER |
			 OVERFLOW | OWNER | PARTITION | PARTITIONED | PARTITIONS | PASSING | PAST |
			 PATH | PATTERN | PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE |
			 PIVOT | PLACING | POLICY | POSITION | PRECEDING | PRECISION | PREPARE |
			 PRIOR | PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON |
			 QUOTES | RANGE | READ | RECURSIVE | REFERENCE | REFERENCES | REFRESH |
			 RELY | RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT | RESTRICTED |
			 RETURN | RETURNING | RETURNS | RLS | ROLE | ROLES | ROLLBACK | ROLLUP |
			 RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS | SECURE | SECURITY |
			 SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES | SERIALIZABLE |
			 SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT | SORTKEY | SQL |
			 STAGE | STATEMENT | STATS | STORED | STREAM | STRICT | STRUCT | SUBSET |
			 SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG | TEMP | TEMPLATE | TEMPORARY |
			 TERMINATED | TEXT | STRING_KW | TIES | TIME | TIMESTAMP | TOP | TRAILING |
			 TARGET_LAG | TRANSACTION | TRANSIENT | TRIM | TRUE | TRUNCATE | TRY_CAST |
			 TUPLE | TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED | UNCONDITIONAL | UNKNOWN |
			 UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET | UNSIGNED | USE | USER |
			 UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE | VALUE | VARYING | VECTOR |
			 VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE | WHEN | WINDOW | WITHIN |
			 WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR | YES | ZONE | ZSTD 
				=> {
					let tmp = UnquotedIdentifierContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					/*InvokeRule nonReserved*/
					recog.base.set_state(5485);
					recog.nonReserved()?;

					}
				}

			 BACKQUOTED_IDENTIFIER 
				=> {
					let tmp = UnquotedIdentifierContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					recog.base.set_state(5486);
					recog.base.match_token(BACKQUOTED_IDENTIFIER,&mut recog.err_handler)?;

					}
				}

				_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- quotedIdentifier ----------------
pub type QuotedIdentifierContextAll<'input> = QuotedIdentifierContext<'input>;


pub type QuotedIdentifierContext<'input> = BaseParserRuleContext<'input,QuotedIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct QuotedIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for QuotedIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for QuotedIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_quotedIdentifier(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_quotedIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for QuotedIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_quotedIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for QuotedIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_quotedIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_quotedIdentifier }
}
antlr_rust::tid!{QuotedIdentifierContextExt<'a>}

impl<'input> QuotedIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<QuotedIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,QuotedIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait QuotedIdentifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<QuotedIdentifierContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token QUOTED_IDENTIFIER
/// Returns `None` if there is no child corresponding to token QUOTED_IDENTIFIER
fn QUOTED_IDENTIFIER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(QUOTED_IDENTIFIER, 0)
}

}

impl<'input> QuotedIdentifierContextAttrs<'input> for QuotedIdentifierContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn quotedIdentifier(&mut self,)
	-> Result<Rc<QuotedIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = QuotedIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 358, RULE_quotedIdentifier);
        let mut _localctx: Rc<QuotedIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5489);
			recog.base.match_token(QUOTED_IDENTIFIER,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- pathComponent ----------------
pub type PathComponentContextAll<'input> = PathComponentContext<'input>;


pub type PathComponentContext<'input> = BaseParserRuleContext<'input,PathComponentContextExt<'input>>;

#[derive(Clone)]
pub struct PathComponentContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for PathComponentContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for PathComponentContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_pathComponent(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_pathComponent(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for PathComponentContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_pathComponent(self);
	}
}

impl<'input> CustomRuleContext<'input> for PathComponentContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_pathComponent }
	//fn type_rule_index() -> usize where Self: Sized { RULE_pathComponent }
}
antlr_rust::tid!{PathComponentContextExt<'a>}

impl<'input> PathComponentContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<PathComponentContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,PathComponentContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait PathComponentContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<PathComponentContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}

}

impl<'input> PathComponentContextAttrs<'input> for PathComponentContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn pathComponent(&mut self,)
	-> Result<Rc<PathComponentContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = PathComponentContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 360, RULE_pathComponent);
        let mut _localctx: Rc<PathComponentContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(5491);
			recog.identifier()?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- standaloneIdentifier ----------------
pub type StandaloneIdentifierContextAll<'input> = StandaloneIdentifierContext<'input>;


pub type StandaloneIdentifierContext<'input> = BaseParserRuleContext<'input,StandaloneIdentifierContextExt<'input>>;

#[derive(Clone)]
pub struct StandaloneIdentifierContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for StandaloneIdentifierContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StandaloneIdentifierContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_standaloneIdentifier(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_standaloneIdentifier(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StandaloneIdentifierContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_standaloneIdentifier(self);
	}
}

impl<'input> CustomRuleContext<'input> for StandaloneIdentifierContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_standaloneIdentifier }
	//fn type_rule_index() -> usize where Self: Sized { RULE_standaloneIdentifier }
}
antlr_rust::tid!{StandaloneIdentifierContextExt<'a>}

impl<'input> StandaloneIdentifierContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StandaloneIdentifierContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StandaloneIdentifierContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StandaloneIdentifierContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<StandaloneIdentifierContextExt<'input>>{

fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token EOF
/// Returns `None` if there is no child corresponding to token EOF
fn EOF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EOF, 0)
}

}

impl<'input> StandaloneIdentifierContextAttrs<'input> for StandaloneIdentifierContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn standaloneIdentifier(&mut self,)
	-> Result<Rc<StandaloneIdentifierContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StandaloneIdentifierContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 362, RULE_standaloneIdentifier);
        let mut _localctx: Rc<StandaloneIdentifierContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(5493);
			recog.identifier()?;

			recog.base.set_state(5494);
			recog.base.match_token(EOF,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- identifierList ----------------
pub type IdentifierListContextAll<'input> = IdentifierListContext<'input>;


pub type IdentifierListContext<'input> = BaseParserRuleContext<'input,IdentifierListContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for IdentifierListContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IdentifierListContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_identifierList(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_identifierList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IdentifierListContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_identifierList(self);
	}
}

impl<'input> CustomRuleContext<'input> for IdentifierListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifierList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifierList }
}
antlr_rust::tid!{IdentifierListContextExt<'a>}

impl<'input> IdentifierListContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IdentifierListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IdentifierListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IdentifierListContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<IdentifierListContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
fn identifierSeq(&self) -> Option<Rc<IdentifierSeqContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}

}

impl<'input> IdentifierListContextAttrs<'input> for IdentifierListContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn identifierList(&mut self,)
	-> Result<Rc<IdentifierListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IdentifierListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 364, RULE_identifierList);
        let mut _localctx: Rc<IdentifierListContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5496);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			/*InvokeRule identifierSeq*/
			recog.base.set_state(5497);
			recog.identifierSeq()?;

			recog.base.set_state(5498);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- identifierSeq ----------------
pub type IdentifierSeqContextAll<'input> = IdentifierSeqContext<'input>;


pub type IdentifierSeqContext<'input> = BaseParserRuleContext<'input,IdentifierSeqContextExt<'input>>;

#[derive(Clone)]
pub struct IdentifierSeqContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for IdentifierSeqContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IdentifierSeqContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_identifierSeq(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_identifierSeq(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IdentifierSeqContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_identifierSeq(self);
	}
}

impl<'input> CustomRuleContext<'input> for IdentifierSeqContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_identifierSeq }
	//fn type_rule_index() -> usize where Self: Sized { RULE_identifierSeq }
}
antlr_rust::tid!{IdentifierSeqContextExt<'a>}

impl<'input> IdentifierSeqContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<IdentifierSeqContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,IdentifierSeqContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait IdentifierSeqContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<IdentifierSeqContextExt<'input>>{

fn identifier_all(&self) ->  Vec<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn identifier(&self, i: usize) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> IdentifierSeqContextAttrs<'input> for IdentifierSeqContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn identifierSeq(&mut self,)
	-> Result<Rc<IdentifierSeqContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = IdentifierSeqContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 366, RULE_identifierSeq);
        let mut _localctx: Rc<IdentifierSeqContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			let mut _alt: isize;
			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule identifier*/
			recog.base.set_state(5500);
			recog.identifier()?;

			recog.base.set_state(5505);
			recog.err_handler.sync(&mut recog.base)?;
			_alt = recog.interpreter.adaptive_predict(762,&mut recog.base)?;
			while { _alt!=2 && _alt!=INVALID_ALT } {
				if _alt==1 {
					{
					{
					recog.base.set_state(5501);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(5502);
					recog.identifier()?;

					}
					} 
				}
				recog.base.set_state(5507);
				recog.err_handler.sync(&mut recog.base)?;
				_alt = recog.interpreter.adaptive_predict(762,&mut recog.base)?;
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- number ----------------
#[derive(Debug)]
pub enum NumberContextAll<'input>{
	DecimalLiteralContext(DecimalLiteralContext<'input>),
	DoubleLiteralContext(DoubleLiteralContext<'input>),
	IntegerLiteralContext(IntegerLiteralContext<'input>),
Error(NumberContext<'input>)
}
antlr_rust::tid!{NumberContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for NumberContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for NumberContextAll<'input>{}

impl<'input> Deref for NumberContextAll<'input>{
	type Target = dyn NumberContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use NumberContextAll::*;
		match self{
			DecimalLiteralContext(inner) => inner,
			DoubleLiteralContext(inner) => inner,
			IntegerLiteralContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NumberContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NumberContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type NumberContext<'input> = BaseParserRuleContext<'input,NumberContextExt<'input>>;

#[derive(Clone)]
pub struct NumberContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NumberContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NumberContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NumberContext<'input>{
}

impl<'input> CustomRuleContext<'input> for NumberContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_number }
	//fn type_rule_index() -> usize where Self: Sized { RULE_number }
}
antlr_rust::tid!{NumberContextExt<'a>}

impl<'input> NumberContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NumberContextAll<'input>> {
		Rc::new(
		NumberContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NumberContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait NumberContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NumberContextExt<'input>>{


}

impl<'input> NumberContextAttrs<'input> for NumberContext<'input>{}

pub type DecimalLiteralContext<'input> = BaseParserRuleContext<'input,DecimalLiteralContextExt<'input>>;

pub trait DecimalLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DECIMAL_VALUE
	/// Returns `None` if there is no child corresponding to token DECIMAL_VALUE
	fn DECIMAL_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DECIMAL_VALUE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MINUS
	/// Returns `None` if there is no child corresponding to token MINUS
	fn MINUS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MINUS, 0)
	}
}

impl<'input> DecimalLiteralContextAttrs<'input> for DecimalLiteralContext<'input>{}

pub struct DecimalLiteralContextExt<'input>{
	base:NumberContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DecimalLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DecimalLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DecimalLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_decimalLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_decimalLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DecimalLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_decimalLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for DecimalLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_number }
	//fn type_rule_index() -> usize where Self: Sized { RULE_number }
}

impl<'input> Borrow<NumberContextExt<'input>> for DecimalLiteralContext<'input>{
	fn borrow(&self) -> &NumberContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NumberContextExt<'input>> for DecimalLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut NumberContextExt<'input> { &mut self.base }
}

impl<'input> NumberContextAttrs<'input> for DecimalLiteralContext<'input> {}

impl<'input> DecimalLiteralContextExt<'input>{
	fn new(ctx: &dyn NumberContextAttrs<'input>) -> Rc<NumberContextAll<'input>>  {
		Rc::new(
			NumberContextAll::DecimalLiteralContext(
				BaseParserRuleContext::copy_from(ctx,DecimalLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type DoubleLiteralContext<'input> = BaseParserRuleContext<'input,DoubleLiteralContextExt<'input>>;

pub trait DoubleLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token DOUBLE_VALUE
	/// Returns `None` if there is no child corresponding to token DOUBLE_VALUE
	fn DOUBLE_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(DOUBLE_VALUE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MINUS
	/// Returns `None` if there is no child corresponding to token MINUS
	fn MINUS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MINUS, 0)
	}
}

impl<'input> DoubleLiteralContextAttrs<'input> for DoubleLiteralContext<'input>{}

pub struct DoubleLiteralContextExt<'input>{
	base:NumberContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{DoubleLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for DoubleLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for DoubleLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_doubleLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_doubleLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for DoubleLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_doubleLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for DoubleLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_number }
	//fn type_rule_index() -> usize where Self: Sized { RULE_number }
}

impl<'input> Borrow<NumberContextExt<'input>> for DoubleLiteralContext<'input>{
	fn borrow(&self) -> &NumberContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NumberContextExt<'input>> for DoubleLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut NumberContextExt<'input> { &mut self.base }
}

impl<'input> NumberContextAttrs<'input> for DoubleLiteralContext<'input> {}

impl<'input> DoubleLiteralContextExt<'input>{
	fn new(ctx: &dyn NumberContextAttrs<'input>) -> Rc<NumberContextAll<'input>>  {
		Rc::new(
			NumberContextAll::DoubleLiteralContext(
				BaseParserRuleContext::copy_from(ctx,DoubleLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type IntegerLiteralContext<'input> = BaseParserRuleContext<'input,IntegerLiteralContextExt<'input>>;

pub trait IntegerLiteralContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token INTEGER_VALUE
	/// Returns `None` if there is no child corresponding to token INTEGER_VALUE
	fn INTEGER_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(INTEGER_VALUE, 0)
	}
	/// Retrieves first TerminalNode corresponding to token MINUS
	/// Returns `None` if there is no child corresponding to token MINUS
	fn MINUS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MINUS, 0)
	}
}

impl<'input> IntegerLiteralContextAttrs<'input> for IntegerLiteralContext<'input>{}

pub struct IntegerLiteralContextExt<'input>{
	base:NumberContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{IntegerLiteralContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for IntegerLiteralContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for IntegerLiteralContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_integerLiteral(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_integerLiteral(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for IntegerLiteralContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_integerLiteral(self);
	}
}

impl<'input> CustomRuleContext<'input> for IntegerLiteralContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_number }
	//fn type_rule_index() -> usize where Self: Sized { RULE_number }
}

impl<'input> Borrow<NumberContextExt<'input>> for IntegerLiteralContext<'input>{
	fn borrow(&self) -> &NumberContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<NumberContextExt<'input>> for IntegerLiteralContext<'input>{
	fn borrow_mut(&mut self) -> &mut NumberContextExt<'input> { &mut self.base }
}

impl<'input> NumberContextAttrs<'input> for IntegerLiteralContext<'input> {}

impl<'input> IntegerLiteralContextExt<'input>{
	fn new(ctx: &dyn NumberContextAttrs<'input>) -> Rc<NumberContextAll<'input>>  {
		Rc::new(
			NumberContextAll::IntegerLiteralContext(
				BaseParserRuleContext::copy_from(ctx,IntegerLiteralContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn number(&mut self,)
	-> Result<Rc<NumberContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NumberContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 368, RULE_number);
        let mut _localctx: Rc<NumberContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5520);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(766,&mut recog.base)? {
				1 =>{
					let tmp = DecimalLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(5509);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==MINUS {
						{
						recog.base.set_state(5508);
						recog.base.match_token(MINUS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(5511);
					recog.base.match_token(DECIMAL_VALUE,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = DoubleLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5513);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==MINUS {
						{
						recog.base.set_state(5512);
						recog.base.match_token(MINUS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(5515);
					recog.base.match_token(DOUBLE_VALUE,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					let tmp = IntegerLiteralContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(5517);
					recog.err_handler.sync(&mut recog.base)?;
					_la = recog.base.input.la(1);
					if _la==MINUS {
						{
						recog.base.set_state(5516);
						recog.base.match_token(MINUS,&mut recog.err_handler)?;

						}
					}

					recog.base.set_state(5519);
					recog.base.match_token(INTEGER_VALUE,&mut recog.err_handler)?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- snowflakeShowFunctionType ----------------
#[derive(Debug)]
pub enum SnowflakeShowFunctionTypeContextAll<'input>{
	SnowflakeFunctionArgumentFloatContext(SnowflakeFunctionArgumentFloatContext<'input>),
	SnowflakeFunctionArgumentDefaultContext(SnowflakeFunctionArgumentDefaultContext<'input>),
	SnowflakeFunctionArgumentVectorContext(SnowflakeFunctionArgumentVectorContext<'input>),
	SnowflakeFunctionArgumentArrayContext(SnowflakeFunctionArgumentArrayContext<'input>),
	SnowflakeFunctionArgumentObjectContext(SnowflakeFunctionArgumentObjectContext<'input>),
	SnowflakeFunctionArgumentAnyContext(SnowflakeFunctionArgumentAnyContext<'input>),
	SnowflakeFunctionArgumentMapContext(SnowflakeFunctionArgumentMapContext<'input>),
Error(SnowflakeShowFunctionTypeContext<'input>)
}
antlr_rust::tid!{SnowflakeShowFunctionTypeContextAll<'a>}

impl<'input> antlr_rust::parser_rule_context::DerefSeal for SnowflakeShowFunctionTypeContextAll<'input>{}

impl<'input> SnowflakeParserContext<'input> for SnowflakeShowFunctionTypeContextAll<'input>{}

impl<'input> Deref for SnowflakeShowFunctionTypeContextAll<'input>{
	type Target = dyn SnowflakeShowFunctionTypeContextAttrs<'input> + 'input;
	fn deref(&self) -> &Self::Target{
		use SnowflakeShowFunctionTypeContextAll::*;
		match self{
			SnowflakeFunctionArgumentFloatContext(inner) => inner,
			SnowflakeFunctionArgumentDefaultContext(inner) => inner,
			SnowflakeFunctionArgumentVectorContext(inner) => inner,
			SnowflakeFunctionArgumentArrayContext(inner) => inner,
			SnowflakeFunctionArgumentObjectContext(inner) => inner,
			SnowflakeFunctionArgumentAnyContext(inner) => inner,
			SnowflakeFunctionArgumentMapContext(inner) => inner,
Error(inner) => inner
		}
	}
}
impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeShowFunctionTypeContextAll<'input>{
	fn accept(&self, visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) { self.deref().accept(visitor) }
}
impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeShowFunctionTypeContextAll<'input>{
    fn enter(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().enter(listener) }
    fn exit(&self, listener: &mut (dyn SnowflakeListener<'input> + 'a)) { self.deref().exit(listener) }
}



pub type SnowflakeShowFunctionTypeContext<'input> = BaseParserRuleContext<'input,SnowflakeShowFunctionTypeContextExt<'input>>;

#[derive(Clone)]
pub struct SnowflakeShowFunctionTypeContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SnowflakeShowFunctionTypeContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeShowFunctionTypeContext<'input>{
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeShowFunctionTypeContext<'input>{
}

impl<'input> CustomRuleContext<'input> for SnowflakeShowFunctionTypeContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionType }
}
antlr_rust::tid!{SnowflakeShowFunctionTypeContextExt<'a>}

impl<'input> SnowflakeShowFunctionTypeContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SnowflakeShowFunctionTypeContextAll<'input>> {
		Rc::new(
		SnowflakeShowFunctionTypeContextAll::Error(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SnowflakeShowFunctionTypeContextExt{
				ph:PhantomData
			}),
		)
		)
	}
}

pub trait SnowflakeShowFunctionTypeContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SnowflakeShowFunctionTypeContextExt<'input>>{


}

impl<'input> SnowflakeShowFunctionTypeContextAttrs<'input> for SnowflakeShowFunctionTypeContext<'input>{}

pub type SnowflakeFunctionArgumentFloatContext<'input> = BaseParserRuleContext<'input,SnowflakeFunctionArgumentFloatContextExt<'input>>;

pub trait SnowflakeFunctionArgumentFloatContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token FLOAT
	/// Returns `None` if there is no child corresponding to token FLOAT
	fn FLOAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(FLOAT, 0)
	}
}

impl<'input> SnowflakeFunctionArgumentFloatContextAttrs<'input> for SnowflakeFunctionArgumentFloatContext<'input>{}

pub struct SnowflakeFunctionArgumentFloatContextExt<'input>{
	base:SnowflakeShowFunctionTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeFunctionArgumentFloatContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeFunctionArgumentFloatContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeFunctionArgumentFloatContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeFunctionArgumentFloat(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeFunctionArgumentFloat(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeFunctionArgumentFloatContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeFunctionArgumentFloat(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeFunctionArgumentFloatContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionType }
}

impl<'input> Borrow<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentFloatContext<'input>{
	fn borrow(&self) -> &SnowflakeShowFunctionTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentFloatContext<'input>{
	fn borrow_mut(&mut self) -> &mut SnowflakeShowFunctionTypeContextExt<'input> { &mut self.base }
}

impl<'input> SnowflakeShowFunctionTypeContextAttrs<'input> for SnowflakeFunctionArgumentFloatContext<'input> {}

impl<'input> SnowflakeFunctionArgumentFloatContextExt<'input>{
	fn new(ctx: &dyn SnowflakeShowFunctionTypeContextAttrs<'input>) -> Rc<SnowflakeShowFunctionTypeContextAll<'input>>  {
		Rc::new(
			SnowflakeShowFunctionTypeContextAll::SnowflakeFunctionArgumentFloatContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeFunctionArgumentFloatContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeFunctionArgumentDefaultContext<'input> = BaseParserRuleContext<'input,SnowflakeFunctionArgumentDefaultContextExt<'input>>;

pub trait SnowflakeFunctionArgumentDefaultContextAttrs<'input>: SnowflakeParserContext<'input>{
	fn type_(&self) -> Option<Rc<Type_ContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
}

impl<'input> SnowflakeFunctionArgumentDefaultContextAttrs<'input> for SnowflakeFunctionArgumentDefaultContext<'input>{}

pub struct SnowflakeFunctionArgumentDefaultContextExt<'input>{
	base:SnowflakeShowFunctionTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeFunctionArgumentDefaultContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeFunctionArgumentDefaultContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeFunctionArgumentDefaultContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeFunctionArgumentDefault(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeFunctionArgumentDefault(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeFunctionArgumentDefaultContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeFunctionArgumentDefault(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeFunctionArgumentDefaultContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionType }
}

impl<'input> Borrow<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentDefaultContext<'input>{
	fn borrow(&self) -> &SnowflakeShowFunctionTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentDefaultContext<'input>{
	fn borrow_mut(&mut self) -> &mut SnowflakeShowFunctionTypeContextExt<'input> { &mut self.base }
}

impl<'input> SnowflakeShowFunctionTypeContextAttrs<'input> for SnowflakeFunctionArgumentDefaultContext<'input> {}

impl<'input> SnowflakeFunctionArgumentDefaultContextExt<'input>{
	fn new(ctx: &dyn SnowflakeShowFunctionTypeContextAttrs<'input>) -> Rc<SnowflakeShowFunctionTypeContextAll<'input>>  {
		Rc::new(
			SnowflakeShowFunctionTypeContextAll::SnowflakeFunctionArgumentDefaultContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeFunctionArgumentDefaultContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeFunctionArgumentVectorContext<'input> = BaseParserRuleContext<'input,SnowflakeFunctionArgumentVectorContextExt<'input>>;

pub trait SnowflakeFunctionArgumentVectorContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token VECTOR
	/// Returns `None` if there is no child corresponding to token VECTOR
	fn VECTOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(VECTOR, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn snowflakeShowFunctionType(&self) -> Option<Rc<SnowflakeShowFunctionTypeContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token COMMA
	/// Returns `None` if there is no child corresponding to token COMMA
	fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, 0)
	}
	fn number(&self) -> Option<Rc<NumberContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> SnowflakeFunctionArgumentVectorContextAttrs<'input> for SnowflakeFunctionArgumentVectorContext<'input>{}

pub struct SnowflakeFunctionArgumentVectorContextExt<'input>{
	base:SnowflakeShowFunctionTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeFunctionArgumentVectorContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeFunctionArgumentVectorContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeFunctionArgumentVectorContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeFunctionArgumentVector(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeFunctionArgumentVector(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeFunctionArgumentVectorContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeFunctionArgumentVector(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeFunctionArgumentVectorContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionType }
}

impl<'input> Borrow<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentVectorContext<'input>{
	fn borrow(&self) -> &SnowflakeShowFunctionTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentVectorContext<'input>{
	fn borrow_mut(&mut self) -> &mut SnowflakeShowFunctionTypeContextExt<'input> { &mut self.base }
}

impl<'input> SnowflakeShowFunctionTypeContextAttrs<'input> for SnowflakeFunctionArgumentVectorContext<'input> {}

impl<'input> SnowflakeFunctionArgumentVectorContextExt<'input>{
	fn new(ctx: &dyn SnowflakeShowFunctionTypeContextAttrs<'input>) -> Rc<SnowflakeShowFunctionTypeContextAll<'input>>  {
		Rc::new(
			SnowflakeShowFunctionTypeContextAll::SnowflakeFunctionArgumentVectorContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeFunctionArgumentVectorContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeFunctionArgumentArrayContext<'input> = BaseParserRuleContext<'input,SnowflakeFunctionArgumentArrayContextExt<'input>>;

pub trait SnowflakeFunctionArgumentArrayContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ROW
	/// Returns `None` if there is no child corresponding to token ROW
	fn ROW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ROW, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn snowflakeShowFunctionType(&self) -> Option<Rc<SnowflakeShowFunctionTypeContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> SnowflakeFunctionArgumentArrayContextAttrs<'input> for SnowflakeFunctionArgumentArrayContext<'input>{}

pub struct SnowflakeFunctionArgumentArrayContextExt<'input>{
	base:SnowflakeShowFunctionTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeFunctionArgumentArrayContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeFunctionArgumentArrayContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeFunctionArgumentArrayContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeFunctionArgumentArray(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeFunctionArgumentArray(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeFunctionArgumentArrayContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeFunctionArgumentArray(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeFunctionArgumentArrayContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionType }
}

impl<'input> Borrow<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentArrayContext<'input>{
	fn borrow(&self) -> &SnowflakeShowFunctionTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentArrayContext<'input>{
	fn borrow_mut(&mut self) -> &mut SnowflakeShowFunctionTypeContextExt<'input> { &mut self.base }
}

impl<'input> SnowflakeShowFunctionTypeContextAttrs<'input> for SnowflakeFunctionArgumentArrayContext<'input> {}

impl<'input> SnowflakeFunctionArgumentArrayContextExt<'input>{
	fn new(ctx: &dyn SnowflakeShowFunctionTypeContextAttrs<'input>) -> Rc<SnowflakeShowFunctionTypeContextAll<'input>>  {
		Rc::new(
			SnowflakeShowFunctionTypeContextAll::SnowflakeFunctionArgumentArrayContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeFunctionArgumentArrayContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeFunctionArgumentObjectContext<'input> = BaseParserRuleContext<'input,SnowflakeFunctionArgumentObjectContextExt<'input>>;

pub trait SnowflakeFunctionArgumentObjectContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token OBJECT
	/// Returns `None` if there is no child corresponding to token OBJECT
	fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(OBJECT, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn identifier(&self) -> Option<Rc<IdentifierContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	fn snowflakeShowFunctionType(&self) -> Option<Rc<SnowflakeShowFunctionTypeContextAll<'input>>> where Self:Sized{
		self.child_of_type(0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> SnowflakeFunctionArgumentObjectContextAttrs<'input> for SnowflakeFunctionArgumentObjectContext<'input>{}

pub struct SnowflakeFunctionArgumentObjectContextExt<'input>{
	base:SnowflakeShowFunctionTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeFunctionArgumentObjectContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeFunctionArgumentObjectContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeFunctionArgumentObjectContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeFunctionArgumentObject(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeFunctionArgumentObject(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeFunctionArgumentObjectContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeFunctionArgumentObject(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeFunctionArgumentObjectContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionType }
}

impl<'input> Borrow<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentObjectContext<'input>{
	fn borrow(&self) -> &SnowflakeShowFunctionTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentObjectContext<'input>{
	fn borrow_mut(&mut self) -> &mut SnowflakeShowFunctionTypeContextExt<'input> { &mut self.base }
}

impl<'input> SnowflakeShowFunctionTypeContextAttrs<'input> for SnowflakeFunctionArgumentObjectContext<'input> {}

impl<'input> SnowflakeFunctionArgumentObjectContextExt<'input>{
	fn new(ctx: &dyn SnowflakeShowFunctionTypeContextAttrs<'input>) -> Rc<SnowflakeShowFunctionTypeContextAll<'input>>  {
		Rc::new(
			SnowflakeShowFunctionTypeContextAll::SnowflakeFunctionArgumentObjectContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeFunctionArgumentObjectContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeFunctionArgumentAnyContext<'input> = BaseParserRuleContext<'input,SnowflakeFunctionArgumentAnyContextExt<'input>>;

pub trait SnowflakeFunctionArgumentAnyContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token ANY
	/// Returns `None` if there is no child corresponding to token ANY
	fn ANY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(ANY, 0)
	}
}

impl<'input> SnowflakeFunctionArgumentAnyContextAttrs<'input> for SnowflakeFunctionArgumentAnyContext<'input>{}

pub struct SnowflakeFunctionArgumentAnyContextExt<'input>{
	base:SnowflakeShowFunctionTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeFunctionArgumentAnyContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeFunctionArgumentAnyContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeFunctionArgumentAnyContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeFunctionArgumentAny(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeFunctionArgumentAny(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeFunctionArgumentAnyContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeFunctionArgumentAny(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeFunctionArgumentAnyContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionType }
}

impl<'input> Borrow<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentAnyContext<'input>{
	fn borrow(&self) -> &SnowflakeShowFunctionTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentAnyContext<'input>{
	fn borrow_mut(&mut self) -> &mut SnowflakeShowFunctionTypeContextExt<'input> { &mut self.base }
}

impl<'input> SnowflakeShowFunctionTypeContextAttrs<'input> for SnowflakeFunctionArgumentAnyContext<'input> {}

impl<'input> SnowflakeFunctionArgumentAnyContextExt<'input>{
	fn new(ctx: &dyn SnowflakeShowFunctionTypeContextAttrs<'input>) -> Rc<SnowflakeShowFunctionTypeContextAll<'input>>  {
		Rc::new(
			SnowflakeShowFunctionTypeContextAll::SnowflakeFunctionArgumentAnyContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeFunctionArgumentAnyContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

pub type SnowflakeFunctionArgumentMapContext<'input> = BaseParserRuleContext<'input,SnowflakeFunctionArgumentMapContextExt<'input>>;

pub trait SnowflakeFunctionArgumentMapContextAttrs<'input>: SnowflakeParserContext<'input>{
	/// Retrieves first TerminalNode corresponding to token MAP
	/// Returns `None` if there is no child corresponding to token MAP
	fn MAP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(MAP, 0)
	}
	/// Retrieves first TerminalNode corresponding to token LPAREN
	/// Returns `None` if there is no child corresponding to token LPAREN
	fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(LPAREN, 0)
	}
	fn snowflakeShowFunctionType_all(&self) ->  Vec<Rc<SnowflakeShowFunctionTypeContextAll<'input>>> where Self:Sized{
		self.children_of_type()
	}
	fn snowflakeShowFunctionType(&self, i: usize) -> Option<Rc<SnowflakeShowFunctionTypeContextAll<'input>>> where Self:Sized{
		self.child_of_type(i)
	}
	/// Retrieves first TerminalNode corresponding to token COMMA
	/// Returns `None` if there is no child corresponding to token COMMA
	fn COMMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(COMMA, 0)
	}
	/// Retrieves first TerminalNode corresponding to token RPAREN
	/// Returns `None` if there is no child corresponding to token RPAREN
	fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
		self.get_token(RPAREN, 0)
	}
}

impl<'input> SnowflakeFunctionArgumentMapContextAttrs<'input> for SnowflakeFunctionArgumentMapContext<'input>{}

pub struct SnowflakeFunctionArgumentMapContextExt<'input>{
	base:SnowflakeShowFunctionTypeContextExt<'input>,
	ph:PhantomData<&'input str>
}

antlr_rust::tid!{SnowflakeFunctionArgumentMapContextExt<'a>}

impl<'input> SnowflakeParserContext<'input> for SnowflakeFunctionArgumentMapContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeFunctionArgumentMapContext<'input>{
	fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.enter_every_rule(self);
		listener.enter_snowflakeFunctionArgumentMap(self);
	}
	fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
		listener.exit_snowflakeFunctionArgumentMap(self);
		listener.exit_every_rule(self);
	}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeFunctionArgumentMapContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeFunctionArgumentMap(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeFunctionArgumentMapContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionType }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionType }
}

impl<'input> Borrow<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentMapContext<'input>{
	fn borrow(&self) -> &SnowflakeShowFunctionTypeContextExt<'input> { &self.base }
}
impl<'input> BorrowMut<SnowflakeShowFunctionTypeContextExt<'input>> for SnowflakeFunctionArgumentMapContext<'input>{
	fn borrow_mut(&mut self) -> &mut SnowflakeShowFunctionTypeContextExt<'input> { &mut self.base }
}

impl<'input> SnowflakeShowFunctionTypeContextAttrs<'input> for SnowflakeFunctionArgumentMapContext<'input> {}

impl<'input> SnowflakeFunctionArgumentMapContextExt<'input>{
	fn new(ctx: &dyn SnowflakeShowFunctionTypeContextAttrs<'input>) -> Rc<SnowflakeShowFunctionTypeContextAll<'input>>  {
		Rc::new(
			SnowflakeShowFunctionTypeContextAll::SnowflakeFunctionArgumentMapContext(
				BaseParserRuleContext::copy_from(ctx,SnowflakeFunctionArgumentMapContextExt{
        			base: ctx.borrow().clone(),
        			ph:PhantomData
				})
			)
		)
	}
}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn snowflakeShowFunctionType(&mut self,)
	-> Result<Rc<SnowflakeShowFunctionTypeContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SnowflakeShowFunctionTypeContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 370, RULE_snowflakeShowFunctionType);
        let mut _localctx: Rc<SnowflakeShowFunctionTypeContextAll> = _localctx;
		let result: Result<(), ANTLRError> = (|| {

			recog.base.set_state(5550);
			recog.err_handler.sync(&mut recog.base)?;
			match  recog.interpreter.adaptive_predict(767,&mut recog.base)? {
				1 =>{
					let tmp = SnowflakeFunctionArgumentAnyContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 1);
					_localctx = tmp;
					{
					recog.base.set_state(5522);
					recog.base.match_token(ANY,&mut recog.err_handler)?;

					}
				}
			,
				2 =>{
					let tmp = SnowflakeFunctionArgumentArrayContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 2);
					_localctx = tmp;
					{
					recog.base.set_state(5523);
					recog.base.match_token(ROW,&mut recog.err_handler)?;

					recog.base.set_state(5524);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule snowflakeShowFunctionType*/
					recog.base.set_state(5525);
					recog.snowflakeShowFunctionType()?;

					recog.base.set_state(5526);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				3 =>{
					let tmp = SnowflakeFunctionArgumentObjectContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 3);
					_localctx = tmp;
					{
					recog.base.set_state(5528);
					recog.base.match_token(OBJECT,&mut recog.err_handler)?;

					recog.base.set_state(5529);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule identifier*/
					recog.base.set_state(5530);
					recog.identifier()?;

					/*InvokeRule snowflakeShowFunctionType*/
					recog.base.set_state(5531);
					recog.snowflakeShowFunctionType()?;

					recog.base.set_state(5532);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				4 =>{
					let tmp = SnowflakeFunctionArgumentMapContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 4);
					_localctx = tmp;
					{
					recog.base.set_state(5534);
					recog.base.match_token(MAP,&mut recog.err_handler)?;

					recog.base.set_state(5535);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule snowflakeShowFunctionType*/
					recog.base.set_state(5536);
					recog.snowflakeShowFunctionType()?;

					recog.base.set_state(5537);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule snowflakeShowFunctionType*/
					recog.base.set_state(5538);
					recog.snowflakeShowFunctionType()?;

					recog.base.set_state(5539);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				5 =>{
					let tmp = SnowflakeFunctionArgumentVectorContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 5);
					_localctx = tmp;
					{
					recog.base.set_state(5541);
					recog.base.match_token(VECTOR,&mut recog.err_handler)?;

					recog.base.set_state(5542);
					recog.base.match_token(LPAREN,&mut recog.err_handler)?;

					/*InvokeRule snowflakeShowFunctionType*/
					recog.base.set_state(5543);
					recog.snowflakeShowFunctionType()?;

					recog.base.set_state(5544);
					recog.base.match_token(COMMA,&mut recog.err_handler)?;

					/*InvokeRule number*/
					recog.base.set_state(5545);
					recog.number()?;

					recog.base.set_state(5546);
					recog.base.match_token(RPAREN,&mut recog.err_handler)?;

					}
				}
			,
				6 =>{
					let tmp = SnowflakeFunctionArgumentFloatContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 6);
					_localctx = tmp;
					{
					recog.base.set_state(5548);
					recog.base.match_token(FLOAT,&mut recog.err_handler)?;

					}
				}
			,
				7 =>{
					let tmp = SnowflakeFunctionArgumentDefaultContextExt::new(&**_localctx);
					recog.base.enter_outer_alt(Some(tmp.clone()), 7);
					_localctx = tmp;
					{
					/*InvokeRule type_*/
					recog.base.set_state(5549);
					recog.type_()?;

					}
				}

				_ => {}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- snowflakeShowFunctionArguments ----------------
pub type SnowflakeShowFunctionArgumentsContextAll<'input> = SnowflakeShowFunctionArgumentsContext<'input>;


pub type SnowflakeShowFunctionArgumentsContext<'input> = BaseParserRuleContext<'input,SnowflakeShowFunctionArgumentsContextExt<'input>>;

#[derive(Clone)]
pub struct SnowflakeShowFunctionArgumentsContextExt<'input>{
	pub snowflakeShowFunctionType: Option<Rc<SnowflakeShowFunctionTypeContextAll<'input>>>,
	pub required:Vec<Rc<SnowflakeShowFunctionTypeContextAll<'input>>>,
	pub optional:Vec<Rc<SnowflakeShowFunctionTypeContextAll<'input>>>,
	pub return_: Option<Rc<SnowflakeShowFunctionTypeContextAll<'input>>>,
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SnowflakeShowFunctionArgumentsContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeShowFunctionArgumentsContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_snowflakeShowFunctionArguments(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_snowflakeShowFunctionArguments(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeShowFunctionArgumentsContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeShowFunctionArguments(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeShowFunctionArgumentsContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionArguments }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionArguments }
}
antlr_rust::tid!{SnowflakeShowFunctionArgumentsContextExt<'a>}

impl<'input> SnowflakeShowFunctionArgumentsContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SnowflakeShowFunctionArgumentsContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SnowflakeShowFunctionArgumentsContextExt{
				snowflakeShowFunctionType: None, return_: None, 
				required: Vec::new(), optional: Vec::new(), 
				ph:PhantomData
			}),
		)
	}
}

pub trait SnowflakeShowFunctionArgumentsContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SnowflakeShowFunctionArgumentsContextExt<'input>>{

fn functionName(&self) -> Option<Rc<FunctionNameContextAll<'input>>> where Self:Sized{
	self.child_of_type(0)
}
/// Retrieves first TerminalNode corresponding to token LPAREN
/// Returns `None` if there is no child corresponding to token LPAREN
fn LPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RPAREN
/// Returns `None` if there is no child corresponding to token RPAREN
fn RPAREN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RPAREN, 0)
}
/// Retrieves first TerminalNode corresponding to token RETURN
/// Returns `None` if there is no child corresponding to token RETURN
fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RETURN, 0)
}
fn snowflakeShowFunctionType_all(&self) ->  Vec<Rc<SnowflakeShowFunctionTypeContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn snowflakeShowFunctionType(&self, i: usize) -> Option<Rc<SnowflakeShowFunctionTypeContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves first TerminalNode corresponding to token LBRACKET
/// Returns `None` if there is no child corresponding to token LBRACKET
fn LBRACKET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LBRACKET, 0)
}
/// Retrieves all `TerminalNode`s corresponding to token RBRACKET in current rule
fn RBRACKET_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token RBRACKET, starting from 0.
/// Returns `None` if number of children corresponding to token RBRACKET is less or equal than `i`.
fn RBRACKET(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RBRACKET, i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> SnowflakeShowFunctionArgumentsContextAttrs<'input> for SnowflakeShowFunctionArgumentsContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn snowflakeShowFunctionArguments(&mut self,)
	-> Result<Rc<SnowflakeShowFunctionArgumentsContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SnowflakeShowFunctionArgumentsContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 372, RULE_snowflakeShowFunctionArguments);
        let mut _localctx: Rc<SnowflakeShowFunctionArgumentsContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule functionName*/
			recog.base.set_state(5552);
			recog.functionName()?;

			recog.base.set_state(5553);
			recog.base.match_token(LPAREN,&mut recog.err_handler)?;

			recog.base.set_state(5559);
			recog.err_handler.sync(&mut recog.base)?;
			match recog.base.input.la(1) {
			 ABORT | ABSENT | ACCESS | ADD | ADMIN | AFTER | ANALYZE | ANTI | ANY |
			 APPEND_ONLY | ARRAY | ARRAYAGG | ARRAY_AGG | ASC | ASOF | AT | ATTACH |
			 AUTHORIZATION | AUTO | AUTOINCREMENT | BACKUP | BEFORE | BEGIN | BERNOULLI |
			 BLOCK | BOTH | BZIP2 | CALL | CALLED | CALLER | CANCEL | CASCADE | CASE |
			 CASE_SENSITIVE | CASE_INSENSITIVE | CAST | CATALOGS | CHANGES | CHAR |
			 CHARACTER | CLONE | CLOSE | CLUSTER | COLLATE | COLUMNS | COMMENT | COMMIT |
			 COMMITTED | COMPOUND | COMPRESSION | CONDITIONAL | CONNECTION | CONNECT_BY_ROOT |
			 CONSTRAINT | COPARTITION | COPY | COUNT | CROSS | CUBE | CURRENT_ROLE |
			 DATA | DATABASE | DATASHARE | DAY | DEALLOCATE | DECLARE | DECODE | DEFAULT |
			 DEFAULTS | DEFINE | DEFINER | DELIMITED | DELIMITER | DENY | DEFERRABLE |
			 DEFERRED | DESC | DESCRIBE | DESCRIPTOR | DIRECTORY | DISABLE | DISTKEY |
			 DISTRIBUTED | DISTSTYLE | DETACH | DOWNSTREAM | DOUBLE | DYNAMIC | EMPTY |
			 ENABLE | ENCODE | ENCODING | END | ENFORCED | ERROR | ESCAPE | EVEN |
			 EVENT | EXCEPT | EXCLUDE | EXCLUDING | EXECUTE | EXPLAIN | EXTERNAL |
			 EXTRACT | FALSE | FETCH | FIELDS | FILE_FORMAT | FILES | FILTER | FINAL |
			 FIRST | FIRST_VALUE | FLOAT | FOREIGN | FORMAT | FORMAT_NAME | FULL |
			 FUNCTION | FUNCTIONS | GENERATED | GLOBAL | GRACE | GRANTED | GRANTS |
			 GRAPHVIZ | GROUPING | GROUPS | GZIP | HEADER | HOUR | ICEBERG | IDENTIFIER_KW |
			 IDENTITY | IF | IGNORE | IMMEDIATE | IMMUTABLE | INCLUDE | INCLUDING |
			 INFORMATION | INITIAL | INITIALLY | INNER | INPUT | INPUTFORMAT | INTERLEAVED |
			 INTERVAL | INVOKER | IO | ISOLATION | JAVA | JAVASCRIPT | JOIN | JSON |
			 JSON_ARRAY | JSON_EXISTS | JSON_OBJECT | JSON_QUERY | JSON_VALUE | KEEP |
			 KEY | KEYS | LAG | LAMBDA | LANGUAGE | LAST | LAST_VALUE | LATERAL |
			 LEADING | LEFT | LEVEL | LIBRARY | LIMIT | LINES | LISTAGG | LOCAL |
			 LOCATION | LOCK | LOGICAL | MAP | MASKING | MATCH | MATCHED | MATCHES |
			 MATCH_CONDITION | MATCH_RECOGNIZE | MATERIALIZED | MAX | MEASURES | MEMORIZABLE |
			 MERGE | MINHASH | MINUTE | MOD | MODEL | MONTH | NAME | NATURAL | NCHAR |
			 NEXT | NFC | NFD | NFKC | NFKD | NO | NONE | NOORDER | NORELY | NORMALIZE |
			 NOVALIDATE | NULL | NULLS | OBJECT | OFFSET | OMIT | ONE | ONLY | OPTION |
			 OPTIONS | ORDINALITY | OUTER | OUTPUT | OUTPUTFORMAT | OVER | OVERFLOW |
			 OWNER | PARTITION | PARTITIONED | PARTITIONS | PASSING | PAST | PATH |
			 PATTERN | PER | PERCENTILE_CONT | PERCENTILE_DISC | PERIOD | PERMUTE |
			 PIVOT | PLACING | POLICY | POSITION | PRECEDING | PRECISION | PREPARE |
			 PRIOR | PROCEDURE | PRIMARY | PRIVILEGES | PROPERTIES | PRUNE | PYTHON |
			 QUOTES | RANGE | READ | RECURSIVE | REFERENCE | REFERENCES | REFRESH |
			 RELY | RENAME | REPEATABLE | REPLACE | RESET | RESPECT | RESTRICT | RESTRICTED |
			 RETURN | RETURNING | RETURNS | RIGHT | RLS | ROLE | ROLES | ROLLBACK |
			 ROLLUP | ROW | RUNNING | SCALA | SCALAR | SECOND | SCHEMA | SCHEMAS |
			 SECURE | SECURITY | SEED | SEEK | SEMI | SEQUENCE | SERDE | SERDEPROPERTIES |
			 SERIALIZABLE | SESSION | SETS | SHOW | SIMILAR | SKIP_KW | SNAPSHOT |
			 SORTKEY | SQL | STAGE | STATEMENT | STATS | STORED | STREAM | STRICT |
			 STRUCT | SUBSET | SUBSTRING | SYSTEM | SYSTEM_TIME | TABLES | TAG | TEMP |
			 TEMPLATE | TEMPORARY | TERMINATED | TEXT | STRING_KW | TIES | TIME |
			 TIMESTAMP | TOP | TRAILING | TARGET_LAG | TRANSACTION | TRANSIENT | TRIM |
			 TRUE | TRUNCATE | TRY_CAST | TUPLE | TYPE | UESCAPE | UNBOUNDED | UNCOMMITTED |
			 UNCONDITIONAL | UNKNOWN | UNLOAD | UNMATCHED | UNNEST | UNPIVOT | UNSET |
			 UNSIGNED | USE | USER | USING | UTF16 | UTF32 | UTF8 | VACUUM | VALIDATE |
			 VALUE | VARYING | VECTOR | VERBOSE | VERSION | VIEW | VOLATILE | WAREHOUSE |
			 WHEN | WINDOW | WITHIN | WITHOUT | WORK | WRAPPER | WRITE | XZ | YEAR |
			 YES | ZONE | ZSTD | DOLLAR | IDENTIFIER | QUOTED_IDENTIFIER | BACKQUOTED_IDENTIFIER 
				=> {
			    	{
			    	/*InvokeRule snowflakeShowFunctionType*/
			    	recog.base.set_state(5554);
			    	let tmp = recog.snowflakeShowFunctionType()?;
			    	 cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).snowflakeShowFunctionType = Some(tmp.clone());
			    	  

			    	let temp =  cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).snowflakeShowFunctionType.clone().unwrap()
			    	 ;
			    	 cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).required.push(temp);
			    	  
			    	}
			    }

			 LBRACKET 
				=> {
			    	{
			    	recog.base.set_state(5555);
			    	recog.base.match_token(LBRACKET,&mut recog.err_handler)?;

			    	/*InvokeRule snowflakeShowFunctionType*/
			    	recog.base.set_state(5556);
			    	let tmp = recog.snowflakeShowFunctionType()?;
			    	 cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).snowflakeShowFunctionType = Some(tmp.clone());
			    	  

			    	let temp =  cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).snowflakeShowFunctionType.clone().unwrap()
			    	 ;
			    	 cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).optional.push(temp);
			    	  
			    	recog.base.set_state(5557);
			    	recog.base.match_token(RBRACKET,&mut recog.err_handler)?;

			    	}
			    }

			 T__10 | COMMA | RPAREN 
				=> {
			    }

				_ => {}
			}
			recog.base.set_state(5569);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==T__10 || _la==COMMA {
				{
				recog.base.set_state(5567);
				recog.err_handler.sync(&mut recog.base)?;
				match recog.base.input.la(1) {
				 COMMA 
					=> {
						{
						recog.base.set_state(5561);
						recog.base.match_token(COMMA,&mut recog.err_handler)?;

						/*InvokeRule snowflakeShowFunctionType*/
						recog.base.set_state(5562);
						let tmp = recog.snowflakeShowFunctionType()?;
						 cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).snowflakeShowFunctionType = Some(tmp.clone());
						  

						let temp =  cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).snowflakeShowFunctionType.clone().unwrap()
						 ;
						 cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).required.push(temp);
						  
						}
					}

				 T__10 
					=> {
						{
						recog.base.set_state(5563);
						recog.base.match_token(T__10,&mut recog.err_handler)?;

						/*InvokeRule snowflakeShowFunctionType*/
						recog.base.set_state(5564);
						let tmp = recog.snowflakeShowFunctionType()?;
						 cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).snowflakeShowFunctionType = Some(tmp.clone());
						  

						let temp =  cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).snowflakeShowFunctionType.clone().unwrap()
						 ;
						 cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).optional.push(temp);
						  
						recog.base.set_state(5565);
						recog.base.match_token(RBRACKET,&mut recog.err_handler)?;

						}
					}

					_ => Err(ANTLRError::NoAltError(NoViableAltError::new(&mut recog.base)))?
				}
				}
				recog.base.set_state(5571);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			recog.base.set_state(5572);
			recog.base.match_token(RPAREN,&mut recog.err_handler)?;

			recog.base.set_state(5573);
			recog.base.match_token(RETURN,&mut recog.err_handler)?;

			/*InvokeRule snowflakeShowFunctionType*/
			recog.base.set_state(5574);
			let tmp = recog.snowflakeShowFunctionType()?;
			 cast_mut::<_,SnowflakeShowFunctionArgumentsContext >(&mut _localctx).return_ = Some(tmp.clone());
			  

			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- snowflakeShowFunctionArgumentsList ----------------
pub type SnowflakeShowFunctionArgumentsListContextAll<'input> = SnowflakeShowFunctionArgumentsListContext<'input>;


pub type SnowflakeShowFunctionArgumentsListContext<'input> = BaseParserRuleContext<'input,SnowflakeShowFunctionArgumentsListContextExt<'input>>;

#[derive(Clone)]
pub struct SnowflakeShowFunctionArgumentsListContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for SnowflakeShowFunctionArgumentsListContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for SnowflakeShowFunctionArgumentsListContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_snowflakeShowFunctionArgumentsList(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_snowflakeShowFunctionArgumentsList(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for SnowflakeShowFunctionArgumentsListContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_snowflakeShowFunctionArgumentsList(self);
	}
}

impl<'input> CustomRuleContext<'input> for SnowflakeShowFunctionArgumentsListContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_snowflakeShowFunctionArgumentsList }
	//fn type_rule_index() -> usize where Self: Sized { RULE_snowflakeShowFunctionArgumentsList }
}
antlr_rust::tid!{SnowflakeShowFunctionArgumentsListContextExt<'a>}

impl<'input> SnowflakeShowFunctionArgumentsListContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<SnowflakeShowFunctionArgumentsListContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,SnowflakeShowFunctionArgumentsListContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait SnowflakeShowFunctionArgumentsListContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<SnowflakeShowFunctionArgumentsListContextExt<'input>>{

fn snowflakeShowFunctionArguments_all(&self) ->  Vec<Rc<SnowflakeShowFunctionArgumentsContextAll<'input>>> where Self:Sized{
	self.children_of_type()
}
fn snowflakeShowFunctionArguments(&self, i: usize) -> Option<Rc<SnowflakeShowFunctionArgumentsContextAll<'input>>> where Self:Sized{
	self.child_of_type(i)
}
/// Retrieves all `TerminalNode`s corresponding to token COMMA in current rule
fn COMMA_all(&self) -> Vec<Rc<TerminalNode<'input,SnowflakeParserContextType>>>  where Self:Sized{
	self.children_of_type()
}
/// Retrieves 'i's TerminalNode corresponding to token COMMA, starting from 0.
/// Returns `None` if number of children corresponding to token COMMA is less or equal than `i`.
fn COMMA(&self, i: usize) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMA, i)
}

}

impl<'input> SnowflakeShowFunctionArgumentsListContextAttrs<'input> for SnowflakeShowFunctionArgumentsListContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn snowflakeShowFunctionArgumentsList(&mut self,)
	-> Result<Rc<SnowflakeShowFunctionArgumentsListContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = SnowflakeShowFunctionArgumentsListContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 374, RULE_snowflakeShowFunctionArgumentsList);
        let mut _localctx: Rc<SnowflakeShowFunctionArgumentsListContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			/*InvokeRule snowflakeShowFunctionArguments*/
			recog.base.set_state(5576);
			recog.snowflakeShowFunctionArguments()?;

			recog.base.set_state(5581);
			recog.err_handler.sync(&mut recog.base)?;
			_la = recog.base.input.la(1);
			while _la==COMMA {
				{
				{
				recog.base.set_state(5577);
				recog.base.match_token(COMMA,&mut recog.err_handler)?;

				/*InvokeRule snowflakeShowFunctionArguments*/
				recog.base.set_state(5578);
				recog.snowflakeShowFunctionArguments()?;

				}
				}
				recog.base.set_state(5583);
				recog.err_handler.sync(&mut recog.base)?;
				_la = recog.base.input.la(1);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- strictNonReserved ----------------
pub type StrictNonReservedContextAll<'input> = StrictNonReservedContext<'input>;


pub type StrictNonReservedContext<'input> = BaseParserRuleContext<'input,StrictNonReservedContextExt<'input>>;

#[derive(Clone)]
pub struct StrictNonReservedContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for StrictNonReservedContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for StrictNonReservedContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_strictNonReserved(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_strictNonReserved(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for StrictNonReservedContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_strictNonReserved(self);
	}
}

impl<'input> CustomRuleContext<'input> for StrictNonReservedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_strictNonReserved }
	//fn type_rule_index() -> usize where Self: Sized { RULE_strictNonReserved }
}
antlr_rust::tid!{StrictNonReservedContextExt<'a>}

impl<'input> StrictNonReservedContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<StrictNonReservedContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,StrictNonReservedContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait StrictNonReservedContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<StrictNonReservedContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ASOF
/// Returns `None` if there is no child corresponding to token ASOF
fn ASOF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ASOF, 0)
}
/// Retrieves first TerminalNode corresponding to token CROSS
/// Returns `None` if there is no child corresponding to token CROSS
fn CROSS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CROSS, 0)
}
/// Retrieves first TerminalNode corresponding to token FULL
/// Returns `None` if there is no child corresponding to token FULL
fn FULL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FULL, 0)
}
/// Retrieves first TerminalNode corresponding to token INNER
/// Returns `None` if there is no child corresponding to token INNER
fn INNER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INNER, 0)
}
/// Retrieves first TerminalNode corresponding to token JOIN
/// Returns `None` if there is no child corresponding to token JOIN
fn JOIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JOIN, 0)
}
/// Retrieves first TerminalNode corresponding to token LATERAL
/// Returns `None` if there is no child corresponding to token LATERAL
fn LATERAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LATERAL, 0)
}
/// Retrieves first TerminalNode corresponding to token LEFT
/// Returns `None` if there is no child corresponding to token LEFT
fn LEFT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LEFT, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCH_CONDITION
/// Returns `None` if there is no child corresponding to token MATCH_CONDITION
fn MATCH_CONDITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCH_CONDITION, 0)
}
/// Retrieves first TerminalNode corresponding to token NATURAL
/// Returns `None` if there is no child corresponding to token NATURAL
fn NATURAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NATURAL, 0)
}
/// Retrieves first TerminalNode corresponding to token RIGHT
/// Returns `None` if there is no child corresponding to token RIGHT
fn RIGHT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RIGHT, 0)
}
/// Retrieves first TerminalNode corresponding to token USING
/// Returns `None` if there is no child corresponding to token USING
fn USING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(USING, 0)
}

}

impl<'input> StrictNonReservedContextAttrs<'input> for StrictNonReservedContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn strictNonReserved(&mut self,)
	-> Result<Rc<StrictNonReservedContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = StrictNonReservedContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 376, RULE_strictNonReserved);
        let mut _localctx: Rc<StrictNonReservedContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5584);
			_la = recog.base.input.la(1);
			if { !(_la==ASOF || _la==CROSS || _la==FULL || _la==INNER || ((((_la - 195)) & !0x3f) == 0 && ((1usize << (_la - 195)) & ((1usize << (JOIN - 195)) | (1usize << (LATERAL - 195)) | (1usize << (LEFT - 195)))) != 0) || _la==MATCH_CONDITION || _la==NATURAL || _la==RIGHT || _la==USING) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}
//------------------- nonReserved ----------------
pub type NonReservedContextAll<'input> = NonReservedContext<'input>;


pub type NonReservedContext<'input> = BaseParserRuleContext<'input,NonReservedContextExt<'input>>;

#[derive(Clone)]
pub struct NonReservedContextExt<'input>{
ph:PhantomData<&'input str>
}

impl<'input> SnowflakeParserContext<'input> for NonReservedContext<'input>{}

impl<'input,'a> Listenable<dyn SnowflakeListener<'input> + 'a> for NonReservedContext<'input>{
		fn enter(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.enter_every_rule(self);
			listener.enter_nonReserved(self);
		}
		fn exit(&self,listener: &mut (dyn SnowflakeListener<'input> + 'a)) {
			listener.exit_nonReserved(self);
			listener.exit_every_rule(self);
		}
}

impl<'input,'a> Visitable<dyn SnowflakeVisitor<'input> + 'a> for NonReservedContext<'input>{
	fn accept(&self,visitor: &mut (dyn SnowflakeVisitor<'input> + 'a)) {
		visitor.visit_nonReserved(self);
	}
}

impl<'input> CustomRuleContext<'input> for NonReservedContextExt<'input>{
	type TF = LocalTokenFactory<'input>;
	type Ctx = SnowflakeParserContextType;
	fn get_rule_index(&self) -> usize { RULE_nonReserved }
	//fn type_rule_index() -> usize where Self: Sized { RULE_nonReserved }
}
antlr_rust::tid!{NonReservedContextExt<'a>}

impl<'input> NonReservedContextExt<'input>{
	fn new(parent: Option<Rc<dyn SnowflakeParserContext<'input> + 'input > >, invoking_state: isize) -> Rc<NonReservedContextAll<'input>> {
		Rc::new(
			BaseParserRuleContext::new_parser_ctx(parent, invoking_state,NonReservedContextExt{
				ph:PhantomData
			}),
		)
	}
}

pub trait NonReservedContextAttrs<'input>: SnowflakeParserContext<'input> + BorrowMut<NonReservedContextExt<'input>>{

/// Retrieves first TerminalNode corresponding to token ABORT
/// Returns `None` if there is no child corresponding to token ABORT
fn ABORT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ABORT, 0)
}
/// Retrieves first TerminalNode corresponding to token ABSENT
/// Returns `None` if there is no child corresponding to token ABSENT
fn ABSENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ABSENT, 0)
}
/// Retrieves first TerminalNode corresponding to token ACCESS
/// Returns `None` if there is no child corresponding to token ACCESS
fn ACCESS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ACCESS, 0)
}
/// Retrieves first TerminalNode corresponding to token ADD
/// Returns `None` if there is no child corresponding to token ADD
fn ADD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ADD, 0)
}
/// Retrieves first TerminalNode corresponding to token ADMIN
/// Returns `None` if there is no child corresponding to token ADMIN
fn ADMIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ADMIN, 0)
}
/// Retrieves first TerminalNode corresponding to token AFTER
/// Returns `None` if there is no child corresponding to token AFTER
fn AFTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AFTER, 0)
}
/// Retrieves first TerminalNode corresponding to token ANALYZE
/// Returns `None` if there is no child corresponding to token ANALYZE
fn ANALYZE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ANALYZE, 0)
}
/// Retrieves first TerminalNode corresponding to token ANTI
/// Returns `None` if there is no child corresponding to token ANTI
fn ANTI(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ANTI, 0)
}
/// Retrieves first TerminalNode corresponding to token APPEND_ONLY
/// Returns `None` if there is no child corresponding to token APPEND_ONLY
fn APPEND_ONLY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(APPEND_ONLY, 0)
}
/// Retrieves first TerminalNode corresponding to token ARRAY
/// Returns `None` if there is no child corresponding to token ARRAY
fn ARRAY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ARRAY, 0)
}
/// Retrieves first TerminalNode corresponding to token ARRAYAGG
/// Returns `None` if there is no child corresponding to token ARRAYAGG
fn ARRAYAGG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ARRAYAGG, 0)
}
/// Retrieves first TerminalNode corresponding to token ARRAY_AGG
/// Returns `None` if there is no child corresponding to token ARRAY_AGG
fn ARRAY_AGG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ARRAY_AGG, 0)
}
/// Retrieves first TerminalNode corresponding to token ASC
/// Returns `None` if there is no child corresponding to token ASC
fn ASC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ASC, 0)
}
/// Retrieves first TerminalNode corresponding to token AT
/// Returns `None` if there is no child corresponding to token AT
fn AT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AT, 0)
}
/// Retrieves first TerminalNode corresponding to token ATTACH
/// Returns `None` if there is no child corresponding to token ATTACH
fn ATTACH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ATTACH, 0)
}
/// Retrieves first TerminalNode corresponding to token AUTHORIZATION
/// Returns `None` if there is no child corresponding to token AUTHORIZATION
fn AUTHORIZATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AUTHORIZATION, 0)
}
/// Retrieves first TerminalNode corresponding to token AUTO
/// Returns `None` if there is no child corresponding to token AUTO
fn AUTO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AUTO, 0)
}
/// Retrieves first TerminalNode corresponding to token AUTOINCREMENT
/// Returns `None` if there is no child corresponding to token AUTOINCREMENT
fn AUTOINCREMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(AUTOINCREMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token BACKUP
/// Returns `None` if there is no child corresponding to token BACKUP
fn BACKUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BACKUP, 0)
}
/// Retrieves first TerminalNode corresponding to token BEFORE
/// Returns `None` if there is no child corresponding to token BEFORE
fn BEFORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BEFORE, 0)
}
/// Retrieves first TerminalNode corresponding to token BEGIN
/// Returns `None` if there is no child corresponding to token BEGIN
fn BEGIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BEGIN, 0)
}
/// Retrieves first TerminalNode corresponding to token BERNOULLI
/// Returns `None` if there is no child corresponding to token BERNOULLI
fn BERNOULLI(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BERNOULLI, 0)
}
/// Retrieves first TerminalNode corresponding to token BLOCK
/// Returns `None` if there is no child corresponding to token BLOCK
fn BLOCK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BLOCK, 0)
}
/// Retrieves first TerminalNode corresponding to token BOTH
/// Returns `None` if there is no child corresponding to token BOTH
fn BOTH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BOTH, 0)
}
/// Retrieves first TerminalNode corresponding to token BZIP2
/// Returns `None` if there is no child corresponding to token BZIP2
fn BZIP2(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(BZIP2, 0)
}
/// Retrieves first TerminalNode corresponding to token CALL
/// Returns `None` if there is no child corresponding to token CALL
fn CALL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CALL, 0)
}
/// Retrieves first TerminalNode corresponding to token CALLED
/// Returns `None` if there is no child corresponding to token CALLED
fn CALLED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CALLED, 0)
}
/// Retrieves first TerminalNode corresponding to token CALLER
/// Returns `None` if there is no child corresponding to token CALLER
fn CALLER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CALLER, 0)
}
/// Retrieves first TerminalNode corresponding to token CANCEL
/// Returns `None` if there is no child corresponding to token CANCEL
fn CANCEL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CANCEL, 0)
}
/// Retrieves first TerminalNode corresponding to token CASCADE
/// Returns `None` if there is no child corresponding to token CASCADE
fn CASCADE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CASCADE, 0)
}
/// Retrieves first TerminalNode corresponding to token CASE
/// Returns `None` if there is no child corresponding to token CASE
fn CASE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CASE, 0)
}
/// Retrieves first TerminalNode corresponding to token CASE_INSENSITIVE
/// Returns `None` if there is no child corresponding to token CASE_INSENSITIVE
fn CASE_INSENSITIVE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CASE_INSENSITIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token CASE_SENSITIVE
/// Returns `None` if there is no child corresponding to token CASE_SENSITIVE
fn CASE_SENSITIVE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CASE_SENSITIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token CAST
/// Returns `None` if there is no child corresponding to token CAST
fn CAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CAST, 0)
}
/// Retrieves first TerminalNode corresponding to token CATALOGS
/// Returns `None` if there is no child corresponding to token CATALOGS
fn CATALOGS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CATALOGS, 0)
}
/// Retrieves first TerminalNode corresponding to token CHANGES
/// Returns `None` if there is no child corresponding to token CHANGES
fn CHANGES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CHANGES, 0)
}
/// Retrieves first TerminalNode corresponding to token CHAR
/// Returns `None` if there is no child corresponding to token CHAR
fn CHAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CHAR, 0)
}
/// Retrieves first TerminalNode corresponding to token CHARACTER
/// Returns `None` if there is no child corresponding to token CHARACTER
fn CHARACTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CHARACTER, 0)
}
/// Retrieves first TerminalNode corresponding to token CLONE
/// Returns `None` if there is no child corresponding to token CLONE
fn CLONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CLONE, 0)
}
/// Retrieves first TerminalNode corresponding to token CLOSE
/// Returns `None` if there is no child corresponding to token CLOSE
fn CLOSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CLOSE, 0)
}
/// Retrieves first TerminalNode corresponding to token CLUSTER
/// Returns `None` if there is no child corresponding to token CLUSTER
fn CLUSTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CLUSTER, 0)
}
/// Retrieves first TerminalNode corresponding to token COLLATE
/// Returns `None` if there is no child corresponding to token COLLATE
fn COLLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COLLATE, 0)
}
/// Retrieves first TerminalNode corresponding to token COLUMNS
/// Returns `None` if there is no child corresponding to token COLUMNS
fn COLUMNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COLUMNS, 0)
}
/// Retrieves first TerminalNode corresponding to token COMMENT
/// Returns `None` if there is no child corresponding to token COMMENT
fn COMMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token COMMIT
/// Returns `None` if there is no child corresponding to token COMMIT
fn COMMIT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMIT, 0)
}
/// Retrieves first TerminalNode corresponding to token COMMITTED
/// Returns `None` if there is no child corresponding to token COMMITTED
fn COMMITTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMMITTED, 0)
}
/// Retrieves first TerminalNode corresponding to token COMPOUND
/// Returns `None` if there is no child corresponding to token COMPOUND
fn COMPOUND(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMPOUND, 0)
}
/// Retrieves first TerminalNode corresponding to token COMPRESSION
/// Returns `None` if there is no child corresponding to token COMPRESSION
fn COMPRESSION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COMPRESSION, 0)
}
/// Retrieves first TerminalNode corresponding to token CONDITIONAL
/// Returns `None` if there is no child corresponding to token CONDITIONAL
fn CONDITIONAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONDITIONAL, 0)
}
/// Retrieves first TerminalNode corresponding to token CONNECTION
/// Returns `None` if there is no child corresponding to token CONNECTION
fn CONNECTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONNECTION, 0)
}
/// Retrieves first TerminalNode corresponding to token CONNECT_BY_ROOT
/// Returns `None` if there is no child corresponding to token CONNECT_BY_ROOT
fn CONNECT_BY_ROOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONNECT_BY_ROOT, 0)
}
/// Retrieves first TerminalNode corresponding to token CONSTRAINT
/// Returns `None` if there is no child corresponding to token CONSTRAINT
fn CONSTRAINT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CONSTRAINT, 0)
}
/// Retrieves first TerminalNode corresponding to token COPARTITION
/// Returns `None` if there is no child corresponding to token COPARTITION
fn COPARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COPARTITION, 0)
}
/// Retrieves first TerminalNode corresponding to token COPY
/// Returns `None` if there is no child corresponding to token COPY
fn COPY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COPY, 0)
}
/// Retrieves first TerminalNode corresponding to token COUNT
/// Returns `None` if there is no child corresponding to token COUNT
fn COUNT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(COUNT, 0)
}
/// Retrieves first TerminalNode corresponding to token CUBE
/// Returns `None` if there is no child corresponding to token CUBE
fn CUBE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CUBE, 0)
}
/// Retrieves first TerminalNode corresponding to token CURRENT_ROLE
/// Returns `None` if there is no child corresponding to token CURRENT_ROLE
fn CURRENT_ROLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(CURRENT_ROLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DATA
/// Returns `None` if there is no child corresponding to token DATA
fn DATA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DATA, 0)
}
/// Retrieves first TerminalNode corresponding to token DATABASE
/// Returns `None` if there is no child corresponding to token DATABASE
fn DATABASE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DATABASE, 0)
}
/// Retrieves first TerminalNode corresponding to token DATASHARE
/// Returns `None` if there is no child corresponding to token DATASHARE
fn DATASHARE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DATASHARE, 0)
}
/// Retrieves first TerminalNode corresponding to token DAY
/// Returns `None` if there is no child corresponding to token DAY
fn DAY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DAY, 0)
}
/// Retrieves first TerminalNode corresponding to token DEALLOCATE
/// Returns `None` if there is no child corresponding to token DEALLOCATE
fn DEALLOCATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEALLOCATE, 0)
}
/// Retrieves first TerminalNode corresponding to token DECLARE
/// Returns `None` if there is no child corresponding to token DECLARE
fn DECLARE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DECLARE, 0)
}
/// Retrieves first TerminalNode corresponding to token DECODE
/// Returns `None` if there is no child corresponding to token DECODE
fn DECODE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DECODE, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULT
/// Returns `None` if there is no child corresponding to token DEFAULT
fn DEFAULT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFAULT, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFAULTS
/// Returns `None` if there is no child corresponding to token DEFAULTS
fn DEFAULTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFAULTS, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFERRABLE
/// Returns `None` if there is no child corresponding to token DEFERRABLE
fn DEFERRABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFERRABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFERRED
/// Returns `None` if there is no child corresponding to token DEFERRED
fn DEFERRED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFERRED, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFINE
/// Returns `None` if there is no child corresponding to token DEFINE
fn DEFINE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFINE, 0)
}
/// Retrieves first TerminalNode corresponding to token DEFINER
/// Returns `None` if there is no child corresponding to token DEFINER
fn DEFINER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DEFINER, 0)
}
/// Retrieves first TerminalNode corresponding to token DELIMITED
/// Returns `None` if there is no child corresponding to token DELIMITED
fn DELIMITED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DELIMITED, 0)
}
/// Retrieves first TerminalNode corresponding to token DELIMITER
/// Returns `None` if there is no child corresponding to token DELIMITER
fn DELIMITER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DELIMITER, 0)
}
/// Retrieves first TerminalNode corresponding to token DENY
/// Returns `None` if there is no child corresponding to token DENY
fn DENY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DENY, 0)
}
/// Retrieves first TerminalNode corresponding to token DESC
/// Returns `None` if there is no child corresponding to token DESC
fn DESC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DESC, 0)
}
/// Retrieves first TerminalNode corresponding to token DESCRIBE
/// Returns `None` if there is no child corresponding to token DESCRIBE
fn DESCRIBE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DESCRIBE, 0)
}
/// Retrieves first TerminalNode corresponding to token DESCRIPTOR
/// Returns `None` if there is no child corresponding to token DESCRIPTOR
fn DESCRIPTOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DESCRIPTOR, 0)
}
/// Retrieves first TerminalNode corresponding to token DETACH
/// Returns `None` if there is no child corresponding to token DETACH
fn DETACH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DETACH, 0)
}
/// Retrieves first TerminalNode corresponding to token DIRECTORY
/// Returns `None` if there is no child corresponding to token DIRECTORY
fn DIRECTORY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DIRECTORY, 0)
}
/// Retrieves first TerminalNode corresponding to token DISABLE
/// Returns `None` if there is no child corresponding to token DISABLE
fn DISABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DISTKEY
/// Returns `None` if there is no child corresponding to token DISTKEY
fn DISTKEY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISTKEY, 0)
}
/// Retrieves first TerminalNode corresponding to token DISTRIBUTED
/// Returns `None` if there is no child corresponding to token DISTRIBUTED
fn DISTRIBUTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISTRIBUTED, 0)
}
/// Retrieves first TerminalNode corresponding to token DISTSTYLE
/// Returns `None` if there is no child corresponding to token DISTSTYLE
fn DISTSTYLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DISTSTYLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DOUBLE
/// Returns `None` if there is no child corresponding to token DOUBLE
fn DOUBLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DOUBLE, 0)
}
/// Retrieves first TerminalNode corresponding to token DOWNSTREAM
/// Returns `None` if there is no child corresponding to token DOWNSTREAM
fn DOWNSTREAM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DOWNSTREAM, 0)
}
/// Retrieves first TerminalNode corresponding to token DYNAMIC
/// Returns `None` if there is no child corresponding to token DYNAMIC
fn DYNAMIC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(DYNAMIC, 0)
}
/// Retrieves first TerminalNode corresponding to token EMPTY
/// Returns `None` if there is no child corresponding to token EMPTY
fn EMPTY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EMPTY, 0)
}
/// Retrieves first TerminalNode corresponding to token ENABLE
/// Returns `None` if there is no child corresponding to token ENABLE
fn ENABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token ENCODE
/// Returns `None` if there is no child corresponding to token ENCODE
fn ENCODE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENCODE, 0)
}
/// Retrieves first TerminalNode corresponding to token ENCODING
/// Returns `None` if there is no child corresponding to token ENCODING
fn ENCODING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENCODING, 0)
}
/// Retrieves first TerminalNode corresponding to token END
/// Returns `None` if there is no child corresponding to token END
fn END(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(END, 0)
}
/// Retrieves first TerminalNode corresponding to token ENFORCED
/// Returns `None` if there is no child corresponding to token ENFORCED
fn ENFORCED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ENFORCED, 0)
}
/// Retrieves first TerminalNode corresponding to token ERROR
/// Returns `None` if there is no child corresponding to token ERROR
fn ERROR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ERROR, 0)
}
/// Retrieves first TerminalNode corresponding to token ESCAPE
/// Returns `None` if there is no child corresponding to token ESCAPE
fn ESCAPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ESCAPE, 0)
}
/// Retrieves first TerminalNode corresponding to token EVEN
/// Returns `None` if there is no child corresponding to token EVEN
fn EVEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EVEN, 0)
}
/// Retrieves first TerminalNode corresponding to token EVENT
/// Returns `None` if there is no child corresponding to token EVENT
fn EVENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EVENT, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCEPT
/// Returns `None` if there is no child corresponding to token EXCEPT
fn EXCEPT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXCEPT, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCLUDE
/// Returns `None` if there is no child corresponding to token EXCLUDE
fn EXCLUDE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXCLUDE, 0)
}
/// Retrieves first TerminalNode corresponding to token EXCLUDING
/// Returns `None` if there is no child corresponding to token EXCLUDING
fn EXCLUDING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXCLUDING, 0)
}
/// Retrieves first TerminalNode corresponding to token EXECUTE
/// Returns `None` if there is no child corresponding to token EXECUTE
fn EXECUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXECUTE, 0)
}
/// Retrieves first TerminalNode corresponding to token EXPLAIN
/// Returns `None` if there is no child corresponding to token EXPLAIN
fn EXPLAIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXPLAIN, 0)
}
/// Retrieves first TerminalNode corresponding to token EXTERNAL
/// Returns `None` if there is no child corresponding to token EXTERNAL
fn EXTERNAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXTERNAL, 0)
}
/// Retrieves first TerminalNode corresponding to token EXTRACT
/// Returns `None` if there is no child corresponding to token EXTRACT
fn EXTRACT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(EXTRACT, 0)
}
/// Retrieves first TerminalNode corresponding to token FALSE
/// Returns `None` if there is no child corresponding to token FALSE
fn FALSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FALSE, 0)
}
/// Retrieves first TerminalNode corresponding to token FETCH
/// Returns `None` if there is no child corresponding to token FETCH
fn FETCH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FETCH, 0)
}
/// Retrieves first TerminalNode corresponding to token FIELDS
/// Returns `None` if there is no child corresponding to token FIELDS
fn FIELDS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FIELDS, 0)
}
/// Retrieves first TerminalNode corresponding to token FILES
/// Returns `None` if there is no child corresponding to token FILES
fn FILES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FILES, 0)
}
/// Retrieves first TerminalNode corresponding to token FILE_FORMAT
/// Returns `None` if there is no child corresponding to token FILE_FORMAT
fn FILE_FORMAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FILE_FORMAT, 0)
}
/// Retrieves first TerminalNode corresponding to token FILTER
/// Returns `None` if there is no child corresponding to token FILTER
fn FILTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FILTER, 0)
}
/// Retrieves first TerminalNode corresponding to token FINAL
/// Returns `None` if there is no child corresponding to token FINAL
fn FINAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FINAL, 0)
}
/// Retrieves first TerminalNode corresponding to token FIRST
/// Returns `None` if there is no child corresponding to token FIRST
fn FIRST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FIRST, 0)
}
/// Retrieves first TerminalNode corresponding to token FIRST_VALUE
/// Returns `None` if there is no child corresponding to token FIRST_VALUE
fn FIRST_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FIRST_VALUE, 0)
}
/// Retrieves first TerminalNode corresponding to token FLOAT
/// Returns `None` if there is no child corresponding to token FLOAT
fn FLOAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FLOAT, 0)
}
/// Retrieves first TerminalNode corresponding to token FOREIGN
/// Returns `None` if there is no child corresponding to token FOREIGN
fn FOREIGN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FOREIGN, 0)
}
/// Retrieves first TerminalNode corresponding to token FORMAT
/// Returns `None` if there is no child corresponding to token FORMAT
fn FORMAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FORMAT, 0)
}
/// Retrieves first TerminalNode corresponding to token FORMAT_NAME
/// Returns `None` if there is no child corresponding to token FORMAT_NAME
fn FORMAT_NAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FORMAT_NAME, 0)
}
/// Retrieves first TerminalNode corresponding to token FUNCTION
/// Returns `None` if there is no child corresponding to token FUNCTION
fn FUNCTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FUNCTION, 0)
}
/// Retrieves first TerminalNode corresponding to token FUNCTIONS
/// Returns `None` if there is no child corresponding to token FUNCTIONS
fn FUNCTIONS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(FUNCTIONS, 0)
}
/// Retrieves first TerminalNode corresponding to token GENERATED
/// Returns `None` if there is no child corresponding to token GENERATED
fn GENERATED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GENERATED, 0)
}
/// Retrieves first TerminalNode corresponding to token GLOBAL
/// Returns `None` if there is no child corresponding to token GLOBAL
fn GLOBAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GLOBAL, 0)
}
/// Retrieves first TerminalNode corresponding to token GRACE
/// Returns `None` if there is no child corresponding to token GRACE
fn GRACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRACE, 0)
}
/// Retrieves first TerminalNode corresponding to token GRANTED
/// Returns `None` if there is no child corresponding to token GRANTED
fn GRANTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRANTED, 0)
}
/// Retrieves first TerminalNode corresponding to token GRANTS
/// Returns `None` if there is no child corresponding to token GRANTS
fn GRANTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRANTS, 0)
}
/// Retrieves first TerminalNode corresponding to token GRAPHVIZ
/// Returns `None` if there is no child corresponding to token GRAPHVIZ
fn GRAPHVIZ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GRAPHVIZ, 0)
}
/// Retrieves first TerminalNode corresponding to token GROUPING
/// Returns `None` if there is no child corresponding to token GROUPING
fn GROUPING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GROUPING, 0)
}
/// Retrieves first TerminalNode corresponding to token GROUPS
/// Returns `None` if there is no child corresponding to token GROUPS
fn GROUPS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GROUPS, 0)
}
/// Retrieves first TerminalNode corresponding to token GZIP
/// Returns `None` if there is no child corresponding to token GZIP
fn GZIP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(GZIP, 0)
}
/// Retrieves first TerminalNode corresponding to token HEADER
/// Returns `None` if there is no child corresponding to token HEADER
fn HEADER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(HEADER, 0)
}
/// Retrieves first TerminalNode corresponding to token HOUR
/// Returns `None` if there is no child corresponding to token HOUR
fn HOUR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(HOUR, 0)
}
/// Retrieves first TerminalNode corresponding to token ICEBERG
/// Returns `None` if there is no child corresponding to token ICEBERG
fn ICEBERG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ICEBERG, 0)
}
/// Retrieves first TerminalNode corresponding to token IDENTIFIER_KW
/// Returns `None` if there is no child corresponding to token IDENTIFIER_KW
fn IDENTIFIER_KW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IDENTIFIER_KW, 0)
}
/// Retrieves first TerminalNode corresponding to token IDENTITY
/// Returns `None` if there is no child corresponding to token IDENTITY
fn IDENTITY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IDENTITY, 0)
}
/// Retrieves first TerminalNode corresponding to token IF
/// Returns `None` if there is no child corresponding to token IF
fn IF(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IF, 0)
}
/// Retrieves first TerminalNode corresponding to token IGNORE
/// Returns `None` if there is no child corresponding to token IGNORE
fn IGNORE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IGNORE, 0)
}
/// Retrieves first TerminalNode corresponding to token IMMEDIATE
/// Returns `None` if there is no child corresponding to token IMMEDIATE
fn IMMEDIATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IMMEDIATE, 0)
}
/// Retrieves first TerminalNode corresponding to token IMMUTABLE
/// Returns `None` if there is no child corresponding to token IMMUTABLE
fn IMMUTABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IMMUTABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token INCLUDE
/// Returns `None` if there is no child corresponding to token INCLUDE
fn INCLUDE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INCLUDE, 0)
}
/// Retrieves first TerminalNode corresponding to token INCLUDING
/// Returns `None` if there is no child corresponding to token INCLUDING
fn INCLUDING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INCLUDING, 0)
}
/// Retrieves first TerminalNode corresponding to token INFORMATION
/// Returns `None` if there is no child corresponding to token INFORMATION
fn INFORMATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INFORMATION, 0)
}
/// Retrieves first TerminalNode corresponding to token INITIAL
/// Returns `None` if there is no child corresponding to token INITIAL
fn INITIAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INITIAL, 0)
}
/// Retrieves first TerminalNode corresponding to token INITIALLY
/// Returns `None` if there is no child corresponding to token INITIALLY
fn INITIALLY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INITIALLY, 0)
}
/// Retrieves first TerminalNode corresponding to token INPUT
/// Returns `None` if there is no child corresponding to token INPUT
fn INPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INPUT, 0)
}
/// Retrieves first TerminalNode corresponding to token INPUTFORMAT
/// Returns `None` if there is no child corresponding to token INPUTFORMAT
fn INPUTFORMAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INPUTFORMAT, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERLEAVED
/// Returns `None` if there is no child corresponding to token INTERLEAVED
fn INTERLEAVED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTERLEAVED, 0)
}
/// Retrieves first TerminalNode corresponding to token INTERVAL
/// Returns `None` if there is no child corresponding to token INTERVAL
fn INTERVAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INTERVAL, 0)
}
/// Retrieves first TerminalNode corresponding to token INVOKER
/// Returns `None` if there is no child corresponding to token INVOKER
fn INVOKER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(INVOKER, 0)
}
/// Retrieves first TerminalNode corresponding to token IO
/// Returns `None` if there is no child corresponding to token IO
fn IO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(IO, 0)
}
/// Retrieves first TerminalNode corresponding to token ISOLATION
/// Returns `None` if there is no child corresponding to token ISOLATION
fn ISOLATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ISOLATION, 0)
}
/// Retrieves first TerminalNode corresponding to token JAVA
/// Returns `None` if there is no child corresponding to token JAVA
fn JAVA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JAVA, 0)
}
/// Retrieves first TerminalNode corresponding to token JAVASCRIPT
/// Returns `None` if there is no child corresponding to token JAVASCRIPT
fn JAVASCRIPT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JAVASCRIPT, 0)
}
/// Retrieves first TerminalNode corresponding to token JSON
/// Returns `None` if there is no child corresponding to token JSON
fn JSON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JSON, 0)
}
/// Retrieves first TerminalNode corresponding to token JSON_ARRAY
/// Returns `None` if there is no child corresponding to token JSON_ARRAY
fn JSON_ARRAY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JSON_ARRAY, 0)
}
/// Retrieves first TerminalNode corresponding to token JSON_EXISTS
/// Returns `None` if there is no child corresponding to token JSON_EXISTS
fn JSON_EXISTS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JSON_EXISTS, 0)
}
/// Retrieves first TerminalNode corresponding to token JSON_OBJECT
/// Returns `None` if there is no child corresponding to token JSON_OBJECT
fn JSON_OBJECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JSON_OBJECT, 0)
}
/// Retrieves first TerminalNode corresponding to token JSON_QUERY
/// Returns `None` if there is no child corresponding to token JSON_QUERY
fn JSON_QUERY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JSON_QUERY, 0)
}
/// Retrieves first TerminalNode corresponding to token JSON_VALUE
/// Returns `None` if there is no child corresponding to token JSON_VALUE
fn JSON_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(JSON_VALUE, 0)
}
/// Retrieves first TerminalNode corresponding to token KEEP
/// Returns `None` if there is no child corresponding to token KEEP
fn KEEP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(KEEP, 0)
}
/// Retrieves first TerminalNode corresponding to token KEY
/// Returns `None` if there is no child corresponding to token KEY
fn KEY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(KEY, 0)
}
/// Retrieves first TerminalNode corresponding to token KEYS
/// Returns `None` if there is no child corresponding to token KEYS
fn KEYS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(KEYS, 0)
}
/// Retrieves first TerminalNode corresponding to token LAG
/// Returns `None` if there is no child corresponding to token LAG
fn LAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LAG, 0)
}
/// Retrieves first TerminalNode corresponding to token LAMBDA
/// Returns `None` if there is no child corresponding to token LAMBDA
fn LAMBDA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LAMBDA, 0)
}
/// Retrieves first TerminalNode corresponding to token LANGUAGE
/// Returns `None` if there is no child corresponding to token LANGUAGE
fn LANGUAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LANGUAGE, 0)
}
/// Retrieves first TerminalNode corresponding to token LAST
/// Returns `None` if there is no child corresponding to token LAST
fn LAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LAST, 0)
}
/// Retrieves first TerminalNode corresponding to token LAST_VALUE
/// Returns `None` if there is no child corresponding to token LAST_VALUE
fn LAST_VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LAST_VALUE, 0)
}
/// Retrieves first TerminalNode corresponding to token LEADING
/// Returns `None` if there is no child corresponding to token LEADING
fn LEADING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LEADING, 0)
}
/// Retrieves first TerminalNode corresponding to token LEVEL
/// Returns `None` if there is no child corresponding to token LEVEL
fn LEVEL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LEVEL, 0)
}
/// Retrieves first TerminalNode corresponding to token LIBRARY
/// Returns `None` if there is no child corresponding to token LIBRARY
fn LIBRARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LIBRARY, 0)
}
/// Retrieves first TerminalNode corresponding to token LIMIT
/// Returns `None` if there is no child corresponding to token LIMIT
fn LIMIT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LIMIT, 0)
}
/// Retrieves first TerminalNode corresponding to token LINES
/// Returns `None` if there is no child corresponding to token LINES
fn LINES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LINES, 0)
}
/// Retrieves first TerminalNode corresponding to token LISTAGG
/// Returns `None` if there is no child corresponding to token LISTAGG
fn LISTAGG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LISTAGG, 0)
}
/// Retrieves first TerminalNode corresponding to token LOCAL
/// Returns `None` if there is no child corresponding to token LOCAL
fn LOCAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LOCAL, 0)
}
/// Retrieves first TerminalNode corresponding to token LOCATION
/// Returns `None` if there is no child corresponding to token LOCATION
fn LOCATION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LOCATION, 0)
}
/// Retrieves first TerminalNode corresponding to token LOCK
/// Returns `None` if there is no child corresponding to token LOCK
fn LOCK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LOCK, 0)
}
/// Retrieves first TerminalNode corresponding to token LOGICAL
/// Returns `None` if there is no child corresponding to token LOGICAL
fn LOGICAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(LOGICAL, 0)
}
/// Retrieves first TerminalNode corresponding to token MAP
/// Returns `None` if there is no child corresponding to token MAP
fn MAP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MAP, 0)
}
/// Retrieves first TerminalNode corresponding to token MASKING
/// Returns `None` if there is no child corresponding to token MASKING
fn MASKING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MASKING, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCH
/// Returns `None` if there is no child corresponding to token MATCH
fn MATCH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCH, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCHED
/// Returns `None` if there is no child corresponding to token MATCHED
fn MATCHED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCHED, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCHES
/// Returns `None` if there is no child corresponding to token MATCHES
fn MATCHES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCHES, 0)
}
/// Retrieves first TerminalNode corresponding to token MATCH_RECOGNIZE
/// Returns `None` if there is no child corresponding to token MATCH_RECOGNIZE
fn MATCH_RECOGNIZE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATCH_RECOGNIZE, 0)
}
/// Retrieves first TerminalNode corresponding to token MATERIALIZED
/// Returns `None` if there is no child corresponding to token MATERIALIZED
fn MATERIALIZED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MATERIALIZED, 0)
}
/// Retrieves first TerminalNode corresponding to token MAX
/// Returns `None` if there is no child corresponding to token MAX
fn MAX(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MAX, 0)
}
/// Retrieves first TerminalNode corresponding to token MEASURES
/// Returns `None` if there is no child corresponding to token MEASURES
fn MEASURES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MEASURES, 0)
}
/// Retrieves first TerminalNode corresponding to token MEMORIZABLE
/// Returns `None` if there is no child corresponding to token MEMORIZABLE
fn MEMORIZABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MEMORIZABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token MERGE
/// Returns `None` if there is no child corresponding to token MERGE
fn MERGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MERGE, 0)
}
/// Retrieves first TerminalNode corresponding to token MINHASH
/// Returns `None` if there is no child corresponding to token MINHASH
fn MINHASH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MINHASH, 0)
}
/// Retrieves first TerminalNode corresponding to token MINUTE
/// Returns `None` if there is no child corresponding to token MINUTE
fn MINUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MINUTE, 0)
}
/// Retrieves first TerminalNode corresponding to token MOD
/// Returns `None` if there is no child corresponding to token MOD
fn MOD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MOD, 0)
}
/// Retrieves first TerminalNode corresponding to token MODEL
/// Returns `None` if there is no child corresponding to token MODEL
fn MODEL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MODEL, 0)
}
/// Retrieves first TerminalNode corresponding to token MONTH
/// Returns `None` if there is no child corresponding to token MONTH
fn MONTH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(MONTH, 0)
}
/// Retrieves first TerminalNode corresponding to token NAME
/// Returns `None` if there is no child corresponding to token NAME
fn NAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NAME, 0)
}
/// Retrieves first TerminalNode corresponding to token NCHAR
/// Returns `None` if there is no child corresponding to token NCHAR
fn NCHAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NCHAR, 0)
}
/// Retrieves first TerminalNode corresponding to token NEXT
/// Returns `None` if there is no child corresponding to token NEXT
fn NEXT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NEXT, 0)
}
/// Retrieves first TerminalNode corresponding to token NFC
/// Returns `None` if there is no child corresponding to token NFC
fn NFC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NFC, 0)
}
/// Retrieves first TerminalNode corresponding to token NFD
/// Returns `None` if there is no child corresponding to token NFD
fn NFD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NFD, 0)
}
/// Retrieves first TerminalNode corresponding to token NFKC
/// Returns `None` if there is no child corresponding to token NFKC
fn NFKC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NFKC, 0)
}
/// Retrieves first TerminalNode corresponding to token NFKD
/// Returns `None` if there is no child corresponding to token NFKD
fn NFKD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NFKD, 0)
}
/// Retrieves first TerminalNode corresponding to token NO
/// Returns `None` if there is no child corresponding to token NO
fn NO(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NO, 0)
}
/// Retrieves first TerminalNode corresponding to token NONE
/// Returns `None` if there is no child corresponding to token NONE
fn NONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NONE, 0)
}
/// Retrieves first TerminalNode corresponding to token NOORDER
/// Returns `None` if there is no child corresponding to token NOORDER
fn NOORDER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOORDER, 0)
}
/// Retrieves first TerminalNode corresponding to token NORELY
/// Returns `None` if there is no child corresponding to token NORELY
fn NORELY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NORELY, 0)
}
/// Retrieves first TerminalNode corresponding to token NORMALIZE
/// Returns `None` if there is no child corresponding to token NORMALIZE
fn NORMALIZE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NORMALIZE, 0)
}
/// Retrieves first TerminalNode corresponding to token NOVALIDATE
/// Returns `None` if there is no child corresponding to token NOVALIDATE
fn NOVALIDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NOVALIDATE, 0)
}
/// Retrieves first TerminalNode corresponding to token NULLS
/// Returns `None` if there is no child corresponding to token NULLS
fn NULLS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(NULLS, 0)
}
/// Retrieves first TerminalNode corresponding to token OBJECT
/// Returns `None` if there is no child corresponding to token OBJECT
fn OBJECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OBJECT, 0)
}
/// Retrieves first TerminalNode corresponding to token OFFSET
/// Returns `None` if there is no child corresponding to token OFFSET
fn OFFSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OFFSET, 0)
}
/// Retrieves first TerminalNode corresponding to token OMIT
/// Returns `None` if there is no child corresponding to token OMIT
fn OMIT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OMIT, 0)
}
/// Retrieves first TerminalNode corresponding to token ONE
/// Returns `None` if there is no child corresponding to token ONE
fn ONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ONE, 0)
}
/// Retrieves first TerminalNode corresponding to token ONLY
/// Returns `None` if there is no child corresponding to token ONLY
fn ONLY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ONLY, 0)
}
/// Retrieves first TerminalNode corresponding to token OPTION
/// Returns `None` if there is no child corresponding to token OPTION
fn OPTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OPTION, 0)
}
/// Retrieves first TerminalNode corresponding to token OPTIONS
/// Returns `None` if there is no child corresponding to token OPTIONS
fn OPTIONS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OPTIONS, 0)
}
/// Retrieves first TerminalNode corresponding to token ORDINALITY
/// Returns `None` if there is no child corresponding to token ORDINALITY
fn ORDINALITY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ORDINALITY, 0)
}
/// Retrieves first TerminalNode corresponding to token OUTER
/// Returns `None` if there is no child corresponding to token OUTER
fn OUTER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OUTER, 0)
}
/// Retrieves first TerminalNode corresponding to token OUTPUT
/// Returns `None` if there is no child corresponding to token OUTPUT
fn OUTPUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OUTPUT, 0)
}
/// Retrieves first TerminalNode corresponding to token OUTPUTFORMAT
/// Returns `None` if there is no child corresponding to token OUTPUTFORMAT
fn OUTPUTFORMAT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OUTPUTFORMAT, 0)
}
/// Retrieves first TerminalNode corresponding to token OVER
/// Returns `None` if there is no child corresponding to token OVER
fn OVER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OVER, 0)
}
/// Retrieves first TerminalNode corresponding to token OVERFLOW
/// Returns `None` if there is no child corresponding to token OVERFLOW
fn OVERFLOW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OVERFLOW, 0)
}
/// Retrieves first TerminalNode corresponding to token OWNER
/// Returns `None` if there is no child corresponding to token OWNER
fn OWNER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(OWNER, 0)
}
/// Retrieves first TerminalNode corresponding to token PARTITION
/// Returns `None` if there is no child corresponding to token PARTITION
fn PARTITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITION, 0)
}
/// Retrieves first TerminalNode corresponding to token PARTITIONED
/// Returns `None` if there is no child corresponding to token PARTITIONED
fn PARTITIONED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITIONED, 0)
}
/// Retrieves first TerminalNode corresponding to token PARTITIONS
/// Returns `None` if there is no child corresponding to token PARTITIONS
fn PARTITIONS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PARTITIONS, 0)
}
/// Retrieves first TerminalNode corresponding to token PASSING
/// Returns `None` if there is no child corresponding to token PASSING
fn PASSING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PASSING, 0)
}
/// Retrieves first TerminalNode corresponding to token PAST
/// Returns `None` if there is no child corresponding to token PAST
fn PAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PAST, 0)
}
/// Retrieves first TerminalNode corresponding to token PATH
/// Returns `None` if there is no child corresponding to token PATH
fn PATH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PATH, 0)
}
/// Retrieves first TerminalNode corresponding to token PATTERN
/// Returns `None` if there is no child corresponding to token PATTERN
fn PATTERN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PATTERN, 0)
}
/// Retrieves first TerminalNode corresponding to token PER
/// Returns `None` if there is no child corresponding to token PER
fn PER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PER, 0)
}
/// Retrieves first TerminalNode corresponding to token PERCENTILE_CONT
/// Returns `None` if there is no child corresponding to token PERCENTILE_CONT
fn PERCENTILE_CONT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PERCENTILE_CONT, 0)
}
/// Retrieves first TerminalNode corresponding to token PERCENTILE_DISC
/// Returns `None` if there is no child corresponding to token PERCENTILE_DISC
fn PERCENTILE_DISC(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PERCENTILE_DISC, 0)
}
/// Retrieves first TerminalNode corresponding to token PERIOD
/// Returns `None` if there is no child corresponding to token PERIOD
fn PERIOD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PERIOD, 0)
}
/// Retrieves first TerminalNode corresponding to token PERMUTE
/// Returns `None` if there is no child corresponding to token PERMUTE
fn PERMUTE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PERMUTE, 0)
}
/// Retrieves first TerminalNode corresponding to token PIVOT
/// Returns `None` if there is no child corresponding to token PIVOT
fn PIVOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PIVOT, 0)
}
/// Retrieves first TerminalNode corresponding to token PLACING
/// Returns `None` if there is no child corresponding to token PLACING
fn PLACING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PLACING, 0)
}
/// Retrieves first TerminalNode corresponding to token POLICY
/// Returns `None` if there is no child corresponding to token POLICY
fn POLICY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(POLICY, 0)
}
/// Retrieves first TerminalNode corresponding to token POSITION
/// Returns `None` if there is no child corresponding to token POSITION
fn POSITION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(POSITION, 0)
}
/// Retrieves first TerminalNode corresponding to token PRECEDING
/// Returns `None` if there is no child corresponding to token PRECEDING
fn PRECEDING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRECEDING, 0)
}
/// Retrieves first TerminalNode corresponding to token PRECISION
/// Returns `None` if there is no child corresponding to token PRECISION
fn PRECISION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRECISION, 0)
}
/// Retrieves first TerminalNode corresponding to token PREPARE
/// Returns `None` if there is no child corresponding to token PREPARE
fn PREPARE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PREPARE, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIMARY
/// Returns `None` if there is no child corresponding to token PRIMARY
fn PRIMARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRIMARY, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIOR
/// Returns `None` if there is no child corresponding to token PRIOR
fn PRIOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRIOR, 0)
}
/// Retrieves first TerminalNode corresponding to token PRIVILEGES
/// Returns `None` if there is no child corresponding to token PRIVILEGES
fn PRIVILEGES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRIVILEGES, 0)
}
/// Retrieves first TerminalNode corresponding to token PROCEDURE
/// Returns `None` if there is no child corresponding to token PROCEDURE
fn PROCEDURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PROCEDURE, 0)
}
/// Retrieves first TerminalNode corresponding to token PROPERTIES
/// Returns `None` if there is no child corresponding to token PROPERTIES
fn PROPERTIES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PROPERTIES, 0)
}
/// Retrieves first TerminalNode corresponding to token PRUNE
/// Returns `None` if there is no child corresponding to token PRUNE
fn PRUNE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PRUNE, 0)
}
/// Retrieves first TerminalNode corresponding to token PYTHON
/// Returns `None` if there is no child corresponding to token PYTHON
fn PYTHON(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(PYTHON, 0)
}
/// Retrieves first TerminalNode corresponding to token QUOTES
/// Returns `None` if there is no child corresponding to token QUOTES
fn QUOTES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(QUOTES, 0)
}
/// Retrieves first TerminalNode corresponding to token RANGE
/// Returns `None` if there is no child corresponding to token RANGE
fn RANGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RANGE, 0)
}
/// Retrieves first TerminalNode corresponding to token READ
/// Returns `None` if there is no child corresponding to token READ
fn READ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(READ, 0)
}
/// Retrieves first TerminalNode corresponding to token RECURSIVE
/// Returns `None` if there is no child corresponding to token RECURSIVE
fn RECURSIVE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RECURSIVE, 0)
}
/// Retrieves first TerminalNode corresponding to token REFERENCE
/// Returns `None` if there is no child corresponding to token REFERENCE
fn REFERENCE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REFERENCE, 0)
}
/// Retrieves first TerminalNode corresponding to token REFERENCES
/// Returns `None` if there is no child corresponding to token REFERENCES
fn REFERENCES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REFERENCES, 0)
}
/// Retrieves first TerminalNode corresponding to token REFRESH
/// Returns `None` if there is no child corresponding to token REFRESH
fn REFRESH(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REFRESH, 0)
}
/// Retrieves first TerminalNode corresponding to token RELY
/// Returns `None` if there is no child corresponding to token RELY
fn RELY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RELY, 0)
}
/// Retrieves first TerminalNode corresponding to token RENAME
/// Returns `None` if there is no child corresponding to token RENAME
fn RENAME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RENAME, 0)
}
/// Retrieves first TerminalNode corresponding to token REPEATABLE
/// Returns `None` if there is no child corresponding to token REPEATABLE
fn REPEATABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REPEATABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token REPLACE
/// Returns `None` if there is no child corresponding to token REPLACE
fn REPLACE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(REPLACE, 0)
}
/// Retrieves first TerminalNode corresponding to token RESET
/// Returns `None` if there is no child corresponding to token RESET
fn RESET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RESET, 0)
}
/// Retrieves first TerminalNode corresponding to token RESPECT
/// Returns `None` if there is no child corresponding to token RESPECT
fn RESPECT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RESPECT, 0)
}
/// Retrieves first TerminalNode corresponding to token RESTRICT
/// Returns `None` if there is no child corresponding to token RESTRICT
fn RESTRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RESTRICT, 0)
}
/// Retrieves first TerminalNode corresponding to token RESTRICTED
/// Returns `None` if there is no child corresponding to token RESTRICTED
fn RESTRICTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RESTRICTED, 0)
}
/// Retrieves first TerminalNode corresponding to token RETURN
/// Returns `None` if there is no child corresponding to token RETURN
fn RETURN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RETURN, 0)
}
/// Retrieves first TerminalNode corresponding to token RETURNING
/// Returns `None` if there is no child corresponding to token RETURNING
fn RETURNING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RETURNING, 0)
}
/// Retrieves first TerminalNode corresponding to token RETURNS
/// Returns `None` if there is no child corresponding to token RETURNS
fn RETURNS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RETURNS, 0)
}
/// Retrieves first TerminalNode corresponding to token RLS
/// Returns `None` if there is no child corresponding to token RLS
fn RLS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RLS, 0)
}
/// Retrieves first TerminalNode corresponding to token ROLE
/// Returns `None` if there is no child corresponding to token ROLE
fn ROLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROLE, 0)
}
/// Retrieves first TerminalNode corresponding to token ROLES
/// Returns `None` if there is no child corresponding to token ROLES
fn ROLES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROLES, 0)
}
/// Retrieves first TerminalNode corresponding to token ROLLBACK
/// Returns `None` if there is no child corresponding to token ROLLBACK
fn ROLLBACK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROLLBACK, 0)
}
/// Retrieves first TerminalNode corresponding to token ROLLUP
/// Returns `None` if there is no child corresponding to token ROLLUP
fn ROLLUP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ROLLUP, 0)
}
/// Retrieves first TerminalNode corresponding to token RUNNING
/// Returns `None` if there is no child corresponding to token RUNNING
fn RUNNING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(RUNNING, 0)
}
/// Retrieves first TerminalNode corresponding to token SCALA
/// Returns `None` if there is no child corresponding to token SCALA
fn SCALA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SCALA, 0)
}
/// Retrieves first TerminalNode corresponding to token SCALAR
/// Returns `None` if there is no child corresponding to token SCALAR
fn SCALAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SCALAR, 0)
}
/// Retrieves first TerminalNode corresponding to token SCHEMA
/// Returns `None` if there is no child corresponding to token SCHEMA
fn SCHEMA(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SCHEMA, 0)
}
/// Retrieves first TerminalNode corresponding to token SCHEMAS
/// Returns `None` if there is no child corresponding to token SCHEMAS
fn SCHEMAS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SCHEMAS, 0)
}
/// Retrieves first TerminalNode corresponding to token SECOND
/// Returns `None` if there is no child corresponding to token SECOND
fn SECOND(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SECOND, 0)
}
/// Retrieves first TerminalNode corresponding to token SECURE
/// Returns `None` if there is no child corresponding to token SECURE
fn SECURE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SECURE, 0)
}
/// Retrieves first TerminalNode corresponding to token SECURITY
/// Returns `None` if there is no child corresponding to token SECURITY
fn SECURITY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SECURITY, 0)
}
/// Retrieves first TerminalNode corresponding to token SEED
/// Returns `None` if there is no child corresponding to token SEED
fn SEED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEED, 0)
}
/// Retrieves first TerminalNode corresponding to token SEEK
/// Returns `None` if there is no child corresponding to token SEEK
fn SEEK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEEK, 0)
}
/// Retrieves first TerminalNode corresponding to token SEMI
/// Returns `None` if there is no child corresponding to token SEMI
fn SEMI(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEMI, 0)
}
/// Retrieves first TerminalNode corresponding to token SEQUENCE
/// Returns `None` if there is no child corresponding to token SEQUENCE
fn SEQUENCE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SEQUENCE, 0)
}
/// Retrieves first TerminalNode corresponding to token SERDE
/// Returns `None` if there is no child corresponding to token SERDE
fn SERDE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SERDE, 0)
}
/// Retrieves first TerminalNode corresponding to token SERDEPROPERTIES
/// Returns `None` if there is no child corresponding to token SERDEPROPERTIES
fn SERDEPROPERTIES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SERDEPROPERTIES, 0)
}
/// Retrieves first TerminalNode corresponding to token SERIALIZABLE
/// Returns `None` if there is no child corresponding to token SERIALIZABLE
fn SERIALIZABLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SERIALIZABLE, 0)
}
/// Retrieves first TerminalNode corresponding to token SESSION
/// Returns `None` if there is no child corresponding to token SESSION
fn SESSION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SESSION, 0)
}
/// Retrieves first TerminalNode corresponding to token SETS
/// Returns `None` if there is no child corresponding to token SETS
fn SETS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SETS, 0)
}
/// Retrieves first TerminalNode corresponding to token SHOW
/// Returns `None` if there is no child corresponding to token SHOW
fn SHOW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SHOW, 0)
}
/// Retrieves first TerminalNode corresponding to token SIMILAR
/// Returns `None` if there is no child corresponding to token SIMILAR
fn SIMILAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SIMILAR, 0)
}
/// Retrieves first TerminalNode corresponding to token SKIP_KW
/// Returns `None` if there is no child corresponding to token SKIP_KW
fn SKIP_KW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SKIP_KW, 0)
}
/// Retrieves first TerminalNode corresponding to token SNAPSHOT
/// Returns `None` if there is no child corresponding to token SNAPSHOT
fn SNAPSHOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SNAPSHOT, 0)
}
/// Retrieves first TerminalNode corresponding to token SORTKEY
/// Returns `None` if there is no child corresponding to token SORTKEY
fn SORTKEY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SORTKEY, 0)
}
/// Retrieves first TerminalNode corresponding to token SQL
/// Returns `None` if there is no child corresponding to token SQL
fn SQL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SQL, 0)
}
/// Retrieves first TerminalNode corresponding to token STAGE
/// Returns `None` if there is no child corresponding to token STAGE
fn STAGE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STAGE, 0)
}
/// Retrieves first TerminalNode corresponding to token STATEMENT
/// Returns `None` if there is no child corresponding to token STATEMENT
fn STATEMENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STATEMENT, 0)
}
/// Retrieves first TerminalNode corresponding to token STATS
/// Returns `None` if there is no child corresponding to token STATS
fn STATS(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STATS, 0)
}
/// Retrieves first TerminalNode corresponding to token STORED
/// Returns `None` if there is no child corresponding to token STORED
fn STORED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STORED, 0)
}
/// Retrieves first TerminalNode corresponding to token STREAM
/// Returns `None` if there is no child corresponding to token STREAM
fn STREAM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STREAM, 0)
}
/// Retrieves first TerminalNode corresponding to token STRICT
/// Returns `None` if there is no child corresponding to token STRICT
fn STRICT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STRICT, 0)
}
/// Retrieves first TerminalNode corresponding to token STRING_KW
/// Returns `None` if there is no child corresponding to token STRING_KW
fn STRING_KW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STRING_KW, 0)
}
/// Retrieves first TerminalNode corresponding to token STRUCT
/// Returns `None` if there is no child corresponding to token STRUCT
fn STRUCT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(STRUCT, 0)
}
/// Retrieves first TerminalNode corresponding to token SUBSET
/// Returns `None` if there is no child corresponding to token SUBSET
fn SUBSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SUBSET, 0)
}
/// Retrieves first TerminalNode corresponding to token SUBSTRING
/// Returns `None` if there is no child corresponding to token SUBSTRING
fn SUBSTRING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SUBSTRING, 0)
}
/// Retrieves first TerminalNode corresponding to token SYSTEM
/// Returns `None` if there is no child corresponding to token SYSTEM
fn SYSTEM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SYSTEM, 0)
}
/// Retrieves first TerminalNode corresponding to token SYSTEM_TIME
/// Returns `None` if there is no child corresponding to token SYSTEM_TIME
fn SYSTEM_TIME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(SYSTEM_TIME, 0)
}
/// Retrieves first TerminalNode corresponding to token TABLES
/// Returns `None` if there is no child corresponding to token TABLES
fn TABLES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TABLES, 0)
}
/// Retrieves first TerminalNode corresponding to token TAG
/// Returns `None` if there is no child corresponding to token TAG
fn TAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TAG, 0)
}
/// Retrieves first TerminalNode corresponding to token TARGET_LAG
/// Returns `None` if there is no child corresponding to token TARGET_LAG
fn TARGET_LAG(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TARGET_LAG, 0)
}
/// Retrieves first TerminalNode corresponding to token TEMP
/// Returns `None` if there is no child corresponding to token TEMP
fn TEMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TEMP, 0)
}
/// Retrieves first TerminalNode corresponding to token TEMPLATE
/// Returns `None` if there is no child corresponding to token TEMPLATE
fn TEMPLATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TEMPLATE, 0)
}
/// Retrieves first TerminalNode corresponding to token TEMPORARY
/// Returns `None` if there is no child corresponding to token TEMPORARY
fn TEMPORARY(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TEMPORARY, 0)
}
/// Retrieves first TerminalNode corresponding to token TERMINATED
/// Returns `None` if there is no child corresponding to token TERMINATED
fn TERMINATED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TERMINATED, 0)
}
/// Retrieves first TerminalNode corresponding to token TEXT
/// Returns `None` if there is no child corresponding to token TEXT
fn TEXT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TEXT, 0)
}
/// Retrieves first TerminalNode corresponding to token TIES
/// Returns `None` if there is no child corresponding to token TIES
fn TIES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIES, 0)
}
/// Retrieves first TerminalNode corresponding to token TIME
/// Returns `None` if there is no child corresponding to token TIME
fn TIME(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIME, 0)
}
/// Retrieves first TerminalNode corresponding to token TIMESTAMP
/// Returns `None` if there is no child corresponding to token TIMESTAMP
fn TIMESTAMP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TIMESTAMP, 0)
}
/// Retrieves first TerminalNode corresponding to token TOP
/// Returns `None` if there is no child corresponding to token TOP
fn TOP(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TOP, 0)
}
/// Retrieves first TerminalNode corresponding to token TRAILING
/// Returns `None` if there is no child corresponding to token TRAILING
fn TRAILING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRAILING, 0)
}
/// Retrieves first TerminalNode corresponding to token TRANSACTION
/// Returns `None` if there is no child corresponding to token TRANSACTION
fn TRANSACTION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRANSACTION, 0)
}
/// Retrieves first TerminalNode corresponding to token TRANSIENT
/// Returns `None` if there is no child corresponding to token TRANSIENT
fn TRANSIENT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRANSIENT, 0)
}
/// Retrieves first TerminalNode corresponding to token TRIM
/// Returns `None` if there is no child corresponding to token TRIM
fn TRIM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRIM, 0)
}
/// Retrieves first TerminalNode corresponding to token TRUE
/// Returns `None` if there is no child corresponding to token TRUE
fn TRUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRUE, 0)
}
/// Retrieves first TerminalNode corresponding to token TRUNCATE
/// Returns `None` if there is no child corresponding to token TRUNCATE
fn TRUNCATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRUNCATE, 0)
}
/// Retrieves first TerminalNode corresponding to token TRY_CAST
/// Returns `None` if there is no child corresponding to token TRY_CAST
fn TRY_CAST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TRY_CAST, 0)
}
/// Retrieves first TerminalNode corresponding to token TUPLE
/// Returns `None` if there is no child corresponding to token TUPLE
fn TUPLE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TUPLE, 0)
}
/// Retrieves first TerminalNode corresponding to token TYPE
/// Returns `None` if there is no child corresponding to token TYPE
fn TYPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(TYPE, 0)
}
/// Retrieves first TerminalNode corresponding to token UESCAPE
/// Returns `None` if there is no child corresponding to token UESCAPE
fn UESCAPE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UESCAPE, 0)
}
/// Retrieves first TerminalNode corresponding to token UNBOUNDED
/// Returns `None` if there is no child corresponding to token UNBOUNDED
fn UNBOUNDED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNBOUNDED, 0)
}
/// Retrieves first TerminalNode corresponding to token UNCOMMITTED
/// Returns `None` if there is no child corresponding to token UNCOMMITTED
fn UNCOMMITTED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNCOMMITTED, 0)
}
/// Retrieves first TerminalNode corresponding to token UNCONDITIONAL
/// Returns `None` if there is no child corresponding to token UNCONDITIONAL
fn UNCONDITIONAL(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNCONDITIONAL, 0)
}
/// Retrieves first TerminalNode corresponding to token UNKNOWN
/// Returns `None` if there is no child corresponding to token UNKNOWN
fn UNKNOWN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNKNOWN, 0)
}
/// Retrieves first TerminalNode corresponding to token UNLOAD
/// Returns `None` if there is no child corresponding to token UNLOAD
fn UNLOAD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNLOAD, 0)
}
/// Retrieves first TerminalNode corresponding to token UNMATCHED
/// Returns `None` if there is no child corresponding to token UNMATCHED
fn UNMATCHED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNMATCHED, 0)
}
/// Retrieves first TerminalNode corresponding to token UNNEST
/// Returns `None` if there is no child corresponding to token UNNEST
fn UNNEST(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNNEST, 0)
}
/// Retrieves first TerminalNode corresponding to token UNPIVOT
/// Returns `None` if there is no child corresponding to token UNPIVOT
fn UNPIVOT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNPIVOT, 0)
}
/// Retrieves first TerminalNode corresponding to token UNSET
/// Returns `None` if there is no child corresponding to token UNSET
fn UNSET(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNSET, 0)
}
/// Retrieves first TerminalNode corresponding to token UNSIGNED
/// Returns `None` if there is no child corresponding to token UNSIGNED
fn UNSIGNED(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UNSIGNED, 0)
}
/// Retrieves first TerminalNode corresponding to token USE
/// Returns `None` if there is no child corresponding to token USE
fn USE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(USE, 0)
}
/// Retrieves first TerminalNode corresponding to token USER
/// Returns `None` if there is no child corresponding to token USER
fn USER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(USER, 0)
}
/// Retrieves first TerminalNode corresponding to token UTF16
/// Returns `None` if there is no child corresponding to token UTF16
fn UTF16(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UTF16, 0)
}
/// Retrieves first TerminalNode corresponding to token UTF32
/// Returns `None` if there is no child corresponding to token UTF32
fn UTF32(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UTF32, 0)
}
/// Retrieves first TerminalNode corresponding to token UTF8
/// Returns `None` if there is no child corresponding to token UTF8
fn UTF8(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(UTF8, 0)
}
/// Retrieves first TerminalNode corresponding to token VACUUM
/// Returns `None` if there is no child corresponding to token VACUUM
fn VACUUM(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VACUUM, 0)
}
/// Retrieves first TerminalNode corresponding to token VALIDATE
/// Returns `None` if there is no child corresponding to token VALIDATE
fn VALIDATE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VALIDATE, 0)
}
/// Retrieves first TerminalNode corresponding to token VALUE
/// Returns `None` if there is no child corresponding to token VALUE
fn VALUE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VALUE, 0)
}
/// Retrieves first TerminalNode corresponding to token VARYING
/// Returns `None` if there is no child corresponding to token VARYING
fn VARYING(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VARYING, 0)
}
/// Retrieves first TerminalNode corresponding to token VECTOR
/// Returns `None` if there is no child corresponding to token VECTOR
fn VECTOR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VECTOR, 0)
}
/// Retrieves first TerminalNode corresponding to token VERBOSE
/// Returns `None` if there is no child corresponding to token VERBOSE
fn VERBOSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VERBOSE, 0)
}
/// Retrieves first TerminalNode corresponding to token VERSION
/// Returns `None` if there is no child corresponding to token VERSION
fn VERSION(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VERSION, 0)
}
/// Retrieves first TerminalNode corresponding to token VIEW
/// Returns `None` if there is no child corresponding to token VIEW
fn VIEW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VIEW, 0)
}
/// Retrieves first TerminalNode corresponding to token VOLATILE
/// Returns `None` if there is no child corresponding to token VOLATILE
fn VOLATILE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(VOLATILE, 0)
}
/// Retrieves first TerminalNode corresponding to token WAREHOUSE
/// Returns `None` if there is no child corresponding to token WAREHOUSE
fn WAREHOUSE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WAREHOUSE, 0)
}
/// Retrieves first TerminalNode corresponding to token WHEN
/// Returns `None` if there is no child corresponding to token WHEN
fn WHEN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WHEN, 0)
}
/// Retrieves first TerminalNode corresponding to token WINDOW
/// Returns `None` if there is no child corresponding to token WINDOW
fn WINDOW(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WINDOW, 0)
}
/// Retrieves first TerminalNode corresponding to token WITHIN
/// Returns `None` if there is no child corresponding to token WITHIN
fn WITHIN(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITHIN, 0)
}
/// Retrieves first TerminalNode corresponding to token WITHOUT
/// Returns `None` if there is no child corresponding to token WITHOUT
fn WITHOUT(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WITHOUT, 0)
}
/// Retrieves first TerminalNode corresponding to token WORK
/// Returns `None` if there is no child corresponding to token WORK
fn WORK(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WORK, 0)
}
/// Retrieves first TerminalNode corresponding to token WRAPPER
/// Returns `None` if there is no child corresponding to token WRAPPER
fn WRAPPER(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WRAPPER, 0)
}
/// Retrieves first TerminalNode corresponding to token WRITE
/// Returns `None` if there is no child corresponding to token WRITE
fn WRITE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(WRITE, 0)
}
/// Retrieves first TerminalNode corresponding to token XZ
/// Returns `None` if there is no child corresponding to token XZ
fn XZ(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(XZ, 0)
}
/// Retrieves first TerminalNode corresponding to token YEAR
/// Returns `None` if there is no child corresponding to token YEAR
fn YEAR(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(YEAR, 0)
}
/// Retrieves first TerminalNode corresponding to token YES
/// Returns `None` if there is no child corresponding to token YES
fn YES(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(YES, 0)
}
/// Retrieves first TerminalNode corresponding to token ZONE
/// Returns `None` if there is no child corresponding to token ZONE
fn ZONE(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ZONE, 0)
}
/// Retrieves first TerminalNode corresponding to token ZSTD
/// Returns `None` if there is no child corresponding to token ZSTD
fn ZSTD(&self) -> Option<Rc<TerminalNode<'input,SnowflakeParserContextType>>> where Self:Sized{
	self.get_token(ZSTD, 0)
}

}

impl<'input> NonReservedContextAttrs<'input> for NonReservedContext<'input>{}

impl<'input, I, H> SnowflakeParser<'input, I, H>
where
    I: TokenStream<'input, TF = LocalTokenFactory<'input> > + TidAble<'input>,
    H: ErrorStrategy<'input,BaseParserType<'input,I>>
{
	pub fn nonReserved(&mut self,)
	-> Result<Rc<NonReservedContextAll<'input>>,ANTLRError> {
		let mut recog = self;
		let _parentctx = recog.ctx.take();
		let mut _localctx = NonReservedContextExt::new(_parentctx.clone(), recog.base.get_state());
        recog.base.enter_rule(_localctx.clone(), 378, RULE_nonReserved);
        let mut _localctx: Rc<NonReservedContextAll> = _localctx;
		let mut _la: isize = -1;
		let result: Result<(), ANTLRError> = (|| {

			//recog.base.enter_outer_alt(_localctx.clone(), 1);
			recog.base.enter_outer_alt(None, 1);
			{
			recog.base.set_state(5586);
			_la = recog.base.input.la(1);
			if { !((((_la) & !0x3f) == 0 && ((1usize << _la) & ((1usize << ABORT) | (1usize << ABSENT) | (1usize << ACCESS) | (1usize << ADD) | (1usize << ADMIN) | (1usize << AFTER) | (1usize << ANALYZE) | (1usize << ANTI) | (1usize << APPEND_ONLY) | (1usize << ARRAY) | (1usize << ARRAYAGG) | (1usize << ARRAY_AGG) | (1usize << ASC) | (1usize << AT))) != 0) || ((((_la - 32)) & !0x3f) == 0 && ((1usize << (_la - 32)) & ((1usize << (ATTACH - 32)) | (1usize << (AUTHORIZATION - 32)) | (1usize << (AUTO - 32)) | (1usize << (AUTOINCREMENT - 32)) | (1usize << (BACKUP - 32)) | (1usize << (BEFORE - 32)) | (1usize << (BEGIN - 32)) | (1usize << (BERNOULLI - 32)) | (1usize << (BLOCK - 32)) | (1usize << (BOTH - 32)) | (1usize << (BZIP2 - 32)) | (1usize << (CALL - 32)) | (1usize << (CALLED - 32)) | (1usize << (CALLER - 32)) | (1usize << (CANCEL - 32)) | (1usize << (CASCADE - 32)) | (1usize << (CASE - 32)) | (1usize << (CASE_SENSITIVE - 32)) | (1usize << (CASE_INSENSITIVE - 32)) | (1usize << (CAST - 32)) | (1usize << (CATALOGS - 32)) | (1usize << (CHANGES - 32)) | (1usize << (CHAR - 32)) | (1usize << (CHARACTER - 32)) | (1usize << (CLONE - 32)) | (1usize << (CLOSE - 32)) | (1usize << (CLUSTER - 32)) | (1usize << (COLLATE - 32)) | (1usize << (COLUMNS - 32)))) != 0) || ((((_la - 65)) & !0x3f) == 0 && ((1usize << (_la - 65)) & ((1usize << (COMMENT - 65)) | (1usize << (COMMIT - 65)) | (1usize << (COMMITTED - 65)) | (1usize << (COMPOUND - 65)) | (1usize << (COMPRESSION - 65)) | (1usize << (CONDITIONAL - 65)) | (1usize << (CONNECTION - 65)) | (1usize << (CONNECT_BY_ROOT - 65)) | (1usize << (CONSTRAINT - 65)) | (1usize << (COPARTITION - 65)) | (1usize << (COPY - 65)) | (1usize << (COUNT - 65)) | (1usize << (CUBE - 65)) | (1usize << (CURRENT_ROLE - 65)) | (1usize << (DATA - 65)) | (1usize << (DATABASE - 65)) | (1usize << (DATASHARE - 65)) | (1usize << (DAY - 65)) | (1usize << (DEALLOCATE - 65)) | (1usize << (DECLARE - 65)) | (1usize << (DECODE - 65)) | (1usize << (DEFAULT - 65)) | (1usize << (DEFAULTS - 65)) | (1usize << (DEFINE - 65)) | (1usize << (DEFINER - 65)) | (1usize << (DELIMITED - 65)) | (1usize << (DELIMITER - 65)))) != 0) || ((((_la - 97)) & !0x3f) == 0 && ((1usize << (_la - 97)) & ((1usize << (DENY - 97)) | (1usize << (DEFERRABLE - 97)) | (1usize << (DEFERRED - 97)) | (1usize << (DESC - 97)) | (1usize << (DESCRIBE - 97)) | (1usize << (DESCRIPTOR - 97)) | (1usize << (DIRECTORY - 97)) | (1usize << (DISABLE - 97)) | (1usize << (DISTKEY - 97)) | (1usize << (DISTRIBUTED - 97)) | (1usize << (DISTSTYLE - 97)) | (1usize << (DETACH - 97)) | (1usize << (DOWNSTREAM - 97)) | (1usize << (DOUBLE - 97)) | (1usize << (DYNAMIC - 97)) | (1usize << (EMPTY - 97)) | (1usize << (ENABLE - 97)) | (1usize << (ENCODE - 97)) | (1usize << (ENCODING - 97)) | (1usize << (END - 97)) | (1usize << (ENFORCED - 97)) | (1usize << (ERROR - 97)) | (1usize << (ESCAPE - 97)) | (1usize << (EVEN - 97)) | (1usize << (EVENT - 97)) | (1usize << (EXCEPT - 97)) | (1usize << (EXCLUDE - 97)) | (1usize << (EXCLUDING - 97)) | (1usize << (EXECUTE - 97)))) != 0) || ((((_la - 130)) & !0x3f) == 0 && ((1usize << (_la - 130)) & ((1usize << (EXPLAIN - 130)) | (1usize << (EXTERNAL - 130)) | (1usize << (EXTRACT - 130)) | (1usize << (FALSE - 130)) | (1usize << (FETCH - 130)) | (1usize << (FIELDS - 130)) | (1usize << (FILE_FORMAT - 130)) | (1usize << (FILES - 130)) | (1usize << (FILTER - 130)) | (1usize << (FINAL - 130)) | (1usize << (FIRST - 130)) | (1usize << (FIRST_VALUE - 130)) | (1usize << (FLOAT - 130)) | (1usize << (FOREIGN - 130)) | (1usize << (FORMAT - 130)) | (1usize << (FORMAT_NAME - 130)) | (1usize << (FUNCTION - 130)) | (1usize << (FUNCTIONS - 130)) | (1usize << (GENERATED - 130)) | (1usize << (GLOBAL - 130)) | (1usize << (GRACE - 130)) | (1usize << (GRANTED - 130)) | (1usize << (GRANTS - 130)) | (1usize << (GRAPHVIZ - 130)) | (1usize << (GROUPING - 130)) | (1usize << (GROUPS - 130)))) != 0) || ((((_la - 162)) & !0x3f) == 0 && ((1usize << (_la - 162)) & ((1usize << (GZIP - 162)) | (1usize << (HEADER - 162)) | (1usize << (HOUR - 162)) | (1usize << (ICEBERG - 162)) | (1usize << (IDENTIFIER_KW - 162)) | (1usize << (IDENTITY - 162)) | (1usize << (IF - 162)) | (1usize << (IGNORE - 162)) | (1usize << (IMMEDIATE - 162)) | (1usize << (IMMUTABLE - 162)) | (1usize << (INCLUDE - 162)) | (1usize << (INCLUDING - 162)) | (1usize << (INFORMATION - 162)) | (1usize << (INITIAL - 162)) | (1usize << (INITIALLY - 162)) | (1usize << (INPUT - 162)) | (1usize << (INPUTFORMAT - 162)) | (1usize << (INTERLEAVED - 162)) | (1usize << (INTERVAL - 162)) | (1usize << (INVOKER - 162)) | (1usize << (IO - 162)) | (1usize << (ISOLATION - 162)) | (1usize << (JAVA - 162)))) != 0) || ((((_la - 194)) & !0x3f) == 0 && ((1usize << (_la - 194)) & ((1usize << (JAVASCRIPT - 194)) | (1usize << (JSON - 194)) | (1usize << (JSON_ARRAY - 194)) | (1usize << (JSON_EXISTS - 194)) | (1usize << (JSON_OBJECT - 194)) | (1usize << (JSON_QUERY - 194)) | (1usize << (JSON_VALUE - 194)) | (1usize << (KEEP - 194)) | (1usize << (KEY - 194)) | (1usize << (KEYS - 194)) | (1usize << (LAG - 194)) | (1usize << (LAMBDA - 194)) | (1usize << (LANGUAGE - 194)) | (1usize << (LAST - 194)) | (1usize << (LAST_VALUE - 194)) | (1usize << (LEADING - 194)) | (1usize << (LEVEL - 194)) | (1usize << (LIBRARY - 194)) | (1usize << (LIMIT - 194)) | (1usize << (LINES - 194)) | (1usize << (LISTAGG - 194)) | (1usize << (LOCAL - 194)) | (1usize << (LOCATION - 194)) | (1usize << (LOCK - 194)) | (1usize << (LOGICAL - 194)) | (1usize << (MAP - 194)) | (1usize << (MASKING - 194)) | (1usize << (MATCH - 194)))) != 0) || ((((_la - 226)) & !0x3f) == 0 && ((1usize << (_la - 226)) & ((1usize << (MATCHED - 226)) | (1usize << (MATCHES - 226)) | (1usize << (MATCH_RECOGNIZE - 226)) | (1usize << (MATERIALIZED - 226)) | (1usize << (MAX - 226)) | (1usize << (MEASURES - 226)) | (1usize << (MEMORIZABLE - 226)) | (1usize << (MERGE - 226)) | (1usize << (MINHASH - 226)) | (1usize << (MINUTE - 226)) | (1usize << (MOD - 226)) | (1usize << (MODEL - 226)) | (1usize << (MONTH - 226)) | (1usize << (NAME - 226)) | (1usize << (NCHAR - 226)) | (1usize << (NEXT - 226)) | (1usize << (NFC - 226)) | (1usize << (NFD - 226)) | (1usize << (NFKC - 226)) | (1usize << (NFKD - 226)) | (1usize << (NO - 226)) | (1usize << (NONE - 226)) | (1usize << (NOORDER - 226)) | (1usize << (NORELY - 226)) | (1usize << (NORMALIZE - 226)) | (1usize << (NOVALIDATE - 226)) | (1usize << (NULLS - 226)))) != 0) || ((((_la - 258)) & !0x3f) == 0 && ((1usize << (_la - 258)) & ((1usize << (OBJECT - 258)) | (1usize << (OFFSET - 258)) | (1usize << (OMIT - 258)) | (1usize << (ONE - 258)) | (1usize << (ONLY - 258)) | (1usize << (OPTION - 258)) | (1usize << (OPTIONS - 258)) | (1usize << (ORDINALITY - 258)) | (1usize << (OUTER - 258)) | (1usize << (OUTPUT - 258)) | (1usize << (OUTPUTFORMAT - 258)) | (1usize << (OVER - 258)) | (1usize << (OVERFLOW - 258)) | (1usize << (OWNER - 258)) | (1usize << (PARTITION - 258)) | (1usize << (PARTITIONED - 258)) | (1usize << (PARTITIONS - 258)) | (1usize << (PASSING - 258)) | (1usize << (PAST - 258)) | (1usize << (PATH - 258)) | (1usize << (PATTERN - 258)) | (1usize << (PER - 258)) | (1usize << (PERCENTILE_CONT - 258)) | (1usize << (PERCENTILE_DISC - 258)) | (1usize << (PERIOD - 258)) | (1usize << (PERMUTE - 258)) | (1usize << (PIVOT - 258)) | (1usize << (PLACING - 258)))) != 0) || ((((_la - 290)) & !0x3f) == 0 && ((1usize << (_la - 290)) & ((1usize << (POLICY - 290)) | (1usize << (POSITION - 290)) | (1usize << (PRECEDING - 290)) | (1usize << (PRECISION - 290)) | (1usize << (PREPARE - 290)) | (1usize << (PRIOR - 290)) | (1usize << (PROCEDURE - 290)) | (1usize << (PRIMARY - 290)) | (1usize << (PRIVILEGES - 290)) | (1usize << (PROPERTIES - 290)) | (1usize << (PRUNE - 290)) | (1usize << (PYTHON - 290)) | (1usize << (QUOTES - 290)) | (1usize << (RANGE - 290)) | (1usize << (READ - 290)) | (1usize << (RECURSIVE - 290)) | (1usize << (REFERENCE - 290)) | (1usize << (REFERENCES - 290)) | (1usize << (REFRESH - 290)) | (1usize << (RELY - 290)) | (1usize << (RENAME - 290)) | (1usize << (REPEATABLE - 290)) | (1usize << (REPLACE - 290)) | (1usize << (RESET - 290)) | (1usize << (RESPECT - 290)) | (1usize << (RESTRICT - 290)) | (1usize << (RESTRICTED - 290)) | (1usize << (RETURN - 290)) | (1usize << (RETURNING - 290)) | (1usize << (RETURNS - 290)))) != 0) || ((((_la - 325)) & !0x3f) == 0 && ((1usize << (_la - 325)) & ((1usize << (RLS - 325)) | (1usize << (ROLE - 325)) | (1usize << (ROLES - 325)) | (1usize << (ROLLBACK - 325)) | (1usize << (ROLLUP - 325)) | (1usize << (RUNNING - 325)) | (1usize << (SCALA - 325)) | (1usize << (SCALAR - 325)) | (1usize << (SECOND - 325)) | (1usize << (SCHEMA - 325)) | (1usize << (SCHEMAS - 325)) | (1usize << (SECURE - 325)) | (1usize << (SECURITY - 325)) | (1usize << (SEED - 325)) | (1usize << (SEEK - 325)) | (1usize << (SEMI - 325)) | (1usize << (SEQUENCE - 325)) | (1usize << (SERDE - 325)) | (1usize << (SERDEPROPERTIES - 325)) | (1usize << (SERIALIZABLE - 325)) | (1usize << (SESSION - 325)) | (1usize << (SETS - 325)) | (1usize << (SHOW - 325)) | (1usize << (SIMILAR - 325)) | (1usize << (SKIP_KW - 325)) | (1usize << (SNAPSHOT - 325)))) != 0) || ((((_la - 357)) & !0x3f) == 0 && ((1usize << (_la - 357)) & ((1usize << (SORTKEY - 357)) | (1usize << (SQL - 357)) | (1usize << (STAGE - 357)) | (1usize << (STATEMENT - 357)) | (1usize << (STATS - 357)) | (1usize << (STORED - 357)) | (1usize << (STREAM - 357)) | (1usize << (STRICT - 357)) | (1usize << (STRUCT - 357)) | (1usize << (SUBSET - 357)) | (1usize << (SUBSTRING - 357)) | (1usize << (SYSTEM - 357)) | (1usize << (SYSTEM_TIME - 357)) | (1usize << (TABLES - 357)) | (1usize << (TAG - 357)) | (1usize << (TEMP - 357)) | (1usize << (TEMPLATE - 357)) | (1usize << (TEMPORARY - 357)) | (1usize << (TERMINATED - 357)) | (1usize << (TEXT - 357)) | (1usize << (STRING_KW - 357)) | (1usize << (TIES - 357)) | (1usize << (TIME - 357)) | (1usize << (TIMESTAMP - 357)) | (1usize << (TOP - 357)) | (1usize << (TRAILING - 357)) | (1usize << (TARGET_LAG - 357)))) != 0) || ((((_la - 389)) & !0x3f) == 0 && ((1usize << (_la - 389)) & ((1usize << (TRANSACTION - 389)) | (1usize << (TRANSIENT - 389)) | (1usize << (TRIM - 389)) | (1usize << (TRUE - 389)) | (1usize << (TRUNCATE - 389)) | (1usize << (TRY_CAST - 389)) | (1usize << (TUPLE - 389)) | (1usize << (TYPE - 389)) | (1usize << (UESCAPE - 389)) | (1usize << (UNBOUNDED - 389)) | (1usize << (UNCOMMITTED - 389)) | (1usize << (UNCONDITIONAL - 389)) | (1usize << (UNKNOWN - 389)) | (1usize << (UNLOAD - 389)) | (1usize << (UNMATCHED - 389)) | (1usize << (UNNEST - 389)) | (1usize << (UNPIVOT - 389)) | (1usize << (UNSET - 389)) | (1usize << (UNSIGNED - 389)) | (1usize << (USE - 389)) | (1usize << (USER - 389)) | (1usize << (UTF16 - 389)) | (1usize << (UTF32 - 389)) | (1usize << (UTF8 - 389)) | (1usize << (VACUUM - 389)) | (1usize << (VALIDATE - 389)) | (1usize << (VALUE - 389)))) != 0) || ((((_la - 421)) & !0x3f) == 0 && ((1usize << (_la - 421)) & ((1usize << (VARYING - 421)) | (1usize << (VECTOR - 421)) | (1usize << (VERBOSE - 421)) | (1usize << (VERSION - 421)) | (1usize << (VIEW - 421)) | (1usize << (VOLATILE - 421)) | (1usize << (WAREHOUSE - 421)) | (1usize << (WHEN - 421)) | (1usize << (WINDOW - 421)) | (1usize << (WITHIN - 421)) | (1usize << (WITHOUT - 421)) | (1usize << (WORK - 421)) | (1usize << (WRAPPER - 421)) | (1usize << (WRITE - 421)) | (1usize << (XZ - 421)) | (1usize << (YEAR - 421)) | (1usize << (YES - 421)) | (1usize << (ZONE - 421)) | (1usize << (ZSTD - 421)))) != 0)) } {
				recog.err_handler.recover_inline(&mut recog.base)?;

			}
			else {
				if  recog.base.input.la(1)==TOKEN_EOF { recog.base.matched_eof = true };
				recog.err_handler.report_match(&mut recog.base);
				recog.base.consume(&mut recog.err_handler);
			}
			}
			Ok(())
		})();
		match result {
		Ok(_)=>{},
        Err(e @ ANTLRError::FallThrough(_)) => return Err(e),
		Err(ref re) => {
				//_localctx.exception = re;
				recog.err_handler.report_error(&mut recog.base, re);
				recog.err_handler.recover(&mut recog.base, re)?;
			}
		}
		recog.base.exit_rule();

		Ok(_localctx)
	}
}

thread_local! {
    static _ATN: Rc<ATN> =
        Rc::new(ATNDeserializer::new(None).deserialize(_serializedATN.chars()));
    static _decision_to_DFA: Rc<Vec<RefCell<DFA>>> = {
        let mut dfa = Vec::new();
        let size = _ATN.with(|atn| atn.decision_to_state.len());
        for i in 0..size {
            dfa.push(DFA::new(_ATN.with(|atn| atn.clone()), _ATN.with(|atn| atn
            .get_decision_state(i)), i as isize).into())
        }
        Rc::new(dfa)
    };
}



const _serializedATN:&'static str =
	"\x03\u{608b}\u{a72a}\u{8133}\u{b9ed}\u{417c}\u{3be7}\u{7786}\u{5964}\x03\
	\u{1e5}\u{15d7}\x04\x02\x09\x02\x04\x03\x09\x03\x04\x04\x09\x04\x04\x05\
	\x09\x05\x04\x06\x09\x06\x04\x07\x09\x07\x04\x08\x09\x08\x04\x09\x09\x09\
	\x04\x0a\x09\x0a\x04\x0b\x09\x0b\x04\x0c\x09\x0c\x04\x0d\x09\x0d\x04\x0e\
	\x09\x0e\x04\x0f\x09\x0f\x04\x10\x09\x10\x04\x11\x09\x11\x04\x12\x09\x12\
	\x04\x13\x09\x13\x04\x14\x09\x14\x04\x15\x09\x15\x04\x16\x09\x16\x04\x17\
	\x09\x17\x04\x18\x09\x18\x04\x19\x09\x19\x04\x1a\x09\x1a\x04\x1b\x09\x1b\
	\x04\x1c\x09\x1c\x04\x1d\x09\x1d\x04\x1e\x09\x1e\x04\x1f\x09\x1f\x04\x20\
	\x09\x20\x04\x21\x09\x21\x04\x22\x09\x22\x04\x23\x09\x23\x04\x24\x09\x24\
	\x04\x25\x09\x25\x04\x26\x09\x26\x04\x27\x09\x27\x04\x28\x09\x28\x04\x29\
	\x09\x29\x04\x2a\x09\x2a\x04\x2b\x09\x2b\x04\x2c\x09\x2c\x04\x2d\x09\x2d\
	\x04\x2e\x09\x2e\x04\x2f\x09\x2f\x04\x30\x09\x30\x04\x31\x09\x31\x04\x32\
	\x09\x32\x04\x33\x09\x33\x04\x34\x09\x34\x04\x35\x09\x35\x04\x36\x09\x36\
	\x04\x37\x09\x37\x04\x38\x09\x38\x04\x39\x09\x39\x04\x3a\x09\x3a\x04\x3b\
	\x09\x3b\x04\x3c\x09\x3c\x04\x3d\x09\x3d\x04\x3e\x09\x3e\x04\x3f\x09\x3f\
	\x04\x40\x09\x40\x04\x41\x09\x41\x04\x42\x09\x42\x04\x43\x09\x43\x04\x44\
	\x09\x44\x04\x45\x09\x45\x04\x46\x09\x46\x04\x47\x09\x47\x04\x48\x09\x48\
	\x04\x49\x09\x49\x04\x4a\x09\x4a\x04\x4b\x09\x4b\x04\x4c\x09\x4c\x04\x4d\
	\x09\x4d\x04\x4e\x09\x4e\x04\x4f\x09\x4f\x04\x50\x09\x50\x04\x51\x09\x51\
	\x04\x52\x09\x52\x04\x53\x09\x53\x04\x54\x09\x54\x04\x55\x09\x55\x04\x56\
	\x09\x56\x04\x57\x09\x57\x04\x58\x09\x58\x04\x59\x09\x59\x04\x5a\x09\x5a\
	\x04\x5b\x09\x5b\x04\x5c\x09\x5c\x04\x5d\x09\x5d\x04\x5e\x09\x5e\x04\x5f\
	\x09\x5f\x04\x60\x09\x60\x04\x61\x09\x61\x04\x62\x09\x62\x04\x63\x09\x63\
	\x04\x64\x09\x64\x04\x65\x09\x65\x04\x66\x09\x66\x04\x67\x09\x67\x04\x68\
	\x09\x68\x04\x69\x09\x69\x04\x6a\x09\x6a\x04\x6b\x09\x6b\x04\x6c\x09\x6c\
	\x04\x6d\x09\x6d\x04\x6e\x09\x6e\x04\x6f\x09\x6f\x04\x70\x09\x70\x04\x71\
	\x09\x71\x04\x72\x09\x72\x04\x73\x09\x73\x04\x74\x09\x74\x04\x75\x09\x75\
	\x04\x76\x09\x76\x04\x77\x09\x77\x04\x78\x09\x78\x04\x79\x09\x79\x04\x7a\
	\x09\x7a\x04\x7b\x09\x7b\x04\x7c\x09\x7c\x04\x7d\x09\x7d\x04\x7e\x09\x7e\
	\x04\x7f\x09\x7f\x04\u{80}\x09\u{80}\x04\u{81}\x09\u{81}\x04\u{82}\x09\u{82}\
	\x04\u{83}\x09\u{83}\x04\u{84}\x09\u{84}\x04\u{85}\x09\u{85}\x04\u{86}\x09\
	\u{86}\x04\u{87}\x09\u{87}\x04\u{88}\x09\u{88}\x04\u{89}\x09\u{89}\x04\u{8a}\
	\x09\u{8a}\x04\u{8b}\x09\u{8b}\x04\u{8c}\x09\u{8c}\x04\u{8d}\x09\u{8d}\x04\
	\u{8e}\x09\u{8e}\x04\u{8f}\x09\u{8f}\x04\u{90}\x09\u{90}\x04\u{91}\x09\u{91}\
	\x04\u{92}\x09\u{92}\x04\u{93}\x09\u{93}\x04\u{94}\x09\u{94}\x04\u{95}\x09\
	\u{95}\x04\u{96}\x09\u{96}\x04\u{97}\x09\u{97}\x04\u{98}\x09\u{98}\x04\u{99}\
	\x09\u{99}\x04\u{9a}\x09\u{9a}\x04\u{9b}\x09\u{9b}\x04\u{9c}\x09\u{9c}\x04\
	\u{9d}\x09\u{9d}\x04\u{9e}\x09\u{9e}\x04\u{9f}\x09\u{9f}\x04\u{a0}\x09\u{a0}\
	\x04\u{a1}\x09\u{a1}\x04\u{a2}\x09\u{a2}\x04\u{a3}\x09\u{a3}\x04\u{a4}\x09\
	\u{a4}\x04\u{a5}\x09\u{a5}\x04\u{a6}\x09\u{a6}\x04\u{a7}\x09\u{a7}\x04\u{a8}\
	\x09\u{a8}\x04\u{a9}\x09\u{a9}\x04\u{aa}\x09\u{aa}\x04\u{ab}\x09\u{ab}\x04\
	\u{ac}\x09\u{ac}\x04\u{ad}\x09\u{ad}\x04\u{ae}\x09\u{ae}\x04\u{af}\x09\u{af}\
	\x04\u{b0}\x09\u{b0}\x04\u{b1}\x09\u{b1}\x04\u{b2}\x09\u{b2}\x04\u{b3}\x09\
	\u{b3}\x04\u{b4}\x09\u{b4}\x04\u{b5}\x09\u{b5}\x04\u{b6}\x09\u{b6}\x04\u{b7}\
	\x09\u{b7}\x04\u{b8}\x09\u{b8}\x04\u{b9}\x09\u{b9}\x04\u{ba}\x09\u{ba}\x04\
	\u{bb}\x09\u{bb}\x04\u{bc}\x09\u{bc}\x04\u{bd}\x09\u{bd}\x04\u{be}\x09\u{be}\
	\x04\u{bf}\x09\u{bf}\x03\x02\x05\x02\u{180}\x0a\x02\x03\x02\x03\x02\x05\
	\x02\u{184}\x0a\x02\x07\x02\u{186}\x0a\x02\x0c\x02\x0e\x02\u{189}\x0b\x02\
	\x03\x02\x03\x02\x03\x03\x05\x03\u{18e}\x0a\x03\x03\x03\x05\x03\u{191}\x0a\
	\x03\x03\x03\x03\x03\x03\x04\x03\x04\x03\x04\x03\x05\x03\x05\x03\x05\x03\
	\x06\x03\x06\x03\x06\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{1aa}\x0a\x07\x03\
	\x07\x03\x07\x07\x07\u{1ae}\x0a\x07\x0c\x07\x0e\x07\u{1b1}\x0b\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{1ca}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{1d1}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x05\x07\u{1d7}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\
	\u{1dd}\x0a\x07\x0c\x07\x0e\x07\u{1e0}\x0b\x07\x03\x07\x05\x07\u{1e3}\x0a\
	\x07\x03\x07\x03\x07\x05\x07\u{1e7}\x0a\x07\x03\x07\x05\x07\u{1ea}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{1f1}\x0a\x07\x03\x07\
	\x05\x07\u{1f4}\x0a\x07\x03\x07\x05\x07\u{1f7}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x05\x07\u{1fd}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{203}\x0a\x07\x03\x07\x03\x07\x05\x07\u{207}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{210}\x0a\x07\x03\x07\
	\x05\x07\u{213}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{219}\x0a\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{229}\x0a\x07\x03\
	\x07\x03\x07\x05\x07\u{22d}\x0a\x07\x03\x07\x03\x07\x05\x07\u{231}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{236}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x05\x07\u{23d}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x05\x07\u{24d}\x0a\x07\x03\x07\x03\x07\x05\x07\u{251}\x0a\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{257}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{25c}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{261}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{268}\x0a\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{278}\x0a\x07\x03\x07\x03\x07\
	\x05\x07\u{27c}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{281}\x0a\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{288}\x0a\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{298}\x0a\x07\x03\x07\x03\x07\x05\
	\x07\u{29c}\x0a\x07\x03\x07\x03\x07\x05\x07\u{2a0}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{2a8}\x0a\x07\x03\x07\x03\x07\
	\x05\x07\u{2ac}\x0a\x07\x03\x07\x03\x07\x05\x07\u{2b0}\x0a\x07\x03\x07\x03\
	\x07\x05\x07\u{2b4}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{2bc}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{2c1}\x0a\x07\
	\x03\x07\x05\x07\u{2c4}\x0a\x07\x03\x07\x05\x07\u{2c7}\x0a\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x05\x07\u{2cd}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{2d3}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{2de}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{2ec}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\
	\x07\u{2f3}\x0a\x07\x0c\x07\x0e\x07\u{2f6}\x0b\x07\x03\x07\x05\x07\u{2f9}\
	\x0a\x07\x05\x07\u{2fb}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{300}\x0a\
	\x07\x03\x07\x05\x07\u{303}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{30a}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{310}\
	\x0a\x07\x03\x07\x03\x07\x05\x07\u{314}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x07\x07\u{31a}\x0a\x07\x0c\x07\x0e\x07\u{31d}\x0b\x07\x03\x07\x05\
	\x07\u{320}\x0a\x07\x03\x07\x03\x07\x05\x07\u{324}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x05\x07\u{329}\x0a\x07\x03\x07\x05\x07\u{32c}\x0a\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{337}\
	\x0a\x07\x0c\x07\x0e\x07\u{33a}\x0b\x07\x03\x07\x03\x07\x05\x07\u{33e}\x0a\
	\x07\x03\x07\x05\x07\u{341}\x0a\x07\x03\x07\x03\x07\x05\x07\u{345}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{34d}\x0a\x07\
	\x0c\x07\x0e\x07\u{350}\x0b\x07\x03\x07\x03\x07\x05\x07\u{354}\x0a\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{35e}\
	\x0a\x07\x03\x07\x05\x07\u{361}\x0a\x07\x03\x07\x05\x07\u{364}\x0a\x07\x03\
	\x07\x05\x07\u{367}\x0a\x07\x03\x07\x05\x07\u{36a}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x05\x07\u{370}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{376}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{37c}\x0a\
	\x07\x0c\x07\x0e\x07\u{37f}\x0b\x07\x03\x07\x05\x07\u{382}\x0a\x07\x03\x07\
	\x03\x07\x05\x07\u{386}\x0a\x07\x03\x07\x05\x07\u{389}\x0a\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{394}\
	\x0a\x07\x0c\x07\x0e\x07\u{397}\x0b\x07\x03\x07\x03\x07\x05\x07\u{39b}\x0a\
	\x07\x03\x07\x05\x07\u{39e}\x0a\x07\x03\x07\x03\x07\x05\x07\u{3a2}\x0a\x07\
	\x03\x07\x03\x07\x05\x07\u{3a6}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\
	\u{3ab}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\
	\u{3b3}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x07\x07\u{3bc}\x0a\x07\x0c\x07\x0e\x07\u{3bf}\x0b\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{3c7}\x0a\x07\x0c\x07\x0e\x07\u{3ca}\
	\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{3d4}\x0a\x07\x03\x07\x05\x07\u{3d7}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x05\x07\u{3dd}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{3e3}\x0a\x07\x03\x07\x07\x07\u{3e6}\x0a\x07\x0c\x07\x0e\x07\u{3e9}\
	\x0b\x07\x03\x07\x05\x07\u{3ec}\x0a\x07\x03\x07\x03\x07\x05\x07\u{3f0}\x0a\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{3f5}\x0a\x07\x03\x07\x05\x07\u{3f8}\
	\x0a\x07\x03\x07\x05\x07\u{3fb}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{401}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{407}\x0a\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{40d}\x0a\x07\x0c\x07\x0e\
	\x07\u{410}\x0b\x07\x03\x07\x05\x07\u{413}\x0a\x07\x05\x07\u{415}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{41a}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{426}\
	\x0a\x07\x0c\x07\x0e\x07\u{429}\x0b\x07\x03\x07\x05\x07\u{42c}\x0a\x07\x03\
	\x07\x03\x07\x05\x07\u{430}\x0a\x07\x03\x07\x05\x07\u{433}\x0a\x07\x03\x07\
	\x05\x07\u{436}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{444}\x0a\x07\
	\x03\x07\x05\x07\u{447}\x0a\x07\x03\x07\x07\x07\u{44a}\x0a\x07\x0c\x07\x0e\
	\x07\u{44d}\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{455}\x0a\x07\x03\x07\x05\x07\u{458}\x0a\x07\x03\x07\x05\x07\u{45b}\
	\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{461}\x0a\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{467}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x07\x07\u{46d}\x0a\x07\x0c\x07\x0e\x07\u{470}\x0b\x07\x03\x07\x05\
	\x07\u{473}\x0a\x07\x05\x07\u{475}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\
	\u{47a}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x07\x07\u{486}\x0a\x07\x0c\x07\x0e\x07\u{489}\x0b\
	\x07\x03\x07\x05\x07\u{48c}\x0a\x07\x03\x07\x03\x07\x05\x07\u{490}\x0a\x07\
	\x03\x07\x05\x07\u{493}\x0a\x07\x03\x07\x05\x07\u{496}\x0a\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x05\x07\u{4a4}\x0a\x07\x03\x07\x05\x07\u{4a7}\x0a\x07\x03\x07\
	\x07\x07\u{4aa}\x0a\x07\x0c\x07\x0e\x07\u{4ad}\x0b\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{4b2}\x0a\x07\x03\x07\x05\x07\u{4b5}\x0a\x07\x03\x07\x05\x07\
	\u{4b8}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{4be}\x0a\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{4c4}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x07\x07\u{4ca}\x0a\x07\x0c\x07\x0e\x07\u{4cd}\x0b\x07\x03\x07\
	\x05\x07\u{4d0}\x0a\x07\x05\x07\u{4d2}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{4d7}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{4e3}\x0a\x07\x0c\x07\x0e\x07\u{4e6}\
	\x0b\x07\x03\x07\x05\x07\u{4e9}\x0a\x07\x03\x07\x03\x07\x05\x07\u{4ed}\x0a\
	\x07\x03\x07\x05\x07\u{4f0}\x0a\x07\x03\x07\x05\x07\u{4f3}\x0a\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x05\x07\u{501}\x0a\x07\x03\x07\x05\x07\u{504}\x0a\x07\x03\
	\x07\x07\x07\u{507}\x0a\x07\x0c\x07\x0e\x07\u{50a}\x0b\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{512}\x0a\x07\x03\x07\x05\x07\
	\u{515}\x0a\x07\x03\x07\x05\x07\u{518}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{51e}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{524}\
	\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{52a}\x0a\x07\x0c\x07\
	\x0e\x07\u{52d}\x0b\x07\x03\x07\x05\x07\u{530}\x0a\x07\x05\x07\u{532}\x0a\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{537}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{543}\
	\x0a\x07\x0c\x07\x0e\x07\u{546}\x0b\x07\x03\x07\x05\x07\u{549}\x0a\x07\x03\
	\x07\x03\x07\x05\x07\u{54d}\x0a\x07\x03\x07\x05\x07\u{550}\x0a\x07\x03\x07\
	\x05\x07\u{553}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{561}\x0a\x07\
	\x03\x07\x05\x07\u{564}\x0a\x07\x03\x07\x07\x07\u{567}\x0a\x07\x0c\x07\x0e\
	\x07\u{56a}\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{572}\x0a\x07\x03\x07\x05\x07\u{575}\x0a\x07\x03\x07\x05\x07\u{578}\
	\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{57e}\x0a\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{584}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x07\x07\u{58a}\x0a\x07\x0c\x07\x0e\x07\u{58d}\x0b\x07\x03\x07\x05\
	\x07\u{590}\x0a\x07\x05\x07\u{592}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\
	\u{597}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x07\x07\u{5a3}\x0a\x07\x0c\x07\x0e\x07\u{5a6}\x0b\
	\x07\x03\x07\x05\x07\u{5a9}\x0a\x07\x03\x07\x03\x07\x05\x07\u{5ad}\x0a\x07\
	\x03\x07\x05\x07\u{5b0}\x0a\x07\x03\x07\x05\x07\u{5b3}\x0a\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x05\x07\u{5c1}\x0a\x07\x03\x07\x05\x07\u{5c4}\x0a\x07\x03\x07\
	\x07\x07\u{5c7}\x0a\x07\x0c\x07\x0e\x07\u{5ca}\x0b\x07\x03\x07\x03\x07\x03\
	\x07\x05\x07\u{5cf}\x0a\x07\x03\x07\x05\x07\u{5d2}\x0a\x07\x03\x07\x05\x07\
	\u{5d5}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{5db}\x0a\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{5e1}\x0a\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x07\x07\u{5e7}\x0a\x07\x0c\x07\x0e\x07\u{5ea}\x0b\x07\x03\x07\
	\x05\x07\u{5ed}\x0a\x07\x05\x07\u{5ef}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{5f4}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{5f9}\x0a\x07\x03\x07\
	\x05\x07\u{5fc}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{60a}\x0a\x07\
	\x03\x07\x05\x07\u{60d}\x0a\x07\x03\x07\x07\x07\u{610}\x0a\x07\x0c\x07\x0e\
	\x07\u{613}\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{61b}\x0a\x07\x03\x07\x05\x07\u{61e}\x0a\x07\x03\x07\x05\x07\u{621}\
	\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{627}\x0a\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{62d}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x07\x07\u{633}\x0a\x07\x0c\x07\x0e\x07\u{636}\x0b\x07\x03\x07\x05\
	\x07\u{639}\x0a\x07\x05\x07\u{63b}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\
	\u{640}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{645}\x0a\x07\x03\x07\x05\
	\x07\u{648}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{656}\x0a\x07\x03\
	\x07\x05\x07\u{659}\x0a\x07\x03\x07\x07\x07\u{65c}\x0a\x07\x0c\x07\x0e\x07\
	\u{65f}\x0b\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{664}\x0a\x07\x03\x07\x05\
	\x07\u{667}\x0a\x07\x03\x07\x05\x07\u{66a}\x0a\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x07\x07\u{672}\x0a\x07\x0c\x07\x0e\x07\u{675}\x0b\
	\x07\x03\x07\x05\x07\u{678}\x0a\x07\x05\x07\u{67a}\x0a\x07\x03\x07\x03\x07\
	\x03\x07\x05\x07\u{67f}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{68b}\x0a\x07\x0c\x07\
	\x0e\x07\u{68e}\x0b\x07\x03\x07\x05\x07\u{691}\x0a\x07\x03\x07\x03\x07\x05\
	\x07\u{695}\x0a\x07\x03\x07\x05\x07\u{698}\x0a\x07\x03\x07\x05\x07\u{69b}\
	\x0a\x07\x03\x07\x03\x07\x05\x07\u{69f}\x0a\x07\x03\x07\x05\x07\u{6a2}\x0a\
	\x07\x03\x07\x05\x07\u{6a5}\x0a\x07\x03\x07\x07\x07\u{6a8}\x0a\x07\x0c\x07\
	\x0e\x07\u{6ab}\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{6b3}\x0a\x07\x03\x07\x05\x07\u{6b6}\x0a\x07\x03\x07\x05\x07\u{6b9}\
	\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{6c1}\
	\x0a\x07\x0c\x07\x0e\x07\u{6c4}\x0b\x07\x03\x07\x05\x07\u{6c7}\x0a\x07\x05\
	\x07\u{6c9}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{6ce}\x0a\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x07\x07\u{6da}\x0a\x07\x0c\x07\x0e\x07\u{6dd}\x0b\x07\x03\x07\x05\x07\u{6e0}\
	\x0a\x07\x03\x07\x03\x07\x05\x07\u{6e4}\x0a\x07\x03\x07\x05\x07\u{6e7}\x0a\
	\x07\x03\x07\x05\x07\u{6ea}\x0a\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{6ef}\
	\x0a\x07\x0c\x07\x0e\x07\u{6f2}\x0b\x07\x03\x07\x03\x07\x05\x07\u{6f6}\x0a\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\
	\x07\u{700}\x0a\x07\x0c\x07\x0e\x07\u{703}\x0b\x07\x03\x07\x05\x07\u{706}\
	\x0a\x07\x05\x07\u{708}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{715}\x0a\x07\
	\x0c\x07\x0e\x07\u{718}\x0b\x07\x03\x07\x05\x07\u{71b}\x0a\x07\x03\x07\x03\
	\x07\x05\x07\u{71f}\x0a\x07\x03\x07\x05\x07\u{722}\x0a\x07\x03\x07\x05\x07\
	\u{725}\x0a\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{72a}\x0a\x07\x0c\x07\x0e\
	\x07\u{72d}\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{735}\x0a\x07\x05\x07\u{737}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{741}\x0a\x07\x0c\x07\x0e\x07\
	\u{744}\x0b\x07\x05\x07\u{746}\x0a\x07\x03\x07\x05\x07\u{749}\x0a\x07\x03\
	\x07\x05\x07\u{74c}\x0a\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{751}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{757}\x0a\x07\x0c\x07\x0e\x07\
	\u{75a}\x0b\x07\x03\x07\x03\x07\x07\x07\u{75e}\x0a\x07\x0c\x07\x0e\x07\u{761}\
	\x0b\x07\x03\x07\x03\x07\x07\x07\u{765}\x0a\x07\x0c\x07\x0e\x07\u{768}\x0b\
	\x07\x03\x07\x03\x07\x07\x07\u{76c}\x0a\x07\x0c\x07\x0e\x07\u{76f}\x0b\x07\
	\x03\x07\x03\x07\x03\x07\x05\x07\u{774}\x0a\x07\x03\x07\x03\x07\x07\x07\
	\u{778}\x0a\x07\x0c\x07\x0e\x07\u{77b}\x0b\x07\x03\x07\x03\x07\x03\x07\x05\
	\x07\u{780}\x0a\x07\x03\x07\x03\x07\x07\x07\u{784}\x0a\x07\x0c\x07\x0e\x07\
	\u{787}\x0b\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{78c}\x0a\x07\x03\x07\x03\
	\x07\x03\x07\x07\x07\u{791}\x0a\x07\x0c\x07\x0e\x07\u{794}\x0b\x07\x03\x07\
	\x03\x07\x03\x07\x05\x07\u{799}\x0a\x07\x03\x07\x03\x07\x07\x07\u{79d}\x0a\
	\x07\x0c\x07\x0e\x07\u{7a0}\x0b\x07\x03\x07\x03\x07\x07\x07\u{7a4}\x0a\x07\
	\x0c\x07\x0e\x07\u{7a7}\x0b\x07\x03\x07\x03\x07\x07\x07\u{7ab}\x0a\x07\x0c\
	\x07\x0e\x07\u{7ae}\x0b\x07\x03\x07\x03\x07\x07\x07\u{7b2}\x0a\x07\x0c\x07\
	\x0e\x07\u{7b5}\x0b\x07\x03\x07\x03\x07\x07\x07\u{7b9}\x0a\x07\x0c\x07\x0e\
	\x07\u{7bc}\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\u{7c2}\x0a\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{7cd}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{7d5}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{7dd}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x05\x07\
	\u{7e4}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x05\x07\u{7ee}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{7f5}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{7fd}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\
	\u{81f}\x0a\x07\x0c\x07\x0e\x07\u{822}\x0b\x07\x05\x07\u{824}\x0a\x07\x03\
	\x07\x05\x07\u{827}\x0a\x07\x03\x07\x05\x07\u{82a}\x0a\x07\x03\x07\x03\x07\
	\x05\x07\u{82e}\x0a\x07\x03\x07\x03\x07\x07\x07\u{832}\x0a\x07\x0c\x07\x0e\
	\x07\u{835}\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x05\x07\u{840}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{85f}\
	\x0a\x07\x0c\x07\x0e\x07\u{862}\x0b\x07\x03\x07\x03\x07\x03\x07\x07\x07\
	\u{867}\x0a\x07\x0c\x07\x0e\x07\u{86a}\x0b\x07\x03\x07\x03\x07\x07\x07\u{86e}\
	\x0a\x07\x0c\x07\x0e\x07\u{871}\x0b\x07\x03\x07\x03\x07\x07\x07\u{875}\x0a\
	\x07\x0c\x07\x0e\x07\u{878}\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\
	\x07\u{87e}\x0a\x07\x0c\x07\x0e\x07\u{881}\x0b\x07\x03\x07\x05\x07\u{884}\
	\x0a\x07\x03\x07\x03\x07\x05\x07\u{888}\x0a\x07\x03\x07\x03\x07\x05\x07\
	\u{88c}\x0a\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\
	\x05\x07\u{895}\x0a\x07\x03\x07\x03\x07\x03\x07\x07\x07\u{89a}\x0a\x07\x0c\
	\x07\x0e\x07\u{89d}\x0b\x07\x03\x07\x03\x07\x07\x07\u{8a1}\x0a\x07\x0c\x07\
	\x0e\x07\u{8a4}\x0b\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\x07\
	\u{8ab}\x0a\x07\x0c\x07\x0e\x07\u{8ae}\x0b\x07\x03\x07\x05\x07\u{8b1}\x0a\
	\x07\x05\x07\u{8b3}\x0a\x07\x03\x07\x03\x07\x07\x07\u{8b7}\x0a\x07\x0c\x07\
	\x0e\x07\u{8ba}\x0b\x07\x03\x07\x03\x07\x07\x07\u{8be}\x0a\x07\x0c\x07\x0e\
	\x07\u{8c1}\x0b\x07\x03\x07\x03\x07\x07\x07\u{8c5}\x0a\x07\x0c\x07\x0e\x07\
	\u{8c8}\x0b\x07\x03\x07\x03\x07\x07\x07\u{8cc}\x0a\x07\x0c\x07\x0e\x07\u{8cf}\
	\x0b\x07\x03\x07\x03\x07\x07\x07\u{8d3}\x0a\x07\x0c\x07\x0e\x07\u{8d6}\x0b\
	\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x03\x07\x07\
	\x07\u{8e0}\x0a\x07\x0c\x07\x0e\x07\u{8e3}\x0b\x07\x05\x07\u{8e5}\x0a\x07\
	\x03\x08\x03\x08\x03\x08\x07\x08\u{8ea}\x0a\x08\x0c\x08\x0e\x08\u{8ed}\x0b\
	\x08\x03\x09\x03\x09\x03\x09\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x03\
	\x0a\x07\x0a\u{8f8}\x0a\x0a\x0c\x0a\x0e\x0a\u{8fb}\x0b\x0a\x03\x0a\x03\x0a\
	\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x05\x0a\u{903}\x0a\x0a\x03\x0a\x03\x0a\
	\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x03\x0a\x07\x0a\u{90e}\
	\x0a\x0a\x0c\x0a\x0e\x0a\u{911}\x0b\x0a\x03\x0a\x03\x0a\x03\x0a\x05\x0a\
	\u{916}\x0a\x0a\x03\x0a\x03\x0a\x07\x0a\u{91a}\x0a\x0a\x0c\x0a\x0e\x0a\u{91d}\
	\x0b\x0a\x03\x0b\x03\x0b\x05\x0b\u{921}\x0a\x0b\x03\x0b\x03\x0b\x05\x0b\
	\u{925}\x0a\x0b\x03\x0b\x03\x0b\x03\x0b\x05\x0b\u{92a}\x0a\x0b\x03\x0b\x03\
	\x0b\x05\x0b\u{92e}\x0a\x0b\x03\x0b\x05\x0b\u{931}\x0a\x0b\x03\x0b\x03\x0b\
	\x03\x0b\x05\x0b\u{936}\x0a\x0b\x05\x0b\u{938}\x0a\x0b\x03\x0b\x03\x0b\x03\
	\x0c\x05\x0c\u{93d}\x0a\x0c\x03\x0c\x05\x0c\u{940}\x0a\x0c\x03\x0c\x05\x0c\
	\u{943}\x0a\x0c\x03\x0c\x05\x0c\u{946}\x0a\x0c\x03\x0c\x03\x0c\x05\x0c\u{94a}\
	\x0a\x0c\x03\x0c\x05\x0c\u{94d}\x0a\x0c\x03\x0c\x05\x0c\u{950}\x0a\x0c\x03\
	\x0c\x05\x0c\u{953}\x0a\x0c\x03\x0d\x03\x0d\x03\x0d\x03\x0d\x07\x0d\u{959}\
	\x0a\x0d\x0c\x0d\x0e\x0d\u{95c}\x0b\x0d\x03\x0d\x05\x0d\u{95f}\x0a\x0d\x03\
	\x0d\x03\x0d\x03\x0e\x03\x0e\x05\x0e\u{965}\x0a\x0e\x03\x0f\x03\x0f\x03\
	\x0f\x03\x0f\x03\x0f\x03\x0f\x05\x0f\u{96d}\x0a\x0f\x03\x0f\x03\x0f\x03\
	\x0f\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x03\x0f\x05\x0f\u{979}\
	\x0a\x0f\x03\x0f\x03\x0f\x07\x0f\u{97d}\x0a\x0f\x0c\x0f\x0e\x0f\u{980}\x0b\
	\x0f\x03\x10\x05\x10\u{983}\x0a\x10\x03\x10\x03\x10\x03\x10\x03\x10\x03\
	\x11\x03\x11\x03\x11\x03\x11\x03\x12\x03\x12\x03\x12\x03\x12\x03\x13\x03\
	\x13\x03\x13\x03\x13\x03\x14\x03\x14\x03\x14\x03\x14\x03\x15\x03\x15\x03\
	\x15\x03\x16\x05\x16\u{99d}\x0a\x16\x03\x16\x03\x16\x03\x17\x03\x17\x05\
	\x17\u{9a3}\x0a\x17\x03\x17\x03\x17\x03\x17\x07\x17\u{9a8}\x0a\x17\x0c\x17\
	\x0e\x17\u{9ab}\x0b\x17\x03\x18\x03\x18\x05\x18\u{9af}\x0a\x18\x03\x19\x03\
	\x19\x05\x19\u{9b3}\x0a\x19\x03\x19\x03\x19\x05\x19\u{9b7}\x0a\x19\x03\x19\
	\x03\x19\x05\x19\u{9bb}\x0a\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\
	\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x03\x19\x05\x19\u{9c9}\
	\x0a\x19\x03\x19\x05\x19\u{9cc}\x0a\x19\x05\x19\u{9ce}\x0a\x19\x05\x19\u{9d0}\
	\x0a\x19\x03\x19\x05\x19\u{9d3}\x0a\x19\x03\x19\x03\x19\x03\x19\x03\x19\
	\x03\x19\x03\x19\x03\x19\x03\x19\x07\x19\u{9dd}\x0a\x19\x0c\x19\x0e\x19\
	\u{9e0}\x0b\x19\x03\x19\x03\x19\x05\x19\u{9e4}\x0a\x19\x05\x19\u{9e6}\x0a\
	\x19\x03\x19\x05\x19\u{9e9}\x0a\x19\x03\x19\x03\x19\x05\x19\u{9ed}\x0a\x19\
	\x03\x19\x03\x19\x05\x19\u{9f1}\x0a\x19\x03\x1a\x03\x1a\x05\x1a\u{9f5}\x0a\
	\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x05\x1a\u{9fc}\x0a\x1a\x03\
	\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x03\x1a\x05\x1a\u{a04}\x0a\x1a\x05\
	\x1a\u{a06}\x0a\x1a\x03\x1a\x03\x1a\x03\x1b\x03\x1b\x05\x1b\u{a0c}\x0a\x1b\
	\x03\x1b\x03\x1b\x05\x1b\u{a10}\x0a\x1b\x03\x1b\x03\x1b\x05\x1b\u{a14}\x0a\
	\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\
	\x1b\x03\x1b\x03\x1b\x03\x1b\x05\x1b\u{a22}\x0a\x1b\x03\x1b\x05\x1b\u{a25}\
	\x0a\x1b\x05\x1b\u{a27}\x0a\x1b\x05\x1b\u{a29}\x0a\x1b\x03\x1b\x05\x1b\u{a2c}\
	\x0a\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\x03\x1b\
	\x07\x1b\u{a36}\x0a\x1b\x0c\x1b\x0e\x1b\u{a39}\x0b\x1b\x03\x1b\x03\x1b\x05\
	\x1b\u{a3d}\x0a\x1b\x05\x1b\u{a3f}\x0a\x1b\x03\x1b\x05\x1b\u{a42}\x0a\x1b\
	\x03\x1b\x03\x1b\x05\x1b\u{a46}\x0a\x1b\x03\x1b\x03\x1b\x05\x1b\u{a4a}\x0a\
	\x1b\x03\x1c\x03\x1c\x03\x1c\x03\x1c\x05\x1c\u{a50}\x0a\x1c\x03\x1d\x03\
	\x1d\x03\x1d\x03\x1e\x03\x1e\x03\x1f\x03\x1f\x03\x20\x03\x20\x05\x20\u{a5b}\
	\x0a\x20\x03\x20\x05\x20\u{a5e}\x0a\x20\x03\x21\x03\x21\x03\x21\x07\x21\
	\u{a63}\x0a\x21\x0c\x21\x0e\x21\u{a66}\x0b\x21\x03\x21\x05\x21\u{a69}\x0a\
	\x21\x03\x22\x03\x22\x03\x22\x03\x22\x03\x23\x03\x23\x03\x24\x03\x24\x05\
	\x24\u{a73}\x0a\x24\x03\x24\x03\x24\x03\x25\x03\x25\x03\x25\x07\x25\u{a7a}\
	\x0a\x25\x0c\x25\x0e\x25\u{a7d}\x0b\x25\x03\x25\x05\x25\u{a80}\x0a\x25\x03\
	\x26\x03\x26\x03\x26\x03\x26\x07\x26\u{a86}\x0a\x26\x0c\x26\x0e\x26\u{a89}\
	\x0b\x26\x03\x26\x03\x26\x03\x26\x03\x26\x03\x26\x03\x26\x05\x26\u{a91}\
	\x0a\x26\x03\x27\x03\x27\x03\x28\x03\x28\x03\x28\x05\x28\u{a98}\x0a\x28\
	\x03\x29\x03\x29\x03\x2a\x03\x2a\x03\x2a\x03\x2a\x03\x2a\x05\x2a\u{aa1}\
	\x0a\x2a\x03\x2a\x03\x2a\x03\x2a\x05\x2a\u{aa6}\x0a\x2a\x05\x2a\u{aa8}\x0a\
	\x2a\x03\x2a\x03\x2a\x05\x2a\u{aac}\x0a\x2a\x03\x2a\x03\x2a\x05\x2a\u{ab0}\
	\x0a\x2a\x03\x2a\x05\x2a\u{ab3}\x0a\x2a\x05\x2a\u{ab5}\x0a\x2a\x03\x2b\x03\
	\x2b\x05\x2b\u{ab9}\x0a\x2b\x03\x2c\x03\x2c\x03\x2d\x03\x2d\x03\x2d\x05\
	\x2d\u{ac0}\x0a\x2d\x03\x2e\x03\x2e\x03\x2f\x03\x2f\x03\x30\x03\x30\x03\
	\x30\x03\x30\x07\x30\u{aca}\x0a\x30\x0c\x30\x0e\x30\u{acd}\x0b\x30\x03\x31\
	\x03\x31\x05\x31\u{ad1}\x0a\x31\x03\x31\x03\x31\x05\x31\u{ad5}\x0a\x31\x03\
	\x31\x03\x31\x05\x31\u{ad9}\x0a\x31\x05\x31\u{adb}\x0a\x31\x03\x32\x03\x32\
	\x03\x32\x03\x32\x07\x32\u{ae1}\x0a\x32\x0c\x32\x0e\x32\u{ae4}\x0b\x32\x03\
	\x33\x03\x33\x05\x33\u{ae8}\x0a\x33\x03\x34\x03\x34\x03\x35\x03\x35\x03\
	\x35\x03\x35\x07\x35\u{af0}\x0a\x35\x0c\x35\x0e\x35\u{af3}\x0b\x35\x03\x35\
	\x05\x35\u{af6}\x0a\x35\x03\x36\x03\x36\x03\x36\x03\x36\x03\x36\x03\x36\
	\x03\x36\x05\x36\u{aff}\x0a\x36\x03\x37\x03\x37\x05\x37\u{b03}\x0a\x37\x03\
	\x37\x03\x37\x05\x37\u{b07}\x0a\x37\x03\x38\x03\x38\x03\x39\x03\x39\x03\
	\x39\x05\x39\u{b0e}\x0a\x39\x03\x39\x05\x39\u{b11}\x0a\x39\x03\x39\x03\x39\
	\x03\x39\x03\x39\x03\x39\x07\x39\u{b18}\x0a\x39\x0c\x39\x0e\x39\u{b1b}\x0b\
	\x39\x03\x39\x05\x39\u{b1e}\x0a\x39\x05\x39\u{b20}\x0a\x39\x03\x39\x03\x39\
	\x05\x39\u{b24}\x0a\x39\x03\x39\x05\x39\u{b27}\x0a\x39\x03\x39\x05\x39\u{b2a}\
	\x0a\x39\x03\x39\x03\x39\x05\x39\u{b2e}\x0a\x39\x03\x39\x03\x39\x05\x39\
	\u{b32}\x0a\x39\x03\x3a\x03\x3a\x03\x3a\x05\x3a\u{b37}\x0a\x3a\x03\x3a\x03\
	\x3a\x03\x3a\x03\x3a\x03\x3a\x07\x3a\u{b3e}\x0a\x3a\x0c\x3a\x0e\x3a\u{b41}\
	\x0b\x3a\x03\x3b\x03\x3b\x05\x3b\u{b45}\x0a\x3b\x03\x3b\x03\x3b\x03\x3c\
	\x03\x3c\x03\x3c\x07\x3c\u{b4c}\x0a\x3c\x0c\x3c\x0e\x3c\u{b4f}\x0b\x3c\x03\
	\x3c\x05\x3c\u{b52}\x0a\x3c\x03\x3d\x03\x3d\x03\x3d\x03\x3d\x03\x3e\x03\
	\x3e\x05\x3e\u{b5a}\x0a\x3e\x03\x3e\x03\x3e\x03\x3e\x07\x3e\u{b5f}\x0a\x3e\
	\x0c\x3e\x0e\x3e\u{b62}\x0b\x3e\x03\x3e\x05\x3e\u{b65}\x0a\x3e\x05\x3e\u{b67}\
	\x0a\x3e\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x07\x3f\u{b6e}\x0a\x3f\
	\x0c\x3f\x0e\x3f\u{b71}\x0b\x3f\x03\x3f\x05\x3f\u{b74}\x0a\x3f\x05\x3f\u{b76}\
	\x0a\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x07\x3f\u{b7e}\
	\x0a\x3f\x0c\x3f\x0e\x3f\u{b81}\x0b\x3f\x03\x3f\x05\x3f\u{b84}\x0a\x3f\x05\
	\x3f\u{b86}\x0a\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\x3f\x03\
	\x3f\x07\x3f\u{b8f}\x0a\x3f\x0c\x3f\x0e\x3f\u{b92}\x0b\x3f\x03\x3f\x05\x3f\
	\u{b95}\x0a\x3f\x03\x3f\x03\x3f\x03\x3f\x05\x3f\u{b9a}\x0a\x3f\x03\x40\x03\
	\x40\x03\x40\x03\x40\x07\x40\u{ba0}\x0a\x40\x0c\x40\x0e\x40\u{ba3}\x0b\x40\
	\x05\x40\u{ba5}\x0a\x40\x03\x40\x05\x40\u{ba8}\x0a\x40\x03\x40\x03\x40\x05\
	\x40\u{bac}\x0a\x40\x03\x41\x03\x41\x03\x41\x03\x41\x03\x41\x03\x41\x03\
	\x42\x05\x42\u{bb5}\x0a\x42\x03\x42\x05\x42\u{bb8}\x0a\x42\x03\x42\x05\x42\
	\u{bbb}\x0a\x42\x03\x42\x05\x42\u{bbe}\x0a\x42\x03\x43\x03\x43\x03\x43\x03\
	\x43\x03\x43\x07\x43\u{bc5}\x0a\x43\x0c\x43\x0e\x43\u{bc8}\x0b\x43\x03\x43\
	\x05\x43\u{bcb}\x0a\x43\x03\x44\x03\x44\x03\x44\x03\x44\x03\x44\x07\x44\
	\u{bd2}\x0a\x44\x0c\x44\x0e\x44\u{bd5}\x0b\x44\x03\x44\x05\x44\u{bd8}\x0a\
	\x44\x03\x45\x03\x45\x05\x45\u{bdc}\x0a\x45\x03\x45\x03\x45\x03\x45\x03\
	\x45\x03\x45\x03\x46\x03\x46\x03\x47\x05\x47\u{be6}\x0a\x47\x03\x47\x03\
	\x47\x03\x47\x05\x47\u{beb}\x0a\x47\x03\x47\x05\x47\u{bee}\x0a\x47\x03\x47\
	\x05\x47\u{bf1}\x0a\x47\x03\x48\x03\x48\x03\x48\x05\x48\u{bf6}\x0a\x48\x03\
	\x48\x03\x48\x03\x48\x05\x48\u{bfb}\x0a\x48\x05\x48\u{bfd}\x0a\x48\x03\x48\
	\x03\x48\x03\x48\x03\x48\x03\x48\x07\x48\u{c04}\x0a\x48\x0c\x48\x0e\x48\
	\u{c07}\x0b\x48\x03\x48\x03\x48\x05\x48\u{c0b}\x0a\x48\x03\x48\x03\x48\x03\
	\x48\x03\x48\x03\x48\x03\x48\x03\x48\x03\x48\x03\x48\x03\x48\x03\x48\x03\
	\x48\x03\x48\x03\x48\x07\x48\u{c1b}\x0a\x48\x0c\x48\x0e\x48\u{c1e}\x0b\x48\
	\x03\x48\x03\x48\x05\x48\u{c22}\x0a\x48\x05\x48\u{c24}\x0a\x48\x03\x49\x03\
	\x49\x03\x49\x03\x49\x03\x49\x05\x49\u{c2b}\x0a\x49\x03\x4a\x03\x4a\x03\
	\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\
	\x4b\x03\x4b\x05\x4b\u{c3a}\x0a\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x05\
	\x4b\u{c40}\x0a\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x05\x4b\u{c47}\
	\x0a\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\x03\x4b\
	\x03\x4b\x05\x4b\u{c52}\x0a\x4b\x07\x4b\u{c54}\x0a\x4b\x0c\x4b\x0e\x4b\u{c57}\
	\x0b\x4b\x03\x4c\x05\x4c\u{c5a}\x0a\x4c\x03\x4c\x03\x4c\x05\x4c\u{c5e}\x0a\
	\x4c\x03\x4c\x03\x4c\x05\x4c\u{c62}\x0a\x4c\x03\x4c\x03\x4c\x05\x4c\u{c66}\
	\x0a\x4c\x05\x4c\u{c68}\x0a\x4c\x03\x4d\x03\x4d\x03\x4d\x03\x4d\x03\x4d\
	\x03\x4d\x03\x4d\x07\x4d\u{c71}\x0a\x4d\x0c\x4d\x0e\x4d\u{c74}\x0b\x4d\x03\
	\x4d\x05\x4d\u{c77}\x0a\x4d\x03\x4d\x03\x4d\x05\x4d\u{c7b}\x0a\x4d\x03\x4e\
	\x03\x4e\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x07\x4f\u{c85}\
	\x0a\x4f\x0c\x4f\x0e\x4f\u{c88}\x0b\x4f\x03\x4f\x05\x4f\u{c8b}\x0a\x4f\x03\
	\x4f\x03\x4f\x05\x4f\u{c8f}\x0a\x4f\x03\x4f\x03\x4f\x05\x4f\u{c93}\x0a\x4f\
	\x05\x4f\u{c95}\x0a\x4f\x03\x4f\x03\x4f\x03\x4f\x03\x4f\x07\x4f\u{c9b}\x0a\
	\x4f\x0c\x4f\x0e\x4f\u{c9e}\x0b\x4f\x03\x4f\x05\x4f\u{ca1}\x0a\x4f\x03\x4f\
	\x05\x4f\u{ca4}\x0a\x4f\x03\x4f\x03\x4f\x05\x4f\u{ca8}\x0a\x4f\x05\x4f\u{caa}\
	\x0a\x4f\x05\x4f\u{cac}\x0a\x4f\x03\x50\x03\x50\x05\x50\u{cb0}\x0a\x50\x03\
	\x51\x03\x51\x03\x51\x03\x52\x05\x52\u{cb6}\x0a\x52\x03\x52\x03\x52\x03\
	\x52\x05\x52\u{cbb}\x0a\x52\x03\x52\x03\x52\x05\x52\u{cbf}\x0a\x52\x03\x52\
	\x03\x52\x03\x52\x03\x52\x03\x52\x05\x52\u{cc6}\x0a\x52\x05\x52\u{cc8}\x0a\
	\x52\x03\x53\x03\x53\x03\x54\x03\x54\x03\x54\x03\x55\x03\x55\x03\x55\x03\
	\x55\x03\x55\x03\x56\x03\x56\x03\x57\x03\x57\x03\x57\x05\x57\u{cd9}\x0a\
	\x57\x03\x57\x05\x57\u{cdc}\x0a\x57\x03\x58\x03\x58\x03\x58\x03\x58\x05\
	\x58\u{ce2}\x0a\x58\x03\x59\x03\x59\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\
	\x5a\x03\x5a\x03\x5a\x03\x5a\x07\x5a\u{cee}\x0a\x5a\x0c\x5a\x0e\x5a\u{cf1}\
	\x0b\x5a\x03\x5a\x05\x5a\u{cf4}\x0a\x5a\x05\x5a\u{cf6}\x0a\x5a\x03\x5a\x03\
	\x5a\x03\x5a\x03\x5a\x03\x5a\x07\x5a\u{cfd}\x0a\x5a\x0c\x5a\x0e\x5a\u{d00}\
	\x0b\x5a\x03\x5a\x05\x5a\u{d03}\x0a\x5a\x05\x5a\u{d05}\x0a\x5a\x03\x5a\x03\
	\x5a\x03\x5a\x03\x5a\x07\x5a\u{d0b}\x0a\x5a\x0c\x5a\x0e\x5a\u{d0e}\x0b\x5a\
	\x03\x5a\x05\x5a\u{d11}\x0a\x5a\x05\x5a\u{d13}\x0a\x5a\x03\x5a\x05\x5a\u{d16}\
	\x0a\x5a\x03\x5a\x03\x5a\x03\x5a\x05\x5a\u{d1b}\x0a\x5a\x03\x5a\x05\x5a\
	\u{d1e}\x0a\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\
	\x03\x5a\x07\x5a\u{d28}\x0a\x5a\x0c\x5a\x0e\x5a\u{d2b}\x0b\x5a\x03\x5a\x05\
	\x5a\u{d2e}\x0a\x5a\x05\x5a\u{d30}\x0a\x5a\x03\x5a\x03\x5a\x03\x5a\x03\x5a\
	\x07\x5a\u{d36}\x0a\x5a\x0c\x5a\x0e\x5a\u{d39}\x0b\x5a\x03\x5a\x05\x5a\u{d3c}\
	\x0a\x5a\x03\x5a\x03\x5a\x05\x5a\u{d40}\x0a\x5a\x03\x5b\x03\x5b\x03\x5b\
	\x03\x5b\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\x03\x5c\
	\x03\x5c\x05\x5c\u{d4f}\x0a\x5c\x05\x5c\u{d51}\x0a\x5c\x03\x5d\x03\x5d\x03\
	\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x03\x5d\x05\x5d\u{d5c}\x0a\
	\x5d\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\
	\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\x5e\x03\
	\x5e\x03\x5e\x05\x5e\u{d71}\x0a\x5e\x03\x5f\x03\x5f\x03\x5f\x03\x5f\x03\
	\x5f\x03\x5f\x07\x5f\u{d79}\x0a\x5f\x0c\x5f\x0e\x5f\u{d7c}\x0b\x5f\x03\x5f\
	\x05\x5f\u{d7f}\x0a\x5f\x03\x5f\x03\x5f\x03\x60\x03\x60\x03\x60\x03\x60\
	\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\
	\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x05\x61\u{d95}\x0a\x61\x03\x61\
	\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x03\x61\x05\x61\
	\u{da0}\x0a\x61\x03\x62\x03\x62\x03\x62\x03\x62\x03\x62\x05\x62\u{da7}\x0a\
	\x62\x03\x63\x03\x63\x05\x63\u{dab}\x0a\x63\x03\x63\x03\x63\x03\x63\x03\
	\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\
	\x63\x03\x63\x03\x63\x03\x63\x03\x63\x03\x63\x05\x63\u{dbf}\x0a\x63\x03\
	\x63\x03\x63\x05\x63\u{dc3}\x0a\x63\x05\x63\u{dc5}\x0a\x63\x03\x64\x03\x64\
	\x03\x64\x03\x64\x03\x64\x03\x64\x05\x64\u{dcd}\x0a\x64\x03\x65\x03\x65\
	\x07\x65\u{dd1}\x0a\x65\x0c\x65\x0e\x65\u{dd4}\x0b\x65\x03\x66\x03\x66\x03\
	\x66\x03\x66\x05\x66\u{dda}\x0a\x66\x03\x66\x05\x66\u{ddd}\x0a\x66\x05\x66\
	\u{ddf}\x0a\x66\x03\x67\x03\x67\x03\x68\x03\x68\x03\x69\x03\x69\x03\x6a\
	\x03\x6a\x03\x6a\x05\x6a\u{dea}\x0a\x6a\x03\x6a\x05\x6a\u{ded}\x0a\x6a\x05\
	\x6a\u{def}\x0a\x6a\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\x6b\x03\
	\x6b\x03\x6b\x03\x6c\x03\x6c\x03\x6c\x07\x6c\u{dfc}\x0a\x6c\x0c\x6c\x0e\
	\x6c\u{dff}\x0b\x6c\x03\x6c\x05\x6c\u{e02}\x0a\x6c\x03\x6d\x03\x6d\x03\x6e\
	\x03\x6e\x03\x6e\x07\x6e\u{e09}\x0a\x6e\x0c\x6e\x0e\x6e\u{e0c}\x0b\x6e\x03\
	\x6e\x05\x6e\u{e0f}\x0a\x6e\x03\x6e\x03\x6e\x05\x6e\u{e13}\x0a\x6e\x03\x6e\
	\x05\x6e\u{e16}\x0a\x6e\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\
	\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x05\x6f\
	\u{e26}\x0a\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x03\x6f\x05\x6f\u{e2d}\x0a\
	\x6f\x03\x70\x03\x70\x03\x71\x03\x71\x03\x71\x03\x71\x05\x71\u{e35}\x0a\
	\x71\x03\x71\x05\x71\u{e38}\x0a\x71\x05\x71\u{e3a}\x0a\x71\x03\x72\x03\x72\
	\x03\x72\x05\x72\u{e3f}\x0a\x72\x03\x72\x03\x72\x03\x73\x03\x73\x03\x73\
	\x03\x73\x03\x73\x03\x73\x05\x73\u{e49}\x0a\x73\x03\x73\x03\x73\x03\x73\
	\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x07\x73\u{e55}\
	\x0a\x73\x0c\x73\x0e\x73\u{e58}\x0b\x73\x03\x73\x05\x73\u{e5b}\x0a\x73\x03\
	\x73\x03\x73\x05\x73\u{e5f}\x0a\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\
	\x73\x07\x73\u{e66}\x0a\x73\x0c\x73\x0e\x73\u{e69}\x0b\x73\x03\x73\x05\x73\
	\u{e6c}\x0a\x73\x03\x73\x03\x73\x05\x73\u{e70}\x0a\x73\x03\x73\x03\x73\x03\
	\x73\x03\x73\x03\x73\x03\x73\x03\x73\x03\x73\x05\x73\u{e7a}\x0a\x73\x03\
	\x74\x03\x74\x03\x74\x03\x74\x03\x74\x03\x74\x03\x74\x03\x74\x03\x74\x03\
	\x74\x03\x74\x03\x74\x07\x74\u{e88}\x0a\x74\x0c\x74\x0e\x74\u{e8b}\x0b\x74\
	\x03\x74\x05\x74\u{e8e}\x0a\x74\x05\x74\u{e90}\x0a\x74\x03\x74\x05\x74\u{e93}\
	\x0a\x74\x03\x74\x03\x74\x05\x74\u{e97}\x0a\x74\x03\x74\x03\x74\x03\x74\
	\x03\x74\x03\x74\x05\x74\u{e9e}\x0a\x74\x03\x74\x03\x74\x05\x74\u{ea2}\x0a\
	\x74\x03\x74\x03\x74\x05\x74\u{ea6}\x0a\x74\x03\x75\x03\x75\x03\x75\x03\
	\x75\x07\x75\u{eac}\x0a\x75\x0c\x75\x0e\x75\u{eaf}\x0b\x75\x03\x75\x05\x75\
	\u{eb2}\x0a\x75\x03\x76\x03\x76\x03\x76\x05\x76\u{eb7}\x0a\x76\x03\x77\x03\
	\x77\x03\x77\x05\x77\u{ebc}\x0a\x77\x03\x77\x03\x77\x03\x77\x05\x77\u{ec1}\
	\x0a\x77\x03\x78\x03\x78\x03\x78\x03\x78\x03\x78\x03\x78\x03\x78\x07\x78\
	\u{eca}\x0a\x78\x0c\x78\x0e\x78\u{ecd}\x0b\x78\x03\x78\x05\x78\u{ed0}\x0a\
	\x78\x05\x78\u{ed2}\x0a\x78\x03\x78\x03\x78\x05\x78\u{ed6}\x0a\x78\x05\x78\
	\u{ed8}\x0a\x78\x03\x78\x03\x78\x03\x78\x03\x78\x03\x78\x03\x78\x05\x78\
	\u{ee0}\x0a\x78\x03\x78\x03\x78\x03\x78\x03\x78\x03\x78\x03\x78\x07\x78\
	\u{ee8}\x0a\x78\x0c\x78\x0e\x78\u{eeb}\x0b\x78\x03\x78\x05\x78\u{eee}\x0a\
	\x78\x03\x78\x03\x78\x03\x78\x05\x78\u{ef3}\x0a\x78\x05\x78\u{ef5}\x0a\x78\
	\x03\x79\x03\x79\x03\x79\x03\x79\x03\x79\x05\x79\u{efc}\x0a\x79\x03\x79\
	\x03\x79\x05\x79\u{f00}\x0a\x79\x05\x79\u{f02}\x0a\x79\x03\x79\x03\x79\x03\
	\x79\x03\x79\x03\x79\x05\x79\u{f09}\x0a\x79\x03\x79\x03\x79\x05\x79\u{f0d}\
	\x0a\x79\x05\x79\u{f0f}\x0a\x79\x05\x79\u{f11}\x0a\x79\x03\x7a\x03\x7a\x03\
	\x7a\x03\x7a\x03\x7a\x07\x7a\u{f18}\x0a\x7a\x0c\x7a\x0e\x7a\u{f1b}\x0b\x7a\
	\x03\x7a\x05\x7a\u{f1e}\x0a\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7a\x03\x7a\
	\x03\x7a\x03\x7a\x03\x7a\x05\x7a\u{f28}\x0a\x7a\x03\x7b\x03\x7b\x05\x7b\
	\u{f2c}\x0a\x7b\x03\x7c\x03\x7c\x03\x7c\x03\x7c\x03\x7c\x03\x7c\x07\x7c\
	\u{f34}\x0a\x7c\x0c\x7c\x0e\x7c\u{f37}\x0b\x7c\x03\x7c\x05\x7c\u{f3a}\x0a\
	\x7c\x03\x7c\x03\x7c\x03\x7d\x03\x7d\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x05\
	\x7e\u{f44}\x0a\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\x7e\x03\
	\x7e\x03\x7e\x07\x7e\u{f4e}\x0a\x7e\x0c\x7e\x0e\x7e\u{f51}\x0b\x7e\x03\x7f\
	\x03\x7f\x03\x7f\x03\x7f\x05\x7f\u{f57}\x0a\x7f\x03\x7f\x03\x7f\x03\x7f\
	\x03\x7f\x03\x7f\x03\x7f\x05\x7f\u{f5f}\x0a\x7f\x03\u{80}\x03\u{80}\x05\
	\u{80}\u{f63}\x0a\u{80}\x03\u{81}\x05\u{81}\u{f66}\x0a\u{81}\x03\u{81}\x03\
	\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{f6e}\x0a\u{81}\
	\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x07\u{81}\u{f75}\x0a\
	\u{81}\x0c\u{81}\x0e\u{81}\u{f78}\x0b\u{81}\x03\u{81}\x05\u{81}\u{f7b}\x0a\
	\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{f80}\x0a\u{81}\x03\u{81}\
	\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\
	\u{81}\x03\u{81}\x05\u{81}\u{f8c}\x0a\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\
	\x05\u{81}\u{f91}\x0a\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{f96}\
	\x0a\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{f9b}\x0a\u{81}\x03\
	\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{fa1}\x0a\u{81}\x03\u{81}\
	\x05\u{81}\u{fa4}\x0a\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x03\
	\u{81}\x05\u{81}\u{fab}\x0a\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{faf}\x0a\
	\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{fb4}\x0a\u{81}\x03\u{81}\
	\x03\u{81}\x03\u{81}\x03\u{81}\x03\u{81}\x05\u{81}\u{fbb}\x0a\u{81}\x03\
	\u{81}\x05\u{81}\u{fbe}\x0a\u{81}\x03\u{82}\x03\u{82}\x03\u{82}\x05\u{82}\
	\u{fc3}\x0a\u{82}\x03\u{82}\x03\u{82}\x05\u{82}\u{fc7}\x0a\u{82}\x03\u{82}\
	\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\
	\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x03\u{82}\x07\u{82}\
	\u{fd8}\x0a\u{82}\x0c\u{82}\x0e\u{82}\u{fdb}\x0b\u{82}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x07\u{83}\u{fe8}\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{feb}\x0b\
	\u{83}\x05\u{83}\u{fed}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x06\u{83}\u{ff4}\x0a\u{83}\x0d\u{83}\x0e\u{83}\u{ff5}\x03\u{83}\
	\x05\u{83}\u{ff9}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x07\u{83}\u{1002}\x0a\u{83}\x0c\u{83}\x0e\u{83}\
	\u{1005}\x0b\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\
	\u{1013}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{1018}\x0a\u{83}\
	\x03\u{83}\x05\u{83}\u{101b}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x07\u{83}\u{1026}\
	\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{1029}\x0b\u{83}\x03\u{83}\x05\u{83}\u{102c}\
	\x0a\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{1030}\x0a\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x07\u{83}\u{1039}\
	\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{103c}\x0b\u{83}\x05\u{83}\u{103e}\x0a\u{83}\
	\x03\u{83}\x05\u{83}\u{1041}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x06\u{83}\u{104b}\x0a\u{83}\
	\x0d\u{83}\x0e\u{83}\u{104c}\x03\u{83}\x03\u{83}\x05\u{83}\u{1051}\x0a\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x06\u{83}\u{1057}\x0a\u{83}\x0d\
	\u{83}\x0e\u{83}\u{1058}\x03\u{83}\x03\u{83}\x05\u{83}\u{105d}\x0a\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{1072}\x0a\u{83}\x03\
	\u{83}\x05\u{83}\u{1075}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{1080}\x0a\
	\u{83}\x03\u{83}\x05\u{83}\u{1083}\x0a\u{83}\x05\u{83}\u{1085}\x0a\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x05\u{83}\u{1090}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{1099}\x0a\u{83}\x03\
	\u{83}\x05\u{83}\u{109c}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x07\u{83}\
	\u{10bf}\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{10c2}\x0b\u{83}\x05\u{83}\u{10c4}\
	\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{10d0}\x0a\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x07\u{83}\u{10d5}\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{10d8}\
	\x0b\u{83}\x05\u{83}\u{10da}\x0a\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{10de}\
	\x0a\u{83}\x03\u{83}\x05\u{83}\u{10e1}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{10eb}\
	\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\
	\u{83}\u{10f3}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{10f8}\
	\x0a\u{83}\x07\u{83}\u{10fa}\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{10fd}\x0b\u{83}\
	\x05\u{83}\u{10ff}\x0a\u{83}\x03\u{83}\x05\u{83}\u{1102}\x0a\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x07\u{83}\u{111d}\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{1120}\
	\x0b\u{83}\x03\u{83}\x05\u{83}\u{1123}\x0a\u{83}\x05\u{83}\u{1125}\x0a\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{112c}\x0a\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x07\u{83}\u{1138}\x0a\u{83}\x0c\u{83}\x0e\
	\u{83}\u{113b}\x0b\u{83}\x05\u{83}\u{113d}\x0a\u{83}\x03\u{83}\x05\u{83}\
	\u{1140}\x0a\u{83}\x03\u{83}\x05\u{83}\u{1143}\x0a\u{83}\x03\u{83}\x05\u{83}\
	\u{1146}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{1153}\
	\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x07\u{83}\u{115d}\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{1160}\
	\x0b\u{83}\x05\u{83}\u{1162}\x0a\u{83}\x03\u{83}\x05\u{83}\u{1165}\x0a\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{1172}\x0a\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x07\
	\u{83}\u{117c}\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{117f}\x0b\u{83}\x05\u{83}\
	\u{1181}\x0a\u{83}\x03\u{83}\x05\u{83}\u{1184}\x0a\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x05\u{83}\u{118b}\x0a\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x05\u{83}\u{1190}\x0a\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\
	\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\u{83}\x03\
	\u{83}\x03\u{83}\x07\u{83}\u{119e}\x0a\u{83}\x0c\u{83}\x0e\u{83}\u{11a1}\
	\x0b\u{83}\x03\u{84}\x05\u{84}\u{11a4}\x0a\u{84}\x03\u{85}\x05\u{85}\u{11a7}\
	\x0a\u{85}\x03\u{85}\x05\u{85}\u{11aa}\x0a\u{85}\x03\u{85}\x05\u{85}\u{11ad}\
	\x0a\u{85}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x03\
	\u{86}\x03\u{86}\x03\u{86}\x03\u{86}\x07\u{86}\u{11b9}\x0a\u{86}\x0c\u{86}\
	\x0e\u{86}\u{11bc}\x0b\u{86}\x03\u{86}\x05\u{86}\u{11bf}\x0a\u{86}\x03\u{87}\
	\x03\u{87}\x03\u{87}\x03\u{87}\x03\u{87}\x07\u{87}\u{11c6}\x0a\u{87}\x0c\
	\u{87}\x0e\u{87}\u{11c9}\x0b\u{87}\x05\u{87}\u{11cb}\x0a\u{87}\x03\u{88}\
	\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x03\
	\u{88}\x03\u{88}\x03\u{88}\x03\u{88}\x05\u{88}\u{11d9}\x0a\u{88}\x03\u{89}\
	\x03\u{89}\x03\u{89}\x07\u{89}\u{11de}\x0a\u{89}\x0c\u{89}\x0e\u{89}\u{11e1}\
	\x0b\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x03\u{89}\x07\u{89}\u{11e7}\x0a\
	\u{89}\x0c\u{89}\x0e\u{89}\u{11ea}\x0b\u{89}\x05\u{89}\u{11ec}\x0a\u{89}\
	\x03\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x03\u{8a}\x05\u{8a}\u{11f4}\
	\x0a\u{8a}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\
	\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\
	\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x03\u{8b}\x05\u{8b}\u{1380}\x0a\
	\u{8b}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\
	\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\u{8c}\x03\
	\u{8c}\x03\u{8c}\x03\u{8c}\x05\u{8c}\u{1393}\x0a\u{8c}\x03\u{8d}\x03\u{8d}\
	\x03\u{8d}\x03\u{8d}\x05\u{8d}\u{1399}\x0a\u{8d}\x03\u{8e}\x03\u{8e}\x03\
	\u{8e}\x03\u{8e}\x05\u{8e}\u{139f}\x0a\u{8e}\x03\u{8e}\x03\u{8e}\x03\u{8e}\
	\x05\u{8e}\u{13a4}\x0a\u{8e}\x03\u{8f}\x03\u{8f}\x03\u{8f}\x05\u{8f}\u{13a9}\
	\x0a\u{8f}\x03\u{90}\x03\u{90}\x03\u{91}\x03\u{91}\x03\u{91}\x03\u{91}\x05\
	\u{91}\u{13b1}\x0a\u{91}\x03\u{92}\x03\u{92}\x03\u{92}\x03\u{92}\x05\u{92}\
	\u{13b7}\x0a\u{92}\x03\u{92}\x05\u{92}\u{13ba}\x0a\u{92}\x03\u{93}\x03\u{93}\
	\x03\u{93}\x03\u{93}\x03\u{93}\x03\u{93}\x05\u{93}\u{13c2}\x0a\u{93}\x03\
	\u{94}\x03\u{94}\x03\u{95}\x03\u{95}\x03\u{96}\x03\u{96}\x03\u{97}\x03\u{97}\
	\x03\u{97}\x05\u{97}\u{13cd}\x0a\u{97}\x03\u{98}\x03\u{98}\x03\u{99}\x03\
	\u{99}\x03\u{9a}\x03\u{9a}\x03\u{9b}\x03\u{9b}\x03\u{9b}\x05\u{9b}\u{13d8}\
	\x0a\u{9b}\x03\u{9b}\x05\u{9b}\u{13db}\x0a\u{9b}\x03\u{9c}\x03\u{9c}\x03\
	\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\
	\u{13e6}\x0a\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\u{13ec}\
	\x0a\u{9c}\x05\u{9c}\u{13ee}\x0a\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\u{13f2}\
	\x0a\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\u{13f8}\x0a\
	\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\u{13ff}\
	\x0a\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x07\u{9c}\u{1406}\
	\x0a\u{9c}\x0c\u{9c}\x0e\u{9c}\u{1409}\x0b\u{9c}\x03\u{9c}\x03\u{9c}\x03\
	\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x07\u{9c}\u{1412}\x0a\u{9c}\
	\x0c\u{9c}\x0e\u{9c}\u{1415}\x0b\u{9c}\x03\u{9c}\x05\u{9c}\u{1418}\x0a\u{9c}\
	\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x07\
	\u{9c}\u{1421}\x0a\u{9c}\x0c\u{9c}\x0e\u{9c}\u{1424}\x0b\u{9c}\x03\u{9c}\
	\x05\u{9c}\u{1427}\x0a\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\
	\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\u{1431}\x0a\u{9c}\x03\u{9c}\
	\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x03\u{9c}\x07\u{9c}\u{143a}\
	\x0a\u{9c}\x0c\u{9c}\x0e\u{9c}\u{143d}\x0b\u{9c}\x03\u{9c}\x05\u{9c}\u{1440}\
	\x0a\u{9c}\x03\u{9c}\x03\u{9c}\x05\u{9c}\u{1444}\x0a\u{9c}\x05\u{9c}\u{1446}\
	\x0a\u{9c}\x03\u{9d}\x03\u{9d}\x03\u{9d}\x03\u{9e}\x03\u{9e}\x05\u{9e}\u{144d}\
	\x0a\u{9e}\x03\u{9f}\x03\u{9f}\x03\u{9f}\x03\u{9f}\x03\u{9f}\x03\u{a0}\x03\
	\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a0}\x03\u{a1}\x03\u{a1}\x03\u{a1}\
	\x03\u{a1}\x03\u{a1}\x03\u{a1}\x05\u{a1}\u{1460}\x0a\u{a1}\x03\u{a2}\x03\
	\u{a2}\x03\u{a2}\x03\u{a2}\x07\u{a2}\u{1466}\x0a\u{a2}\x0c\u{a2}\x0e\u{a2}\
	\u{1469}\x0b\u{a2}\x03\u{a2}\x05\u{a2}\u{146c}\x0a\u{a2}\x05\u{a2}\u{146e}\
	\x0a\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\x05\u{a2}\u{1474}\x0a\
	\u{a2}\x03\u{a2}\x05\u{a2}\u{1477}\x0a\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\
	\x03\u{a2}\x03\u{a2}\x05\u{a2}\u{147e}\x0a\u{a2}\x03\u{a2}\x03\u{a2}\x03\
	\u{a2}\x03\u{a2}\x07\u{a2}\u{1484}\x0a\u{a2}\x0c\u{a2}\x0e\u{a2}\u{1487}\
	\x0b\u{a2}\x03\u{a2}\x05\u{a2}\u{148a}\x0a\u{a2}\x05\u{a2}\u{148c}\x0a\u{a2}\
	\x03\u{a2}\x03\u{a2}\x03\u{a2}\x03\u{a2}\x07\u{a2}\u{1492}\x0a\u{a2}\x0c\
	\u{a2}\x0e\u{a2}\u{1495}\x0b\u{a2}\x03\u{a2}\x05\u{a2}\u{1498}\x0a\u{a2}\
	\x05\u{a2}\u{149a}\x0a\u{a2}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\
	\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\
	\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\
	\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x03\u{a3}\x05\u{a3}\u{14b4}\x0a\u{a3}\
	\x03\u{a4}\x03\u{a4}\x03\u{a4}\x03\u{a4}\x03\u{a4}\x03\u{a4}\x03\u{a4}\x03\
	\u{a4}\x03\u{a4}\x05\u{a4}\u{14bf}\x0a\u{a4}\x03\u{a5}\x03\u{a5}\x03\u{a5}\
	\x05\u{a5}\u{14c4}\x0a\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\u{a5}\x03\
	\u{a5}\x07\u{a5}\u{14cb}\x0a\u{a5}\x0c\u{a5}\x0e\u{a5}\u{14ce}\x0b\u{a5}\
	\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\
	\u{a6}\x07\u{a6}\u{14d8}\x0a\u{a6}\x0c\u{a6}\x0e\u{a6}\u{14db}\x0b\u{a6}\
	\x03\u{a6}\x05\u{a6}\u{14de}\x0a\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\
	\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\x03\u{a6}\
	\x03\u{a6}\x05\u{a6}\u{14ec}\x0a\u{a6}\x03\u{a7}\x03\u{a7}\x05\u{a7}\u{14f0}\
	\x0a\u{a7}\x03\u{a7}\x03\u{a7}\x05\u{a7}\u{14f4}\x0a\u{a7}\x03\u{a7}\x03\
	\u{a7}\x05\u{a7}\u{14f8}\x0a\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\x03\u{a7}\
	\x05\u{a7}\u{14fe}\x0a\u{a7}\x03\u{a7}\x03\u{a7}\x05\u{a7}\u{1502}\x0a\u{a7}\
	\x03\u{a7}\x03\u{a7}\x05\u{a7}\u{1506}\x0a\u{a7}\x03\u{a7}\x05\u{a7}\u{1509}\
	\x0a\u{a7}\x03\u{a7}\x03\u{a7}\x05\u{a7}\u{150d}\x0a\u{a7}\x05\u{a7}\u{150f}\
	\x0a\u{a7}\x03\u{a8}\x03\u{a8}\x03\u{a8}\x03\u{a8}\x03\u{a8}\x05\u{a8}\u{1516}\
	\x0a\u{a8}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\u{a9}\x03\
	\u{a9}\x05\u{a9}\u{151f}\x0a\u{a9}\x03\u{aa}\x03\u{aa}\x03\u{ab}\x03\u{ab}\
	\x03\u{ab}\x07\u{ab}\u{1526}\x0a\u{ab}\x0c\u{ab}\x0e\u{ab}\u{1529}\x0b\u{ab}\
	\x03\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x03\u{ab}\x05\u{ab}\u{1530}\x0a\
	\u{ab}\x03\u{ac}\x03\u{ac}\x03\u{ad}\x03\u{ad}\x05\u{ad}\u{1536}\x0a\u{ad}\
	\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\
	\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x05\u{ae}\
	\u{1546}\x0a\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\
	\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x03\u{ae}\x07\u{ae}\u{1552}\x0a\u{ae}\
	\x0c\u{ae}\x0e\u{ae}\u{1555}\x0b\u{ae}\x03\u{af}\x03\u{af}\x05\u{af}\u{1559}\
	\x0a\u{af}\x03\u{b0}\x03\u{b0}\x03\u{b0}\x03\u{b0}\x03\u{b0}\x03\u{b0}\x03\
	\u{b1}\x03\u{b1}\x03\u{b2}\x03\u{b2}\x03\u{b2}\x03\u{b2}\x03\u{b2}\x05\u{b2}\
	\u{1568}\x0a\u{b2}\x03\u{b3}\x03\u{b3}\x05\u{b3}\u{156c}\x0a\u{b3}\x03\u{b4}\
	\x03\u{b4}\x03\u{b4}\x03\u{b4}\x05\u{b4}\u{1572}\x0a\u{b4}\x03\u{b5}\x03\
	\u{b5}\x03\u{b6}\x03\u{b6}\x03\u{b7}\x03\u{b7}\x03\u{b7}\x03\u{b8}\x03\u{b8}\
	\x03\u{b8}\x03\u{b8}\x03\u{b9}\x03\u{b9}\x03\u{b9}\x07\u{b9}\u{1582}\x0a\
	\u{b9}\x0c\u{b9}\x0e\u{b9}\u{1585}\x0b\u{b9}\x03\u{ba}\x05\u{ba}\u{1588}\
	\x0a\u{ba}\x03\u{ba}\x03\u{ba}\x05\u{ba}\u{158c}\x0a\u{ba}\x03\u{ba}\x03\
	\u{ba}\x05\u{ba}\u{1590}\x0a\u{ba}\x03\u{ba}\x05\u{ba}\u{1593}\x0a\u{ba}\
	\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\
	\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\
	\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\
	\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x03\u{bb}\x05\u{bb}\u{15b1}\
	\x0a\u{bb}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\
	\u{bc}\x05\u{bc}\u{15ba}\x0a\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\
	\x03\u{bc}\x03\u{bc}\x07\u{bc}\u{15c2}\x0a\u{bc}\x0c\u{bc}\x0e\u{bc}\u{15c5}\
	\x0b\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bc}\x03\u{bd}\x03\u{bd}\x03\
	\u{bd}\x07\u{bd}\u{15ce}\x0a\u{bd}\x0c\u{bd}\x0e\u{bd}\u{15d1}\x0b\u{bd}\
	\x03\u{be}\x03\u{be}\x03\u{bf}\x03\u{bf}\x03\u{bf}\x02\x08\u{94}\u{fa}\u{102}\
	\u{104}\u{148}\u{15a}\u{c0}\x02\x04\x06\x08\x0a\x0c\x0e\x10\x12\x14\x16\
	\x18\x1a\x1c\x1e\x20\x22\x24\x26\x28\x2a\x2c\x2e\x30\x32\x34\x36\x38\x3a\
	\x3c\x3e\x40\x42\x44\x46\x48\x4a\x4c\x4e\x50\x52\x54\x56\x58\x5a\x5c\x5e\
	\x60\x62\x64\x66\x68\x6a\x6c\x6e\x70\x72\x74\x76\x78\x7a\x7c\x7e\u{80}\u{82}\
	\u{84}\u{86}\u{88}\u{8a}\u{8c}\u{8e}\u{90}\u{92}\u{94}\u{96}\u{98}\u{9a}\
	\u{9c}\u{9e}\u{a0}\u{a2}\u{a4}\u{a6}\u{a8}\u{aa}\u{ac}\u{ae}\u{b0}\u{b2}\
	\u{b4}\u{b6}\u{b8}\u{ba}\u{bc}\u{be}\u{c0}\u{c2}\u{c4}\u{c6}\u{c8}\u{ca}\
	\u{cc}\u{ce}\u{d0}\u{d2}\u{d4}\u{d6}\u{d8}\u{da}\u{dc}\u{de}\u{e0}\u{e2}\
	\u{e4}\u{e6}\u{e8}\u{ea}\u{ec}\u{ee}\u{f0}\u{f2}\u{f4}\u{f6}\u{f8}\u{fa}\
	\u{fc}\u{fe}\u{100}\u{102}\u{104}\u{106}\u{108}\u{10a}\u{10c}\u{10e}\u{110}\
	\u{112}\u{114}\u{116}\u{118}\u{11a}\u{11c}\u{11e}\u{120}\u{122}\u{124}\u{126}\
	\u{128}\u{12a}\u{12c}\u{12e}\u{130}\u{132}\u{134}\u{136}\u{138}\u{13a}\u{13c}\
	\u{13e}\u{140}\u{142}\u{144}\u{146}\u{148}\u{14a}\u{14c}\u{14e}\u{150}\u{152}\
	\u{154}\u{156}\u{158}\u{15a}\u{15c}\u{15e}\u{160}\u{162}\u{164}\u{166}\u{168}\
	\u{16a}\u{16c}\u{16e}\u{170}\u{172}\u{174}\u{176}\u{178}\u{17a}\u{17c}\x02\
	\x37\x03\x02\u{1ce}\u{1ce}\x04\x02\u{9b}\u{9b}\u{dd}\u{dd}\x06\x02\u{179}\
	\u{179}\u{17b}\u{17b}\u{188}\u{188}\u{1ac}\u{1ac}\x04\x02\x21\x21\x27\x27\
	\x05\x02\u{179}\u{179}\u{17b}\u{17b}\u{1ac}\u{1ac}\x03\x02\x66\x67\x04\x02\
	\u{179}\u{179}\u{17b}\u{17b}\x04\x02\u{ae}\u{ae}\u{1ac}\u{1ac}\x04\x02\u{153}\
	\u{153}\u{175}\u{175}\x04\x02\u{80}\u{80}\u{b0}\u{b0}\x04\x02\x65\x65\u{ad}\
	\u{ad}\x04\x02\x6a\x6a\x76\x76\x04\x02\u{101}\u{101}\u{1a4}\u{1a4}\x04\x02\
	\u{fe}\u{fe}\u{139}\u{139}\x06\x02\x2e\x2e\u{a4}\u{a4}\u{1b7}\u{1b7}\u{1bb}\
	\u{1bb}\x04\x02\x25\x25\u{aa}\u{aa}\x04\x02\u{fd}\u{fd}\u{10e}\u{10e}\x04\
	\x02\u{8e}\u{8e}\u{f6}\u{f6}\x03\x02\u{14c}\u{14d}\x04\x02\u{1cd}\u{1cd}\
	\u{1d8}\u{1d8}\x04\x02\x7f\x7f\u{ee}\u{ee}\x04\x02\x14\x14\x6b\x6b\x04\x02\
	\x1f\x1f\x66\x66\x04\x02\u{8e}\u{8e}\u{d2}\u{d2}\x04\x02\u{14f}\u{14f}\u{177}\
	\u{177}\x04\x02\x29\x29\u{14c}\u{14c}\x04\x02\x2b\x2b\u{173}\u{173}\x03\
	\x02\u{1d8}\u{1d9}\x04\x02\u{13b}\u{13b}\u{157}\u{157}\x05\x02\x2c\x2c\u{d5}\
	\u{d5}\u{185}\u{185}\x04\x02\u{b4}\u{b4}\u{158}\u{158}\x04\x02\x1a\x1a\x5c\
	\x5c\x04\x02\u{c2}\u{c2}\u{d9}\u{d9}\x04\x02\x14\x14\x19\x19\x04\x02\u{1c7}\
	\u{1c8}\u{1d2}\u{1d2}\x03\x02\u{1c9}\u{1cb}\x03\x02\u{1c7}\u{1c8}\x03\x02\
	\x1c\x1d\x05\x02\u{8f}\u{8f}\u{cf}\u{cf}\u{d3}\u{d3}\x04\x02\u{ac}\u{ac}\
	\u{13e}\u{13e}\x04\x02\u{8d}\u{8d}\u{14e}\u{14e}\x03\x02\u{1c1}\u{1c6}\x05\
	\x02\x14\x14\x19\x19\u{166}\u{166}\x04\x02\u{87}\u{87}\u{18a}\u{18a}\x08\
	\x02\x58\x58\u{a7}\u{a7}\u{ef}\u{ef}\u{f2}\u{f2}\u{152}\u{152}\u{1b8}\u{1b8}\
	\x03\x02\u{f7}\u{fa}\x04\x02\x3a\x3b\u{f5}\u{f5}\x04\x02\u{91}\u{91}\u{126}\
	\u{126}\x04\x02\u{10a}\u{10a}\u{1b6}\u{1b6}\x07\x02\x50\x50\x60\x60\u{ba}\
	\u{ba}\u{159}\u{159}\u{19c}\u{19c}\x04\x02\u{182}\u{182}\u{1aa}\u{1aa}\x0d\
	\x02\x20\x20\x51\x51\u{97}\u{97}\u{b6}\u{b6}\u{c5}\u{c5}\u{d4}\u{d4}\u{d6}\
	\u{d6}\u{e6}\u{e6}\u{f4}\u{f4}\u{145}\u{145}\u{19f}\u{19f}\x3f\x02\x0e\x13\
	\x16\x16\x18\x18\x1a\x1d\x1f\x1f\x21\x29\x2b\x2c\x2e\x3f\x41\x41\x43\x48\
	\x4a\x4f\x52\x52\x54\x5f\x61\x6a\x6c\x71\x73\x73\x75\u{82}\u{84}\u{90}\u{93}\
	\u{95}\u{98}\u{9c}\u{9e}\u{a0}\u{a2}\u{a4}\u{a6}\u{ae}\u{b0}\u{b1}\u{b3}\
	\u{b5}\u{b7}\u{b9}\u{bc}\u{bc}\u{be}\u{bf}\u{c1}\u{c1}\u{c3}\u{c4}\u{c6}\
	\u{d3}\u{d5}\u{d5}\u{d7}\u{d8}\u{da}\u{e5}\u{e7}\u{ed}\u{ef}\u{f3}\u{f5}\
	\u{ff}\u{101}\u{101}\u{103}\u{104}\u{106}\u{107}\u{109}\u{10c}\u{10f}\u{12f}\
	\u{131}\u{134}\u{136}\u{143}\u{147}\u{14b}\u{14e}\u{14e}\u{150}\u{158}\u{15a}\
	\u{15f}\u{161}\u{165}\u{167}\u{169}\u{16b}\u{174}\u{176}\u{176}\u{178}\u{17e}\
	\u{180}\u{182}\u{184}\u{192}\u{195}\u{19b}\u{19d}\u{19e}\u{1a0}\u{1a5}\u{1a7}\
	\u{1ae}\u{1b0}\u{1b0}\u{1b2}\u{1bb}\x02\u{1a9a}\x02\u{17f}\x03\x02\x02\x02\
	\x04\u{18d}\x03\x02\x02\x02\x06\u{194}\x03\x02\x02\x02\x08\u{197}\x03\x02\
	\x02\x02\x0a\u{19a}\x03\x02\x02\x02\x0c\u{8e4}\x03\x02\x02\x02\x0e\u{8e6}\
	\x03\x02\x02\x02\x10\u{8ee}\x03\x02\x02\x02\x12\u{91b}\x03\x02\x02\x02\x14\
	\u{920}\x03\x02\x02\x02\x16\u{93f}\x03\x02\x02\x02\x18\u{954}\x03\x02\x02\
	\x02\x1a\u{964}\x03\x02\x02\x02\x1c\u{97e}\x03\x02\x02\x02\x1e\u{982}\x03\
	\x02\x02\x02\x20\u{988}\x03\x02\x02\x02\x22\u{98c}\x03\x02\x02\x02\x24\u{990}\
	\x03\x02\x02\x02\x26\u{994}\x03\x02\x02\x02\x28\u{998}\x03\x02\x02\x02\x2a\
	\u{99c}\x03\x02\x02\x02\x2c\u{9a0}\x03\x02\x02\x02\x2e\u{9ae}\x03\x02\x02\
	\x02\x30\u{9b0}\x03\x02\x02\x02\x32\u{9f4}\x03\x02\x02\x02\x34\u{a09}\x03\
	\x02\x02\x02\x36\u{a4b}\x03\x02\x02\x02\x38\u{a51}\x03\x02\x02\x02\x3a\u{a54}\
	\x03\x02\x02\x02\x3c\u{a56}\x03\x02\x02\x02\x3e\u{a58}\x03\x02\x02\x02\x40\
	\u{a5f}\x03\x02\x02\x02\x42\u{a6a}\x03\x02\x02\x02\x44\u{a6e}\x03\x02\x02\
	\x02\x46\u{a70}\x03\x02\x02\x02\x48\u{a76}\x03\x02\x02\x02\x4a\u{a90}\x03\
	\x02\x02\x02\x4c\u{a92}\x03\x02\x02\x02\x4e\u{a97}\x03\x02\x02\x02\x50\u{a99}\
	\x03\x02\x02\x02\x52\u{a9b}\x03\x02\x02\x02\x54\u{ab6}\x03\x02\x02\x02\x56\
	\u{aba}\x03\x02\x02\x02\x58\u{abf}\x03\x02\x02\x02\x5a\u{ac1}\x03\x02\x02\
	\x02\x5c\u{ac3}\x03\x02\x02\x02\x5e\u{ac5}\x03\x02\x02\x02\x60\u{ada}\x03\
	\x02\x02\x02\x62\u{adc}\x03\x02\x02\x02\x64\u{ae5}\x03\x02\x02\x02\x66\u{ae9}\
	\x03\x02\x02\x02\x68\u{aeb}\x03\x02\x02\x02\x6a\u{afe}\x03\x02\x02\x02\x6c\
	\u{b00}\x03\x02\x02\x02\x6e\u{b08}\x03\x02\x02\x02\x70\u{b0a}\x03\x02\x02\
	\x02\x72\u{b36}\x03\x02\x02\x02\x74\u{b42}\x03\x02\x02\x02\x76\u{b48}\x03\
	\x02\x02\x02\x78\u{b53}\x03\x02\x02\x02\x7a\u{b66}\x03\x02\x02\x02\x7c\u{b99}\
	\x03\x02\x02\x02\x7e\u{bab}\x03\x02\x02\x02\u{80}\u{bad}\x03\x02\x02\x02\
	\u{82}\u{bb4}\x03\x02\x02\x02\u{84}\u{bbf}\x03\x02\x02\x02\u{86}\u{bcc}\
	\x03\x02\x02\x02\u{88}\u{bd9}\x03\x02\x02\x02\u{8a}\u{be2}\x03\x02\x02\x02\
	\u{8c}\u{bf0}\x03\x02\x02\x02\u{8e}\u{bf2}\x03\x02\x02\x02\u{90}\u{c2a}\
	\x03\x02\x02\x02\u{92}\u{c2c}\x03\x02\x02\x02\u{94}\u{c2e}\x03\x02\x02\x02\
	\u{96}\u{c67}\x03\x02\x02\x02\u{98}\u{c7a}\x03\x02\x02\x02\u{9a}\u{c7c}\
	\x03\x02\x02\x02\u{9c}\u{cab}\x03\x02\x02\x02\u{9e}\u{cad}\x03\x02\x02\x02\
	\u{a0}\u{cb1}\x03\x02\x02\x02\u{a2}\u{cc7}\x03\x02\x02\x02\u{a4}\u{cc9}\
	\x03\x02\x02\x02\u{a6}\u{ccb}\x03\x02\x02\x02\u{a8}\u{cce}\x03\x02\x02\x02\
	\u{aa}\u{cd3}\x03\x02\x02\x02\u{ac}\u{cdb}\x03\x02\x02\x02\u{ae}\u{ce1}\
	\x03\x02\x02\x02\u{b0}\u{ce3}\x03\x02\x02\x02\u{b2}\u{ce5}\x03\x02\x02\x02\
	\u{b4}\u{d41}\x03\x02\x02\x02\u{b6}\u{d50}\x03\x02\x02\x02\u{b8}\u{d5b}\
	\x03\x02\x02\x02\u{ba}\u{d70}\x03\x02\x02\x02\u{bc}\u{d72}\x03\x02\x02\x02\
	\u{be}\u{d82}\x03\x02\x02\x02\u{c0}\u{d9f}\x03\x02\x02\x02\u{c2}\u{da6}\
	\x03\x02\x02\x02\u{c4}\u{da8}\x03\x02\x02\x02\u{c6}\u{dcc}\x03\x02\x02\x02\
	\u{c8}\u{dce}\x03\x02\x02\x02\u{ca}\u{dd5}\x03\x02\x02\x02\u{cc}\u{de0}\
	\x03\x02\x02\x02\u{ce}\u{de2}\x03\x02\x02\x02\u{d0}\u{de4}\x03\x02\x02\x02\
	\u{d2}\u{dee}\x03\x02\x02\x02\u{d4}\u{df0}\x03\x02\x02\x02\u{d6}\u{df8}\
	\x03\x02\x02\x02\u{d8}\u{e03}\x03\x02\x02\x02\u{da}\u{e15}\x03\x02\x02\x02\
	\u{dc}\u{e2c}\x03\x02\x02\x02\u{de}\u{e2e}\x03\x02\x02\x02\u{e0}\u{e30}\
	\x03\x02\x02\x02\u{e2}\u{e3b}\x03\x02\x02\x02\u{e4}\u{e79}\x03\x02\x02\x02\
	\u{e6}\u{ea5}\x03\x02\x02\x02\u{e8}\u{ea7}\x03\x02\x02\x02\u{ea}\u{eb6}\
	\x03\x02\x02\x02\u{ec}\u{ebb}\x03\x02\x02\x02\u{ee}\u{ec2}\x03\x02\x02\x02\
	\u{f0}\u{f10}\x03\x02\x02\x02\u{f2}\u{f27}\x03\x02\x02\x02\u{f4}\u{f29}\
	\x03\x02\x02\x02\u{f6}\u{f2d}\x03\x02\x02\x02\u{f8}\u{f3d}\x03\x02\x02\x02\
	\u{fa}\u{f43}\x03\x02\x02\x02\u{fc}\u{f5e}\x03\x02\x02\x02\u{fe}\u{f60}\
	\x03\x02\x02\x02\u{100}\u{fbd}\x03\x02\x02\x02\u{102}\u{fc6}\x03\x02\x02\
	\x02\u{104}\u{118f}\x03\x02\x02\x02\u{106}\u{11a3}\x03\x02\x02\x02\u{108}\
	\u{11a6}\x03\x02\x02\x02\u{10a}\u{11be}\x03\x02\x02\x02\u{10c}\u{11ca}\x03\
	\x02\x02\x02\u{10e}\u{11d8}\x03\x02\x02\x02\u{110}\u{11eb}\x03\x02\x02\x02\
	\u{112}\u{11f3}\x03\x02\x02\x02\u{114}\u{137f}\x03\x02\x02\x02\u{116}\u{1392}\
	\x03\x02\x02\x02\u{118}\u{1394}\x03\x02\x02\x02\u{11a}\u{13a3}\x03\x02\x02\
	\x02\u{11c}\u{13a5}\x03\x02\x02\x02\u{11e}\u{13aa}\x03\x02\x02\x02\u{120}\
	\u{13b0}\x03\x02\x02\x02\u{122}\u{13b9}\x03\x02\x02\x02\u{124}\u{13c1}\x03\
	\x02\x02\x02\u{126}\u{13c3}\x03\x02\x02\x02\u{128}\u{13c5}\x03\x02\x02\x02\
	\u{12a}\u{13c7}\x03\x02\x02\x02\u{12c}\u{13c9}\x03\x02\x02\x02\u{12e}\u{13ce}\
	\x03\x02\x02\x02\u{130}\u{13d0}\x03\x02\x02\x02\u{132}\u{13d2}\x03\x02\x02\
	\x02\u{134}\u{13da}\x03\x02\x02\x02\u{136}\u{1445}\x03\x02\x02\x02\u{138}\
	\u{1447}\x03\x02\x02\x02\u{13a}\u{144c}\x03\x02\x02\x02\u{13c}\u{144e}\x03\
	\x02\x02\x02\u{13e}\u{1453}\x03\x02\x02\x02\u{140}\u{1459}\x03\x02\x02\x02\
	\u{142}\u{146d}\x03\x02\x02\x02\u{144}\u{14b3}\x03\x02\x02\x02\u{146}\u{14be}\
	\x03\x02\x02\x02\u{148}\u{14c0}\x03\x02\x02\x02\u{14a}\u{14eb}\x03\x02\x02\
	\x02\u{14c}\u{150e}\x03\x02\x02\x02\u{14e}\u{1515}\x03\x02\x02\x02\u{150}\
	\u{151e}\x03\x02\x02\x02\u{152}\u{1520}\x03\x02\x02\x02\u{154}\u{152f}\x03\
	\x02\x02\x02\u{156}\u{1531}\x03\x02\x02\x02\u{158}\u{1535}\x03\x02\x02\x02\
	\u{15a}\u{1545}\x03\x02\x02\x02\u{15c}\u{1558}\x03\x02\x02\x02\u{15e}\u{155a}\
	\x03\x02\x02\x02\u{160}\u{1560}\x03\x02\x02\x02\u{162}\u{1567}\x03\x02\x02\
	\x02\u{164}\u{156b}\x03\x02\x02\x02\u{166}\u{1571}\x03\x02\x02\x02\u{168}\
	\u{1573}\x03\x02\x02\x02\u{16a}\u{1575}\x03\x02\x02\x02\u{16c}\u{1577}\x03\
	\x02\x02\x02\u{16e}\u{157a}\x03\x02\x02\x02\u{170}\u{157e}\x03\x02\x02\x02\
	\u{172}\u{1592}\x03\x02\x02\x02\u{174}\u{15b0}\x03\x02\x02\x02\u{176}\u{15b2}\
	\x03\x02\x02\x02\u{178}\u{15ca}\x03\x02\x02\x02\u{17a}\u{15d2}\x03\x02\x02\
	\x02\u{17c}\u{15d4}\x03\x02\x02\x02\u{17e}\u{180}\x05\x0c\x07\x02\u{17f}\
	\u{17e}\x03\x02\x02\x02\u{17f}\u{180}\x03\x02\x02\x02\u{180}\u{187}\x03\
	\x02\x02\x02\u{181}\u{183}\x07\u{1ce}\x02\x02\u{182}\u{184}\x05\x0c\x07\
	\x02\u{183}\u{182}\x03\x02\x02\x02\u{183}\u{184}\x03\x02\x02\x02\u{184}\
	\u{186}\x03\x02\x02\x02\u{185}\u{181}\x03\x02\x02\x02\u{186}\u{189}\x03\
	\x02\x02\x02\u{187}\u{185}\x03\x02\x02\x02\u{187}\u{188}\x03\x02\x02\x02\
	\u{188}\u{18a}\x03\x02\x02\x02\u{189}\u{187}\x03\x02\x02\x02\u{18a}\u{18b}\
	\x07\x02\x02\x03\u{18b}\x03\x03\x02\x02\x02\u{18c}\u{18e}\x05\x0c\x07\x02\
	\u{18d}\u{18c}\x03\x02\x02\x02\u{18d}\u{18e}\x03\x02\x02\x02\u{18e}\u{190}\
	\x03\x02\x02\x02\u{18f}\u{191}\x07\u{1ce}\x02\x02\u{190}\u{18f}\x03\x02\
	\x02\x02\u{190}\u{191}\x03\x02\x02\x02\u{191}\u{192}\x03\x02\x02\x02\u{192}\
	\u{193}\x07\x02\x02\x03\u{193}\x05\x03\x02\x02\x02\u{194}\u{195}\x05\u{f8}\
	\x7d\x02\u{195}\u{196}\x07\x02\x02\x03\u{196}\x07\x03\x02\x02\x02\u{197}\
	\u{198}\x05\u{154}\u{ab}\x02\u{198}\u{199}\x07\x02\x02\x03\u{199}\x09\x03\
	\x02\x02\x02\u{19a}\u{19b}\x05\u{134}\u{9b}\x02\u{19b}\u{19c}\x07\x02\x02\
	\x03\u{19c}\x0b\x03\x02\x02\x02\u{19d}\u{8e5}\x05\x2a\x16\x02\u{19e}\u{19f}\
	\x07\u{19d}\x02\x02\u{19f}\u{8e5}\x05\u{164}\u{b3}\x02\u{1a0}\u{1a1}\x07\
	\u{19d}\x02\x02\u{1a1}\u{1a2}\x05\u{164}\u{b3}\x02\u{1a2}\u{1a3}\x07\u{1c0}\
	\x02\x02\u{1a3}\u{1a4}\x05\u{164}\u{b3}\x02\u{1a4}\u{8e5}\x03\x02\x02\x02\
	\u{1a5}\u{1a6}\x07\x72\x02\x02\u{1a6}\u{1a9}\x07\u{153}\x02\x02\u{1a7}\u{1a8}\
	\x07\u{ab}\x02\x02\u{1a8}\u{1aa}\x07\u{83}\x02\x02\u{1a9}\u{1a7}\x03\x02\
	\x02\x02\u{1a9}\u{1aa}\x03\x02\x02\x02\u{1aa}\u{1ab}\x03\x02\x02\x02\u{1ab}\
	\u{1af}\x05\u{154}\u{ab}\x02\u{1ac}\u{1ae}\x0a\x02\x02\x02\u{1ad}\u{1ac}\
	\x03\x02\x02\x02\u{1ae}\u{1b1}\x03\x02\x02\x02\u{1af}\u{1ad}\x03\x02\x02\
	\x02\u{1af}\u{1b0}\x03\x02\x02\x02\u{1b0}\u{8e5}\x03\x02\x02\x02\u{1b1}\
	\u{1af}\x03\x02\x02\x02\u{1b2}\u{1b3}\x07\x15\x02\x02\u{1b3}\u{1b4}\x07\
	\u{153}\x02\x02\u{1b4}\u{1b5}\x05\u{154}\u{ab}\x02\u{1b5}\u{1b6}\x07\u{13a}\
	\x02\x02\u{1b6}\u{1b7}\x07\u{183}\x02\x02\u{1b7}\u{1b8}\x05\u{164}\u{b3}\
	\x02\u{1b8}\u{8e5}\x03\x02\x02\x02\u{1b9}\u{1ba}\x07\x15\x02\x02\u{1ba}\
	\u{1bb}\x07\u{153}\x02\x02\u{1bb}\u{1bc}\x05\u{154}\u{ab}\x02\u{1bc}\u{1bd}\
	\x07\u{160}\x02\x02\u{1bd}\u{1be}\x07\x23\x02\x02\u{1be}\u{1bf}\x05\u{162}\
	\u{b2}\x02\u{1bf}\u{8e5}\x03\x02\x02\x02\u{1c0}\u{1c1}\x07\x72\x02\x02\u{1c1}\
	\u{1c2}\x07\u{175}\x02\x02\u{1c2}\u{8e5}\x05\u{154}\u{ab}\x02\u{1c3}\u{1c4}\
	\x07\x72\x02\x02\u{1c4}\u{1c5}\x07\u{1ab}\x02\x02\u{1c5}\u{8e5}\x05\u{154}\
	\u{ab}\x02\u{1c6}\u{1c9}\x07\x50\x02\x02\u{1c7}\u{1c8}\x07\u{10d}\x02\x02\
	\u{1c8}\u{1ca}\x07\u{13c}\x02\x02\u{1c9}\u{1c7}\x03\x02\x02\x02\u{1c9}\u{1ca}\
	\x03\x02\x02\x02\u{1ca}\u{1cb}\x03\x02\x02\x02\u{1cb}\u{1cc}\x07\u{85}\x02\
	\x02\u{1cc}\u{1d0}\x07\u{175}\x02\x02\u{1cd}\u{1ce}\x07\u{ab}\x02\x02\u{1ce}\
	\u{1cf}\x07\u{100}\x02\x02\u{1cf}\u{1d1}\x07\u{83}\x02\x02\u{1d0}\u{1cd}\
	\x03\x02\x02\x02\u{1d0}\u{1d1}\x03\x02\x02\x02\u{1d1}\u{1d2}\x03\x02\x02\
	\x02\u{1d2}\u{1d6}\x05\u{154}\u{ab}\x02\u{1d3}\u{1d4}\x07\u{ab}\x02\x02\
	\u{1d4}\u{1d5}\x07\u{100}\x02\x02\u{1d5}\u{1d7}\x07\u{83}\x02\x02\u{1d6}\
	\u{1d3}\x03\x02\x02\x02\u{1d6}\u{1d7}\x03\x02\x02\x02\u{1d7}\u{1e6}\x03\
	\x02\x02\x02\u{1d8}\u{1d9}\x07\u{1bc}\x02\x02\u{1d9}\u{1de}\x05\x36\x1c\
	\x02\u{1da}\u{1db}\x07\x42\x02\x02\u{1db}\u{1dd}\x05\x36\x1c\x02\u{1dc}\
	\u{1da}\x03\x02\x02\x02\u{1dd}\u{1e0}\x03\x02\x02\x02\u{1de}\u{1dc}\x03\
	\x02\x02\x02\u{1de}\u{1df}\x03\x02\x02\x02\u{1df}\u{1e2}\x03\x02\x02\x02\
	\u{1e0}\u{1de}\x03\x02\x02\x02\u{1e1}\u{1e3}\x07\x42\x02\x02\u{1e2}\u{1e1}\
	\x03\x02\x02\x02\u{1e2}\u{1e3}\x03\x02\x02\x02\u{1e3}\u{1e4}\x03\x02\x02\
	\x02\u{1e4}\u{1e5}\x07\u{1bd}\x02\x02\u{1e5}\u{1e7}\x03\x02\x02\x02\u{1e6}\
	\u{1d8}\x03\x02\x02\x02\u{1e6}\u{1e7}\x03\x02\x02\x02\u{1e7}\u{1e9}\x03\
	\x02\x02\x02\u{1e8}\u{1ea}\x07\x42\x02\x02\u{1e9}\u{1e8}\x03\x02\x02\x02\
	\u{1e9}\u{1ea}\x03\x02\x02\x02\u{1ea}\u{1eb}\x03\x02\x02\x02\u{1eb}\u{1ec}\
	\x05\x1c\x0f\x02\u{1ec}\u{8e5}\x03\x02\x02\x02\u{1ed}\u{1f0}\x07\x50\x02\
	\x02\u{1ee}\u{1ef}\x07\u{10d}\x02\x02\u{1ef}\u{1f1}\x07\u{13c}\x02\x02\u{1f0}\
	\u{1ee}\x03\x02\x02\x02\u{1f0}\u{1f1}\x03\x02\x02\x02\u{1f1}\u{1f6}\x03\
	\x02\x02\x02\u{1f2}\u{1f4}\x09\x03\x02\x02\u{1f3}\u{1f2}\x03\x02\x02\x02\
	\u{1f3}\u{1f4}\x03\x02\x02\x02\u{1f4}\u{1f5}\x03\x02\x02\x02\u{1f5}\u{1f7}\
	\x09\x04\x02\x02\u{1f6}\u{1f3}\x03\x02\x02\x02\u{1f6}\u{1f7}\x03\x02\x02\
	\x02\u{1f7}\u{1f8}\x03\x02\x02\x02\u{1f8}\u{1fc}\x07\u{175}\x02\x02\u{1f9}\
	\u{1fa}\x07\u{ab}\x02\x02\u{1fa}\u{1fb}\x07\u{100}\x02\x02\u{1fb}\u{1fd}\
	\x07\u{83}\x02\x02\u{1fc}\u{1f9}\x03\x02\x02\x02\u{1fc}\u{1fd}\x03\x02\x02\
	\x02\u{1fd}\u{1fe}\x03\x02\x02\x02\u{1fe}\u{202}\x05\u{154}\u{ab}\x02\u{1ff}\
	\u{200}\x07\u{ab}\x02\x02\u{200}\u{201}\x07\u{100}\x02\x02\u{201}\u{203}\
	\x07\u{83}\x02\x02\u{202}\u{1ff}\x03\x02\x02\x02\u{202}\u{203}\x03\x02\x02\
	\x02\u{203}\u{204}\x03\x02\x02\x02\u{204}\u{206}\x05\x12\x0a\x02\u{205}\
	\u{207}\x05\u{e2}\x72\x02\u{206}\u{205}\x03\x02\x02\x02\u{206}\u{207}\x03\
	\x02\x02\x02\u{207}\u{208}\x03\x02\x02\x02\u{208}\u{209}\x05\x12\x0a\x02\
	\u{209}\u{20a}\x07\x1e\x02\x02\u{20a}\u{20b}\x05\x2a\x16\x02\u{20b}\u{8e5}\
	\x03\x02\x02\x02\u{20c}\u{20f}\x07\x50\x02\x02\u{20d}\u{20e}\x07\u{10d}\
	\x02\x02\u{20e}\u{210}\x07\u{13c}\x02\x02\u{20f}\u{20d}\x03\x02\x02\x02\
	\u{20f}\u{210}\x03\x02\x02\x02\u{210}\u{212}\x03\x02\x02\x02\u{211}\u{213}\
	\x09\x04\x02\x02\u{212}\u{211}\x03\x02\x02\x02\u{212}\u{213}\x03\x02\x02\
	\x02\u{213}\u{214}\x03\x02\x02\x02\u{214}\u{218}\x07\u{175}\x02\x02\u{215}\
	\u{216}\x07\u{ab}\x02\x02\u{216}\u{217}\x07\u{100}\x02\x02\u{217}\u{219}\
	\x07\u{83}\x02\x02\u{218}\u{215}\x03\x02\x02\x02\u{218}\u{219}\x03\x02\x02\
	\x02\u{219}\u{21a}\x03\x02\x02\x02\u{21a}\u{21b}\x05\u{154}\u{ab}\x02\u{21b}\
	\u{21c}\x07\x3c\x02\x02\u{21c}\u{22c}\x05\u{154}\u{ab}\x02\u{21d}\u{21e}\
	\x09\x05\x02\x02\u{21e}\u{228}\x07\u{1bc}\x02\x02\u{21f}\u{220}\x07\u{182}\
	\x02\x02\u{220}\u{221}\x07\x03\x02\x02\u{221}\u{229}\x05\u{f8}\x7d\x02\u{222}\
	\u{223}\x07\u{106}\x02\x02\u{223}\u{224}\x07\x03\x02\x02\u{224}\u{229}\x05\
	\u{f8}\x7d\x02\u{225}\u{226}\x07\u{16b}\x02\x02\u{226}\u{227}\x07\x03\x02\
	\x02\u{227}\u{229}\x05\u{f8}\x7d\x02\u{228}\u{21f}\x03\x02\x02\x02\u{228}\
	\u{222}\x03\x02\x02\x02\u{228}\u{225}\x03\x02\x02\x02\u{229}\u{22a}\x03\
	\x02\x02\x02\u{22a}\u{22b}\x07\u{1bd}\x02\x02\u{22b}\u{22d}\x03\x02\x02\
	\x02\u{22c}\u{21d}\x03\x02\x02\x02\u{22c}\u{22d}\x03\x02\x02\x02\u{22d}\
	\u{230}\x03\x02\x02\x02\u{22e}\u{22f}\x07\x4e\x02\x02\u{22f}\u{231}\x07\
	\u{9f}\x02\x02\u{230}\u{22e}\x03\x02\x02\x02\u{230}\u{231}\x03\x02\x02\x02\
	\u{231}\u{8e5}\x03\x02\x02\x02\u{232}\u{235}\x07\x50\x02\x02\u{233}\u{234}\
	\x07\u{10d}\x02\x02\u{234}\u{236}\x07\u{13c}\x02\x02\u{235}\u{233}\x03\x02\
	\x02\x02\u{235}\u{236}\x03\x02\x02\x02\u{236}\u{237}\x03\x02\x02\x02\u{237}\
	\u{238}\x07\x73\x02\x02\u{238}\u{23c}\x07\u{175}\x02\x02\u{239}\u{23a}\x07\
	\u{ab}\x02\x02\u{23a}\u{23b}\x07\u{100}\x02\x02\u{23b}\u{23d}\x07\u{83}\
	\x02\x02\u{23c}\u{239}\x03\x02\x02\x02\u{23c}\u{23d}\x03\x02\x02\x02\u{23d}\
	\u{23e}\x03\x02\x02\x02\u{23e}\u{23f}\x05\u{154}\u{ab}\x02\u{23f}\u{240}\
	\x07\x3c\x02\x02\u{240}\u{250}\x05\u{154}\u{ab}\x02\u{241}\u{242}\x09\x05\
	\x02\x02\u{242}\u{24c}\x07\u{1bc}\x02\x02\u{243}\u{244}\x07\u{182}\x02\x02\
	\u{244}\u{245}\x07\x03\x02\x02\u{245}\u{24d}\x05\u{f8}\x7d\x02\u{246}\u{247}\
	\x07\u{106}\x02\x02\u{247}\u{248}\x07\x03\x02\x02\u{248}\u{24d}\x05\u{f8}\
	\x7d\x02\u{249}\u{24a}\x07\u{16b}\x02\x02\u{24a}\u{24b}\x07\x03\x02\x02\
	\u{24b}\u{24d}\x05\u{f8}\x7d\x02\u{24c}\u{243}\x03\x02\x02\x02\u{24c}\u{246}\
	\x03\x02\x02\x02\u{24c}\u{249}\x03\x02\x02\x02\u{24d}\u{24e}\x03\x02\x02\
	\x02\u{24e}\u{24f}\x07\u{1bd}\x02\x02\u{24f}\u{251}\x03\x02\x02\x02\u{250}\
	\u{241}\x03\x02\x02\x02\u{250}\u{251}\x03\x02\x02\x02\u{251}\u{25b}\x03\
	\x02\x02\x02\u{252}\u{253}\x07\u{186}\x02\x02\u{253}\u{256}\x07\u{1c1}\x02\
	\x02\u{254}\u{257}\x05\u{122}\u{92}\x02\u{255}\u{257}\x07\x70\x02\x02\u{256}\
	\u{254}\x03\x02\x02\x02\u{256}\u{255}\x03\x02\x02\x02\u{257}\u{258}\x03\
	\x02\x02\x02\u{258}\u{259}\x07\u{1ad}\x02\x02\u{259}\u{25a}\x07\u{1c1}\x02\
	\x02\u{25a}\u{25c}\x05\u{122}\u{92}\x02\u{25b}\u{252}\x03\x02\x02\x02\u{25b}\
	\u{25c}\x03\x02\x02\x02\u{25c}\u{8e5}\x03\x02\x02\x02\u{25d}\u{260}\x07\
	\x50\x02\x02\u{25e}\u{25f}\x07\u{10d}\x02\x02\u{25f}\u{261}\x07\u{13c}\x02\
	\x02\u{260}\u{25e}\x03\x02\x02\x02\u{260}\u{261}\x03\x02\x02\x02\u{261}\
	\u{262}\x03\x02\x02\x02\u{262}\u{263}\x07\x7e\x02\x02\u{263}\u{267}\x07\
	\u{175}\x02\x02\u{264}\u{265}\x07\u{ab}\x02\x02\u{265}\u{266}\x07\u{100}\
	\x02\x02\u{266}\u{268}\x07\u{83}\x02\x02\u{267}\u{264}\x03\x02\x02\x02\u{267}\
	\u{268}\x03\x02\x02\x02\u{268}\u{269}\x03\x02\x02\x02\u{269}\u{26a}\x05\
	\u{154}\u{ab}\x02\u{26a}\u{26b}\x07\x3c\x02\x02\u{26b}\u{27b}\x05\u{154}\
	\u{ab}\x02\u{26c}\u{26d}\x09\x05\x02\x02\u{26d}\u{277}\x07\u{1bc}\x02\x02\
	\u{26e}\u{26f}\x07\u{182}\x02\x02\u{26f}\u{270}\x07\x03\x02\x02\u{270}\u{278}\
	\x05\u{f8}\x7d\x02\u{271}\u{272}\x07\u{106}\x02\x02\u{272}\u{273}\x07\x03\
	\x02\x02\u{273}\u{278}\x05\u{f8}\x7d\x02\u{274}\u{275}\x07\u{16b}\x02\x02\
	\u{275}\u{276}\x07\x03\x02\x02\u{276}\u{278}\x05\u{f8}\x7d\x02\u{277}\u{26e}\
	\x03\x02\x02\x02\u{277}\u{271}\x03\x02\x02\x02\u{277}\u{274}\x03\x02\x02\
	\x02\u{278}\u{279}\x03\x02\x02\x02\u{279}\u{27a}\x07\u{1bd}\x02\x02\u{27a}\
	\u{27c}\x03\x02\x02\x02\u{27b}\u{26c}\x03\x02\x02\x02\u{27b}\u{27c}\x03\
	\x02\x02\x02\u{27c}\u{8e5}\x03\x02\x02\x02\u{27d}\u{280}\x07\x50\x02\x02\
	\u{27e}\u{27f}\x07\u{10d}\x02\x02\u{27f}\u{281}\x07\u{13c}\x02\x02\u{280}\
	\u{27e}\x03\x02\x02\x02\u{280}\u{281}\x03\x02\x02\x02\u{281}\u{282}\x03\
	\x02\x02\x02\u{282}\u{283}\x07\u{a8}\x02\x02\u{283}\u{287}\x07\u{175}\x02\
	\x02\u{284}\u{285}\x07\u{ab}\x02\x02\u{285}\u{286}\x07\u{100}\x02\x02\u{286}\
	\u{288}\x07\u{83}\x02\x02\u{287}\u{284}\x03\x02\x02\x02\u{287}\u{288}\x03\
	\x02\x02\x02\u{288}\u{289}\x03\x02\x02\x02\u{289}\u{28a}\x05\u{154}\u{ab}\
	\x02\u{28a}\u{28b}\x07\x3c\x02\x02\u{28b}\u{29b}\x05\u{154}\u{ab}\x02\u{28c}\
	\u{28d}\x09\x05\x02\x02\u{28d}\u{297}\x07\u{1bc}\x02\x02\u{28e}\u{28f}\x07\
	\u{182}\x02\x02\u{28f}\u{290}\x07\x03\x02\x02\u{290}\u{298}\x05\u{f8}\x7d\
	\x02\u{291}\u{292}\x07\u{106}\x02\x02\u{292}\u{293}\x07\x03\x02\x02\u{293}\
	\u{298}\x05\u{f8}\x7d\x02\u{294}\u{295}\x07\u{16b}\x02\x02\u{295}\u{296}\
	\x07\x03\x02\x02\u{296}\u{298}\x05\u{f8}\x7d\x02\u{297}\u{28e}\x03\x02\x02\
	\x02\u{297}\u{291}\x03\x02\x02\x02\u{297}\u{294}\x03\x02\x02\x02\u{298}\
	\u{299}\x03\x02\x02\x02\u{299}\u{29a}\x07\u{1bd}\x02\x02\u{29a}\u{29c}\x03\
	\x02\x02\x02\u{29b}\u{28c}\x03\x02\x02\x02\u{29b}\u{29c}\x03\x02\x02\x02\
	\u{29c}\u{29f}\x03\x02\x02\x02\u{29d}\u{29e}\x07\x4e\x02\x02\u{29e}\u{2a0}\
	\x07\u{9f}\x02\x02\u{29f}\u{29d}\x03\x02\x02\x02\u{29f}\u{2a0}\x03\x02\x02\
	\x02\u{2a0}\u{8e5}\x03\x02\x02\x02\u{2a1}\u{2a2}\x07\x50\x02\x02\u{2a2}\
	\u{2a3}\x07\u{134}\x02\x02\u{2a3}\u{2a7}\x07\u{175}\x02\x02\u{2a4}\u{2a5}\
	\x07\u{ab}\x02\x02\u{2a5}\u{2a6}\x07\u{100}\x02\x02\u{2a6}\u{2a8}\x07\u{83}\
	\x02\x02\u{2a7}\u{2a4}\x03\x02\x02\x02\u{2a7}\u{2a8}\x03\x02\x02\x02\u{2a8}\
	\u{2a9}\x03\x02\x02\x02\u{2a9}\u{2ab}\x05\u{154}\u{ab}\x02\u{2aa}\u{2ac}\
	\x05\u{e2}\x72\x02\u{2ab}\u{2aa}\x03\x02\x02\x02\u{2ab}\u{2ac}\x03\x02\x02\
	\x02\u{2ac}\u{2af}\x03\x02\x02\x02\u{2ad}\u{2ae}\x07\x43\x02\x02\u{2ae}\
	\u{2b0}\x05\u{122}\u{92}\x02\u{2af}\u{2ad}\x03\x02\x02\x02\u{2af}\u{2b0}\
	\x03\x02\x02\x02\u{2b0}\u{2b3}\x03\x02\x02\x02\u{2b1}\u{2b2}\x07\u{1b1}\
	\x02\x02\u{2b2}\u{2b4}\x05\x46\x24\x02\u{2b3}\u{2b1}\x03\x02\x02\x02\u{2b3}\
	\u{2b4}\x03\x02\x02\x02\u{2b4}\u{2b5}\x03\x02\x02\x02\u{2b5}\u{2bb}\x07\
	\x1e\x02\x02\u{2b6}\u{2bc}\x05\x2a\x16\x02\u{2b7}\u{2b8}\x07\u{1bc}\x02\
	\x02\u{2b8}\u{2b9}\x05\x2a\x16\x02\u{2b9}\u{2ba}\x07\u{1bd}\x02\x02\u{2ba}\
	\u{2bc}\x03\x02\x02\x02\u{2bb}\u{2b6}\x03\x02\x02\x02\u{2bb}\u{2b7}\x03\
	\x02\x02\x02\u{2bc}\u{8e5}\x03\x02\x02\x02\u{2bd}\u{2c0}\x07\x50\x02\x02\
	\u{2be}\u{2bf}\x07\u{10d}\x02\x02\u{2bf}\u{2c1}\x07\u{13c}\x02\x02\u{2c0}\
	\u{2be}\x03\x02\x02\x02\u{2c0}\u{2c1}\x03\x02\x02\x02\u{2c1}\u{2c6}\x03\
	\x02\x02\x02\u{2c2}\u{2c4}\x09\x03\x02\x02\u{2c3}\u{2c2}\x03\x02\x02\x02\
	\u{2c3}\u{2c4}\x03\x02\x02\x02\u{2c4}\u{2c5}\x03\x02\x02\x02\u{2c5}\u{2c7}\
	\x09\x04\x02\x02\u{2c6}\u{2c3}\x03\x02\x02\x02\u{2c6}\u{2c7}\x03\x02\x02\
	\x02\u{2c7}\u{2c8}\x03\x02\x02\x02\u{2c8}\u{2cc}\x07\u{175}\x02\x02\u{2c9}\
	\u{2ca}\x07\u{ab}\x02\x02\u{2ca}\u{2cb}\x07\u{100}\x02\x02\u{2cb}\u{2cd}\
	\x07\u{83}\x02\x02\u{2cc}\u{2c9}\x03\x02\x02\x02\u{2cc}\u{2cd}\x03\x02\x02\
	\x02\u{2cd}\u{2ce}\x03\x02\x02\x02\u{2ce}\u{2d2}\x05\u{154}\u{ab}\x02\u{2cf}\
	\u{2d0}\x07\u{ab}\x02\x02\u{2d0}\u{2d1}\x07\u{100}\x02\x02\u{2d1}\u{2d3}\
	\x07\u{83}\x02\x02\u{2d2}\u{2cf}\x03\x02\x02\x02\u{2d2}\u{2d3}\x03\x02\x02\
	\x02\u{2d3}\u{2d4}\x03\x02\x02\x02\u{2d4}\u{2d5}\x05\x12\x0a\x02\u{2d5}\
	\u{2d6}\x07\u{1bc}\x02\x02\u{2d6}\u{2d7}\x05\x0e\x08\x02\u{2d7}\u{2d8}\x07\
	\u{1bd}\x02\x02\u{2d8}\u{2d9}\x05\x12\x0a\x02\u{2d9}\u{8e5}\x03\x02\x02\
	\x02\u{2da}\u{2dd}\x07\x50\x02\x02\u{2db}\u{2dc}\x07\u{10d}\x02\x02\u{2dc}\
	\u{2de}\x07\u{13c}\x02\x02\u{2dd}\u{2db}\x03\x02\x02\x02\u{2dd}\u{2de}\x03\
	\x02\x02\x02\u{2de}\u{2df}\x03\x02\x02\x02\u{2df}\u{2e0}\x07\u{175}\x02\
	\x02\u{2e0}\u{2e1}\x05\u{154}\u{ab}\x02\u{2e1}\u{2e2}\x07\u{19f}\x02\x02\
	\u{2e2}\u{2e3}\x07\u{17a}\x02\x02\u{2e3}\u{2e4}\x07\u{1bc}\x02\x02\u{2e4}\
	\u{2e5}\x05\x2a\x16\x02\u{2e5}\u{2e6}\x07\u{1bd}\x02\x02\u{2e6}\u{8e5}\x03\
	\x02\x02\x02\u{2e7}\u{2e8}\x07\u{ba}\x02\x02\u{2e8}\u{2e9}\x07\u{bd}\x02\
	\x02\u{2e9}\u{2eb}\x05\u{154}\u{ab}\x02\u{2ea}\u{2ec}\x05\u{e2}\x72\x02\
	\u{2eb}\u{2ea}\x03\x02\x02\x02\u{2eb}\u{2ec}\x03\x02\x02\x02\u{2ec}\u{2fa}\
	\x03\x02\x02\x02\u{2ed}\u{2fb}\x05\x2a\x16\x02\u{2ee}\u{2ef}\x07\u{1a6}\
	\x02\x02\u{2ef}\u{2f4}\x05\x18\x0d\x02\u{2f0}\u{2f1}\x07\x42\x02\x02\u{2f1}\
	\u{2f3}\x05\x18\x0d\x02\u{2f2}\u{2f0}\x03\x02\x02\x02\u{2f3}\u{2f6}\x03\
	\x02\x02\x02\u{2f4}\u{2f2}\x03\x02\x02\x02\u{2f4}\u{2f5}\x03\x02\x02\x02\
	\u{2f5}\u{2f8}\x03\x02\x02\x02\u{2f6}\u{2f4}\x03\x02\x02\x02\u{2f7}\u{2f9}\
	\x07\x42\x02\x02\u{2f8}\u{2f7}\x03\x02\x02\x02\u{2f8}\u{2f9}\x03\x02\x02\
	\x02\u{2f9}\u{2fb}\x03\x02\x02\x02\u{2fa}\u{2ed}\x03\x02\x02\x02\u{2fa}\
	\u{2ee}\x03\x02\x02\x02\u{2fb}\u{8e5}\x03\x02\x02\x02\u{2fc}\u{2ff}\x07\
	\x50\x02\x02\u{2fd}\u{2fe}\x07\u{10d}\x02\x02\u{2fe}\u{300}\x07\u{13c}\x02\
	\x02\u{2ff}\u{2fd}\x03\x02\x02\x02\u{2ff}\u{300}\x03\x02\x02\x02\u{300}\
	\u{302}\x03\x02\x02\x02\u{301}\u{303}\x07\u{155}\x02\x02\u{302}\u{301}\x03\
	\x02\x02\x02\u{302}\u{303}\x03\x02\x02\x02\u{303}\u{304}\x03\x02\x02\x02\
	\u{304}\u{305}\x07\u{e8}\x02\x02\u{305}\u{309}\x07\u{1ab}\x02\x02\u{306}\
	\u{307}\x07\u{ab}\x02\x02\u{307}\u{308}\x07\u{100}\x02\x02\u{308}\u{30a}\
	\x07\u{83}\x02\x02\u{309}\u{306}\x03\x02\x02\x02\u{309}\u{30a}\x03\x02\x02\
	\x02\u{30a}\u{30b}\x03\x02\x02\x02\u{30b}\u{30f}\x05\u{154}\u{ab}\x02\u{30c}\
	\u{30d}\x07\u{ab}\x02\x02\u{30d}\u{30e}\x07\u{100}\x02\x02\u{30e}\u{310}\
	\x07\u{83}\x02\x02\u{30f}\u{30c}\x03\x02\x02\x02\u{30f}\u{310}\x03\x02\x02\
	\x02\u{310}\u{313}\x03\x02\x02\x02\u{311}\u{312}\x07\x4e\x02\x02\u{312}\
	\u{314}\x07\u{9d}\x02\x02\u{313}\u{311}\x03\x02\x02\x02\u{313}\u{314}\x03\
	\x02\x02\x02\u{314}\u{323}\x03\x02\x02\x02\u{315}\u{316}\x07\u{1bc}\x02\
	\x02\u{316}\u{31b}\x05\x34\x1b\x02\u{317}\u{318}\x07\x42\x02\x02\u{318}\
	\u{31a}\x05\x34\x1b\x02\u{319}\u{317}\x03\x02\x02\x02\u{31a}\u{31d}\x03\
	\x02\x02\x02\u{31b}\u{319}\x03\x02\x02\x02\u{31b}\u{31c}\x03\x02\x02\x02\
	\u{31c}\u{31f}\x03\x02\x02\x02\u{31d}\u{31b}\x03\x02\x02\x02\u{31e}\u{320}\
	\x07\x42\x02\x02\u{31f}\u{31e}\x03\x02\x02\x02\u{31f}\u{320}\x03\x02\x02\
	\x02\u{320}\u{321}\x03\x02\x02\x02\u{321}\u{322}\x07\u{1bd}\x02\x02\u{322}\
	\u{324}\x03\x02\x02\x02\u{323}\u{315}\x03\x02\x02\x02\u{323}\u{324}\x03\
	\x02\x02\x02\u{324}\u{328}\x03\x02\x02\x02\u{325}\u{326}\x07\x43\x02\x02\
	\u{326}\u{327}\x07\u{1c1}\x02\x02\u{327}\u{329}\x05\u{122}\u{92}\x02\u{328}\
	\u{325}\x03\x02\x02\x02\u{328}\u{329}\x03\x02\x02\x02\u{329}\u{33d}\x03\
	\x02\x02\x02\u{32a}\u{32c}\x07\u{1b1}\x02\x02\u{32b}\u{32a}\x03\x02\x02\
	\x02\u{32b}\u{32c}\x03\x02\x02\x02\u{32c}\u{32d}\x03\x02\x02\x02\u{32d}\
	\u{32e}\x07\u{14c}\x02\x02\u{32e}\u{32f}\x07\x10\x02\x02\u{32f}\u{330}\x07\
	\u{124}\x02\x02\u{330}\u{331}\x05\u{164}\u{b3}\x02\u{331}\u{332}\x07\u{108}\
	\x02\x02\u{332}\u{333}\x07\u{1bc}\x02\x02\u{333}\u{338}\x05\u{164}\u{b3}\
	\x02\u{334}\u{335}\x07\x42\x02\x02\u{335}\u{337}\x05\u{164}\u{b3}\x02\u{336}\
	\u{334}\x03\x02\x02\x02\u{337}\u{33a}\x03\x02\x02\x02\u{338}\u{336}\x03\
	\x02\x02\x02\u{338}\u{339}\x03\x02\x02\x02\u{339}\u{33b}\x03\x02\x02\x02\
	\u{33a}\u{338}\x03\x02\x02\x02\u{33b}\u{33c}\x07\u{1bd}\x02\x02\u{33c}\u{33e}\
	\x03\x02\x02\x02\u{33d}\u{32b}\x03\x02\x02\x02\u{33d}\u{33e}\x03\x02\x02\
	\x02\u{33e}\u{344}\x03\x02\x02\x02\u{33f}\u{341}\x07\u{1b1}\x02\x02\u{340}\
	\u{33f}\x03\x02\x02\x02\u{340}\u{341}\x03\x02\x02\x02\u{341}\u{342}\x03\
	\x02\x02\x02\u{342}\u{343}\x07\u{178}\x02\x02\u{343}\u{345}\x05\x46\x24\
	\x02\u{344}\u{340}\x03\x02\x02\x02\u{344}\u{345}\x03\x02\x02\x02\u{345}\
	\u{353}\x03\x02\x02\x02\u{346}\u{347}\x07\x3e\x02\x02\u{347}\u{348}\x07\
	\x2d\x02\x02\u{348}\u{349}\x07\u{1bc}\x02\x02\u{349}\u{34e}\x05\u{f8}\x7d\
	\x02\u{34a}\u{34b}\x07\x42\x02\x02\u{34b}\u{34d}\x05\u{f8}\x7d\x02\u{34c}\
	\u{34a}\x03\x02\x02\x02\u{34d}\u{350}\x03\x02\x02\x02\u{34e}\u{34c}\x03\
	\x02\x02\x02\u{34e}\u{34f}\x03\x02\x02\x02\u{34f}\u{351}\x03\x02\x02\x02\
	\u{350}\u{34e}\x03\x02\x02\x02\u{351}\u{352}\x07\u{1bd}\x02\x02\u{352}\u{354}\
	\x03\x02\x02\x02\u{353}\u{346}\x03\x02\x02\x02\u{353}\u{354}\x03\x02\x02\
	\x02\u{354}\u{355}\x03\x02\x02\x02\u{355}\u{356}\x07\x1e\x02\x02\u{356}\
	\u{357}\x07\u{1bc}\x02\x02\u{357}\u{358}\x05\x2a\x16\x02\u{358}\u{359}\x07\
	\u{1bd}\x02\x02\u{359}\u{8e5}\x03\x02\x02\x02\u{35a}\u{35d}\x07\x50\x02\
	\x02\u{35b}\u{35c}\x07\u{10d}\x02\x02\u{35c}\u{35e}\x07\u{13c}\x02\x02\u{35d}\
	\u{35b}\x03\x02\x02\x02\u{35d}\u{35e}\x03\x02\x02\x02\u{35e}\u{360}\x03\
	\x02\x02\x02\u{35f}\u{361}\x07\u{155}\x02\x02\u{360}\u{35f}\x03\x02\x02\
	\x02\u{360}\u{361}\x03\x02\x02\x02\u{361}\u{366}\x03\x02\x02\x02\u{362}\
	\u{364}\x09\x03\x02\x02\u{363}\u{362}\x03\x02\x02\x02\u{363}\u{364}\x03\
	\x02\x02\x02\u{364}\u{365}\x03\x02\x02\x02\u{365}\u{367}\x09\x06\x02\x02\
	\u{366}\u{363}\x03\x02\x02\x02\u{366}\u{367}\x03\x02\x02\x02\u{367}\u{369}\
	\x03\x02\x02\x02\u{368}\u{36a}\x07\u{134}\x02\x02\u{369}\u{368}\x03\x02\
	\x02\x02\u{369}\u{36a}\x03\x02\x02\x02\u{36a}\u{36b}\x03\x02\x02\x02\u{36b}\
	\u{36f}\x07\u{1ab}\x02\x02\u{36c}\u{36d}\x07\u{ab}\x02\x02\u{36d}\u{36e}\
	\x07\u{100}\x02\x02\u{36e}\u{370}\x07\u{83}\x02\x02\u{36f}\u{36c}\x03\x02\
	\x02\x02\u{36f}\u{370}\x03\x02\x02\x02\u{370}\u{371}\x03\x02\x02\x02\u{371}\
	\u{375}\x05\u{154}\u{ab}\x02\u{372}\u{373}\x07\u{ab}\x02\x02\u{373}\u{374}\
	\x07\u{100}\x02\x02\u{374}\u{376}\x07\u{83}\x02\x02\u{375}\u{372}\x03\x02\
	\x02\x02\u{375}\u{376}\x03\x02\x02\x02\u{376}\u{385}\x03\x02\x02\x02\u{377}\
	\u{378}\x07\u{1bc}\x02\x02\u{378}\u{37d}\x05\x34\x1b\x02\u{379}\u{37a}\x07\
	\x42\x02\x02\u{37a}\u{37c}\x05\x34\x1b\x02\u{37b}\u{379}\x03\x02\x02\x02\
	\u{37c}\u{37f}\x03\x02\x02\x02\u{37d}\u{37b}\x03\x02\x02\x02\u{37d}\u{37e}\
	\x03\x02\x02\x02\u{37e}\u{381}\x03\x02\x02\x02\u{37f}\u{37d}\x03\x02\x02\
	\x02\u{380}\u{382}\x07\x42\x02\x02\u{381}\u{380}\x03\x02\x02\x02\u{381}\
	\u{382}\x03\x02\x02\x02\u{382}\u{383}\x03\x02\x02\x02\u{383}\u{384}\x07\
	\u{1bd}\x02\x02\u{384}\u{386}\x03\x02\x02\x02\u{385}\u{377}\x03\x02\x02\
	\x02\u{385}\u{386}\x03\x02\x02\x02\u{386}\u{39a}\x03\x02\x02\x02\u{387}\
	\u{389}\x07\u{1b1}\x02\x02\u{388}\u{387}\x03\x02\x02\x02\u{388}\u{389}\x03\
	\x02\x02\x02\u{389}\u{38a}\x03\x02\x02\x02\u{38a}\u{38b}\x07\u{14c}\x02\
	\x02\u{38b}\u{38c}\x07\x10\x02\x02\u{38c}\u{38d}\x07\u{124}\x02\x02\u{38d}\
	\u{38e}\x05\u{164}\u{b3}\x02\u{38e}\u{38f}\x07\u{108}\x02\x02\u{38f}\u{390}\
	\x07\u{1bc}\x02\x02\u{390}\u{395}\x05\u{164}\u{b3}\x02\u{391}\u{392}\x07\
	\x42\x02\x02\u{392}\u{394}\x05\u{164}\u{b3}\x02\u{393}\u{391}\x03\x02\x02\
	\x02\u{394}\u{397}\x03\x02\x02\x02\u{395}\u{393}\x03\x02\x02\x02\u{395}\
	\u{396}\x03\x02\x02\x02\u{396}\u{398}\x03\x02\x02\x02\u{397}\u{395}\x03\
	\x02\x02\x02\u{398}\u{399}\x07\u{1bd}\x02\x02\u{399}\u{39b}\x03\x02\x02\
	\x02\u{39a}\u{388}\x03\x02\x02\x02\u{39a}\u{39b}\x03\x02\x02\x02\u{39b}\
	\u{3a1}\x03\x02\x02\x02\u{39c}\u{39e}\x07\u{1b1}\x02\x02\u{39d}\u{39c}\x03\
	\x02\x02\x02\u{39d}\u{39e}\x03\x02\x02\x02\u{39e}\u{39f}\x03\x02\x02\x02\
	\u{39f}\u{3a0}\x07\u{178}\x02\x02\u{3a0}\u{3a2}\x05\x46\x24\x02\u{3a1}\u{39d}\
	\x03\x02\x02\x02\u{3a1}\u{3a2}\x03\x02\x02\x02\u{3a2}\u{3a5}\x03\x02\x02\
	\x02\u{3a3}\u{3a4}\x07\x4e\x02\x02\u{3a4}\u{3a6}\x07\u{9d}\x02\x02\u{3a5}\
	\u{3a3}\x03\x02\x02\x02\u{3a5}\u{3a6}\x03\x02\x02\x02\u{3a6}\u{3aa}\x03\
	\x02\x02\x02\u{3a7}\u{3a8}\x07\x43\x02\x02\u{3a8}\u{3a9}\x07\u{1c1}\x02\
	\x02\u{3a9}\u{3ab}\x05\u{122}\u{92}\x02\u{3aa}\u{3a7}\x03\x02\x02\x02\u{3aa}\
	\u{3ab}\x03\x02\x02\x02\u{3ab}\u{3ac}\x03\x02\x02\x02\u{3ac}\u{3b2}\x07\
	\x1e\x02\x02\u{3ad}\u{3ae}\x07\u{1bc}\x02\x02\u{3ae}\u{3af}\x05\x2a\x16\
	\x02\u{3af}\u{3b0}\x07\u{1bd}\x02\x02\u{3b0}\u{3b3}\x03\x02\x02\x02\u{3b1}\
	\u{3b3}\x05\x2a\x16\x02\u{3b2}\u{3ad}\x03\x02\x02\x02\u{3b2}\u{3b1}\x03\
	\x02\x02\x02\u{3b3}\u{8e5}\x03\x02\x02\x02\u{3b4}\u{3b5}\x07\u{160}\x02\
	\x02\u{3b5}\u{8e5}\x05\x4a\x26\x02\u{3b6}\u{3b7}\x07\u{160}\x02\x02\u{3b7}\
	\u{3b8}\x07\u{1bc}\x02\x02\u{3b8}\u{3bd}\x05\u{164}\u{b3}\x02\u{3b9}\u{3ba}\
	\x07\x42\x02\x02\u{3ba}\u{3bc}\x05\u{164}\u{b3}\x02\u{3bb}\u{3b9}\x03\x02\
	\x02\x02\u{3bc}\u{3bf}\x03\x02\x02\x02\u{3bd}\u{3bb}\x03\x02\x02\x02\u{3bd}\
	\u{3be}\x03\x02\x02\x02\u{3be}\u{3c0}\x03\x02\x02\x02\u{3bf}\u{3bd}\x03\
	\x02\x02\x02\u{3c0}\u{3c1}\x07\u{1bd}\x02\x02\u{3c1}\u{3c2}\x07\u{1c1}\x02\
	\x02\u{3c2}\u{3c3}\x07\u{1bc}\x02\x02\u{3c3}\u{3c8}\x05\u{f8}\x7d\x02\u{3c4}\
	\u{3c5}\x07\x42\x02\x02\u{3c5}\u{3c7}\x05\u{f8}\x7d\x02\u{3c6}\u{3c4}\x03\
	\x02\x02\x02\u{3c7}\u{3ca}\x03\x02\x02\x02\u{3c8}\u{3c6}\x03\x02\x02\x02\
	\u{3c8}\u{3c9}\x03\x02\x02\x02\u{3c9}\u{3cb}\x03\x02\x02\x02\u{3ca}\u{3c8}\
	\x03\x02\x02\x02\u{3cb}\u{3cc}\x07\u{1bd}\x02\x02\u{3cc}\u{8e5}\x03\x02\
	\x02\x02\u{3cd}\u{3ce}\x09\x07\x02\x02\u{3ce}\u{3cf}\x07\u{175}\x02\x02\
	\u{3cf}\u{8e5}\x05\u{154}\u{ab}\x02\u{3d0}\u{3d3}\x07\x50\x02\x02\u{3d1}\
	\u{3d2}\x07\u{10d}\x02\x02\u{3d2}\u{3d4}\x07\u{13c}\x02\x02\u{3d3}\u{3d1}\
	\x03\x02\x02\x02\u{3d3}\u{3d4}\x03\x02\x02\x02\u{3d4}\u{3d6}\x03\x02\x02\
	\x02\u{3d5}\u{3d7}\x09\x08\x02\x02\u{3d6}\u{3d5}\x03\x02\x02\x02\u{3d6}\
	\u{3d7}\x03\x02\x02\x02\u{3d7}\u{3d8}\x03\x02\x02\x02\u{3d8}\u{3dc}\x07\
	\u{169}\x02\x02\u{3d9}\u{3da}\x07\u{ab}\x02\x02\u{3da}\u{3db}\x07\u{100}\
	\x02\x02\u{3db}\u{3dd}\x07\u{83}\x02\x02\u{3dc}\u{3d9}\x03\x02\x02\x02\u{3dc}\
	\u{3dd}\x03\x02\x02\x02\u{3dd}\u{3de}\x03\x02\x02\x02\u{3de}\u{3e2}\x05\
	\u{154}\u{ab}\x02\u{3df}\u{3e0}\x07\u{ab}\x02\x02\u{3e0}\u{3e1}\x07\u{100}\
	\x02\x02\u{3e1}\u{3e3}\x07\u{83}\x02\x02\u{3e2}\u{3df}\x03\x02\x02\x02\u{3e2}\
	\u{3e3}\x03\x02\x02\x02\u{3e3}\u{3e7}\x03\x02\x02\x02\u{3e4}\u{3e6}\x05\
	\x4a\x26\x02\u{3e5}\u{3e4}\x03\x02\x02\x02\u{3e6}\u{3e9}\x03\x02\x02\x02\
	\u{3e7}\u{3e5}\x03\x02\x02\x02\u{3e7}\u{3e8}\x03\x02\x02\x02\u{3e8}\u{3ef}\
	\x03\x02\x02\x02\u{3e9}\u{3e7}\x03\x02\x02\x02\u{3ea}\u{3ec}\x07\u{1b1}\
	\x02\x02\u{3eb}\u{3ea}\x03\x02\x02\x02\u{3eb}\u{3ec}\x03\x02\x02\x02\u{3ec}\
	\u{3ed}\x03\x02\x02\x02\u{3ed}\u{3ee}\x07\u{178}\x02\x02\u{3ee}\u{3f0}\x05\
	\x46\x24\x02\u{3ef}\u{3eb}\x03\x02\x02\x02\u{3ef}\u{3f0}\x03\x02\x02\x02\
	\u{3f0}\u{8e5}\x03\x02\x02\x02\u{3f1}\u{3f4}\x07\x50\x02\x02\u{3f2}\u{3f3}\
	\x07\u{10d}\x02\x02\u{3f3}\u{3f5}\x07\u{13c}\x02\x02\u{3f4}\u{3f2}\x03\x02\
	\x02\x02\u{3f4}\u{3f5}\x03\x02\x02\x02\u{3f5}\u{3f7}\x03\x02\x02\x02\u{3f6}\
	\u{3f8}\x09\x08\x02\x02\u{3f7}\u{3f6}\x03\x02\x02\x02\u{3f7}\u{3f8}\x03\
	\x02\x02\x02\u{3f8}\u{3fa}\x03\x02\x02\x02\u{3f9}\u{3fb}\x07\u{155}\x02\
	\x02\u{3fa}\u{3f9}\x03\x02\x02\x02\u{3fa}\u{3fb}\x03\x02\x02\x02\u{3fb}\
	\u{3fc}\x03\x02\x02\x02\u{3fc}\u{400}\x07\u{98}\x02\x02\u{3fd}\u{3fe}\x07\
	\u{ab}\x02\x02\u{3fe}\u{3ff}\x07\u{100}\x02\x02\u{3ff}\u{401}\x07\u{83}\
	\x02\x02\u{400}\u{3fd}\x03\x02\x02\x02\u{400}\u{401}\x03\x02\x02\x02\u{401}\
	\u{402}\x03\x02\x02\x02\u{402}\u{406}\x05\u{154}\u{ab}\x02\u{403}\u{404}\
	\x07\u{ab}\x02\x02\u{404}\u{405}\x07\u{100}\x02\x02\u{405}\u{407}\x07\u{83}\
	\x02\x02\u{406}\u{403}\x03\x02\x02\x02\u{406}\u{407}\x03\x02\x02\x02\u{407}\
	\u{408}\x03\x02\x02\x02\u{408}\u{414}\x07\u{1bc}\x02\x02\u{409}\u{40e}\x05\
	\u{118}\u{8d}\x02\u{40a}\u{40b}\x07\x42\x02\x02\u{40b}\u{40d}\x05\u{118}\
	\u{8d}\x02\u{40c}\u{40a}\x03\x02\x02\x02\u{40d}\u{410}\x03\x02\x02\x02\u{40e}\
	\u{40c}\x03\x02\x02\x02\u{40e}\u{40f}\x03\x02\x02\x02\u{40f}\u{412}\x03\
	\x02\x02\x02\u{410}\u{40e}\x03\x02\x02\x02\u{411}\u{413}\x07\x42\x02\x02\
	\u{412}\u{411}\x03\x02\x02\x02\u{412}\u{413}\x03\x02\x02\x02\u{413}\u{415}\
	\x03\x02\x02\x02\u{414}\u{409}\x03\x02\x02\x02\u{414}\u{415}\x03\x02\x02\
	\x02\u{415}\u{416}\x03\x02\x02\x02\u{416}\u{419}\x07\u{1bd}\x02\x02\u{417}\
	\u{418}\x07\x4e\x02\x02\u{418}\u{41a}\x07\u{9f}\x02\x02\u{419}\u{417}\x03\
	\x02\x02\x02\u{419}\u{41a}\x03\x02\x02\x02\u{41a}\u{41b}\x03\x02\x02\x02\
	\u{41b}\u{42f}\x07\u{143}\x02\x02\u{41c}\u{430}\x05\u{134}\u{9b}\x02\u{41d}\
	\u{41e}\x07\u{175}\x02\x02\u{41e}\u{41f}\x07\u{1bc}\x02\x02\u{41f}\u{420}\
	\x05\u{164}\u{b3}\x02\u{420}\u{427}\x05\u{134}\u{9b}\x02\u{421}\u{422}\x07\
	\x42\x02\x02\u{422}\u{423}\x05\u{164}\u{b3}\x02\u{423}\u{424}\x05\u{134}\
	\u{9b}\x02\u{424}\u{426}\x03\x02\x02\x02\u{425}\u{421}\x03\x02\x02\x02\u{426}\
	\u{429}\x03\x02\x02\x02\u{427}\u{425}\x03\x02\x02\x02\u{427}\u{428}\x03\
	\x02\x02\x02\u{428}\u{42b}\x03\x02\x02\x02\u{429}\u{427}\x03\x02\x02\x02\
	\u{42a}\u{42c}\x07\x42\x02\x02\u{42b}\u{42a}\x03\x02\x02\x02\u{42b}\u{42c}\
	\x03\x02\x02\x02\u{42c}\u{42d}\x03\x02\x02\x02\u{42d}\u{42e}\x07\u{1bd}\
	\x02\x02\u{42e}\u{430}\x03\x02\x02\x02\u{42f}\u{41c}\x03\x02\x02\x02\u{42f}\
	\u{41d}\x03\x02\x02\x02\u{430}\u{435}\x03\x02\x02\x02\u{431}\u{433}\x07\
	\u{100}\x02\x02\u{432}\u{431}\x03\x02\x02\x02\u{432}\u{433}\x03\x02\x02\
	\x02\u{433}\u{434}\x03\x02\x02\x02\u{434}\u{436}\x07\u{102}\x02\x02\u{435}\
	\u{432}\x03\x02\x02\x02\u{435}\u{436}\x03\x02\x02\x02\u{436}\u{437}\x03\
	\x02\x02\x02\u{437}\u{438}\x07\u{d1}\x02\x02\u{438}\u{443}\x07\u{c3}\x02\
	\x02\u{439}\u{43a}\x07\x30\x02\x02\u{43a}\u{43b}\x07\u{108}\x02\x02\u{43b}\
	\u{43c}\x07\u{102}\x02\x02\u{43c}\u{444}\x07\u{b7}\x02\x02\u{43d}\u{43e}\
	\x07\u{141}\x02\x02\u{43e}\u{43f}\x07\u{102}\x02\x02\u{43f}\u{440}\x07\u{108}\
	\x02\x02\u{440}\u{441}\x07\u{102}\x02\x02\u{441}\u{444}\x07\u{b7}\x02\x02\
	\u{442}\u{444}\x07\u{16f}\x02\x02\u{443}\u{439}\x03\x02\x02\x02\u{443}\u{43d}\
	\x03\x02\x02\x02\u{443}\u{442}\x03\x02\x02\x02\u{443}\u{444}\x03\x02\x02\
	\x02\u{444}\u{446}\x03\x02\x02\x02\u{445}\u{447}\x09\x09\x02\x02\u{446}\
	\u{445}\x03\x02\x02\x02\u{446}\u{447}\x03\x02\x02\x02\u{447}\u{44b}\x03\
	\x02\x02\x02\u{448}\u{44a}\x05\x4a\x26\x02\u{449}\u{448}\x03\x02\x02\x02\
	\u{44a}\u{44d}\x03\x02\x02\x02\u{44b}\u{449}\x03\x02\x02\x02\u{44b}\u{44c}\
	\x03\x02\x02\x02\u{44c}\u{44e}\x03\x02\x02\x02\u{44d}\u{44b}\x03\x02\x02\
	\x02\u{44e}\u{44f}\x07\x1e\x02\x02\u{44f}\u{450}\x05\u{f8}\x7d\x02\u{450}\
	\u{8e5}\x03\x02\x02\x02\u{451}\u{454}\x07\x50\x02\x02\u{452}\u{453}\x07\
	\u{10d}\x02\x02\u{453}\u{455}\x07\u{13c}\x02\x02\u{454}\u{452}\x03\x02\x02\
	\x02\u{454}\u{455}\x03\x02\x02\x02\u{455}\u{457}\x03\x02\x02\x02\u{456}\
	\u{458}\x09\x08\x02\x02\u{457}\u{456}\x03\x02\x02\x02\u{457}\u{458}\x03\
	\x02\x02\x02\u{458}\u{45a}\x03\x02\x02\x02\u{459}\u{45b}\x07\u{155}\x02\
	\x02\u{45a}\u{459}\x03\x02\x02\x02\u{45a}\u{45b}\x03\x02\x02\x02\u{45b}\
	\u{45c}\x03\x02\x02\x02\u{45c}\u{460}\x07\u{98}\x02\x02\u{45d}\u{45e}\x07\
	\u{ab}\x02\x02\u{45e}\u{45f}\x07\u{100}\x02\x02\u{45f}\u{461}\x07\u{83}\
	\x02\x02\u{460}\u{45d}\x03\x02\x02\x02\u{460}\u{461}\x03\x02\x02\x02\u{461}\
	\u{462}\x03\x02\x02\x02\u{462}\u{466}\x05\u{154}\u{ab}\x02\u{463}\u{464}\
	\x07\u{ab}\x02\x02\u{464}\u{465}\x07\u{100}\x02\x02\u{465}\u{467}\x07\u{83}\
	\x02\x02\u{466}\u{463}\x03\x02\x02\x02\u{466}\u{467}\x03\x02\x02\x02\u{467}\
	\u{468}\x03\x02\x02\x02\u{468}\u{474}\x07\u{1bc}\x02\x02\u{469}\u{46e}\x05\
	\u{118}\u{8d}\x02\u{46a}\u{46b}\x07\x42\x02\x02\u{46b}\u{46d}\x05\u{118}\
	\u{8d}\x02\u{46c}\u{46a}\x03\x02\x02\x02\u{46d}\u{470}\x03\x02\x02\x02\u{46e}\
	\u{46c}\x03\x02\x02\x02\u{46e}\u{46f}\x03\x02\x02\x02\u{46f}\u{472}\x03\
	\x02\x02\x02\u{470}\u{46e}\x03\x02\x02\x02\u{471}\u{473}\x07\x42\x02\x02\
	\u{472}\u{471}\x03\x02\x02\x02\u{472}\u{473}\x03\x02\x02\x02\u{473}\u{475}\
	\x03\x02\x02\x02\u{474}\u{469}\x03\x02\x02\x02\u{474}\u{475}\x03\x02\x02\
	\x02\u{475}\u{476}\x03\x02\x02\x02\u{476}\u{479}\x07\u{1bd}\x02\x02\u{477}\
	\u{478}\x07\x4e\x02\x02\u{478}\u{47a}\x07\u{9f}\x02\x02\u{479}\u{477}\x03\
	\x02\x02\x02\u{479}\u{47a}\x03\x02\x02\x02\u{47a}\u{47b}\x03\x02\x02\x02\
	\u{47b}\u{48f}\x07\u{143}\x02\x02\u{47c}\u{490}\x05\u{134}\u{9b}\x02\u{47d}\
	\u{47e}\x07\u{175}\x02\x02\u{47e}\u{47f}\x07\u{1bc}\x02\x02\u{47f}\u{480}\
	\x05\u{164}\u{b3}\x02\u{480}\u{487}\x05\u{134}\u{9b}\x02\u{481}\u{482}\x07\
	\x42\x02\x02\u{482}\u{483}\x05\u{164}\u{b3}\x02\u{483}\u{484}\x05\u{134}\
	\u{9b}\x02\u{484}\u{486}\x03\x02\x02\x02\u{485}\u{481}\x03\x02\x02\x02\u{486}\
	\u{489}\x03\x02\x02\x02\u{487}\u{485}\x03\x02\x02\x02\u{487}\u{488}\x03\
	\x02\x02\x02\u{488}\u{48b}\x03\x02\x02\x02\u{489}\u{487}\x03\x02\x02\x02\
	\u{48a}\u{48c}\x07\x42\x02\x02\u{48b}\u{48a}\x03\x02\x02\x02\u{48b}\u{48c}\
	\x03\x02\x02\x02\u{48c}\u{48d}\x03\x02\x02\x02\u{48d}\u{48e}\x07\u{1bd}\
	\x02\x02\u{48e}\u{490}\x03\x02\x02\x02\u{48f}\u{47c}\x03\x02\x02\x02\u{48f}\
	\u{47d}\x03\x02\x02\x02\u{490}\u{495}\x03\x02\x02\x02\u{491}\u{493}\x07\
	\u{100}\x02\x02\u{492}\u{491}\x03\x02\x02\x02\u{492}\u{493}\x03\x02\x02\
	\x02\u{493}\u{494}\x03\x02\x02\x02\u{494}\u{496}\x07\u{102}\x02\x02\u{495}\
	\u{492}\x03\x02\x02\x02\u{495}\u{496}\x03\x02\x02\x02\u{496}\u{497}\x03\
	\x02\x02\x02\u{497}\u{498}\x07\u{d1}\x02\x02\u{498}\u{4a3}\x07\u{c3}\x02\
	\x02\u{499}\u{49a}\x07\x30\x02\x02\u{49a}\u{49b}\x07\u{108}\x02\x02\u{49b}\
	\u{49c}\x07\u{102}\x02\x02\u{49c}\u{4a4}\x07\u{b7}\x02\x02\u{49d}\u{49e}\
	\x07\u{141}\x02\x02\u{49e}\u{49f}\x07\u{102}\x02\x02\u{49f}\u{4a0}\x07\u{108}\
	\x02\x02\u{4a0}\u{4a1}\x07\u{102}\x02\x02\u{4a1}\u{4a4}\x07\u{b7}\x02\x02\
	\u{4a2}\u{4a4}\x07\u{16f}\x02\x02\u{4a3}\u{499}\x03\x02\x02\x02\u{4a3}\u{49d}\
	\x03\x02\x02\x02\u{4a3}\u{4a2}\x03\x02\x02\x02\u{4a3}\u{4a4}\x03\x02\x02\
	\x02\u{4a4}\u{4a6}\x03\x02\x02\x02\u{4a5}\u{4a7}\x09\x09\x02\x02\u{4a6}\
	\u{4a5}\x03\x02\x02\x02\u{4a6}\u{4a7}\x03\x02\x02\x02\u{4a7}\u{4ab}\x03\
	\x02\x02\x02\u{4a8}\u{4aa}\x05\x4a\x26\x02\u{4a9}\u{4a8}\x03\x02\x02\x02\
	\u{4aa}\u{4ad}\x03\x02\x02\x02\u{4ab}\u{4a9}\x03\x02\x02\x02\u{4ab}\u{4ac}\
	\x03\x02\x02\x02\u{4ac}\u{8e5}\x03\x02\x02\x02\u{4ad}\u{4ab}\x03\x02\x02\
	\x02\u{4ae}\u{4b1}\x07\x50\x02\x02\u{4af}\u{4b0}\x07\u{10d}\x02\x02\u{4b0}\
	\u{4b2}\x07\u{13c}\x02\x02\u{4b1}\u{4af}\x03\x02\x02\x02\u{4b1}\u{4b2}\x03\
	\x02\x02\x02\u{4b2}\u{4b4}\x03\x02\x02\x02\u{4b3}\u{4b5}\x09\x08\x02\x02\
	\u{4b4}\u{4b3}\x03\x02\x02\x02\u{4b4}\u{4b5}\x03\x02\x02\x02\u{4b5}\u{4b7}\
	\x03\x02\x02\x02\u{4b6}\u{4b8}\x07\u{155}\x02\x02\u{4b7}\u{4b6}\x03\x02\
	\x02\x02\u{4b7}\u{4b8}\x03\x02\x02\x02\u{4b8}\u{4b9}\x03\x02\x02\x02\u{4b9}\
	\u{4bd}\x07\u{98}\x02\x02\u{4ba}\u{4bb}\x07\u{ab}\x02\x02\u{4bb}\u{4bc}\
	\x07\u{100}\x02\x02\u{4bc}\u{4be}\x07\u{83}\x02\x02\u{4bd}\u{4ba}\x03\x02\
	\x02\x02\u{4bd}\u{4be}\x03\x02\x02\x02\u{4be}\u{4bf}\x03\x02\x02\x02\u{4bf}\
	\u{4c3}\x05\u{154}\u{ab}\x02\u{4c0}\u{4c1}\x07\u{ab}\x02\x02\u{4c1}\u{4c2}\
	\x07\u{100}\x02\x02\u{4c2}\u{4c4}\x07\u{83}\x02\x02\u{4c3}\u{4c0}\x03\x02\
	\x02\x02\u{4c3}\u{4c4}\x03\x02\x02\x02\u{4c4}\u{4c5}\x03\x02\x02\x02\u{4c5}\
	\u{4d1}\x07\u{1bc}\x02\x02\u{4c6}\u{4cb}\x05\u{118}\u{8d}\x02\u{4c7}\u{4c8}\
	\x07\x42\x02\x02\u{4c8}\u{4ca}\x05\u{118}\u{8d}\x02\u{4c9}\u{4c7}\x03\x02\
	\x02\x02\u{4ca}\u{4cd}\x03\x02\x02\x02\u{4cb}\u{4c9}\x03\x02\x02\x02\u{4cb}\
	\u{4cc}\x03\x02\x02\x02\u{4cc}\u{4cf}\x03\x02\x02\x02\u{4cd}\u{4cb}\x03\
	\x02\x02\x02\u{4ce}\u{4d0}\x07\x42\x02\x02\u{4cf}\u{4ce}\x03\x02\x02\x02\
	\u{4cf}\u{4d0}\x03\x02\x02\x02\u{4d0}\u{4d2}\x03\x02\x02\x02\u{4d1}\u{4c6}\
	\x03\x02\x02\x02\u{4d1}\u{4d2}\x03\x02\x02\x02\u{4d2}\u{4d3}\x03\x02\x02\
	\x02\u{4d3}\u{4d6}\x07\u{1bd}\x02\x02\u{4d4}\u{4d5}\x07\x4e\x02\x02\u{4d5}\
	\u{4d7}\x07\u{9f}\x02\x02\u{4d6}\u{4d4}\x03\x02\x02\x02\u{4d6}\u{4d7}\x03\
	\x02\x02\x02\u{4d7}\u{4d8}\x03\x02\x02\x02\u{4d8}\u{4ec}\x07\u{143}\x02\
	\x02\u{4d9}\u{4ed}\x05\u{134}\u{9b}\x02\u{4da}\u{4db}\x07\u{175}\x02\x02\
	\u{4db}\u{4dc}\x07\u{1bc}\x02\x02\u{4dc}\u{4dd}\x05\u{164}\u{b3}\x02\u{4dd}\
	\u{4e4}\x05\u{134}\u{9b}\x02\u{4de}\u{4df}\x07\x42\x02\x02\u{4df}\u{4e0}\
	\x05\u{164}\u{b3}\x02\u{4e0}\u{4e1}\x05\u{134}\u{9b}\x02\u{4e1}\u{4e3}\x03\
	\x02\x02\x02\u{4e2}\u{4de}\x03\x02\x02\x02\u{4e3}\u{4e6}\x03\x02\x02\x02\
	\u{4e4}\u{4e2}\x03\x02\x02\x02\u{4e4}\u{4e5}\x03\x02\x02\x02\u{4e5}\u{4e8}\
	\x03\x02\x02\x02\u{4e6}\u{4e4}\x03\x02\x02\x02\u{4e7}\u{4e9}\x07\x42\x02\
	\x02\u{4e8}\u{4e7}\x03\x02\x02\x02\u{4e8}\u{4e9}\x03\x02\x02\x02\u{4e9}\
	\u{4ea}\x03\x02\x02\x02\u{4ea}\u{4eb}\x07\u{1bd}\x02\x02\u{4eb}\u{4ed}\x03\
	\x02\x02\x02\u{4ec}\u{4d9}\x03\x02\x02\x02\u{4ec}\u{4da}\x03\x02\x02\x02\
	\u{4ed}\u{4f2}\x03\x02\x02\x02\u{4ee}\u{4f0}\x07\u{100}\x02\x02\u{4ef}\u{4ee}\
	\x03\x02\x02\x02\u{4ef}\u{4f0}\x03\x02\x02\x02\u{4f0}\u{4f1}\x03\x02\x02\
	\x02\u{4f1}\u{4f3}\x07\u{102}\x02\x02\u{4f2}\u{4ef}\x03\x02\x02\x02\u{4f2}\
	\u{4f3}\x03\x02\x02\x02\u{4f3}\u{4f4}\x03\x02\x02\x02\u{4f4}\u{4f5}\x07\
	\u{d1}\x02\x02\u{4f5}\u{500}\x07\u{c4}\x02\x02\u{4f6}\u{4f7}\x07\x30\x02\
	\x02\u{4f7}\u{4f8}\x07\u{108}\x02\x02\u{4f8}\u{4f9}\x07\u{102}\x02\x02\u{4f9}\
	\u{501}\x07\u{b7}\x02\x02\u{4fa}\u{4fb}\x07\u{141}\x02\x02\u{4fb}\u{4fc}\
	\x07\u{102}\x02\x02\u{4fc}\u{4fd}\x07\u{108}\x02\x02\u{4fd}\u{4fe}\x07\u{102}\
	\x02\x02\u{4fe}\u{501}\x07\u{b7}\x02\x02\u{4ff}\u{501}\x07\u{16f}\x02\x02\
	\u{500}\u{4f6}\x03\x02\x02\x02\u{500}\u{4fa}\x03\x02\x02\x02\u{500}\u{4ff}\
	\x03\x02\x02\x02\u{500}\u{501}\x03\x02\x02\x02\u{501}\u{503}\x03\x02\x02\
	\x02\u{502}\u{504}\x09\x09\x02\x02\u{503}\u{502}\x03\x02\x02\x02\u{503}\
	\u{504}\x03\x02\x02\x02\u{504}\u{508}\x03\x02\x02\x02\u{505}\u{507}\x05\
	\x4a\x26\x02\u{506}\u{505}\x03\x02\x02\x02\u{507}\u{50a}\x03\x02\x02\x02\
	\u{508}\u{506}\x03\x02\x02\x02\u{508}\u{509}\x03\x02\x02\x02\u{509}\u{50b}\
	\x03\x02\x02\x02\u{50a}\u{508}\x03\x02\x02\x02\u{50b}\u{50c}\x07\x1e\x02\
	\x02\u{50c}\u{50d}\x05\u{f8}\x7d\x02\u{50d}\u{8e5}\x03\x02\x02\x02\u{50e}\
	\u{511}\x07\x50\x02\x02\u{50f}\u{510}\x07\u{10d}\x02\x02\u{510}\u{512}\x07\
	\u{13c}\x02\x02\u{511}\u{50f}\x03\x02\x02\x02\u{511}\u{512}\x03\x02\x02\
	\x02\u{512}\u{514}\x03\x02\x02\x02\u{513}\u{515}\x09\x08\x02\x02\u{514}\
	\u{513}\x03\x02\x02\x02\u{514}\u{515}\x03\x02\x02\x02\u{515}\u{517}\x03\
	\x02\x02\x02\u{516}\u{518}\x07\u{155}\x02\x02\u{517}\u{516}\x03\x02\x02\
	\x02\u{517}\u{518}\x03\x02\x02\x02\u{518}\u{519}\x03\x02\x02\x02\u{519}\
	\u{51d}\x07\u{98}\x02\x02\u{51a}\u{51b}\x07\u{ab}\x02\x02\u{51b}\u{51c}\
	\x07\u{100}\x02\x02\u{51c}\u{51e}\x07\u{83}\x02\x02\u{51d}\u{51a}\x03\x02\
	\x02\x02\u{51d}\u{51e}\x03\x02\x02\x02\u{51e}\u{51f}\x03\x02\x02\x02\u{51f}\
	\u{523}\x05\u{154}\u{ab}\x02\u{520}\u{521}\x07\u{ab}\x02\x02\u{521}\u{522}\
	\x07\u{100}\x02\x02\u{522}\u{524}\x07\u{83}\x02\x02\u{523}\u{520}\x03\x02\
	\x02\x02\u{523}\u{524}\x03\x02\x02\x02\u{524}\u{525}\x03\x02\x02\x02\u{525}\
	\u{531}\x07\u{1bc}\x02\x02\u{526}\u{52b}\x05\u{118}\u{8d}\x02\u{527}\u{528}\
	\x07\x42\x02\x02\u{528}\u{52a}\x05\u{118}\u{8d}\x02\u{529}\u{527}\x03\x02\
	\x02\x02\u{52a}\u{52d}\x03\x02\x02\x02\u{52b}\u{529}\x03\x02\x02\x02\u{52b}\
	\u{52c}\x03\x02\x02\x02\u{52c}\u{52f}\x03\x02\x02\x02\u{52d}\u{52b}\x03\
	\x02\x02\x02\u{52e}\u{530}\x07\x42\x02\x02\u{52f}\u{52e}\x03\x02\x02\x02\
	\u{52f}\u{530}\x03\x02\x02\x02\u{530}\u{532}\x03\x02\x02\x02\u{531}\u{526}\
	\x03\x02\x02\x02\u{531}\u{532}\x03\x02\x02\x02\u{532}\u{533}\x03\x02\x02\
	\x02\u{533}\u{536}\x07\u{1bd}\x02\x02\u{534}\u{535}\x07\x4e\x02\x02\u{535}\
	\u{537}\x07\u{9f}\x02\x02\u{536}\u{534}\x03\x02\x02\x02\u{536}\u{537}\x03\
	\x02\x02\x02\u{537}\u{538}\x03\x02\x02\x02\u{538}\u{54c}\x07\u{143}\x02\
	\x02\u{539}\u{54d}\x05\u{134}\u{9b}\x02\u{53a}\u{53b}\x07\u{175}\x02\x02\
	\u{53b}\u{53c}\x07\u{1bc}\x02\x02\u{53c}\u{53d}\x05\u{164}\u{b3}\x02\u{53d}\
	\u{544}\x05\u{134}\u{9b}\x02\u{53e}\u{53f}\x07\x42\x02\x02\u{53f}\u{540}\
	\x05\u{164}\u{b3}\x02\u{540}\u{541}\x05\u{134}\u{9b}\x02\u{541}\u{543}\x03\
	\x02\x02\x02\u{542}\u{53e}\x03\x02\x02\x02\u{543}\u{546}\x03\x02\x02\x02\
	\u{544}\u{542}\x03\x02\x02\x02\u{544}\u{545}\x03\x02\x02\x02\u{545}\u{548}\
	\x03\x02\x02\x02\u{546}\u{544}\x03\x02\x02\x02\u{547}\u{549}\x07\x42\x02\
	\x02\u{548}\u{547}\x03\x02\x02\x02\u{548}\u{549}\x03\x02\x02\x02\u{549}\
	\u{54a}\x03\x02\x02\x02\u{54a}\u{54b}\x07\u{1bd}\x02\x02\u{54b}\u{54d}\x03\
	\x02\x02\x02\u{54c}\u{539}\x03\x02\x02\x02\u{54c}\u{53a}\x03\x02\x02\x02\
	\u{54d}\u{552}\x03\x02\x02\x02\u{54e}\u{550}\x07\u{100}\x02\x02\u{54f}\u{54e}\
	\x03\x02\x02\x02\u{54f}\u{550}\x03\x02\x02\x02\u{550}\u{551}\x03\x02\x02\
	\x02\u{551}\u{553}\x07\u{102}\x02\x02\u{552}\u{54f}\x03\x02\x02\x02\u{552}\
	\u{553}\x03\x02\x02\x02\u{553}\u{554}\x03\x02\x02\x02\u{554}\u{555}\x07\
	\u{d1}\x02\x02\u{555}\u{560}\x07\u{12f}\x02\x02\u{556}\u{557}\x07\x30\x02\
	\x02\u{557}\u{558}\x07\u{108}\x02\x02\u{558}\u{559}\x07\u{102}\x02\x02\u{559}\
	\u{561}\x07\u{b7}\x02\x02\u{55a}\u{55b}\x07\u{141}\x02\x02\u{55b}\u{55c}\
	\x07\u{102}\x02\x02\u{55c}\u{55d}\x07\u{108}\x02\x02\u{55d}\u{55e}\x07\u{102}\
	\x02\x02\u{55e}\u{561}\x07\u{b7}\x02\x02\u{55f}\u{561}\x07\u{16f}\x02\x02\
	\u{560}\u{556}\x03\x02\x02\x02\u{560}\u{55a}\x03\x02\x02\x02\u{560}\u{55f}\
	\x03\x02\x02\x02\u{560}\u{561}\x03\x02\x02\x02\u{561}\u{563}\x03\x02\x02\
	\x02\u{562}\u{564}\x09\x09\x02\x02\u{563}\u{562}\x03\x02\x02\x02\u{563}\
	\u{564}\x03\x02\x02\x02\u{564}\u{568}\x03\x02\x02\x02\u{565}\u{567}\x05\
	\x4a\x26\x02\u{566}\u{565}\x03\x02\x02\x02\u{567}\u{56a}\x03\x02\x02\x02\
	\u{568}\u{566}\x03\x02\x02\x02\u{568}\u{569}\x03\x02\x02\x02\u{569}\u{56b}\
	\x03\x02\x02\x02\u{56a}\u{568}\x03\x02\x02\x02\u{56b}\u{56c}\x07\x1e\x02\
	\x02\u{56c}\u{56d}\x05\u{f8}\x7d\x02\u{56d}\u{8e5}\x03\x02\x02\x02\u{56e}\
	\u{571}\x07\x50\x02\x02\u{56f}\u{570}\x07\u{10d}\x02\x02\u{570}\u{572}\x07\
	\u{13c}\x02\x02\u{571}\u{56f}\x03\x02\x02\x02\u{571}\u{572}\x03\x02\x02\
	\x02\u{572}\u{574}\x03\x02\x02\x02\u{573}\u{575}\x09\x08\x02\x02\u{574}\
	\u{573}\x03\x02\x02\x02\u{574}\u{575}\x03\x02\x02\x02\u{575}\u{577}\x03\
	\x02\x02\x02\u{576}\u{578}\x07\u{155}\x02\x02\u{577}\u{576}\x03\x02\x02\
	\x02\u{577}\u{578}\x03\x02\x02\x02\u{578}\u{579}\x03\x02\x02\x02\u{579}\
	\u{57d}\x07\u{98}\x02\x02\u{57a}\u{57b}\x07\u{ab}\x02\x02\u{57b}\u{57c}\
	\x07\u{100}\x02\x02\u{57c}\u{57e}\x07\u{83}\x02\x02\u{57d}\u{57a}\x03\x02\
	\x02\x02\u{57d}\u{57e}\x03\x02\x02\x02\u{57e}\u{57f}\x03\x02\x02\x02\u{57f}\
	\u{583}\x05\u{154}\u{ab}\x02\u{580}\u{581}\x07\u{ab}\x02\x02\u{581}\u{582}\
	\x07\u{100}\x02\x02\u{582}\u{584}\x07\u{83}\x02\x02\u{583}\u{580}\x03\x02\
	\x02\x02\u{583}\u{584}\x03\x02\x02\x02\u{584}\u{585}\x03\x02\x02\x02\u{585}\
	\u{591}\x07\u{1bc}\x02\x02\u{586}\u{58b}\x05\u{118}\u{8d}\x02\u{587}\u{588}\
	\x07\x42\x02\x02\u{588}\u{58a}\x05\u{118}\u{8d}\x02\u{589}\u{587}\x03\x02\
	\x02\x02\u{58a}\u{58d}\x03\x02\x02\x02\u{58b}\u{589}\x03\x02\x02\x02\u{58b}\
	\u{58c}\x03\x02\x02\x02\u{58c}\u{58f}\x03\x02\x02\x02\u{58d}\u{58b}\x03\
	\x02\x02\x02\u{58e}\u{590}\x07\x42\x02\x02\u{58f}\u{58e}\x03\x02\x02\x02\
	\u{58f}\u{590}\x03\x02\x02\x02\u{590}\u{592}\x03\x02\x02\x02\u{591}\u{586}\
	\x03\x02\x02\x02\u{591}\u{592}\x03\x02\x02\x02\u{592}\u{593}\x03\x02\x02\
	\x02\u{593}\u{596}\x07\u{1bd}\x02\x02\u{594}\u{595}\x07\x4e\x02\x02\u{595}\
	\u{597}\x07\u{9f}\x02\x02\u{596}\u{594}\x03\x02\x02\x02\u{596}\u{597}\x03\
	\x02\x02\x02\u{597}\u{598}\x03\x02\x02\x02\u{598}\u{5ac}\x07\u{143}\x02\
	\x02\u{599}\u{5ad}\x05\u{134}\u{9b}\x02\u{59a}\u{59b}\x07\u{175}\x02\x02\
	\u{59b}\u{59c}\x07\u{1bc}\x02\x02\u{59c}\u{59d}\x05\u{164}\u{b3}\x02\u{59d}\
	\u{5a4}\x05\u{134}\u{9b}\x02\u{59e}\u{59f}\x07\x42\x02\x02\u{59f}\u{5a0}\
	\x05\u{164}\u{b3}\x02\u{5a0}\u{5a1}\x05\u{134}\u{9b}\x02\u{5a1}\u{5a3}\x03\
	\x02\x02\x02\u{5a2}\u{59e}\x03\x02\x02\x02\u{5a3}\u{5a6}\x03\x02\x02\x02\
	\u{5a4}\u{5a2}\x03\x02\x02\x02\u{5a4}\u{5a5}\x03\x02\x02\x02\u{5a5}\u{5a8}\
	\x03\x02\x02\x02\u{5a6}\u{5a4}\x03\x02\x02\x02\u{5a7}\u{5a9}\x07\x42\x02\
	\x02\u{5a8}\u{5a7}\x03\x02\x02\x02\u{5a8}\u{5a9}\x03\x02\x02\x02\u{5a9}\
	\u{5aa}\x03\x02\x02\x02\u{5aa}\u{5ab}\x07\u{1bd}\x02\x02\u{5ab}\u{5ad}\x03\
	\x02\x02\x02\u{5ac}\u{599}\x03\x02\x02\x02\u{5ac}\u{59a}\x03\x02\x02\x02\
	\u{5ad}\u{5b2}\x03\x02\x02\x02\u{5ae}\u{5b0}\x07\u{100}\x02\x02\u{5af}\u{5ae}\
	\x03\x02\x02\x02\u{5af}\u{5b0}\x03\x02\x02\x02\u{5b0}\u{5b1}\x03\x02\x02\
	\x02\u{5b1}\u{5b3}\x07\u{102}\x02\x02\u{5b2}\u{5af}\x03\x02\x02\x02\u{5b2}\
	\u{5b3}\x03\x02\x02\x02\u{5b3}\u{5b4}\x03\x02\x02\x02\u{5b4}\u{5b5}\x07\
	\u{d1}\x02\x02\u{5b5}\u{5c0}\x07\u{12f}\x02\x02\u{5b6}\u{5b7}\x07\x30\x02\
	\x02\u{5b7}\u{5b8}\x07\u{108}\x02\x02\u{5b8}\u{5b9}\x07\u{102}\x02\x02\u{5b9}\
	\u{5c1}\x07\u{b7}\x02\x02\u{5ba}\u{5bb}\x07\u{141}\x02\x02\u{5bb}\u{5bc}\
	\x07\u{102}\x02\x02\u{5bc}\u{5bd}\x07\u{108}\x02\x02\u{5bd}\u{5be}\x07\u{102}\
	\x02\x02\u{5be}\u{5c1}\x07\u{b7}\x02\x02\u{5bf}\u{5c1}\x07\u{16f}\x02\x02\
	\u{5c0}\u{5b6}\x03\x02\x02\x02\u{5c0}\u{5ba}\x03\x02\x02\x02\u{5c0}\u{5bf}\
	\x03\x02\x02\x02\u{5c0}\u{5c1}\x03\x02\x02\x02\u{5c1}\u{5c3}\x03\x02\x02\
	\x02\u{5c2}\u{5c4}\x09\x09\x02\x02\u{5c3}\u{5c2}\x03\x02\x02\x02\u{5c3}\
	\u{5c4}\x03\x02\x02\x02\u{5c4}\u{5c8}\x03\x02\x02\x02\u{5c5}\u{5c7}\x05\
	\x4a\x26\x02\u{5c6}\u{5c5}\x03\x02\x02\x02\u{5c7}\u{5ca}\x03\x02\x02\x02\
	\u{5c8}\u{5c6}\x03\x02\x02\x02\u{5c8}\u{5c9}\x03\x02\x02\x02\u{5c9}\u{8e5}\
	\x03\x02\x02\x02\u{5ca}\u{5c8}\x03\x02\x02\x02\u{5cb}\u{5ce}\x07\x50\x02\
	\x02\u{5cc}\u{5cd}\x07\u{10d}\x02\x02\u{5cd}\u{5cf}\x07\u{13c}\x02\x02\u{5ce}\
	\u{5cc}\x03\x02\x02\x02\u{5ce}\u{5cf}\x03\x02\x02\x02\u{5cf}\u{5d1}\x03\
	\x02\x02\x02\u{5d0}\u{5d2}\x09\x08\x02\x02\u{5d1}\u{5d0}\x03\x02\x02\x02\
	\u{5d1}\u{5d2}\x03\x02\x02\x02\u{5d2}\u{5d4}\x03\x02\x02\x02\u{5d3}\u{5d5}\
	\x07\u{155}\x02\x02\u{5d4}\u{5d3}\x03\x02\x02\x02\u{5d4}\u{5d5}\x03\x02\
	\x02\x02\u{5d5}\u{5d6}\x03\x02\x02\x02\u{5d6}\u{5da}\x07\u{98}\x02\x02\u{5d7}\
	\u{5d8}\x07\u{ab}\x02\x02\u{5d8}\u{5d9}\x07\u{100}\x02\x02\u{5d9}\u{5db}\
	\x07\u{83}\x02\x02\u{5da}\u{5d7}\x03\x02\x02\x02\u{5da}\u{5db}\x03\x02\x02\
	\x02\u{5db}\u{5dc}\x03\x02\x02\x02\u{5dc}\u{5e0}\x05\u{154}\u{ab}\x02\u{5dd}\
	\u{5de}\x07\u{ab}\x02\x02\u{5de}\u{5df}\x07\u{100}\x02\x02\u{5df}\u{5e1}\
	\x07\u{83}\x02\x02\u{5e0}\u{5dd}\x03\x02\x02\x02\u{5e0}\u{5e1}\x03\x02\x02\
	\x02\u{5e1}\u{5e2}\x03\x02\x02\x02\u{5e2}\u{5ee}\x07\u{1bc}\x02\x02\u{5e3}\
	\u{5e8}\x05\u{118}\u{8d}\x02\u{5e4}\u{5e5}\x07\x42\x02\x02\u{5e5}\u{5e7}\
	\x05\u{118}\u{8d}\x02\u{5e6}\u{5e4}\x03\x02\x02\x02\u{5e7}\u{5ea}\x03\x02\
	\x02\x02\u{5e8}\u{5e6}\x03\x02\x02\x02\u{5e8}\u{5e9}\x03\x02\x02\x02\u{5e9}\
	\u{5ec}\x03\x02\x02\x02\u{5ea}\u{5e8}\x03\x02\x02\x02\u{5eb}\u{5ed}\x07\
	\x42\x02\x02\u{5ec}\u{5eb}\x03\x02\x02\x02\u{5ec}\u{5ed}\x03\x02\x02\x02\
	\u{5ed}\u{5ef}\x03\x02\x02\x02\u{5ee}\u{5e3}\x03\x02\x02\x02\u{5ee}\u{5ef}\
	\x03\x02\x02\x02\u{5ef}\u{5f0}\x03\x02\x02\x02\u{5f0}\u{5f3}\x07\u{1bd}\
	\x02\x02\u{5f1}\u{5f2}\x07\x4e\x02\x02\u{5f2}\u{5f4}\x07\u{9f}\x02\x02\u{5f3}\
	\u{5f1}\x03\x02\x02\x02\u{5f3}\u{5f4}\x03\x02\x02\x02\u{5f4}\u{5f5}\x03\
	\x02\x02\x02\u{5f5}\u{5f6}\x07\u{143}\x02\x02\u{5f6}\u{5fb}\x05\u{134}\u{9b}\
	\x02\u{5f7}\u{5f9}\x07\u{100}\x02\x02\u{5f8}\u{5f7}\x03\x02\x02\x02\u{5f8}\
	\u{5f9}\x03\x02\x02\x02\u{5f9}\u{5fa}\x03\x02\x02\x02\u{5fa}\u{5fc}\x07\
	\u{102}\x02\x02\u{5fb}\u{5f8}\x03\x02\x02\x02\u{5fb}\u{5fc}\x03\x02\x02\
	\x02\u{5fc}\u{5fd}\x03\x02\x02\x02\u{5fd}\u{5fe}\x07\u{d1}\x02\x02\u{5fe}\
	\u{609}\x07\u{150}\x02\x02\u{5ff}\u{600}\x07\x30\x02\x02\u{600}\u{601}\x07\
	\u{108}\x02\x02\u{601}\u{602}\x07\u{102}\x02\x02\u{602}\u{60a}\x07\u{b7}\
	\x02\x02\u{603}\u{604}\x07\u{141}\x02\x02\u{604}\u{605}\x07\u{102}\x02\x02\
	\u{605}\u{606}\x07\u{108}\x02\x02\u{606}\u{607}\x07\u{102}\x02\x02\u{607}\
	\u{60a}\x07\u{b7}\x02\x02\u{608}\u{60a}\x07\u{16f}\x02\x02\u{609}\u{5ff}\
	\x03\x02\x02\x02\u{609}\u{603}\x03\x02\x02\x02\u{609}\u{608}\x03\x02\x02\
	\x02\u{609}\u{60a}\x03\x02\x02\x02\u{60a}\u{60c}\x03\x02\x02\x02\u{60b}\
	\u{60d}\x09\x09\x02\x02\u{60c}\u{60b}\x03\x02\x02\x02\u{60c}\u{60d}\x03\
	\x02\x02\x02\u{60d}\u{611}\x03\x02\x02\x02\u{60e}\u{610}\x05\x4a\x26\x02\
	\u{60f}\u{60e}\x03\x02\x02\x02\u{610}\u{613}\x03\x02\x02\x02\u{611}\u{60f}\
	\x03\x02\x02\x02\u{611}\u{612}\x03\x02\x02\x02\u{612}\u{614}\x03\x02\x02\
	\x02\u{613}\u{611}\x03\x02\x02\x02\u{614}\u{615}\x07\x1e\x02\x02\u{615}\
	\u{616}\x05\u{f8}\x7d\x02\u{616}\u{8e5}\x03\x02\x02\x02\u{617}\u{61a}\x07\
	\x50\x02\x02\u{618}\u{619}\x07\u{10d}\x02\x02\u{619}\u{61b}\x07\u{13c}\x02\
	\x02\u{61a}\u{618}\x03\x02\x02\x02\u{61a}\u{61b}\x03\x02\x02\x02\u{61b}\
	\u{61d}\x03\x02\x02\x02\u{61c}\u{61e}\x09\x08\x02\x02\u{61d}\u{61c}\x03\
	\x02\x02\x02\u{61d}\u{61e}\x03\x02\x02\x02\u{61e}\u{620}\x03\x02\x02\x02\
	\u{61f}\u{621}\x07\u{155}\x02\x02\u{620}\u{61f}\x03\x02\x02\x02\u{620}\u{621}\
	\x03\x02\x02\x02\u{621}\u{622}\x03\x02\x02\x02\u{622}\u{626}\x07\u{98}\x02\
	\x02\u{623}\u{624}\x07\u{ab}\x02\x02\u{624}\u{625}\x07\u{100}\x02\x02\u{625}\
	\u{627}\x07\u{83}\x02\x02\u{626}\u{623}\x03\x02\x02\x02\u{626}\u{627}\x03\
	\x02\x02\x02\u{627}\u{628}\x03\x02\x02\x02\u{628}\u{62c}\x05\u{154}\u{ab}\
	\x02\u{629}\u{62a}\x07\u{ab}\x02\x02\u{62a}\u{62b}\x07\u{100}\x02\x02\u{62b}\
	\u{62d}\x07\u{83}\x02\x02\u{62c}\u{629}\x03\x02\x02\x02\u{62c}\u{62d}\x03\
	\x02\x02\x02\u{62d}\u{62e}\x03\x02\x02\x02\u{62e}\u{63a}\x07\u{1bc}\x02\
	\x02\u{62f}\u{634}\x05\u{118}\u{8d}\x02\u{630}\u{631}\x07\x42\x02\x02\u{631}\
	\u{633}\x05\u{118}\u{8d}\x02\u{632}\u{630}\x03\x02\x02\x02\u{633}\u{636}\
	\x03\x02\x02\x02\u{634}\u{632}\x03\x02\x02\x02\u{634}\u{635}\x03\x02\x02\
	\x02\u{635}\u{638}\x03\x02\x02\x02\u{636}\u{634}\x03\x02\x02\x02\u{637}\
	\u{639}\x07\x42\x02\x02\u{638}\u{637}\x03\x02\x02\x02\u{638}\u{639}\x03\
	\x02\x02\x02\u{639}\u{63b}\x03\x02\x02\x02\u{63a}\u{62f}\x03\x02\x02\x02\
	\u{63a}\u{63b}\x03\x02\x02\x02\u{63b}\u{63c}\x03\x02\x02\x02\u{63c}\u{63f}\
	\x07\u{1bd}\x02\x02\u{63d}\u{63e}\x07\x4e\x02\x02\u{63e}\u{640}\x07\u{9f}\
	\x02\x02\u{63f}\u{63d}\x03\x02\x02\x02\u{63f}\u{640}\x03\x02\x02\x02\u{640}\
	\u{641}\x03\x02\x02\x02\u{641}\u{642}\x07\u{143}\x02\x02\u{642}\u{647}\x05\
	\u{134}\u{9b}\x02\u{643}\u{645}\x07\u{100}\x02\x02\u{644}\u{643}\x03\x02\
	\x02\x02\u{644}\u{645}\x03\x02\x02\x02\u{645}\u{646}\x03\x02\x02\x02\u{646}\
	\u{648}\x07\u{102}\x02\x02\u{647}\u{644}\x03\x02\x02\x02\u{647}\u{648}\x03\
	\x02\x02\x02\u{648}\u{649}\x03\x02\x02\x02\u{649}\u{64a}\x07\u{d1}\x02\x02\
	\u{64a}\u{655}\x07\u{150}\x02\x02\u{64b}\u{64c}\x07\x30\x02\x02\u{64c}\u{64d}\
	\x07\u{108}\x02\x02\u{64d}\u{64e}\x07\u{102}\x02\x02\u{64e}\u{656}\x07\u{b7}\
	\x02\x02\u{64f}\u{650}\x07\u{141}\x02\x02\u{650}\u{651}\x07\u{102}\x02\x02\
	\u{651}\u{652}\x07\u{108}\x02\x02\u{652}\u{653}\x07\u{102}\x02\x02\u{653}\
	\u{656}\x07\u{b7}\x02\x02\u{654}\u{656}\x07\u{16f}\x02\x02\u{655}\u{64b}\
	\x03\x02\x02\x02\u{655}\u{64f}\x03\x02\x02\x02\u{655}\u{654}\x03\x02\x02\
	\x02\u{655}\u{656}\x03\x02\x02\x02\u{656}\u{658}\x03\x02\x02\x02\u{657}\
	\u{659}\x09\x09\x02\x02\u{658}\u{657}\x03\x02\x02\x02\u{658}\u{659}\x03\
	\x02\x02\x02\u{659}\u{65d}\x03\x02\x02\x02\u{65a}\u{65c}\x05\x4a\x26\x02\
	\u{65b}\u{65a}\x03\x02\x02\x02\u{65c}\u{65f}\x03\x02\x02\x02\u{65d}\u{65b}\
	\x03\x02\x02\x02\u{65d}\u{65e}\x03\x02\x02\x02\u{65e}\u{8e5}\x03\x02\x02\
	\x02\u{65f}\u{65d}\x03\x02\x02\x02\u{660}\u{663}\x07\x50\x02\x02\u{661}\
	\u{662}\x07\u{10d}\x02\x02\u{662}\u{664}\x07\u{13c}\x02\x02\u{663}\u{661}\
	\x03\x02\x02\x02\u{663}\u{664}\x03\x02\x02\x02\u{664}\u{666}\x03\x02\x02\
	\x02\u{665}\u{667}\x09\x08\x02\x02\u{666}\u{665}\x03\x02\x02\x02\u{666}\
	\u{667}\x03\x02\x02\x02\u{667}\u{669}\x03\x02\x02\x02\u{668}\u{66a}\x07\
	\u{155}\x02\x02\u{669}\u{668}\x03\x02\x02\x02\u{669}\u{66a}\x03\x02\x02\
	\x02\u{66a}\u{66b}\x03\x02\x02\x02\u{66b}\u{66c}\x07\u{98}\x02\x02\u{66c}\
	\u{66d}\x05\u{154}\u{ab}\x02\u{66d}\u{679}\x07\u{1bc}\x02\x02\u{66e}\u{673}\
	\x05\u{118}\u{8d}\x02\u{66f}\u{670}\x07\x42\x02\x02\u{670}\u{672}\x05\u{118}\
	\u{8d}\x02\u{671}\u{66f}\x03\x02\x02\x02\u{672}\u{675}\x03\x02\x02\x02\u{673}\
	\u{671}\x03\x02\x02\x02\u{673}\u{674}\x03\x02\x02\x02\u{674}\u{677}\x03\
	\x02\x02\x02\u{675}\u{673}\x03\x02\x02\x02\u{676}\u{678}\x07\x42\x02\x02\
	\u{677}\u{676}\x03\x02\x02\x02\u{677}\u{678}\x03\x02\x02\x02\u{678}\u{67a}\
	\x03\x02\x02\x02\u{679}\u{66e}\x03\x02\x02\x02\u{679}\u{67a}\x03\x02\x02\
	\x02\u{67a}\u{67b}\x03\x02\x02\x02\u{67b}\u{67e}\x07\u{1bd}\x02\x02\u{67c}\
	\u{67d}\x07\x4e\x02\x02\u{67d}\u{67f}\x07\u{9f}\x02\x02\u{67e}\u{67c}\x03\
	\x02\x02\x02\u{67e}\u{67f}\x03\x02\x02\x02\u{67f}\u{680}\x03\x02\x02\x02\
	\u{680}\u{694}\x07\u{143}\x02\x02\u{681}\u{695}\x05\u{134}\u{9b}\x02\u{682}\
	\u{683}\x07\u{175}\x02\x02\u{683}\u{684}\x07\u{1bc}\x02\x02\u{684}\u{685}\
	\x05\u{164}\u{b3}\x02\u{685}\u{68c}\x05\u{134}\u{9b}\x02\u{686}\u{687}\x07\
	\x42\x02\x02\u{687}\u{688}\x05\u{164}\u{b3}\x02\u{688}\u{689}\x05\u{134}\
	\u{9b}\x02\u{689}\u{68b}\x03\x02\x02\x02\u{68a}\u{686}\x03\x02\x02\x02\u{68b}\
	\u{68e}\x03\x02\x02\x02\u{68c}\u{68a}\x03\x02\x02\x02\u{68c}\u{68d}\x03\
	\x02\x02\x02\u{68d}\u{690}\x03\x02\x02\x02\u{68e}\u{68c}\x03\x02\x02\x02\
	\u{68f}\u{691}\x07\x42\x02\x02\u{690}\u{68f}\x03\x02\x02\x02\u{690}\u{691}\
	\x03\x02\x02\x02\u{691}\u{692}\x03\x02\x02\x02\u{692}\u{693}\x07\u{1bd}\
	\x02\x02\u{693}\u{695}\x03\x02\x02\x02\u{694}\u{681}\x03\x02\x02\x02\u{694}\
	\u{682}\x03\x02\x02\x02\u{695}\u{69a}\x03\x02\x02\x02\u{696}\u{698}\x07\
	\u{100}\x02\x02\u{697}\u{696}\x03\x02\x02\x02\u{697}\u{698}\x03\x02\x02\
	\x02\u{698}\u{699}\x03\x02\x02\x02\u{699}\u{69b}\x07\u{102}\x02\x02\u{69a}\
	\u{697}\x03\x02\x02\x02\u{69a}\u{69b}\x03\x02\x02\x02\u{69b}\u{69e}\x03\
	\x02\x02\x02\u{69c}\u{69d}\x07\u{d1}\x02\x02\u{69d}\u{69f}\x07\u{168}\x02\
	\x02\u{69e}\u{69c}\x03\x02\x02\x02\u{69e}\u{69f}\x03\x02\x02\x02\u{69f}\
	\u{6a1}\x03\x02\x02\x02\u{6a0}\u{6a2}\x09\x09\x02\x02\u{6a1}\u{6a0}\x03\
	\x02\x02\x02\u{6a1}\u{6a2}\x03\x02\x02\x02\u{6a2}\u{6a4}\x03\x02\x02\x02\
	\u{6a3}\u{6a5}\x07\u{eb}\x02\x02\u{6a4}\u{6a3}\x03\x02\x02\x02\u{6a4}\u{6a5}\
	\x03\x02\x02\x02\u{6a5}\u{6a9}\x03\x02\x02\x02\u{6a6}\u{6a8}\x05\x4a\x26\
	\x02\u{6a7}\u{6a6}\x03\x02\x02\x02\u{6a8}\u{6ab}\x03\x02\x02\x02\u{6a9}\
	\u{6a7}\x03\x02\x02\x02\u{6a9}\u{6aa}\x03\x02\x02\x02\u{6aa}\u{6ac}\x03\
	\x02\x02\x02\u{6ab}\u{6a9}\x03\x02\x02\x02\u{6ac}\u{6ad}\x07\x1e\x02\x02\
	\u{6ad}\u{6ae}\x05\u{f8}\x7d\x02\u{6ae}\u{8e5}\x03\x02\x02\x02\u{6af}\u{6b2}\
	\x07\x50\x02\x02\u{6b0}\u{6b1}\x07\u{10d}\x02\x02\u{6b1}\u{6b3}\x07\u{13c}\
	\x02\x02\u{6b2}\u{6b0}\x03\x02\x02\x02\u{6b2}\u{6b3}\x03\x02\x02\x02\u{6b3}\
	\u{6b5}\x03\x02\x02\x02\u{6b4}\u{6b6}\x09\x08\x02\x02\u{6b5}\u{6b4}\x03\
	\x02\x02\x02\u{6b5}\u{6b6}\x03\x02\x02\x02\u{6b6}\u{6b8}\x03\x02\x02\x02\
	\u{6b7}\u{6b9}\x07\u{155}\x02\x02\u{6b8}\u{6b7}\x03\x02\x02\x02\u{6b8}\u{6b9}\
	\x03\x02\x02\x02\u{6b9}\u{6ba}\x03\x02\x02\x02\u{6ba}\u{6bb}\x07\u{12a}\
	\x02\x02\u{6bb}\u{6bc}\x05\u{154}\u{ab}\x02\u{6bc}\u{6c8}\x07\u{1bc}\x02\
	\x02\u{6bd}\u{6c2}\x05\u{118}\u{8d}\x02\u{6be}\u{6bf}\x07\x42\x02\x02\u{6bf}\
	\u{6c1}\x05\u{118}\u{8d}\x02\u{6c0}\u{6be}\x03\x02\x02\x02\u{6c1}\u{6c4}\
	\x03\x02\x02\x02\u{6c2}\u{6c0}\x03\x02\x02\x02\u{6c2}\u{6c3}\x03\x02\x02\
	\x02\u{6c3}\u{6c6}\x03\x02\x02\x02\u{6c4}\u{6c2}\x03\x02\x02\x02\u{6c5}\
	\u{6c7}\x07\x42\x02\x02\u{6c6}\u{6c5}\x03\x02\x02\x02\u{6c6}\u{6c7}\x03\
	\x02\x02\x02\u{6c7}\u{6c9}\x03\x02\x02\x02\u{6c8}\u{6bd}\x03\x02\x02\x02\
	\u{6c8}\u{6c9}\x03\x02\x02\x02\u{6c9}\u{6ca}\x03\x02\x02\x02\u{6ca}\u{6cd}\
	\x07\u{1bd}\x02\x02\u{6cb}\u{6cc}\x07\x4e\x02\x02\u{6cc}\u{6ce}\x07\u{9f}\
	\x02\x02\u{6cd}\u{6cb}\x03\x02\x02\x02\u{6cd}\u{6ce}\x03\x02\x02\x02\u{6ce}\
	\u{6cf}\x03\x02\x02\x02\u{6cf}\u{6e3}\x07\u{143}\x02\x02\u{6d0}\u{6e4}\x05\
	\u{134}\u{9b}\x02\u{6d1}\u{6d2}\x07\u{175}\x02\x02\u{6d2}\u{6d3}\x07\u{1bc}\
	\x02\x02\u{6d3}\u{6d4}\x05\u{164}\u{b3}\x02\u{6d4}\u{6db}\x05\u{134}\u{9b}\
	\x02\u{6d5}\u{6d6}\x07\x42\x02\x02\u{6d6}\u{6d7}\x05\u{164}\u{b3}\x02\u{6d7}\
	\u{6d8}\x05\u{134}\u{9b}\x02\u{6d8}\u{6da}\x03\x02\x02\x02\u{6d9}\u{6d5}\
	\x03\x02\x02\x02\u{6da}\u{6dd}\x03\x02\x02\x02\u{6db}\u{6d9}\x03\x02\x02\
	\x02\u{6db}\u{6dc}\x03\x02\x02\x02\u{6dc}\u{6df}\x03\x02\x02\x02\u{6dd}\
	\u{6db}\x03\x02\x02\x02\u{6de}\u{6e0}\x07\x42\x02\x02\u{6df}\u{6de}\x03\
	\x02\x02\x02\u{6df}\u{6e0}\x03\x02\x02\x02\u{6e0}\u{6e1}\x03\x02\x02\x02\
	\u{6e1}\u{6e2}\x07\u{1bd}\x02\x02\u{6e2}\u{6e4}\x03\x02\x02\x02\u{6e3}\u{6d0}\
	\x03\x02\x02\x02\u{6e3}\u{6d1}\x03\x02\x02\x02\u{6e4}\u{6e9}\x03\x02\x02\
	\x02\u{6e5}\u{6e7}\x07\u{100}\x02\x02\u{6e6}\u{6e5}\x03\x02\x02\x02\u{6e6}\
	\u{6e7}\x03\x02\x02\x02\u{6e7}\u{6e8}\x03\x02\x02\x02\u{6e8}\u{6ea}\x07\
	\u{102}\x02\x02\u{6e9}\u{6e6}\x03\x02\x02\x02\u{6e9}\u{6ea}\x03\x02\x02\
	\x02\u{6ea}\u{6eb}\x03\x02\x02\x02\u{6eb}\u{6ec}\x07\u{d1}\x02\x02\u{6ec}\
	\u{6f0}\x07\u{12f}\x02\x02\u{6ed}\u{6ef}\x05\x4a\x26\x02\u{6ee}\u{6ed}\x03\
	\x02\x02\x02\u{6ef}\u{6f2}\x03\x02\x02\x02\u{6f0}\u{6ee}\x03\x02\x02\x02\
	\u{6f0}\u{6f1}\x03\x02\x02\x02\u{6f1}\u{6f5}\x03\x02\x02\x02\u{6f2}\u{6f0}\
	\x03\x02\x02\x02\u{6f3}\u{6f4}\x07\x1e\x02\x02\u{6f4}\u{6f6}\x05\u{f8}\x7d\
	\x02\u{6f5}\u{6f3}\x03\x02\x02\x02\u{6f5}\u{6f6}\x03\x02\x02\x02\u{6f6}\
	\u{8e5}\x03\x02\x02\x02\u{6f7}\u{6f8}\x07\u{1b1}\x02\x02\u{6f8}\u{6f9}\x05\
	\u{154}\u{ab}\x02\u{6f9}\u{6fa}\x07\x1e\x02\x02\u{6fa}\u{6fb}\x07\u{12a}\
	\x02\x02\u{6fb}\u{707}\x07\u{1bc}\x02\x02\u{6fc}\u{701}\x05\u{118}\u{8d}\
	\x02\u{6fd}\u{6fe}\x07\x42\x02\x02\u{6fe}\u{700}\x05\u{118}\u{8d}\x02\u{6ff}\
	\u{6fd}\x03\x02\x02\x02\u{700}\u{703}\x03\x02\x02\x02\u{701}\u{6ff}\x03\
	\x02\x02\x02\u{701}\u{702}\x03\x02\x02\x02\u{702}\u{705}\x03\x02\x02\x02\
	\u{703}\u{701}\x03\x02\x02\x02\u{704}\u{706}\x07\x42\x02\x02\u{705}\u{704}\
	\x03\x02\x02\x02\u{705}\u{706}\x03\x02\x02\x02\u{706}\u{708}\x03\x02\x02\
	\x02\u{707}\u{6fc}\x03\x02\x02\x02\u{707}\u{708}\x03\x02\x02\x02\u{708}\
	\u{709}\x03\x02\x02\x02\u{709}\u{70a}\x07\u{1bd}\x02\x02\u{70a}\u{71e}\x07\
	\u{143}\x02\x02\u{70b}\u{71f}\x05\u{134}\u{9b}\x02\u{70c}\u{70d}\x07\u{175}\
	\x02\x02\u{70d}\u{70e}\x07\u{1bc}\x02\x02\u{70e}\u{70f}\x05\u{164}\u{b3}\
	\x02\u{70f}\u{716}\x05\u{134}\u{9b}\x02\u{710}\u{711}\x07\x42\x02\x02\u{711}\
	\u{712}\x05\u{164}\u{b3}\x02\u{712}\u{713}\x05\u{134}\u{9b}\x02\u{713}\u{715}\
	\x03\x02\x02\x02\u{714}\u{710}\x03\x02\x02\x02\u{715}\u{718}\x03\x02\x02\
	\x02\u{716}\u{714}\x03\x02\x02\x02\u{716}\u{717}\x03\x02\x02\x02\u{717}\
	\u{71a}\x03\x02\x02\x02\u{718}\u{716}\x03\x02\x02\x02\u{719}\u{71b}\x07\
	\x42\x02\x02\u{71a}\u{719}\x03\x02\x02\x02\u{71a}\u{71b}\x03\x02\x02\x02\
	\u{71b}\u{71c}\x03\x02\x02\x02\u{71c}\u{71d}\x07\u{1bd}\x02\x02\u{71d}\u{71f}\
	\x03\x02\x02\x02\u{71e}\u{70b}\x03\x02\x02\x02\u{71e}\u{70c}\x03\x02\x02\
	\x02\u{71f}\u{724}\x03\x02\x02\x02\u{720}\u{722}\x07\u{100}\x02\x02\u{721}\
	\u{720}\x03\x02\x02\x02\u{721}\u{722}\x03\x02\x02\x02\u{722}\u{723}\x03\
	\x02\x02\x02\u{723}\u{725}\x07\u{102}\x02\x02\u{724}\u{721}\x03\x02\x02\
	\x02\u{724}\u{725}\x03\x02\x02\x02\u{725}\u{726}\x03\x02\x02\x02\u{726}\
	\u{727}\x07\u{d1}\x02\x02\u{727}\u{72b}\x07\u{12f}\x02\x02\u{728}\u{72a}\
	\x05\x4a\x26\x02\u{729}\u{728}\x03\x02\x02\x02\u{72a}\u{72d}\x03\x02\x02\
	\x02\u{72b}\u{729}\x03\x02\x02\x02\u{72b}\u{72c}\x03\x02\x02\x02\u{72c}\
	\u{736}\x03\x02\x02\x02\u{72d}\u{72b}\x03\x02\x02\x02\u{72e}\u{72f}\x07\
	\u{82}\x02\x02\u{72f}\u{734}\x07\x1e\x02\x02\u{730}\u{735}\x07\u{115}\x02\
	\x02\u{731}\u{735}\x07\x31\x02\x02\u{732}\u{733}\x07\u{140}\x02\x02\u{733}\
	\u{735}\x07\x31\x02\x02\u{734}\u{730}\x03\x02\x02\x02\u{734}\u{731}\x03\
	\x02\x02\x02\u{734}\u{732}\x03\x02\x02\x02\u{735}\u{737}\x03\x02\x02\x02\
	\u{736}\u{72e}\x03\x02\x02\x02\u{736}\u{737}\x03\x02\x02\x02\u{737}\u{738}\
	\x03\x02\x02\x02\u{738}\u{739}\x07\x1e\x02\x02\u{739}\u{73a}\x05\u{f8}\x7d\
	\x02\u{73a}\u{73b}\x07\x2f\x02\x02\u{73b}\u{74b}\x05\u{154}\u{ab}\x02\u{73c}\
	\u{745}\x07\u{1bc}\x02\x02\u{73d}\u{742}\x05\u{10a}\u{86}\x02\u{73e}\u{73f}\
	\x07\x42\x02\x02\u{73f}\u{741}\x05\u{10a}\u{86}\x02\u{740}\u{73e}\x03\x02\
	\x02\x02\u{741}\u{744}\x03\x02\x02\x02\u{742}\u{740}\x03\x02\x02\x02\u{742}\
	\u{743}\x03\x02\x02\x02\u{743}\u{746}\x03\x02\x02\x02\u{744}\u{742}\x03\
	\x02\x02\x02\u{745}\u{73d}\x03\x02\x02\x02\u{745}\u{746}\x03\x02\x02\x02\
	\u{746}\u{748}\x03\x02\x02\x02\u{747}\u{749}\x07\x42\x02\x02\u{748}\u{747}\
	\x03\x02\x02\x02\u{748}\u{749}\x03\x02\x02\x02\u{749}\u{74a}\x03\x02\x02\
	\x02\u{74a}\u{74c}\x07\u{1bd}\x02\x02\u{74b}\u{73c}\x03\x02\x02\x02\u{74b}\
	\u{74c}\x03\x02\x02\x02\u{74c}\u{750}\x03\x02\x02\x02\u{74d}\u{74e}\x07\
	\u{bd}\x02\x02\u{74e}\u{74f}\x07\u{1cf}\x02\x02\u{74f}\u{751}\x05\u{164}\
	\u{b3}\x02\u{750}\u{74d}\x03\x02\x02\x02\u{750}\u{751}\x03\x02\x02\x02\u{751}\
	\u{8e5}\x03\x02\x02\x02\u{752}\u{753}\x07\u{19a}\x02\x02\u{753}\u{8e5}\x05\
	\u{164}\u{b3}\x02\u{754}\u{758}\x07\u{ec}\x02\x02\u{755}\u{757}\x0a\x02\
	\x02\x02\u{756}\u{755}\x03\x02\x02\x02\u{757}\u{75a}\x03\x02\x02\x02\u{758}\
	\u{756}\x03\x02\x02\x02\u{758}\u{759}\x03\x02\x02\x02\u{759}\u{8e5}\x03\
	\x02\x02\x02\u{75a}\u{758}\x03\x02\x02\x02\u{75b}\u{75f}\x07\x15\x02\x02\
	\u{75c}\u{75e}\x0a\x02\x02\x02\u{75d}\u{75c}\x03\x02\x02\x02\u{75e}\u{761}\
	\x03\x02\x02\x02\u{75f}\u{75d}\x03\x02\x02\x02\u{75f}\u{760}\x03\x02\x02\
	\x02\u{760}\u{8e5}\x03\x02\x02\x02\u{761}\u{75f}\x03\x02\x02\x02\u{762}\
	\u{766}\x07\x28\x02\x02\u{763}\u{765}\x0a\x02\x02\x02\u{764}\u{763}\x03\
	\x02\x02\x02\u{765}\u{768}\x03\x02\x02\x02\u{766}\u{764}\x03\x02\x02\x02\
	\u{766}\u{767}\x03\x02\x02\x02\u{767}\u{8e5}\x03\x02\x02\x02\u{768}\u{766}\
	\x03\x02\x02\x02\u{769}\u{76d}\x07\u{19d}\x02\x02\u{76a}\u{76c}\x0a\x02\
	\x02\x02\u{76b}\u{76a}\x03\x02\x02\x02\u{76c}\u{76f}\x03\x02\x02\x02\u{76d}\
	\u{76b}\x03\x02\x02\x02\u{76d}\u{76e}\x03\x02\x02\x02\u{76e}\u{8e5}\x03\
	\x02\x02\x02\u{76f}\u{76d}\x03\x02\x02\x02\u{770}\u{773}\x07\x50\x02\x02\
	\u{771}\u{772}\x07\u{10d}\x02\x02\u{772}\u{774}\x07\u{13c}\x02\x02\u{773}\
	\u{771}\x03\x02\x02\x02\u{773}\u{774}\x03\x02\x02\x02\u{774}\u{775}\x03\
	\x02\x02\x02\u{775}\u{779}\x07\x56\x02\x02\u{776}\u{778}\x0a\x02\x02\x02\
	\u{777}\u{776}\x03\x02\x02\x02\u{778}\u{77b}\x03\x02\x02\x02\u{779}\u{777}\
	\x03\x02\x02\x02\u{779}\u{77a}\x03\x02\x02\x02\u{77a}\u{8e5}\x03\x02\x02\
	\x02\u{77b}\u{779}\x03\x02\x02\x02\u{77c}\u{77f}\x07\x50\x02\x02\u{77d}\
	\u{77e}\x07\u{10d}\x02\x02\u{77e}\u{780}\x07\u{13c}\x02\x02\u{77f}\u{77d}\
	\x03\x02\x02\x02\u{77f}\u{780}\x03\x02\x02\x02\u{780}\u{781}\x03\x02\x02\
	\x02\u{781}\u{785}\x07\u{15b}\x02\x02\u{782}\u{784}\x0a\x02\x02\x02\u{783}\
	\u{782}\x03\x02\x02\x02\u{784}\u{787}\x03\x02\x02\x02\u{785}\u{783}\x03\
	\x02\x02\x02\u{785}\u{786}\x03\x02\x02\x02\u{786}\u{8e5}\x03\x02\x02\x02\
	\u{787}\u{785}\x03\x02\x02\x02\u{788}\u{78b}\x07\x50\x02\x02\u{789}\u{78a}\
	\x07\u{10d}\x02\x02\u{78a}\u{78c}\x07\u{13c}\x02\x02\u{78b}\u{789}\x03\x02\
	\x02\x02\u{78b}\u{78c}\x03\x02\x02\x02\u{78c}\u{78d}\x03\x02\x02\x02\u{78d}\
	\u{78e}\x07\u{e2}\x02\x02\u{78e}\u{792}\x07\u{124}\x02\x02\u{78f}\u{791}\
	\x0a\x02\x02\x02\u{790}\u{78f}\x03\x02\x02\x02\u{791}\u{794}\x03\x02\x02\
	\x02\u{792}\u{790}\x03\x02\x02\x02\u{792}\u{793}\x03\x02\x02\x02\u{793}\
	\u{8e5}\x03\x02\x02\x02\u{794}\u{792}\x03\x02\x02\x02\u{795}\u{798}\x07\
	\x50\x02\x02\u{796}\u{797}\x07\u{10d}\x02\x02\u{797}\u{799}\x07\u{13c}\x02\
	\x02\u{798}\u{796}\x03\x02\x02\x02\u{798}\u{799}\x03\x02\x02\x02\u{799}\
	\u{79a}\x03\x02\x02\x02\u{79a}\u{79e}\x07\u{153}\x02\x02\u{79b}\u{79d}\x0a\
	\x02\x02\x02\u{79c}\u{79b}\x03\x02\x02\x02\u{79d}\u{7a0}\x03\x02\x02\x02\
	\u{79e}\u{79c}\x03\x02\x02\x02\u{79e}\u{79f}\x03\x02\x02\x02\u{79f}\u{8e5}\
	\x03\x02\x02\x02\u{7a0}\u{79e}\x03\x02\x02\x02\u{7a1}\u{7a5}\x07\x72\x02\
	\x02\u{7a2}\u{7a4}\x0a\x02\x02\x02\u{7a3}\u{7a2}\x03\x02\x02\x02\u{7a4}\
	\u{7a7}\x03\x02\x02\x02\u{7a5}\u{7a3}\x03\x02\x02\x02\u{7a5}\u{7a6}\x03\
	\x02\x02\x02\u{7a6}\u{8e5}\x03\x02\x02\x02\u{7a7}\u{7a5}\x03\x02\x02\x02\
	\u{7a8}\u{7ac}\x07\x60\x02\x02\u{7a9}\u{7ab}\x0a\x02\x02\x02\u{7aa}\u{7a9}\
	\x03\x02\x02\x02\u{7ab}\u{7ae}\x03\x02\x02\x02\u{7ac}\u{7aa}\x03\x02\x02\
	\x02\u{7ac}\u{7ad}\x03\x02\x02\x02\u{7ad}\u{8e5}\x03\x02\x02\x02\u{7ae}\
	\u{7ac}\x03\x02\x02\x02\u{7af}\u{7b3}\x07\u{18b}\x02\x02\u{7b0}\u{7b2}\x0a\
	\x02\x02\x02\u{7b1}\u{7b0}\x03\x02\x02\x02\u{7b2}\u{7b5}\x03\x02\x02\x02\
	\u{7b3}\u{7b1}\x03\x02\x02\x02\u{7b3}\u{7b4}\x03\x02\x02\x02\u{7b4}\u{8e5}\
	\x03\x02\x02\x02\u{7b5}\u{7b3}\x03\x02\x02\x02\u{7b6}\u{7ba}\x07\x43\x02\
	\x02\u{7b7}\u{7b9}\x0a\x02\x02\x02\u{7b8}\u{7b7}\x03\x02\x02\x02\u{7b9}\
	\u{7bc}\x03\x02\x02\x02\u{7ba}\u{7b8}\x03\x02\x02\x02\u{7ba}\u{7bb}\x03\
	\x02\x02\x02\u{7bb}\u{8e5}\x03\x02\x02\x02\u{7bc}\u{7ba}\x03\x02\x02\x02\
	\u{7bd}\u{7be}\x07\x15\x02\x02\u{7be}\u{7c1}\x07\u{175}\x02\x02\u{7bf}\u{7c0}\
	\x07\u{ab}\x02\x02\u{7c0}\u{7c2}\x07\u{83}\x02\x02\u{7c1}\u{7bf}\x03\x02\
	\x02\x02\u{7c1}\u{7c2}\x03\x02\x02\x02\u{7c2}\u{7c3}\x03\x02\x02\x02\u{7c3}\
	\u{7c4}\x05\u{154}\u{ab}\x02\u{7c4}\u{7c5}\x07\u{13a}\x02\x02\u{7c5}\u{7c6}\
	\x07\u{183}\x02\x02\u{7c6}\u{7c7}\x05\u{154}\u{ab}\x02\u{7c7}\u{8e5}\x03\
	\x02\x02\x02\u{7c8}\u{7c9}\x07\x15\x02\x02\u{7c9}\u{7cc}\x07\u{175}\x02\
	\x02\u{7ca}\u{7cb}\x07\u{ab}\x02\x02\u{7cb}\u{7cd}\x07\u{83}\x02\x02\u{7cc}\
	\u{7ca}\x03\x02\x02\x02\u{7cc}\u{7cd}\x03\x02\x02\x02\u{7cd}\u{7ce}\x03\
	\x02\x02\x02\u{7ce}\u{7cf}\x05\u{154}\u{ab}\x02\u{7cf}\u{7d0}\x07\x11\x02\
	\x02\u{7d0}\u{7d4}\x07\x40\x02\x02\u{7d1}\u{7d2}\x07\u{ab}\x02\x02\u{7d2}\
	\u{7d3}\x07\u{100}\x02\x02\u{7d3}\u{7d5}\x07\u{83}\x02\x02\u{7d4}\u{7d1}\
	\x03\x02\x02\x02\u{7d4}\u{7d5}\x03\x02\x02\x02\u{7d5}\u{7d6}\x03\x02\x02\
	\x02\u{7d6}\u{7d7}\x05\x30\x19\x02\u{7d7}\u{8e5}\x03\x02\x02\x02\u{7d8}\
	\u{7d9}\x07\x15\x02\x02\u{7d9}\u{7dc}\x07\u{175}\x02\x02\u{7da}\u{7db}\x07\
	\u{ab}\x02\x02\u{7db}\u{7dd}\x07\u{83}\x02\x02\u{7dc}\u{7da}\x03\x02\x02\
	\x02\u{7dc}\u{7dd}\x03\x02\x02\x02\u{7dd}\u{7de}\x03\x02\x02\x02\u{7de}\
	\u{7df}\x05\u{154}\u{ab}\x02\u{7df}\u{7e0}\x07\u{13a}\x02\x02\u{7e0}\u{7e3}\
	\x07\x40\x02\x02\u{7e1}\u{7e2}\x07\u{ab}\x02\x02\u{7e2}\u{7e4}\x07\u{83}\
	\x02\x02\u{7e3}\u{7e1}\x03\x02\x02\x02\u{7e3}\u{7e4}\x03\x02\x02\x02\u{7e4}\
	\u{7e5}\x03\x02\x02\x02\u{7e5}\u{7e6}\x05\u{164}\u{b3}\x02\u{7e6}\u{7e7}\
	\x07\u{183}\x02\x02\u{7e7}\u{7e8}\x05\u{164}\u{b3}\x02\u{7e8}\u{8e5}\x03\
	\x02\x02\x02\u{7e9}\u{7ea}\x07\x15\x02\x02\u{7ea}\u{7ed}\x07\u{175}\x02\
	\x02\u{7eb}\u{7ec}\x07\u{ab}\x02\x02\u{7ec}\u{7ee}\x07\u{83}\x02\x02\u{7ed}\
	\u{7eb}\x03\x02\x02\x02\u{7ed}\u{7ee}\x03\x02\x02\x02\u{7ee}\u{7ef}\x03\
	\x02\x02\x02\u{7ef}\u{7f0}\x05\u{154}\u{ab}\x02\u{7f0}\u{7f1}\x07\x72\x02\
	\x02\u{7f1}\u{7f4}\x07\x40\x02\x02\u{7f2}\u{7f3}\x07\u{ab}\x02\x02\u{7f3}\
	\u{7f5}\x07\u{83}\x02\x02\u{7f4}\u{7f2}\x03\x02\x02\x02\u{7f4}\u{7f5}\x03\
	\x02\x02\x02\u{7f5}\u{7f6}\x03\x02\x02\x02\u{7f6}\u{7f7}\x05\u{154}\u{ab}\
	\x02\u{7f7}\u{8e5}\x03\x02\x02\x02\u{7f8}\u{7f9}\x07\x15\x02\x02\u{7f9}\
	\u{7fc}\x07\u{175}\x02\x02\u{7fa}\u{7fb}\x07\u{ab}\x02\x02\u{7fb}\u{7fd}\
	\x07\u{83}\x02\x02\u{7fc}\u{7fa}\x03\x02\x02\x02\u{7fc}\u{7fd}\x03\x02\x02\
	\x02\u{7fd}\u{7fe}\x03\x02\x02\x02\u{7fe}\u{7ff}\x05\u{154}\u{ab}\x02\u{7ff}\
	\u{800}\x07\x15\x02\x02\u{800}\u{801}\x07\x40\x02\x02\u{801}\u{802}\x05\
	\u{164}\u{b3}\x02\u{802}\u{803}\x07\u{160}\x02\x02\u{803}\u{804}\x07\x55\
	\x02\x02\u{804}\u{805}\x07\u{18e}\x02\x02\u{805}\u{806}\x05\u{134}\u{9b}\
	\x02\u{806}\u{8e5}\x03\x02\x02\x02\u{807}\u{808}\x07\x15\x02\x02\u{808}\
	\u{809}\x07\u{175}\x02\x02\u{809}\u{80a}\x05\u{154}\u{ab}\x02\u{80a}\u{80b}\
	\x07\u{160}\x02\x02\u{80b}\u{80c}\x07\x23\x02\x02\u{80c}\u{80d}\x05\u{162}\
	\u{b2}\x02\u{80d}\u{8e5}\x03\x02\x02\x02\u{80e}\u{80f}\x07\x15\x02\x02\u{80f}\
	\u{810}\x07\u{175}\x02\x02\u{810}\u{811}\x05\u{154}\u{ab}\x02\u{811}\u{812}\
	\x07\u{160}\x02\x02\u{812}\u{813}\x07\u{12d}\x02\x02\u{813}\u{814}\x05\x48\
	\x25\x02\u{814}\u{8e5}\x03\x02\x02\x02\u{815}\u{816}\x07\x15\x02\x02\u{816}\
	\u{817}\x07\u{175}\x02\x02\u{817}\u{818}\x05\u{154}\u{ab}\x02\u{818}\u{819}\
	\x07\u{82}\x02\x02\u{819}\u{829}\x05\u{164}\u{b3}\x02\u{81a}\u{823}\x07\
	\u{1bc}\x02\x02\u{81b}\u{820}\x05\u{10a}\u{86}\x02\u{81c}\u{81d}\x07\x42\
	\x02\x02\u{81d}\u{81f}\x05\u{10a}\u{86}\x02\u{81e}\u{81c}\x03\x02\x02\x02\
	\u{81f}\u{822}\x03\x02\x02\x02\u{820}\u{81e}\x03\x02\x02\x02\u{820}\u{821}\
	\x03\x02\x02\x02\u{821}\u{824}\x03\x02\x02\x02\u{822}\u{820}\x03\x02\x02\
	\x02\u{823}\u{81b}\x03\x02\x02\x02\u{823}\u{824}\x03\x02\x02\x02\u{824}\
	\u{826}\x03\x02\x02\x02\u{825}\u{827}\x07\x42\x02\x02\u{826}\u{825}\x03\
	\x02\x02\x02\u{826}\u{827}\x03\x02\x02\x02\u{827}\u{828}\x03\x02\x02\x02\
	\u{828}\u{82a}\x07\u{1bd}\x02\x02\u{829}\u{81a}\x03\x02\x02\x02\u{829}\u{82a}\
	\x03\x02\x02\x02\u{82a}\u{82d}\x03\x02\x02\x02\u{82b}\u{82c}\x07\u{1af}\
	\x02\x02\u{82c}\u{82e}\x05\u{fa}\x7e\x02\u{82d}\u{82b}\x03\x02\x02\x02\u{82d}\
	\u{82e}\x03\x02\x02\x02\u{82e}\u{8e5}\x03\x02\x02\x02\u{82f}\u{833}\x07\
	\x16\x02\x02\u{830}\u{832}\x0a\x02\x02\x02\u{831}\u{830}\x03\x02\x02\x02\
	\u{832}\u{835}\x03\x02\x02\x02\u{833}\u{831}\x03\x02\x02\x02\u{833}\u{834}\
	\x03\x02\x02\x02\u{834}\u{8e5}\x03\x02\x02\x02\u{835}\u{833}\x03\x02\x02\
	\x02\u{836}\u{837}\x07\u{138}\x02\x02\u{837}\u{838}\x07\u{e8}\x02\x02\u{838}\
	\u{839}\x07\u{1ab}\x02\x02\u{839}\u{8e5}\x05\u{154}\u{ab}\x02\u{83a}\u{83b}\
	\x07\x15\x02\x02\u{83b}\u{83c}\x07\u{e8}\x02\x02\u{83c}\u{83f}\x07\u{1ab}\
	\x02\x02\u{83d}\u{83e}\x07\u{ab}\x02\x02\u{83e}\u{840}\x07\u{83}\x02\x02\
	\u{83f}\u{83d}\x03\x02\x02\x02\u{83f}\u{840}\x03\x02\x02\x02\u{840}\u{841}\
	\x03\x02\x02\x02\u{841}\u{842}\x05\u{154}\u{ab}\x02\u{842}\u{843}\x07\u{13a}\
	\x02\x02\u{843}\u{844}\x07\u{183}\x02\x02\u{844}\u{845}\x05\u{154}\u{ab}\
	\x02\u{845}\u{8e5}\x03\x02\x02\x02\u{846}\u{847}\x07\x15\x02\x02\u{847}\
	\u{848}\x07\u{e8}\x02\x02\u{848}\u{849}\x07\u{1ab}\x02\x02\u{849}\u{84a}\
	\x05\u{154}\u{ab}\x02\u{84a}\u{84b}\x07\u{160}\x02\x02\u{84b}\u{84c}\x07\
	\u{12d}\x02\x02\u{84c}\u{84d}\x05\x48\x25\x02\u{84d}\u{8e5}\x03\x02\x02\
	\x02\u{84e}\u{84f}\x07\x15\x02\x02\u{84f}\u{850}\x07\u{1ab}\x02\x02\u{850}\
	\u{851}\x05\u{154}\u{ab}\x02\u{851}\u{852}\x07\u{13a}\x02\x02\u{852}\u{853}\
	\x07\u{183}\x02\x02\u{853}\u{854}\x05\u{154}\u{ab}\x02\u{854}\u{8e5}\x03\
	\x02\x02\x02\u{855}\u{856}\x07\x15\x02\x02\u{856}\u{857}\x07\u{1ab}\x02\
	\x02\u{857}\u{858}\x05\u{154}\u{ab}\x02\u{858}\u{859}\x07\u{160}\x02\x02\
	\u{859}\u{85a}\x07\x23\x02\x02\u{85a}\u{85b}\x05\u{162}\u{b2}\x02\u{85b}\
	\u{8e5}\x03\x02\x02\x02\u{85c}\u{860}\x07\x2f\x02\x02\u{85d}\u{85f}\x0a\
	\x02\x02\x02\u{85e}\u{85d}\x03\x02\x02\x02\u{85f}\u{862}\x03\x02\x02\x02\
	\u{860}\u{85e}\x03\x02\x02\x02\u{860}\u{861}\x03\x02\x02\x02\u{861}\u{8e5}\
	\x03\x02\x02\x02\u{862}\u{860}\x03\x02\x02\x02\u{863}\u{864}\x07\x50\x02\
	\x02\u{864}\u{868}\x07\u{148}\x02\x02\u{865}\u{867}\x0a\x02\x02\x02\u{866}\
	\u{865}\x03\x02\x02\x02\u{867}\u{86a}\x03\x02\x02\x02\u{868}\u{866}\x03\
	\x02\x02\x02\u{868}\u{869}\x03\x02\x02\x02\u{869}\u{8e5}\x03\x02\x02\x02\
	\u{86a}\u{868}\x03\x02\x02\x02\u{86b}\u{86f}\x07\u{9d}\x02\x02\u{86c}\u{86e}\
	\x0a\x02\x02\x02\u{86d}\u{86c}\x03\x02\x02\x02\u{86e}\u{871}\x03\x02\x02\
	\x02\u{86f}\u{86d}\x03\x02\x02\x02\u{86f}\u{870}\x03\x02\x02\x02\u{870}\
	\u{8e5}\x03\x02\x02\x02\u{871}\u{86f}\x03\x02\x02\x02\u{872}\u{876}\x07\
	\u{144}\x02\x02\u{873}\u{875}\x0a\x02\x02\x02\u{874}\u{873}\x03\x02\x02\
	\x02\u{875}\u{878}\x03\x02\x02\x02\u{876}\u{874}\x03\x02\x02\x02\u{876}\
	\u{877}\x03\x02\x02\x02\u{877}\u{8e5}\x03\x02\x02\x02\u{878}\u{876}\x03\
	\x02\x02\x02\u{879}\u{887}\x07\x63\x02\x02\u{87a}\u{87f}\x05\u{152}\u{aa}\
	\x02\u{87b}\u{87c}\x07\x42\x02\x02\u{87c}\u{87e}\x05\u{152}\u{aa}\x02\u{87d}\
	\u{87b}\x03\x02\x02\x02\u{87e}\u{881}\x03\x02\x02\x02\u{87f}\u{87d}\x03\
	\x02\x02\x02\u{87f}\u{880}\x03\x02\x02\x02\u{880}\u{883}\x03\x02\x02\x02\
	\u{881}\u{87f}\x03\x02\x02\x02\u{882}\u{884}\x07\x42\x02\x02\u{883}\u{882}\
	\x03\x02\x02\x02\u{883}\u{884}\x03\x02\x02\x02\u{884}\u{888}\x03\x02\x02\
	\x02\u{885}\u{886}\x07\x14\x02\x02\u{886}\u{888}\x07\u{12c}\x02\x02\u{887}\
	\u{87a}\x03\x02\x02\x02\u{887}\u{885}\x03\x02\x02\x02\u{888}\u{889}\x03\
	\x02\x02\x02\u{889}\u{88b}\x07\u{108}\x02\x02\u{88a}\u{88c}\x09\x0a\x02\
	\x02\u{88b}\u{88a}\x03\x02\x02\x02\u{88b}\u{88c}\x03\x02\x02\x02\u{88c}\
	\u{88d}\x03\x02\x02\x02\u{88d}\u{88e}\x05\u{154}\u{ab}\x02\u{88e}\u{88f}\
	\x07\u{183}\x02\x02\u{88f}\u{890}\x05\u{162}\u{b2}\x02\u{890}\u{8e5}\x03\
	\x02\x02\x02\u{891}\u{894}\x07\u{84}\x02\x02\u{892}\u{893}\x07\u{19f}\x02\
	\x02\u{893}\u{895}\x05\u{164}\u{b3}\x02\u{894}\u{892}\x03\x02\x02\x02\u{894}\
	\u{895}\x03\x02\x02\x02\u{895}\u{896}\x03\x02\x02\x02\u{896}\u{8e5}\x05\
	\x0c\x07\x02\u{897}\u{89b}\x07\u{162}\x02\x02\u{898}\u{89a}\x0a\x02\x02\
	\x02\u{899}\u{898}\x03\x02\x02\x02\u{89a}\u{89d}\x03\x02\x02\x02\u{89b}\
	\u{899}\x03\x02\x02\x02\u{89b}\u{89c}\x03\x02\x02\x02\u{89c}\u{8e5}\x03\
	\x02\x02\x02\u{89d}\u{89b}\x03\x02\x02\x02\u{89e}\u{8a2}\x07\u{13d}\x02\
	\x02\u{89f}\u{8a1}\x0a\x02\x02\x02\u{8a0}\u{89f}\x03\x02\x02\x02\u{8a1}\
	\u{8a4}\x03\x02\x02\x02\u{8a2}\u{8a0}\x03\x02\x02\x02\u{8a2}\u{8a3}\x03\
	\x02\x02\x02\u{8a3}\u{8e5}\x03\x02\x02\x02\u{8a4}\u{8a2}\x03\x02\x02\x02\
	\u{8a5}\u{8a6}\x07\u{16a}\x02\x02\u{8a6}\u{8b2}\x07\u{187}\x02\x02\u{8a7}\
	\u{8ac}\x05\u{14e}\u{a8}\x02\u{8a8}\u{8a9}\x07\x42\x02\x02\u{8a9}\u{8ab}\
	\x05\u{14e}\u{a8}\x02\u{8aa}\u{8a8}\x03\x02\x02\x02\u{8ab}\u{8ae}\x03\x02\
	\x02\x02\u{8ac}\u{8aa}\x03\x02\x02\x02\u{8ac}\u{8ad}\x03\x02\x02\x02\u{8ad}\
	\u{8b0}\x03\x02\x02\x02\u{8ae}\u{8ac}\x03\x02\x02\x02\u{8af}\u{8b1}\x07\
	\x42\x02\x02\u{8b0}\u{8af}\x03\x02\x02\x02\u{8b0}\u{8b1}\x03\x02\x02\x02\
	\u{8b1}\u{8b3}\x03\x02\x02\x02\u{8b2}\u{8a7}\x03\x02\x02\x02\u{8b2}\u{8b3}\
	\x03\x02\x02\x02\u{8b3}\u{8e5}\x03\x02\x02\x02\u{8b4}\u{8b8}\x07\x44\x02\
	\x02\u{8b5}\u{8b7}\x0a\x02\x02\x02\u{8b6}\u{8b5}\x03\x02\x02\x02\u{8b7}\
	\u{8ba}\x03\x02\x02\x02\u{8b8}\u{8b6}\x03\x02\x02\x02\u{8b8}\u{8b9}\x03\
	\x02\x02\x02\u{8b9}\u{8e5}\x03\x02\x02\x02\u{8ba}\u{8b8}\x03\x02\x02\x02\
	\u{8bb}\u{8bf}\x07\u{14a}\x02\x02\u{8bc}\u{8be}\x0a\x02\x02\x02\u{8bd}\u{8bc}\
	\x03\x02\x02\x02\u{8be}\u{8c1}\x03\x02\x02\x02\u{8bf}\u{8bd}\x03\x02\x02\
	\x02\u{8bf}\u{8c0}\x03\x02\x02\x02\u{8c0}\u{8e5}\x03\x02\x02\x02\u{8c1}\
	\u{8bf}\x03\x02\x02\x02\u{8c2}\u{8c6}\x07\u{128}\x02\x02\u{8c3}\u{8c5}\x0a\
	\x02\x02\x02\u{8c4}\u{8c3}\x03\x02\x02\x02\u{8c5}\u{8c8}\x03\x02\x02\x02\
	\u{8c6}\u{8c4}\x03\x02\x02\x02\u{8c6}\u{8c7}\x03\x02\x02\x02\u{8c7}\u{8e5}\
	\x03\x02\x02\x02\u{8c8}\u{8c6}\x03\x02\x02\x02\u{8c9}\u{8cd}\x07\x59\x02\
	\x02\u{8ca}\u{8cc}\x0a\x02\x02\x02\u{8cb}\u{8ca}\x03\x02\x02\x02\u{8cc}\
	\u{8cf}\x03\x02\x02\x02\u{8cd}\u{8cb}\x03\x02\x02\x02\u{8cd}\u{8ce}\x03\
	\x02\x02\x02\u{8ce}\u{8e5}\x03\x02\x02\x02\u{8cf}\u{8cd}\x03\x02\x02\x02\
	\u{8d0}\u{8d4}\x07\u{82}\x02\x02\u{8d1}\u{8d3}\x0a\x02\x02\x02\u{8d2}\u{8d1}\
	\x03\x02\x02\x02\u{8d3}\u{8d6}\x03\x02\x02\x02\u{8d4}\u{8d2}\x03\x02\x02\
	\x02\u{8d4}\u{8d5}\x03\x02\x02\x02\u{8d5}\u{8e5}\x03\x02\x02\x02\u{8d6}\
	\u{8d4}\x03\x02\x02\x02\u{8d7}\u{8d8}\x07\x67\x02\x02\u{8d8}\u{8d9}\x07\
	\u{b7}\x02\x02\u{8d9}\u{8e5}\x05\u{164}\u{b3}\x02\u{8da}\u{8db}\x07\x67\
	\x02\x02\u{8db}\u{8dc}\x07\u{111}\x02\x02\u{8dc}\u{8e5}\x05\u{164}\u{b3}\
	\x02\u{8dd}\u{8e1}\x07\u{19c}\x02\x02\u{8de}\u{8e0}\x0a\x02\x02\x02\u{8df}\
	\u{8de}\x03\x02\x02\x02\u{8e0}\u{8e3}\x03\x02\x02\x02\u{8e1}\u{8df}\x03\
	\x02\x02\x02\u{8e1}\u{8e2}\x03\x02\x02\x02\u{8e2}\u{8e5}\x03\x02\x02\x02\
	\u{8e3}\u{8e1}\x03\x02\x02\x02\u{8e4}\u{19d}\x03\x02\x02\x02\u{8e4}\u{19e}\
	\x03\x02\x02\x02\u{8e4}\u{1a0}\x03\x02\x02\x02\u{8e4}\u{1a5}\x03\x02\x02\
	\x02\u{8e4}\u{1b2}\x03\x02\x02\x02\u{8e4}\u{1b9}\x03\x02\x02\x02\u{8e4}\
	\u{1c0}\x03\x02\x02\x02\u{8e4}\u{1c3}\x03\x02\x02\x02\u{8e4}\u{1c6}\x03\
	\x02\x02\x02\u{8e4}\u{1ed}\x03\x02\x02\x02\u{8e4}\u{20c}\x03\x02\x02\x02\
	\u{8e4}\u{232}\x03\x02\x02\x02\u{8e4}\u{25d}\x03\x02\x02\x02\u{8e4}\u{27d}\
	\x03\x02\x02\x02\u{8e4}\u{2a1}\x03\x02\x02\x02\u{8e4}\u{2bd}\x03\x02\x02\
	\x02\u{8e4}\u{2da}\x03\x02\x02\x02\u{8e4}\u{2e7}\x03\x02\x02\x02\u{8e4}\
	\u{2fc}\x03\x02\x02\x02\u{8e4}\u{35a}\x03\x02\x02\x02\u{8e4}\u{3b4}\x03\
	\x02\x02\x02\u{8e4}\u{3b6}\x03\x02\x02\x02\u{8e4}\u{3cd}\x03\x02\x02\x02\
	\u{8e4}\u{3d0}\x03\x02\x02\x02\u{8e4}\u{3f1}\x03\x02\x02\x02\u{8e4}\u{451}\
	\x03\x02\x02\x02\u{8e4}\u{4ae}\x03\x02\x02\x02\u{8e4}\u{50e}\x03\x02\x02\
	\x02\u{8e4}\u{56e}\x03\x02\x02\x02\u{8e4}\u{5cb}\x03\x02\x02\x02\u{8e4}\
	\u{617}\x03\x02\x02\x02\u{8e4}\u{660}\x03\x02\x02\x02\u{8e4}\u{6af}\x03\
	\x02\x02\x02\u{8e4}\u{6f7}\x03\x02\x02\x02\u{8e4}\u{752}\x03\x02\x02\x02\
	\u{8e4}\u{754}\x03\x02\x02\x02\u{8e4}\u{75b}\x03\x02\x02\x02\u{8e4}\u{762}\
	\x03\x02\x02\x02\u{8e4}\u{769}\x03\x02\x02\x02\u{8e4}\u{770}\x03\x02\x02\
	\x02\u{8e4}\u{77c}\x03\x02\x02\x02\u{8e4}\u{788}\x03\x02\x02\x02\u{8e4}\
	\u{795}\x03\x02\x02\x02\u{8e4}\u{7a1}\x03\x02\x02\x02\u{8e4}\u{7a8}\x03\
	\x02\x02\x02\u{8e4}\u{7af}\x03\x02\x02\x02\u{8e4}\u{7b6}\x03\x02\x02\x02\
	\u{8e4}\u{7bd}\x03\x02\x02\x02\u{8e4}\u{7c8}\x03\x02\x02\x02\u{8e4}\u{7d8}\
	\x03\x02\x02\x02\u{8e4}\u{7e9}\x03\x02\x02\x02\u{8e4}\u{7f8}\x03\x02\x02\
	\x02\u{8e4}\u{807}\x03\x02\x02\x02\u{8e4}\u{80e}\x03\x02\x02\x02\u{8e4}\
	\u{815}\x03\x02\x02\x02\u{8e4}\u{82f}\x03\x02\x02\x02\u{8e4}\u{836}\x03\
	\x02\x02\x02\u{8e4}\u{83a}\x03\x02\x02\x02\u{8e4}\u{846}\x03\x02\x02\x02\
	\u{8e4}\u{84e}\x03\x02\x02\x02\u{8e4}\u{855}\x03\x02\x02\x02\u{8e4}\u{85c}\
	\x03\x02\x02\x02\u{8e4}\u{863}\x03\x02\x02\x02\u{8e4}\u{86b}\x03\x02\x02\
	\x02\u{8e4}\u{872}\x03\x02\x02\x02\u{8e4}\u{879}\x03\x02\x02\x02\u{8e4}\
	\u{891}\x03\x02\x02\x02\u{8e4}\u{897}\x03\x02\x02\x02\u{8e4}\u{89e}\x03\
	\x02\x02\x02\u{8e4}\u{8a5}\x03\x02\x02\x02\u{8e4}\u{8b4}\x03\x02\x02\x02\
	\u{8e4}\u{8bb}\x03\x02\x02\x02\u{8e4}\u{8c2}\x03\x02\x02\x02\u{8e4}\u{8c9}\
	\x03\x02\x02\x02\u{8e4}\u{8d0}\x03\x02\x02\x02\u{8e4}\u{8d7}\x03\x02\x02\
	\x02\u{8e4}\u{8da}\x03\x02\x02\x02\u{8e4}\u{8dd}\x03\x02\x02\x02\u{8e5}\
	\x0d\x03\x02\x02\x02\u{8e6}\u{8eb}\x05\x2e\x18\x02\u{8e7}\u{8e8}\x07\x42\
	\x02\x02\u{8e8}\u{8ea}\x05\x2e\x18\x02\u{8e9}\u{8e7}\x03\x02\x02\x02\u{8ea}\
	\u{8ed}\x03\x02\x02\x02\u{8eb}\u{8e9}\x03\x02\x02\x02\u{8eb}\u{8ec}\x03\
	\x02\x02\x02\u{8ec}\x0f\x03\x02\x02\x02\u{8ed}\u{8eb}\x03\x02\x02\x02\u{8ee}\
	\u{8ef}\x09\x0b\x02\x02\u{8ef}\u{8f0}\x07\u{103}\x02\x02\u{8f0}\x11\x03\
	\x02\x02\x02\u{8f1}\u{8f2}\x07\x3e\x02\x02\u{8f2}\u{8f3}\x07\x2d\x02\x02\
	\u{8f3}\u{8f4}\x07\u{1bc}\x02\x02\u{8f4}\u{8f9}\x05\u{f8}\x7d\x02\u{8f5}\
	\u{8f6}\x07\x42\x02\x02\u{8f6}\u{8f8}\x05\u{f8}\x7d\x02\u{8f7}\u{8f5}\x03\
	\x02\x02\x02\u{8f8}\u{8fb}\x03\x02\x02\x02\u{8f9}\u{8f7}\x03\x02\x02\x02\
	\u{8f9}\u{8fa}\x03\x02\x02\x02\u{8fa}\u{8fc}\x03\x02\x02\x02\u{8fb}\u{8f9}\
	\x03\x02\x02\x02\u{8fc}\u{8fd}\x07\u{1bd}\x02\x02\u{8fd}\u{91a}\x03\x02\
	\x02\x02\u{8fe}\u{91a}\x05\x4a\x26\x02\u{8ff}\u{900}\x07\x4e\x02\x02\u{900}\
	\u{91a}\x07\u{9f}\x02\x02\u{901}\u{903}\x07\u{1b1}\x02\x02\u{902}\u{901}\
	\x03\x02\x02\x02\u{902}\u{903}\x03\x02\x02\x02\u{903}\u{904}\x03\x02\x02\
	\x02\u{904}\u{905}\x07\u{14c}\x02\x02\u{905}\u{906}\x07\x10\x02\x02\u{906}\
	\u{907}\x07\u{124}\x02\x02\u{907}\u{908}\x05\u{164}\u{b3}\x02\u{908}\u{909}\
	\x07\u{108}\x02\x02\u{909}\u{90a}\x07\u{1bc}\x02\x02\u{90a}\u{90f}\x05\u{164}\
	\u{b3}\x02\u{90b}\u{90c}\x07\x42\x02\x02\u{90c}\u{90e}\x05\u{164}\u{b3}\
	\x02\u{90d}\u{90b}\x03\x02\x02\x02\u{90e}\u{911}\x03\x02\x02\x02\u{90f}\
	\u{90d}\x03\x02\x02\x02\u{90f}\u{910}\x03\x02\x02\x02\u{910}\u{912}\x03\
	\x02\x02\x02\u{911}\u{90f}\x03\x02\x02\x02\u{912}\u{913}\x07\u{1bd}\x02\
	\x02\u{913}\u{91a}\x03\x02\x02\x02\u{914}\u{916}\x07\u{1b1}\x02\x02\u{915}\
	\u{914}\x03\x02\x02\x02\u{915}\u{916}\x03\x02\x02\x02\u{916}\u{917}\x03\
	\x02\x02\x02\u{917}\u{918}\x07\u{178}\x02\x02\u{918}\u{91a}\x05\x46\x24\
	\x02\u{919}\u{8f1}\x03\x02\x02\x02\u{919}\u{8fe}\x03\x02\x02\x02\u{919}\
	\u{8ff}\x03\x02\x02\x02\u{919}\u{902}\x03\x02\x02\x02\u{919}\u{915}\x03\
	\x02\x02\x02\u{91a}\u{91d}\x03\x02\x02\x02\u{91b}\u{919}\x03\x02\x02\x02\
	\u{91b}\u{91c}\x03\x02\x02\x02\u{91c}\x13\x03\x02\x02\x02\u{91d}\u{91b}\
	\x03\x02\x02\x02\u{91e}\u{91f}\x07\x4c\x02\x02\u{91f}\u{921}\x05\u{164}\
	\u{b3}\x02\u{920}\u{91e}\x03\x02\x02\x02\u{920}\u{921}\x03\x02\x02\x02\u{921}\
	\u{937}\x03\x02\x02\x02\u{922}\u{924}\x07\u{194}\x02\x02\u{923}\u{925}\x05\
	\u{e2}\x72\x02\u{924}\u{923}\x03\x02\x02\x02\u{924}\u{925}\x03\x02\x02\x02\
	\u{925}\u{938}\x03\x02\x02\x02\u{926}\u{927}\x07\u{12b}\x02\x02\u{927}\u{929}\
	\x07\u{cd}\x02\x02\u{928}\u{92a}\x05\u{e2}\x72\x02\u{929}\u{928}\x03\x02\
	\x02\x02\u{929}\u{92a}\x03\x02\x02\x02\u{92a}\u{938}\x03\x02\x02\x02\u{92b}\
	\u{92c}\x07\u{93}\x02\x02\u{92c}\u{92e}\x07\u{cd}\x02\x02\u{92d}\u{92b}\
	\x03\x02\x02\x02\u{92d}\u{92e}\x03\x02\x02\x02\u{92e}\u{930}\x03\x02\x02\
	\x02\u{92f}\u{931}\x05\u{e2}\x72\x02\u{930}\u{92f}\x03\x02\x02\x02\u{930}\
	\u{931}\x03\x02\x02\x02\u{931}\u{932}\x03\x02\x02\x02\u{932}\u{933}\x07\
	\u{137}\x02\x02\u{933}\u{935}\x05\u{154}\u{ab}\x02\u{934}\u{936}\x05\u{e2}\
	\x72\x02\u{935}\u{934}\x03\x02\x02\x02\u{935}\u{936}\x03\x02\x02\x02\u{936}\
	\u{938}\x03\x02\x02\x02\u{937}\u{922}\x03\x02\x02\x02\u{937}\u{926}\x03\
	\x02\x02\x02\u{937}\u{92d}\x03\x02\x02\x02\u{938}\u{939}\x03\x02\x02\x02\
	\u{939}\u{93a}\x05\x16\x0c\x02\u{93a}\x15\x03\x02\x02\x02\u{93b}\u{93d}\
	\x07\u{100}\x02\x02\u{93c}\u{93b}\x03\x02\x02\x02\u{93c}\u{93d}\x03\x02\
	\x02\x02\u{93d}\u{93e}\x03\x02\x02\x02\u{93e}\u{940}\x07\x7a\x02\x02\u{93f}\
	\u{93c}\x03\x02\x02\x02\u{93f}\u{940}\x03\x02\x02\x02\u{940}\u{945}\x03\
	\x02\x02\x02\u{941}\u{943}\x07\u{100}\x02\x02\u{942}\u{941}\x03\x02\x02\
	\x02\u{942}\u{943}\x03\x02\x02\x02\u{943}\u{944}\x03\x02\x02\x02\u{944}\
	\u{946}\x07\x64\x02\x02\u{945}\u{942}\x03\x02\x02\x02\u{945}\u{946}\x03\
	\x02\x02\x02\u{946}\u{949}\x03\x02\x02\x02\u{947}\u{948}\x07\u{b5}\x02\x02\
	\u{948}\u{94a}\x09\x0c\x02\x02\u{949}\u{947}\x03\x02\x02\x02\u{949}\u{94a}\
	\x03\x02\x02\x02\u{94a}\u{94c}\x03\x02\x02\x02\u{94b}\u{94d}\x09\x0d\x02\
	\x02\u{94c}\u{94b}\x03\x02\x02\x02\u{94c}\u{94d}\x03\x02\x02\x02\u{94d}\
	\u{94f}\x03\x02\x02\x02\u{94e}\u{950}\x09\x0e\x02\x02\u{94f}\u{94e}\x03\
	\x02\x02\x02\u{94f}\u{950}\x03\x02\x02\x02\u{950}\u{952}\x03\x02\x02\x02\
	\u{951}\u{953}\x09\x0f\x02\x02\u{952}\u{951}\x03\x02\x02\x02\u{952}\u{953}\
	\x03\x02\x02\x02\u{953}\x17\x03\x02\x02\x02\u{954}\u{955}\x07\u{1bc}\x02\
	\x02\u{955}\u{95a}\x05\x1a\x0e\x02\u{956}\u{957}\x07\x42\x02\x02\u{957}\
	\u{959}\x05\x1a\x0e\x02\u{958}\u{956}\x03\x02\x02\x02\u{959}\u{95c}\x03\
	\x02\x02\x02\u{95a}\u{958}\x03\x02\x02\x02\u{95a}\u{95b}\x03\x02\x02\x02\
	\u{95b}\u{95e}\x03\x02\x02\x02\u{95c}\u{95a}\x03\x02\x02\x02\u{95d}\u{95f}\
	\x07\x42\x02\x02\u{95e}\u{95d}\x03\x02\x02\x02\u{95e}\u{95f}\x03\x02\x02\
	\x02\u{95f}\u{960}\x03\x02\x02\x02\u{960}\u{961}\x07\u{1bd}\x02\x02\u{961}\
	\x19\x03\x02\x02\x02\u{962}\u{965}\x05\u{f8}\x7d\x02\u{963}\u{965}\x07\x5c\
	\x02\x02\u{964}\u{962}\x03\x02\x02\x02\u{964}\u{963}\x03\x02\x02\x02\u{965}\
	\x1b\x03\x02\x02\x02\u{966}\u{97d}\x05\x1e\x10\x02\u{967}\u{97d}\x05\x4a\
	\x26\x02\u{968}\u{97d}\x05\x20\x11\x02\u{969}\u{96a}\x07\x4e\x02\x02\u{96a}\
	\u{97d}\x07\u{9f}\x02\x02\u{96b}\u{96d}\x07\u{1b1}\x02\x02\u{96c}\u{96b}\
	\x03\x02\x02\x02\u{96c}\u{96d}\x03\x02\x02\x02\u{96d}\u{96e}\x03\x02\x02\
	\x02\u{96e}\u{96f}\x07\u{14c}\x02\x02\u{96f}\u{970}\x07\x10\x02\x02\u{970}\
	\u{971}\x07\u{124}\x02\x02\u{971}\u{972}\x05\u{164}\u{b3}\x02\u{972}\u{973}\
	\x07\u{108}\x02\x02\u{973}\u{974}\x07\u{1bc}\x02\x02\u{974}\u{975}\x05\u{164}\
	\u{b3}\x02\u{975}\u{976}\x07\u{1bd}\x02\x02\u{976}\u{97d}\x03\x02\x02\x02\
	\u{977}\u{979}\x07\u{1b1}\x02\x02\u{978}\u{977}\x03\x02\x02\x02\u{978}\u{979}\
	\x03\x02\x02\x02\u{979}\u{97a}\x03\x02\x02\x02\u{97a}\u{97b}\x07\u{178}\
	\x02\x02\u{97b}\u{97d}\x05\x46\x24\x02\u{97c}\u{966}\x03\x02\x02\x02\u{97c}\
	\u{967}\x03\x02\x02\x02\u{97c}\u{968}\x03\x02\x02\x02\u{97c}\u{969}\x03\
	\x02\x02\x02\u{97c}\u{96c}\x03\x02\x02\x02\u{97c}\u{978}\x03\x02\x02\x02\
	\u{97d}\u{980}\x03\x02\x02\x02\u{97e}\u{97c}\x03\x02\x02\x02\u{97e}\u{97f}\
	\x03\x02\x02\x02\u{97f}\x1d\x03\x02\x02\x02\u{980}\u{97e}\x03\x02\x02\x02\
	\u{981}\u{983}\x07\u{1b1}\x02\x02\u{982}\u{981}\x03\x02\x02\x02\u{982}\u{983}\
	\x03\x02\x02\x02\u{983}\u{984}\x03\x02\x02\x02\u{984}\u{985}\x07\u{de}\x02\
	\x02\u{985}\u{986}\x07\u{1c1}\x02\x02\u{986}\u{987}\x07\u{1de}\x02\x02\u{987}\
	\x1f\x03\x02\x02\x02\u{988}\u{989}\x07\u{116}\x02\x02\u{989}\u{98a}\x07\
	\x2d\x02\x02\u{98a}\u{98b}\x05\u{e2}\x72\x02\u{98b}\x21\x03\x02\x02\x02\
	\u{98c}\u{98d}\x07\u{16d}\x02\x02\u{98d}\u{98e}\x07\x1e\x02\x02\u{98e}\u{98f}\
	\x05\u{164}\u{b3}\x02\u{98f}\x23\x03\x02\x02\x02\u{990}\u{991}\x07\x47\x02\
	\x02\u{991}\u{992}\x07\u{18e}\x02\x02\u{992}\u{993}\x09\x10\x02\x02\u{993}\
	\x25\x03\x02\x02\x02\u{994}\u{995}\x07\u{1b1}\x02\x02\u{995}\u{996}\x07\
	\u{a6}\x02\x02\u{996}\u{997}\x07\u{14c}\x02\x02\u{997}\x27\x03\x02\x02\x02\
	\u{998}\u{999}\x07\x62\x02\x02\u{999}\u{99a}\x05\u{122}\u{92}\x02\u{99a}\
	\x29\x03\x02\x02\x02\u{99b}\u{99d}\x05\x2c\x17\x02\u{99c}\u{99b}\x03\x02\
	\x02\x02\u{99c}\u{99d}\x03\x02\x02\x02\u{99d}\u{99e}\x03\x02\x02\x02\u{99e}\
	\u{99f}\x05\x50\x29\x02\u{99f}\x2b\x03\x02\x02\x02\u{9a0}\u{9a2}\x07\u{1b1}\
	\x02\x02\u{9a1}\u{9a3}\x07\u{134}\x02\x02\u{9a2}\u{9a1}\x03\x02\x02\x02\
	\u{9a2}\u{9a3}\x03\x02\x02\x02\u{9a3}\u{9a4}\x03\x02\x02\x02\u{9a4}\u{9a9}\
	\x05\u{88}\x45\x02\u{9a5}\u{9a6}\x07\x42\x02\x02\u{9a6}\u{9a8}\x05\u{88}\
	\x45\x02\u{9a7}\u{9a5}\x03\x02\x02\x02\u{9a8}\u{9ab}\x03\x02\x02\x02\u{9a9}\
	\u{9a7}\x03\x02\x02\x02\u{9a9}\u{9aa}\x03\x02\x02\x02\u{9aa}\x2d\x03\x02\
	\x02\x02\u{9ab}\u{9a9}\x03\x02\x02\x02\u{9ac}\u{9af}\x05\x14\x0b\x02\u{9ad}\
	\u{9af}\x05\x30\x19\x02\u{9ae}\u{9ac}\x03\x02\x02\x02\u{9ae}\u{9ad}\x03\
	\x02\x02\x02\u{9af}\x2f\x03\x02\x02\x02\u{9b0}\u{9b2}\x05\x38\x1d\x02\u{9b1}\
	\u{9b3}\x05\x32\x1a\x02\u{9b2}\u{9b1}\x03\x02\x02\x02\u{9b2}\u{9b3}\x03\
	\x02\x02\x02\u{9b3}\u{9b6}\x03\x02\x02\x02\u{9b4}\u{9b5}\x07\u{100}\x02\
	\x02\u{9b5}\u{9b7}\x07\u{102}\x02\x02\u{9b6}\u{9b4}\x03\x02\x02\x02\u{9b6}\
	\u{9b7}\x03\x02\x02\x02\u{9b7}\u{9ba}\x03\x02\x02\x02\u{9b8}\u{9b9}\x07\
	\x3f\x02\x02\u{9b9}\u{9bb}\x05\u{122}\u{92}\x02\u{9ba}\u{9b8}\x03\x02\x02\
	\x02\u{9ba}\u{9bb}\x03\x02\x02\x02\u{9bb}\u{9cf}\x03\x02\x02\x02\u{9bc}\
	\u{9bd}\x07\x5c\x02\x02\u{9bd}\u{9ce}\x05\u{f8}\x7d\x02\u{9be}\u{9c8}\x09\
	\x11\x02\x02\u{9bf}\u{9c0}\x05\u{172}\u{ba}\x02\u{9c0}\u{9c1}\x07\x42\x02\
	\x02\u{9c1}\u{9c2}\x05\u{172}\u{ba}\x02\u{9c2}\u{9c9}\x03\x02\x02\x02\u{9c3}\
	\u{9c4}\x07\u{16a}\x02\x02\u{9c4}\u{9c5}\x05\u{172}\u{ba}\x02\u{9c5}\u{9c6}\
	\x07\u{b2}\x02\x02\u{9c6}\u{9c7}\x05\u{172}\u{ba}\x02\u{9c7}\u{9c9}\x03\
	\x02\x02\x02\u{9c8}\u{9bf}\x03\x02\x02\x02\u{9c8}\u{9c3}\x03\x02\x02\x02\
	\u{9c8}\u{9c9}\x03\x02\x02\x02\u{9c9}\u{9cb}\x03\x02\x02\x02\u{9ca}\u{9cc}\
	\x09\x12\x02\x02\u{9cb}\u{9ca}\x03\x02\x02\x02\u{9cb}\u{9cc}\x03\x02\x02\
	\x02\u{9cc}\u{9ce}\x03\x02\x02\x02\u{9cd}\u{9bc}\x03\x02\x02\x02\u{9cd}\
	\u{9be}\x03\x02\x02\x02\u{9ce}\u{9d0}\x03\x02\x02\x02\u{9cf}\u{9cd}\x03\
	\x02\x02\x02\u{9cf}\u{9d0}\x03\x02\x02\x02\u{9d0}\u{9e5}\x03\x02\x02\x02\
	\u{9d1}\u{9d3}\x07\u{1b1}\x02\x02\u{9d2}\u{9d1}\x03\x02\x02\x02\u{9d2}\u{9d3}\
	\x03\x02\x02\x02\u{9d3}\u{9d4}\x03\x02\x02\x02\u{9d4}\u{9d5}\x07\u{e2}\x02\
	\x02\u{9d5}\u{9d6}\x07\u{124}\x02\x02\u{9d6}\u{9e3}\x05\u{164}\u{b3}\x02\
	\u{9d7}\u{9d8}\x07\u{19f}\x02\x02\u{9d8}\u{9d9}\x07\u{1bc}\x02\x02\u{9d9}\
	\u{9de}\x05\u{164}\u{b3}\x02\u{9da}\u{9db}\x07\x42\x02\x02\u{9db}\u{9dd}\
	\x05\u{164}\u{b3}\x02\u{9dc}\u{9da}\x03\x02\x02\x02\u{9dd}\u{9e0}\x03\x02\
	\x02\x02\u{9de}\u{9dc}\x03\x02\x02\x02\u{9de}\u{9df}\x03\x02\x02\x02\u{9df}\
	\u{9e1}\x03\x02\x02\x02\u{9e0}\u{9de}\x03\x02\x02\x02\u{9e1}\u{9e2}\x07\
	\u{1bd}\x02\x02\u{9e2}\u{9e4}\x03\x02\x02\x02\u{9e3}\u{9d7}\x03\x02\x02\
	\x02\u{9e3}\u{9e4}\x03\x02\x02\x02\u{9e4}\u{9e6}\x03\x02\x02\x02\u{9e5}\
	\u{9d2}\x03\x02\x02\x02\u{9e5}\u{9e6}\x03\x02\x02\x02\u{9e6}\u{9ec}\x03\
	\x02\x02\x02\u{9e7}\u{9e9}\x07\u{1b1}\x02\x02\u{9e8}\u{9e7}\x03\x02\x02\
	\x02\u{9e8}\u{9e9}\x03\x02\x02\x02\u{9e9}\u{9ea}\x03\x02\x02\x02\u{9ea}\
	\u{9eb}\x07\u{178}\x02\x02\u{9eb}\u{9ed}\x05\x46\x24\x02\u{9ec}\u{9e8}\x03\
	\x02\x02\x02\u{9ec}\u{9ed}\x03\x02\x02\x02\u{9ed}\u{9f0}\x03\x02\x02\x02\
	\u{9ee}\u{9ef}\x07\x43\x02\x02\u{9ef}\u{9f1}\x05\u{122}\u{92}\x02\u{9f0}\
	\u{9ee}\x03\x02\x02\x02\u{9f0}\u{9f1}\x03\x02\x02\x02\u{9f1}\x31\x03\x02\
	\x02\x02\u{9f2}\u{9f3}\x07\x4c\x02\x02\u{9f3}\u{9f5}\x05\u{164}\u{b3}\x02\
	\u{9f4}\u{9f2}\x03\x02\x02\x02\u{9f4}\u{9f5}\x03\x02\x02\x02\u{9f5}\u{a05}\
	\x03\x02\x02\x02\u{9f6}\u{a06}\x07\u{194}\x02\x02\u{9f7}\u{9f8}\x07\u{12b}\
	\x02\x02\u{9f8}\u{a06}\x07\u{cd}\x02\x02\u{9f9}\u{9fa}\x07\u{93}\x02\x02\
	\u{9fa}\u{9fc}\x07\u{cd}\x02\x02\u{9fb}\u{9f9}\x03\x02\x02\x02\u{9fb}\u{9fc}\
	\x03\x02\x02\x02\u{9fc}\u{9fd}\x03\x02\x02\x02\u{9fd}\u{9fe}\x07\u{137}\
	\x02\x02\u{9fe}\u{a03}\x05\u{154}\u{ab}\x02\u{9ff}\u{a00}\x07\u{1bc}\x02\
	\x02\u{a00}\u{a01}\x05\u{164}\u{b3}\x02\u{a01}\u{a02}\x07\u{1bd}\x02\x02\
	\u{a02}\u{a04}\x03\x02\x02\x02\u{a03}\u{9ff}\x03\x02\x02\x02\u{a03}\u{a04}\
	\x03\x02\x02\x02\u{a04}\u{a06}\x03\x02\x02\x02\u{a05}\u{9f6}\x03\x02\x02\
	\x02\u{a05}\u{9f7}\x03\x02\x02\x02\u{a05}\u{9fb}\x03\x02\x02\x02\u{a06}\
	\u{a07}\x03\x02\x02\x02\u{a07}\u{a08}\x05\x16\x0c\x02\u{a08}\x33\x03\x02\
	\x02\x02\u{a09}\u{a0b}\x05\x3a\x1e\x02\u{a0a}\u{a0c}\x05\x32\x1a\x02\u{a0b}\
	\u{a0a}\x03\x02\x02\x02\u{a0b}\u{a0c}\x03\x02\x02\x02\u{a0c}\u{a0f}\x03\
	\x02\x02\x02\u{a0d}\u{a0e}\x07\u{100}\x02\x02\u{a0e}\u{a10}\x07\u{102}\x02\
	\x02\u{a0f}\u{a0d}\x03\x02\x02\x02\u{a0f}\u{a10}\x03\x02\x02\x02\u{a10}\
	\u{a13}\x03\x02\x02\x02\u{a11}\u{a12}\x07\x3f\x02\x02\u{a12}\u{a14}\x05\
	\u{122}\u{92}\x02\u{a13}\u{a11}\x03\x02\x02\x02\u{a13}\u{a14}\x03\x02\x02\
	\x02\u{a14}\u{a28}\x03\x02\x02\x02\u{a15}\u{a16}\x07\x5c\x02\x02\u{a16}\
	\u{a27}\x05\u{f8}\x7d\x02\u{a17}\u{a21}\x09\x11\x02\x02\u{a18}\u{a19}\x05\
	\u{172}\u{ba}\x02\u{a19}\u{a1a}\x07\x42\x02\x02\u{a1a}\u{a1b}\x05\u{172}\
	\u{ba}\x02\u{a1b}\u{a22}\x03\x02\x02\x02\u{a1c}\u{a1d}\x07\u{16a}\x02\x02\
	\u{a1d}\u{a1e}\x05\u{172}\u{ba}\x02\u{a1e}\u{a1f}\x07\u{b2}\x02\x02\u{a1f}\
	\u{a20}\x05\u{172}\u{ba}\x02\u{a20}\u{a22}\x03\x02\x02\x02\u{a21}\u{a18}\
	\x03\x02\x02\x02\u{a21}\u{a1c}\x03\x02\x02\x02\u{a21}\u{a22}\x03\x02\x02\
	\x02\u{a22}\u{a24}\x03\x02\x02\x02\u{a23}\u{a25}\x09\x12\x02\x02\u{a24}\
	\u{a23}\x03\x02\x02\x02\u{a24}\u{a25}\x03\x02\x02\x02\u{a25}\u{a27}\x03\
	\x02\x02\x02\u{a26}\u{a15}\x03\x02\x02\x02\u{a26}\u{a17}\x03\x02\x02\x02\
	\u{a27}\u{a29}\x03\x02\x02\x02\u{a28}\u{a26}\x03\x02\x02\x02\u{a28}\u{a29}\
	\x03\x02\x02\x02\u{a29}\u{a3e}\x03\x02\x02\x02\u{a2a}\u{a2c}\x07\u{1b1}\
	\x02\x02\u{a2b}\u{a2a}\x03\x02\x02\x02\u{a2b}\u{a2c}\x03\x02\x02\x02\u{a2c}\
	\u{a2d}\x03\x02\x02\x02\u{a2d}\u{a2e}\x07\u{e2}\x02\x02\u{a2e}\u{a2f}\x07\
	\u{124}\x02\x02\u{a2f}\u{a3c}\x05\u{164}\u{b3}\x02\u{a30}\u{a31}\x07\u{19f}\
	\x02\x02\u{a31}\u{a32}\x07\u{1bc}\x02\x02\u{a32}\u{a37}\x05\u{164}\u{b3}\
	\x02\u{a33}\u{a34}\x07\x42\x02\x02\u{a34}\u{a36}\x05\u{164}\u{b3}\x02\u{a35}\
	\u{a33}\x03\x02\x02\x02\u{a36}\u{a39}\x03\x02\x02\x02\u{a37}\u{a35}\x03\
	\x02\x02\x02\u{a37}\u{a38}\x03\x02\x02\x02\u{a38}\u{a3a}\x03\x02\x02\x02\
	\u{a39}\u{a37}\x03\x02\x02\x02\u{a3a}\u{a3b}\x07\u{1bd}\x02\x02\u{a3b}\u{a3d}\
	\x03\x02\x02\x02\u{a3c}\u{a30}\x03\x02\x02\x02\u{a3c}\u{a3d}\x03\x02\x02\
	\x02\u{a3d}\u{a3f}\x03\x02\x02\x02\u{a3e}\u{a2b}\x03\x02\x02\x02\u{a3e}\
	\u{a3f}\x03\x02\x02\x02\u{a3f}\u{a45}\x03\x02\x02\x02\u{a40}\u{a42}\x07\
	\u{1b1}\x02\x02\u{a41}\u{a40}\x03\x02\x02\x02\u{a41}\u{a42}\x03\x02\x02\
	\x02\u{a42}\u{a43}\x03\x02\x02\x02\u{a43}\u{a44}\x07\u{178}\x02\x02\u{a44}\
	\u{a46}\x05\x46\x24\x02\u{a45}\u{a41}\x03\x02\x02\x02\u{a45}\u{a46}\x03\
	\x02\x02\x02\u{a46}\u{a49}\x03\x02\x02\x02\u{a47}\u{a48}\x07\x43\x02\x02\
	\u{a48}\u{a4a}\x05\u{122}\u{92}\x02\u{a49}\u{a47}\x03\x02\x02\x02\u{a49}\
	\u{a4a}\x03\x02\x02\x02\u{a4a}\x35\x03\x02\x02\x02\u{a4b}\u{a4c}\x05\x38\
	\x1d\x02\u{a4c}\u{a4d}\x07\x1e\x02\x02\u{a4d}\u{a4f}\x05\u{f8}\x7d\x02\u{a4e}\
	\u{a50}\x05\x32\x1a\x02\u{a4f}\u{a4e}\x03\x02\x02\x02\u{a4f}\u{a50}\x03\
	\x02\x02\x02\u{a50}\x37\x03\x02\x02\x02\u{a51}\u{a52}\x05\x3a\x1e\x02\u{a52}\
	\u{a53}\x05\x3e\x20\x02\u{a53}\x39\x03\x02\x02\x02\u{a54}\u{a55}\x05\u{164}\
	\u{b3}\x02\u{a55}\x3b\x03\x02\x02\x02\u{a56}\u{a57}\x05\u{164}\u{b3}\x02\
	\u{a57}\x3d\x03\x02\x02\x02\u{a58}\u{a5d}\x05\x44\x23\x02\u{a59}\u{a5b}\
	\x07\u{100}\x02\x02\u{a5a}\u{a59}\x03\x02\x02\x02\u{a5a}\u{a5b}\x03\x02\
	\x02\x02\u{a5b}\u{a5c}\x03\x02\x02\x02\u{a5c}\u{a5e}\x07\u{102}\x02\x02\
	\u{a5d}\u{a5a}\x03\x02\x02\x02\u{a5d}\u{a5e}\x03\x02\x02\x02\u{a5e}\x3f\
	\x03\x02\x02\x02\u{a5f}\u{a64}\x05\x42\x22\x02\u{a60}\u{a61}\x07\x42\x02\
	\x02\u{a61}\u{a63}\x05\x42\x22\x02\u{a62}\u{a60}\x03\x02\x02\x02\u{a63}\
	\u{a66}\x03\x02\x02\x02\u{a64}\u{a62}\x03\x02\x02\x02\u{a64}\u{a65}\x03\
	\x02\x02\x02\u{a65}\u{a68}\x03\x02\x02\x02\u{a66}\u{a64}\x03\x02\x02\x02\
	\u{a67}\u{a69}\x07\x42\x02\x02\u{a68}\u{a67}\x03\x02\x02\x02\u{a68}\u{a69}\
	\x03\x02\x02\x02\u{a69}\x41\x03\x02\x02\x02\u{a6a}\u{a6b}\x05\u{164}\u{b3}\
	\x02\u{a6b}\u{a6c}\x07\u{1c1}\x02\x02\u{a6c}\u{a6d}\x05\u{f8}\x7d\x02\u{a6d}\
	\x43\x03\x02\x02\x02\u{a6e}\u{a6f}\x05\u{134}\u{9b}\x02\u{a6f}\x45\x03\x02\
	\x02\x02\u{a70}\u{a72}\x07\u{1bc}\x02\x02\u{a71}\u{a73}\x05\x48\x25\x02\
	\u{a72}\u{a71}\x03\x02\x02\x02\u{a72}\u{a73}\x03\x02\x02\x02\u{a73}\u{a74}\
	\x03\x02\x02\x02\u{a74}\u{a75}\x07\u{1bd}\x02\x02\u{a75}\x47\x03\x02\x02\
	\x02\u{a76}\u{a7b}\x05\x4a\x26\x02\u{a77}\u{a78}\x07\x42\x02\x02\u{a78}\
	\u{a7a}\x05\x4a\x26\x02\u{a79}\u{a77}\x03\x02\x02\x02\u{a7a}\u{a7d}\x03\
	\x02\x02\x02\u{a7b}\u{a79}\x03\x02\x02\x02\u{a7b}\u{a7c}\x03\x02\x02\x02\
	\u{a7c}\u{a7f}\x03\x02\x02\x02\u{a7d}\u{a7b}\x03\x02\x02\x02\u{a7e}\u{a80}\
	\x07\x42\x02\x02\u{a7f}\u{a7e}\x03\x02\x02\x02\u{a7f}\u{a80}\x03\x02\x02\
	\x02\u{a80}\x49\x03\x02\x02\x02\u{a81}\u{a82}\x05\x4c\x27\x02\u{a82}\u{a83}\
	\x07\u{1c1}\x02\x02\u{a83}\u{a87}\x07\u{1bc}\x02\x02\u{a84}\u{a86}\x05\x4a\
	\x26\x02\u{a85}\u{a84}\x03\x02\x02\x02\u{a86}\u{a89}\x03\x02\x02\x02\u{a87}\
	\u{a85}\x03\x02\x02\x02\u{a87}\u{a88}\x03\x02\x02\x02\u{a88}\u{a8a}\x03\
	\x02\x02\x02\u{a89}\u{a87}\x03\x02\x02\x02\u{a8a}\u{a8b}\x07\u{1bd}\x02\
	\x02\u{a8b}\u{a91}\x03\x02\x02\x02\u{a8c}\u{a8d}\x05\x4c\x27\x02\u{a8d}\
	\u{a8e}\x07\u{1c1}\x02\x02\u{a8e}\u{a8f}\x05\x4e\x28\x02\u{a8f}\u{a91}\x03\
	\x02\x02\x02\u{a90}\u{a81}\x03\x02\x02\x02\u{a90}\u{a8c}\x03\x02\x02\x02\
	\u{a91}\x4b\x03\x02\x02\x02\u{a92}\u{a93}\x05\u{164}\u{b3}\x02\u{a93}\x4d\
	\x03\x02\x02\x02\u{a94}\u{a98}\x07\x5c\x02\x02\u{a95}\u{a98}\x05\u{164}\
	\u{b3}\x02\u{a96}\u{a98}\x05\u{f8}\x7d\x02\u{a97}\u{a94}\x03\x02\x02\x02\
	\u{a97}\u{a95}\x03\x02\x02\x02\u{a97}\u{a96}\x03\x02\x02\x02\u{a98}\x4f\
	\x03\x02\x02\x02\u{a99}\u{a9a}\x05\x52\x2a\x02\u{a9a}\x51\x03\x02\x02\x02\
	\u{a9b}\u{ab4}\x05\x54\x2b\x02\u{a9c}\u{a9d}\x07\u{da}\x02\x02\u{a9d}\u{aa0}\
	\x05\x58\x2d\x02\u{a9e}\u{a9f}\x07\u{106}\x02\x02\u{a9f}\u{aa1}\x05\x5a\
	\x2e\x02\u{aa0}\u{a9e}\x03\x02\x02\x02\u{aa0}\u{aa1}\x03\x02\x02\x02\u{aa1}\
	\u{ab5}\x03\x02\x02\x02\u{aa2}\u{aa3}\x07\u{106}\x02\x02\u{aa3}\u{aa5}\x05\
	\x5a\x2e\x02\u{aa4}\u{aa6}\x05\x56\x2c\x02\u{aa5}\u{aa4}\x03\x02\x02\x02\
	\u{aa5}\u{aa6}\x03\x02\x02\x02\u{aa6}\u{aa8}\x03\x02\x02\x02\u{aa7}\u{aa2}\
	\x03\x02\x02\x02\u{aa7}\u{aa8}\x03\x02\x02\x02\u{aa8}\u{aa9}\x03\x02\x02\
	\x02\u{aa9}\u{aab}\x07\u{88}\x02\x02\u{aaa}\u{aac}\x09\x13\x02\x02\u{aab}\
	\u{aaa}\x03\x02\x02\x02\u{aab}\u{aac}\x03\x02\x02\x02\u{aac}\u{aad}\x03\
	\x02\x02\x02\u{aad}\u{aaf}\x05\x5a\x2e\x02\u{aae}\u{ab0}\x05\x56\x2c\x02\
	\u{aaf}\u{aae}\x03\x02\x02\x02\u{aaf}\u{ab0}\x03\x02\x02\x02\u{ab0}\u{ab2}\
	\x03\x02\x02\x02\u{ab1}\u{ab3}\x07\u{10a}\x02\x02\u{ab2}\u{ab1}\x03\x02\
	\x02\x02\u{ab2}\u{ab3}\x03\x02\x02\x02\u{ab3}\u{ab5}\x03\x02\x02\x02\u{ab4}\
	\u{a9c}\x03\x02\x02\x02\u{ab4}\u{aa7}\x03\x02\x02\x02\u{ab4}\u{ab5}\x03\
	\x02\x02\x02\u{ab5}\x53\x03\x02\x02\x02\u{ab6}\u{ab8}\x05\x5c\x2f\x02\u{ab7}\
	\u{ab9}\x05\u{86}\x44\x02\u{ab8}\u{ab7}\x03\x02\x02\x02\u{ab8}\u{ab9}\x03\
	\x02\x02\x02\u{ab9}\x55\x03\x02\x02\x02\u{aba}\u{abb}\x09\x14\x02\x02\u{abb}\
	\x57\x03\x02\x02\x02\u{abc}\u{ac0}\x07\x14\x02\x02\u{abd}\u{ac0}\x07\u{102}\
	\x02\x02\u{abe}\u{ac0}\x05\x5a\x2e\x02\u{abf}\u{abc}\x03\x02\x02\x02\u{abf}\
	\u{abd}\x03\x02\x02\x02\u{abf}\u{abe}\x03\x02\x02\x02\u{ac0}\x59\x03\x02\
	\x02\x02\u{ac1}\u{ac2}\x09\x15\x02\x02\u{ac2}\x5b\x03\x02\x02\x02\u{ac3}\
	\u{ac4}\x05\x5e\x30\x02\u{ac4}\x5d\x03\x02\x02\x02\u{ac5}\u{acb}\x05\x62\
	\x32\x02\u{ac6}\u{ac7}\x05\x60\x31\x02\u{ac7}\u{ac8}\x05\x62\x32\x02\u{ac8}\
	\u{aca}\x03\x02\x02\x02\u{ac9}\u{ac6}\x03\x02\x02\x02\u{aca}\u{acd}\x03\
	\x02\x02\x02\u{acb}\u{ac9}\x03\x02\x02\x02\u{acb}\u{acc}\x03\x02\x02\x02\
	\u{acc}\x5f\x03\x02\x02\x02\u{acd}\u{acb}\x03\x02\x02\x02\u{ace}\u{ad0}\
	\x07\u{193}\x02\x02\u{acf}\u{ad1}\x05\x66\x34\x02\u{ad0}\u{acf}\x03\x02\
	\x02\x02\u{ad0}\u{ad1}\x03\x02\x02\x02\u{ad1}\u{ad4}\x03\x02\x02\x02\u{ad2}\
	\u{ad3}\x07\x2d\x02\x02\u{ad3}\u{ad5}\x07\u{f3}\x02\x02\u{ad4}\u{ad2}\x03\
	\x02\x02\x02\u{ad4}\u{ad5}\x03\x02\x02\x02\u{ad5}\u{adb}\x03\x02\x02\x02\
	\u{ad6}\u{ad8}\x09\x16\x02\x02\u{ad7}\u{ad9}\x05\x66\x34\x02\u{ad8}\u{ad7}\
	\x03\x02\x02\x02\u{ad8}\u{ad9}\x03\x02\x02\x02\u{ad9}\u{adb}\x03\x02\x02\
	\x02\u{ada}\u{ace}\x03\x02\x02\x02\u{ada}\u{ad6}\x03\x02\x02\x02\u{adb}\
	\x61\x03\x02\x02\x02\u{adc}\u{ae2}\x05\x6a\x36\x02\u{add}\u{ade}\x05\x64\
	\x33\x02\u{ade}\u{adf}\x05\x6a\x36\x02\u{adf}\u{ae1}\x03\x02\x02\x02\u{ae0}\
	\u{add}\x03\x02\x02\x02\u{ae1}\u{ae4}\x03\x02\x02\x02\u{ae2}\u{ae0}\x03\
	\x02\x02\x02\u{ae2}\u{ae3}\x03\x02\x02\x02\u{ae3}\x63\x03\x02\x02\x02\u{ae4}\
	\u{ae2}\x03\x02\x02\x02\u{ae5}\u{ae7}\x07\u{bb}\x02\x02\u{ae6}\u{ae8}\x05\
	\x66\x34\x02\u{ae7}\u{ae6}\x03\x02\x02\x02\u{ae7}\u{ae8}\x03\x02\x02\x02\
	\u{ae8}\x65\x03\x02\x02\x02\u{ae9}\u{aea}\x09\x17\x02\x02\u{aea}\x67\x03\
	\x02\x02\x02\u{aeb}\u{aec}\x07\u{1a6}\x02\x02\u{aec}\u{af1}\x05\u{f8}\x7d\
	\x02\u{aed}\u{aee}\x07\x42\x02\x02\u{aee}\u{af0}\x05\u{f8}\x7d\x02\u{aef}\
	\u{aed}\x03\x02\x02\x02\u{af0}\u{af3}\x03\x02\x02\x02\u{af1}\u{aef}\x03\
	\x02\x02\x02\u{af1}\u{af2}\x03\x02\x02\x02\u{af2}\u{af5}\x03\x02\x02\x02\
	\u{af3}\u{af1}\x03\x02\x02\x02\u{af4}\u{af6}\x07\x42\x02\x02\u{af5}\u{af4}\
	\x03\x02\x02\x02\u{af5}\u{af6}\x03\x02\x02\x02\u{af6}\x69\x03\x02\x02\x02\
	\u{af7}\u{aff}\x05\x70\x39\x02\u{af8}\u{af9}\x07\u{175}\x02\x02\u{af9}\u{aff}\
	\x05\u{156}\u{ac}\x02\u{afa}\u{afb}\x07\u{1bc}\x02\x02\u{afb}\u{afc}\x05\
	\x2a\x16\x02\u{afc}\u{afd}\x07\u{1bd}\x02\x02\u{afd}\u{aff}\x03\x02\x02\
	\x02\u{afe}\u{af7}\x03\x02\x02\x02\u{afe}\u{af8}\x03\x02\x02\x02\u{afe}\
	\u{afa}\x03\x02\x02\x02\u{aff}\x6b\x03\x02\x02\x02\u{b00}\u{b02}\x05\u{f8}\
	\x7d\x02\u{b01}\u{b03}\x09\x18\x02\x02\u{b02}\u{b01}\x03\x02\x02\x02\u{b02}\
	\u{b03}\x03\x02\x02\x02\u{b03}\u{b06}\x03\x02\x02\x02\u{b04}\u{b05}\x07\
	\u{103}\x02\x02\u{b05}\u{b07}\x09\x19\x02\x02\u{b06}\u{b04}\x03\x02\x02\
	\x02\u{b06}\u{b07}\x03\x02\x02\x02\u{b07}\x6d\x03\x02\x02\x02\u{b08}\u{b09}\
	\x05\u{f8}\x7d\x02\u{b09}\x6f\x03\x02\x02\x02\u{b0a}\u{b0d}\x07\u{159}\x02\
	\x02\u{b0b}\u{b0c}\x07\u{184}\x02\x02\u{b0c}\u{b0e}\x05\u{172}\u{ba}\x02\
	\u{b0d}\u{b0b}\x03\x02\x02\x02\u{b0d}\u{b0e}\x03\x02\x02\x02\u{b0e}\u{b10}\
	\x03\x02\x02\x02\u{b0f}\u{b11}\x05\x66\x34\x02\u{b10}\u{b0f}\x03\x02\x02\
	\x02\u{b10}\u{b11}\x03\x02\x02\x02\u{b11}\u{b12}\x03\x02\x02\x02\u{b12}\
	\u{b1f}\x05\x76\x3c\x02\u{b13}\u{b14}\x07\u{96}\x02\x02\u{b14}\u{b19}\x05\
	\u{92}\x4a\x02\u{b15}\u{b16}\x07\x42\x02\x02\u{b16}\u{b18}\x05\u{92}\x4a\
	\x02\u{b17}\u{b15}\x03\x02\x02\x02\u{b18}\u{b1b}\x03\x02\x02\x02\u{b19}\
	\u{b17}\x03\x02\x02\x02\u{b19}\u{b1a}\x03\x02\x02\x02\u{b1a}\u{b1d}\x03\
	\x02\x02\x02\u{b1b}\u{b19}\x03\x02\x02\x02\u{b1c}\u{b1e}\x07\x42\x02\x02\
	\u{b1d}\u{b1c}\x03\x02\x02\x02\u{b1d}\u{b1e}\x03\x02\x02\x02\u{b1e}\u{b20}\
	\x03\x02\x02\x02\u{b1f}\u{b13}\x03\x02\x02\x02\u{b1f}\u{b20}\x03\x02\x02\
	\x02\u{b20}\u{b23}\x03\x02\x02\x02\u{b21}\u{b22}\x07\u{1af}\x02\x02\u{b22}\
	\u{b24}\x05\u{fa}\x7e\x02\u{b23}\u{b21}\x03\x02\x02\x02\u{b23}\u{b24}\x03\
	\x02\x02\x02\u{b24}\u{b26}\x03\x02\x02\x02\u{b25}\u{b27}\x05\x72\x3a\x02\
	\u{b26}\u{b25}\x03\x02\x02\x02\u{b26}\u{b27}\x03\x02\x02\x02\u{b27}\u{b29}\
	\x03\x02\x02\x02\u{b28}\u{b2a}\x05\x78\x3d\x02\u{b29}\u{b28}\x03\x02\x02\
	\x02\u{b29}\u{b2a}\x03\x02\x02\x02\u{b2a}\u{b2d}\x03\x02\x02\x02\u{b2b}\
	\u{b2c}\x07\u{a5}\x02\x02\u{b2c}\u{b2e}\x05\u{fa}\x7e\x02\u{b2d}\u{b2b}\
	\x03\x02\x02\x02\u{b2d}\u{b2e}\x03\x02\x02\x02\u{b2e}\u{b31}\x03\x02\x02\
	\x02\u{b2f}\u{b30}\x07\u{130}\x02\x02\u{b30}\u{b32}\x05\u{fa}\x7e\x02\u{b31}\
	\u{b2f}\x03\x02\x02\x02\u{b31}\u{b32}\x03\x02\x02\x02\u{b32}\x71\x03\x02\
	\x02\x02\u{b33}\u{b34}\x07\u{16a}\x02\x02\u{b34}\u{b35}\x07\u{1b1}\x02\x02\
	\u{b35}\u{b37}\x05\u{f8}\x7d\x02\u{b36}\u{b33}\x03\x02\x02\x02\u{b36}\u{b37}\
	\x03\x02\x02\x02\u{b37}\u{b38}\x03\x02\x02\x02\u{b38}\u{b39}\x07\x49\x02\
	\x02\u{b39}\u{b3a}\x07\x2d\x02\x02\u{b3a}\u{b3f}\x05\x6e\x38\x02\u{b3b}\
	\u{b3c}\x07\x17\x02\x02\u{b3c}\u{b3e}\x05\x6e\x38\x02\u{b3d}\u{b3b}\x03\
	\x02\x02\x02\u{b3e}\u{b41}\x03\x02\x02\x02\u{b3f}\u{b3d}\x03\x02\x02\x02\
	\u{b3f}\u{b40}\x03\x02\x02\x02\u{b40}\x73\x03\x02\x02\x02\u{b41}\u{b3f}\
	\x03\x02\x02\x02\u{b42}\u{b44}\x05\u{f8}\x7d\x02\u{b43}\u{b45}\x07\x1e\x02\
	\x02\u{b44}\u{b43}\x03\x02\x02\x02\u{b44}\u{b45}\x03\x02\x02\x02\u{b45}\
	\u{b46}\x03\x02\x02\x02\u{b46}\u{b47}\x05\u{164}\u{b3}\x02\u{b47}\x75\x03\
	\x02\x02\x02\u{b48}\u{b4d}\x05\u{8c}\x47\x02\u{b49}\u{b4a}\x07\x42\x02\x02\
	\u{b4a}\u{b4c}\x05\u{8c}\x47\x02\u{b4b}\u{b49}\x03\x02\x02\x02\u{b4c}\u{b4f}\
	\x03\x02\x02\x02\u{b4d}\u{b4b}\x03\x02\x02\x02\u{b4d}\u{b4e}\x03\x02\x02\
	\x02\u{b4e}\u{b51}\x03\x02\x02\x02\u{b4f}\u{b4d}\x03\x02\x02\x02\u{b50}\
	\u{b52}\x07\x42\x02\x02\u{b51}\u{b50}\x03\x02\x02\x02\u{b51}\u{b52}\x03\
	\x02\x02\x02\u{b52}\x77\x03\x02\x02\x02\u{b53}\u{b54}\x07\u{a1}\x02\x02\
	\u{b54}\u{b55}\x07\x2d\x02\x02\u{b55}\u{b56}\x05\x7a\x3e\x02\u{b56}\x79\
	\x03\x02\x02\x02\u{b57}\u{b67}\x07\x14\x02\x02\u{b58}\u{b5a}\x05\x66\x34\
	\x02\u{b59}\u{b58}\x03\x02\x02\x02\u{b59}\u{b5a}\x03\x02\x02\x02\u{b5a}\
	\u{b5b}\x03\x02\x02\x02\u{b5b}\u{b60}\x05\x7c\x3f\x02\u{b5c}\u{b5d}\x07\
	\x42\x02\x02\u{b5d}\u{b5f}\x05\x7c\x3f\x02\u{b5e}\u{b5c}\x03\x02\x02\x02\
	\u{b5f}\u{b62}\x03\x02\x02\x02\u{b60}\u{b5e}\x03\x02\x02\x02\u{b60}\u{b61}\
	\x03\x02\x02\x02\u{b61}\u{b64}\x03\x02\x02\x02\u{b62}\u{b60}\x03\x02\x02\
	\x02\u{b63}\u{b65}\x07\x42\x02\x02\u{b64}\u{b63}\x03\x02\x02\x02\u{b64}\
	\u{b65}\x03\x02\x02\x02\u{b65}\u{b67}\x03\x02\x02\x02\u{b66}\u{b57}\x03\
	\x02\x02\x02\u{b66}\u{b59}\x03\x02\x02\x02\u{b67}\x7b\x03\x02\x02\x02\u{b68}\
	\u{b69}\x07\u{14b}\x02\x02\u{b69}\u{b75}\x07\u{1bc}\x02\x02\u{b6a}\u{b6f}\
	\x05\u{f8}\x7d\x02\u{b6b}\u{b6c}\x07\x42\x02\x02\u{b6c}\u{b6e}\x05\u{f8}\
	\x7d\x02\u{b6d}\u{b6b}\x03\x02\x02\x02\u{b6e}\u{b71}\x03\x02\x02\x02\u{b6f}\
	\u{b6d}\x03\x02\x02\x02\u{b6f}\u{b70}\x03\x02\x02\x02\u{b70}\u{b73}\x03\
	\x02\x02\x02\u{b71}\u{b6f}\x03\x02\x02\x02\u{b72}\u{b74}\x07\x42\x02\x02\
	\u{b73}\u{b72}\x03\x02\x02\x02\u{b73}\u{b74}\x03\x02\x02\x02\u{b74}\u{b76}\
	\x03\x02\x02\x02\u{b75}\u{b6a}\x03\x02\x02\x02\u{b75}\u{b76}\x03\x02\x02\
	\x02\u{b76}\u{b77}\x03\x02\x02\x02\u{b77}\u{b9a}\x07\u{1bd}\x02\x02\u{b78}\
	\u{b79}\x07\x52\x02\x02\u{b79}\u{b85}\x07\u{1bc}\x02\x02\u{b7a}\u{b7f}\x05\
	\u{f8}\x7d\x02\u{b7b}\u{b7c}\x07\x42\x02\x02\u{b7c}\u{b7e}\x05\u{f8}\x7d\
	\x02\u{b7d}\u{b7b}\x03\x02\x02\x02\u{b7e}\u{b81}\x03\x02\x02\x02\u{b7f}\
	\u{b7d}\x03\x02\x02\x02\u{b7f}\u{b80}\x03\x02\x02\x02\u{b80}\u{b83}\x03\
	\x02\x02\x02\u{b81}\u{b7f}\x03\x02\x02\x02\u{b82}\u{b84}\x07\x42\x02\x02\
	\u{b83}\u{b82}\x03\x02\x02\x02\u{b83}\u{b84}\x03\x02\x02\x02\u{b84}\u{b86}\
	\x03\x02\x02\x02\u{b85}\u{b7a}\x03\x02\x02\x02\u{b85}\u{b86}\x03\x02\x02\
	\x02\u{b86}\u{b87}\x03\x02\x02\x02\u{b87}\u{b9a}\x07\u{1bd}\x02\x02\u{b88}\
	\u{b89}\x07\u{a2}\x02\x02\u{b89}\u{b8a}\x07\u{161}\x02\x02\u{b8a}\u{b8b}\
	\x07\u{1bc}\x02\x02\u{b8b}\u{b90}\x05\x7e\x40\x02\u{b8c}\u{b8d}\x07\x42\
	\x02\x02\u{b8d}\u{b8f}\x05\x7e\x40\x02\u{b8e}\u{b8c}\x03\x02\x02\x02\u{b8f}\
	\u{b92}\x03\x02\x02\x02\u{b90}\u{b8e}\x03\x02\x02\x02\u{b90}\u{b91}\x03\
	\x02\x02\x02\u{b91}\u{b94}\x03\x02\x02\x02\u{b92}\u{b90}\x03\x02\x02\x02\
	\u{b93}\u{b95}\x07\x42\x02\x02\u{b94}\u{b93}\x03\x02\x02\x02\u{b94}\u{b95}\
	\x03\x02\x02\x02\u{b95}\u{b96}\x03\x02\x02\x02\u{b96}\u{b97}\x07\u{1bd}\
	\x02\x02\u{b97}\u{b9a}\x03\x02\x02\x02\u{b98}\u{b9a}\x05\x7e\x40\x02\u{b99}\
	\u{b68}\x03\x02\x02\x02\u{b99}\u{b78}\x03\x02\x02\x02\u{b99}\u{b88}\x03\
	\x02\x02\x02\u{b99}\u{b98}\x03\x02\x02\x02\u{b9a}\x7d\x03\x02\x02\x02\u{b9b}\
	\u{ba4}\x07\u{1bc}\x02\x02\u{b9c}\u{ba1}\x05\u{f8}\x7d\x02\u{b9d}\u{b9e}\
	\x07\x42\x02\x02\u{b9e}\u{ba0}\x05\u{f8}\x7d\x02\u{b9f}\u{b9d}\x03\x02\x02\
	\x02\u{ba0}\u{ba3}\x03\x02\x02\x02\u{ba1}\u{b9f}\x03\x02\x02\x02\u{ba1}\
	\u{ba2}\x03\x02\x02\x02\u{ba2}\u{ba5}\x03\x02\x02\x02\u{ba3}\u{ba1}\x03\
	\x02\x02\x02\u{ba4}\u{b9c}\x03\x02\x02\x02\u{ba4}\u{ba5}\x03\x02\x02\x02\
	\u{ba5}\u{ba7}\x03\x02\x02\x02\u{ba6}\u{ba8}\x07\x42\x02\x02\u{ba7}\u{ba6}\
	\x03\x02\x02\x02\u{ba7}\u{ba8}\x03\x02\x02\x02\u{ba8}\u{ba9}\x03\x02\x02\
	\x02\u{ba9}\u{bac}\x07\u{1bd}\x02\x02\u{baa}\u{bac}\x05\u{f8}\x7d\x02\u{bab}\
	\u{b9b}\x03\x02\x02\x02\u{bab}\u{baa}\x03\x02\x02\x02\u{bac}\x7f\x03\x02\
	\x02\x02\u{bad}\u{bae}\x05\u{164}\u{b3}\x02\u{bae}\u{baf}\x07\x1e\x02\x02\
	\u{baf}\u{bb0}\x07\u{1bc}\x02\x02\u{bb0}\u{bb1}\x05\u{82}\x42\x02\u{bb1}\
	\u{bb2}\x07\u{1bd}\x02\x02\u{bb2}\u{81}\x03\x02\x02\x02\u{bb3}\u{bb5}\x05\
	\u{164}\u{b3}\x02\u{bb4}\u{bb3}\x03\x02\x02\x02\u{bb4}\u{bb5}\x03\x02\x02\
	\x02\u{bb5}\u{bb7}\x03\x02\x02\x02\u{bb6}\u{bb8}\x05\u{84}\x43\x02\u{bb7}\
	\u{bb6}\x03\x02\x02\x02\u{bb7}\u{bb8}\x03\x02\x02\x02\u{bb8}\u{bba}\x03\
	\x02\x02\x02\u{bb9}\u{bbb}\x05\u{86}\x44\x02\u{bba}\u{bb9}\x03\x02\x02\x02\
	\u{bba}\u{bbb}\x03\x02\x02\x02\u{bbb}\u{bbd}\x03\x02\x02\x02\u{bbc}\u{bbe}\
	\x05\u{142}\u{a2}\x02\u{bbd}\u{bbc}\x03\x02\x02\x02\u{bbd}\u{bbe}\x03\x02\
	\x02\x02\u{bbe}\u{83}\x03\x02\x02\x02\u{bbf}\u{bc0}\x07\u{116}\x02\x02\u{bc0}\
	\u{bc1}\x07\x2d\x02\x02\u{bc1}\u{bc6}\x05\u{f8}\x7d\x02\u{bc2}\u{bc3}\x07\
	\x42\x02\x02\u{bc3}\u{bc5}\x05\u{f8}\x7d\x02\u{bc4}\u{bc2}\x03\x02\x02\x02\
	\u{bc5}\u{bc8}\x03\x02\x02\x02\u{bc6}\u{bc4}\x03\x02\x02\x02\u{bc6}\u{bc7}\
	\x03\x02\x02\x02\u{bc7}\u{bca}\x03\x02\x02\x02\u{bc8}\u{bc6}\x03\x02\x02\
	\x02\u{bc9}\u{bcb}\x07\x42\x02\x02\u{bca}\u{bc9}\x03\x02\x02\x02\u{bca}\
	\u{bcb}\x03\x02\x02\x02\u{bcb}\u{85}\x03\x02\x02\x02\u{bcc}\u{bcd}\x07\u{10e}\
	\x02\x02\u{bcd}\u{bce}\x07\x2d\x02\x02\u{bce}\u{bd3}\x05\x6c\x37\x02\u{bcf}\
	\u{bd0}\x07\x42\x02\x02\u{bd0}\u{bd2}\x05\x6c\x37\x02\u{bd1}\u{bcf}\x03\
	\x02\x02\x02\u{bd2}\u{bd5}\x03\x02\x02\x02\u{bd3}\u{bd1}\x03\x02\x02\x02\
	\u{bd3}\u{bd4}\x03\x02\x02\x02\u{bd4}\u{bd7}\x03\x02\x02\x02\u{bd5}\u{bd3}\
	\x03\x02\x02\x02\u{bd6}\u{bd8}\x07\x42\x02\x02\u{bd7}\u{bd6}\x03\x02\x02\
	\x02\u{bd7}\u{bd8}\x03\x02\x02\x02\u{bd8}\u{87}\x03\x02\x02\x02\u{bd9}\u{bdb}\
	\x05\u{164}\u{b3}\x02\u{bda}\u{bdc}\x05\u{e2}\x72\x02\u{bdb}\u{bda}\x03\
	\x02\x02\x02\u{bdb}\u{bdc}\x03\x02\x02\x02\u{bdc}\u{bdd}\x03\x02\x02\x02\
	\u{bdd}\u{bde}\x07\x1e\x02\x02\u{bde}\u{bdf}\x07\u{1bc}\x02\x02\u{bdf}\u{be0}\
	\x05\x2a\x16\x02\u{be0}\u{be1}\x07\u{1bd}\x02\x02\u{be1}\u{89}\x03\x02\x02\
	\x02\u{be2}\u{be3}\x05\x3a\x1e\x02\u{be3}\u{8b}\x03\x02\x02\x02\u{be4}\u{be6}\
	\x07\x4b\x02\x02\u{be5}\u{be4}\x03\x02\x02\x02\u{be5}\u{be6}\x03\x02\x02\
	\x02\u{be6}\u{be7}\x03\x02\x02\x02\u{be7}\u{bed}\x05\u{f8}\x7d\x02\u{be8}\
	\u{bee}\x07\u{113}\x02\x02\u{be9}\u{beb}\x07\x1e\x02\x02\u{bea}\u{be9}\x03\
	\x02\x02\x02\u{bea}\u{beb}\x03\x02\x02\x02\u{beb}\u{bec}\x03\x02\x02\x02\
	\u{bec}\u{bee}\x05\u{8a}\x46\x02\u{bed}\u{be8}\x03\x02\x02\x02\u{bed}\u{bea}\
	\x03\x02\x02\x02\u{bed}\u{bee}\x03\x02\x02\x02\u{bee}\u{bf1}\x03\x02\x02\
	\x02\u{bef}\u{bf1}\x05\u{8e}\x48\x02\u{bf0}\u{be5}\x03\x02\x02\x02\u{bf0}\
	\u{bef}\x03\x02\x02\x02\u{bf1}\u{8d}\x03\x02\x02\x02\u{bf2}\u{bf5}\x05\u{90}\
	\x49\x02\u{bf3}\u{bf4}\x07\u{c2}\x02\x02\u{bf4}\u{bf6}\x05\u{122}\u{92}\
	\x02\u{bf5}\u{bf3}\x03\x02\x02\x02\u{bf5}\u{bf6}\x03\x02\x02\x02\u{bf6}\
	\u{bfc}\x03\x02\x02\x02\u{bf7}\u{bfa}\x07\u{80}\x02\x02\u{bf8}\u{bfb}\x05\
	\u{16e}\u{b8}\x02\u{bf9}\u{bfb}\x05\u{170}\u{b9}\x02\u{bfa}\u{bf8}\x03\x02\
	\x02\x02\u{bfa}\u{bf9}\x03\x02\x02\x02\u{bfb}\u{bfd}\x03\x02\x02\x02\u{bfc}\
	\u{bf7}\x03\x02\x02\x02\u{bfc}\u{bfd}\x03\x02\x02\x02\u{bfd}\u{c0a}\x03\
	\x02\x02\x02\u{bfe}\u{bff}\x07\u{13c}\x02\x02\u{bff}\u{c00}\x07\u{1bc}\x02\
	\x02\u{c00}\u{c05}\x05\x74\x3b\x02\u{c01}\u{c02}\x07\x42\x02\x02\u{c02}\
	\u{c04}\x05\x74\x3b\x02\u{c03}\u{c01}\x03\x02\x02\x02\u{c04}\u{c07}\x03\
	\x02\x02\x02\u{c05}\u{c03}\x03\x02\x02\x02\u{c05}\u{c06}\x03\x02\x02\x02\
	\u{c06}\u{c08}\x03\x02\x02\x02\u{c07}\u{c05}\x03\x02\x02\x02\u{c08}\u{c09}\
	\x07\u{1bd}\x02\x02\u{c09}\u{c0b}\x03\x02\x02\x02\u{c0a}\u{bfe}\x03\x02\
	\x02\x02\u{c0a}\u{c0b}\x03\x02\x02\x02\u{c0b}\u{c23}\x03\x02\x02\x02\u{c0c}\
	\u{c21}\x07\u{13a}\x02\x02\u{c0d}\u{c0e}\x05\u{164}\u{b3}\x02\u{c0e}\u{c0f}\
	\x07\x1e\x02\x02\u{c0f}\u{c10}\x05\u{164}\u{b3}\x02\u{c10}\u{c22}\x03\x02\
	\x02\x02\u{c11}\u{c12}\x07\u{1bc}\x02\x02\u{c12}\u{c13}\x05\u{164}\u{b3}\
	\x02\u{c13}\u{c14}\x07\x1e\x02\x02\u{c14}\u{c1c}\x05\u{164}\u{b3}\x02\u{c15}\
	\u{c16}\x07\x42\x02\x02\u{c16}\u{c17}\x05\u{164}\u{b3}\x02\u{c17}\u{c18}\
	\x07\x1e\x02\x02\u{c18}\u{c19}\x05\u{164}\u{b3}\x02\u{c19}\u{c1b}\x03\x02\
	\x02\x02\u{c1a}\u{c15}\x03\x02\x02\x02\u{c1b}\u{c1e}\x03\x02\x02\x02\u{c1c}\
	\u{c1a}\x03\x02\x02\x02\u{c1c}\u{c1d}\x03\x02\x02\x02\u{c1d}\u{c1f}\x03\
	\x02\x02\x02\u{c1e}\u{c1c}\x03\x02\x02\x02\u{c1f}\u{c20}\x07\u{1bd}\x02\
	\x02\u{c20}\u{c22}\x03\x02\x02\x02\u{c21}\u{c0d}\x03\x02\x02\x02\u{c21}\
	\u{c11}\x03\x02\x02\x02\u{c22}\u{c24}\x03\x02\x02\x02\u{c23}\u{c0c}\x03\
	\x02\x02\x02\u{c23}\u{c24}\x03\x02\x02\x02\u{c24}\u{8f}\x03\x02\x02\x02\
	\u{c25}\u{c26}\x05\u{104}\u{83}\x02\u{c26}\u{c27}\x07\u{1c0}\x02\x02\u{c27}\
	\u{c28}\x07\u{1c9}\x02\x02\u{c28}\u{c2b}\x03\x02\x02\x02\u{c29}\u{c2b}\x07\
	\u{1c9}\x02\x02\u{c2a}\u{c25}\x03\x02\x02\x02\u{c2a}\u{c29}\x03\x02\x02\
	\x02\u{c2b}\u{91}\x03\x02\x02\x02\u{c2c}\u{c2d}\x05\u{94}\x4b\x02\u{c2d}\
	\u{93}\x03\x02\x02\x02\u{c2e}\u{c2f}\x08\x4b\x01\x02\u{c2f}\u{c30}\x05\u{9a}\
	\x4e\x02\u{c30}\u{c55}\x03\x02\x02\x02\u{c31}\u{c46}\x0c\x05\x02\x02\u{c32}\
	\u{c33}\x07\x51\x02\x02\u{c33}\u{c34}\x07\u{c5}\x02\x02\u{c34}\u{c47}\x05\
	\u{9a}\x4e\x02\u{c35}\u{c36}\x05\u{96}\x4c\x02\u{c36}\u{c37}\x07\u{c5}\x02\
	\x02\u{c37}\u{c39}\x05\u{9a}\x4e\x02\u{c38}\u{c3a}\x05\u{98}\x4d\x02\u{c39}\
	\u{c38}\x03\x02\x02\x02\u{c39}\u{c3a}\x03\x02\x02\x02\u{c3a}\u{c47}\x03\
	\x02\x02\x02\u{c3b}\u{c3c}\x05\u{96}\x4c\x02\u{c3c}\u{c3d}\x07\u{c5}\x02\
	\x02\u{c3d}\u{c3f}\x05\u{94}\x4b\x02\u{c3e}\u{c40}\x05\u{98}\x4d\x02\u{c3f}\
	\u{c3e}\x03\x02\x02\x02\u{c3f}\u{c40}\x03\x02\x02\x02\u{c40}\u{c47}\x03\
	\x02\x02\x02\u{c41}\u{c42}\x07\u{f4}\x02\x02\u{c42}\u{c43}\x05\u{96}\x4c\
	\x02\u{c43}\u{c44}\x07\u{c5}\x02\x02\u{c44}\u{c45}\x05\u{9a}\x4e\x02\u{c45}\
	\u{c47}\x03\x02\x02\x02\u{c46}\u{c32}\x03\x02\x02\x02\u{c46}\u{c35}\x03\
	\x02\x02\x02\u{c46}\u{c3b}\x03\x02\x02\x02\u{c46}\u{c41}\x03\x02\x02\x02\
	\u{c47}\u{c54}\x03\x02\x02\x02\u{c48}\u{c49}\x0c\x04\x02\x02\u{c49}\u{c4a}\
	\x07\x20\x02\x02\u{c4a}\u{c4b}\x07\u{c5}\x02\x02\u{c4b}\u{c4c}\x05\u{9a}\
	\x4e\x02\u{c4c}\u{c4d}\x07\u{e6}\x02\x02\u{c4d}\u{c4e}\x07\u{1bc}\x02\x02\
	\u{c4e}\u{c4f}\x05\u{f8}\x7d\x02\u{c4f}\u{c51}\x07\u{1bd}\x02\x02\u{c50}\
	\u{c52}\x05\u{98}\x4d\x02\u{c51}\u{c50}\x03\x02\x02\x02\u{c51}\u{c52}\x03\
	\x02\x02\x02\u{c52}\u{c54}\x03\x02\x02\x02\u{c53}\u{c31}\x03\x02\x02\x02\
	\u{c53}\u{c48}\x03\x02\x02\x02\u{c54}\u{c57}\x03\x02\x02\x02\u{c55}\u{c53}\
	\x03\x02\x02\x02\u{c55}\u{c56}\x03\x02\x02\x02\u{c56}\u{95}\x03\x02\x02\
	\x02\u{c57}\u{c55}\x03\x02\x02\x02\u{c58}\u{c5a}\x07\u{b6}\x02\x02\u{c59}\
	\u{c58}\x03\x02\x02\x02\u{c59}\u{c5a}\x03\x02\x02\x02\u{c5a}\u{c68}\x03\
	\x02\x02\x02\u{c5b}\u{c5d}\x07\u{d6}\x02\x02\u{c5c}\u{c5e}\x07\u{110}\x02\
	\x02\u{c5d}\u{c5c}\x03\x02\x02\x02\u{c5d}\u{c5e}\x03\x02\x02\x02\u{c5e}\
	\u{c68}\x03\x02\x02\x02\u{c5f}\u{c61}\x07\u{145}\x02\x02\u{c60}\u{c62}\x07\
	\u{110}\x02\x02\u{c61}\u{c60}\x03\x02\x02\x02\u{c61}\u{c62}\x03\x02\x02\
	\x02\u{c62}\u{c68}\x03\x02\x02\x02\u{c63}\u{c65}\x07\u{97}\x02\x02\u{c64}\
	\u{c66}\x07\u{110}\x02\x02\u{c65}\u{c64}\x03\x02\x02\x02\u{c65}\u{c66}\x03\
	\x02\x02\x02\u{c66}\u{c68}\x03\x02\x02\x02\u{c67}\u{c59}\x03\x02\x02\x02\
	\u{c67}\u{c5b}\x03\x02\x02\x02\u{c67}\u{c5f}\x03\x02\x02\x02\u{c67}\u{c63}\
	\x03\x02\x02\x02\u{c68}\u{97}\x03\x02\x02\x02\u{c69}\u{c6a}\x07\u{108}\x02\
	\x02\u{c6a}\u{c7b}\x05\u{fa}\x7e\x02\u{c6b}\u{c6c}\x07\u{19f}\x02\x02\u{c6c}\
	\u{c6d}\x07\u{1bc}\x02\x02\u{c6d}\u{c72}\x05\u{164}\u{b3}\x02\u{c6e}\u{c6f}\
	\x07\x42\x02\x02\u{c6f}\u{c71}\x05\u{164}\u{b3}\x02\u{c70}\u{c6e}\x03\x02\
	\x02\x02\u{c71}\u{c74}\x03\x02\x02\x02\u{c72}\u{c70}\x03\x02\x02\x02\u{c72}\
	\u{c73}\x03\x02\x02\x02\u{c73}\u{c76}\x03\x02\x02\x02\u{c74}\u{c72}\x03\
	\x02\x02\x02\u{c75}\u{c77}\x07\x42\x02\x02\u{c76}\u{c75}\x03\x02\x02\x02\
	\u{c76}\u{c77}\x03\x02\x02\x02\u{c77}\u{c78}\x03\x02\x02\x02\u{c78}\u{c79}\
	\x07\u{1bd}\x02\x02\u{c79}\u{c7b}\x03\x02\x02\x02\u{c7a}\u{c69}\x03\x02\
	\x02\x02\u{c7a}\u{c6b}\x03\x02\x02\x02\u{c7b}\u{99}\x03\x02\x02\x02\u{c7c}\
	\u{c7d}\x05\u{9e}\x50\x02\u{c7d}\u{9b}\x03\x02\x02\x02\u{c7e}\u{cac}\x05\
	\u{ca}\x66\x02\u{c7f}\u{c80}\x07\u{1bc}\x02\x02\u{c80}\u{c81}\x07\u{1a6}\
	\x02\x02\u{c81}\u{c86}\x05\u{f8}\x7d\x02\u{c82}\u{c83}\x07\x42\x02\x02\u{c83}\
	\u{c85}\x05\u{f8}\x7d\x02\u{c84}\u{c82}\x03\x02\x02\x02\u{c85}\u{c88}\x03\
	\x02\x02\x02\u{c86}\u{c84}\x03\x02\x02\x02\u{c86}\u{c87}\x03\x02\x02\x02\
	\u{c87}\u{c8a}\x03\x02\x02\x02\u{c88}\u{c86}\x03\x02\x02\x02\u{c89}\u{c8b}\
	\x07\x42\x02\x02\u{c8a}\u{c89}\x03\x02\x02\x02\u{c8a}\u{c8b}\x03\x02\x02\
	\x02\u{c8b}\u{c8c}\x03\x02\x02\x02\u{c8c}\u{c94}\x07\u{1bd}\x02\x02\u{c8d}\
	\u{c8f}\x07\x1e\x02\x02\u{c8e}\u{c8d}\x03\x02\x02\x02\u{c8e}\u{c8f}\x03\
	\x02\x02\x02\u{c8f}\u{c90}\x03\x02\x02\x02\u{c90}\u{c92}\x05\u{164}\u{b3}\
	\x02\u{c91}\u{c93}\x05\u{e2}\x72\x02\u{c92}\u{c91}\x03\x02\x02\x02\u{c92}\
	\u{c93}\x03\x02\x02\x02\u{c93}\u{c95}\x03\x02\x02\x02\u{c94}\u{c8e}\x03\
	\x02\x02\x02\u{c94}\u{c95}\x03\x02\x02\x02\u{c95}\u{cac}\x03\x02\x02\x02\
	\u{c96}\u{c97}\x07\u{1a6}\x02\x02\u{c97}\u{c9c}\x05\u{f8}\x7d\x02\u{c98}\
	\u{c99}\x07\x42\x02\x02\u{c99}\u{c9b}\x05\u{f8}\x7d\x02\u{c9a}\u{c98}\x03\
	\x02\x02\x02\u{c9b}\u{c9e}\x03\x02\x02\x02\u{c9c}\u{c9a}\x03\x02\x02\x02\
	\u{c9c}\u{c9d}\x03\x02\x02\x02\u{c9d}\u{ca0}\x03\x02\x02\x02\u{c9e}\u{c9c}\
	\x03\x02\x02\x02\u{c9f}\u{ca1}\x07\x42\x02\x02\u{ca0}\u{c9f}\x03\x02\x02\
	\x02\u{ca0}\u{ca1}\x03\x02\x02\x02\u{ca1}\u{ca9}\x03\x02\x02\x02\u{ca2}\
	\u{ca4}\x07\x1e\x02\x02\u{ca3}\u{ca2}\x03\x02\x02\x02\u{ca3}\u{ca4}\x03\
	\x02\x02\x02\u{ca4}\u{ca5}\x03\x02\x02\x02\u{ca5}\u{ca7}\x05\u{164}\u{b3}\
	\x02\u{ca6}\u{ca8}\x05\u{e2}\x72\x02\u{ca7}\u{ca6}\x03\x02\x02\x02\u{ca7}\
	\u{ca8}\x03\x02\x02\x02\u{ca8}\u{caa}\x03\x02\x02\x02\u{ca9}\u{ca3}\x03\
	\x02\x02\x02\u{ca9}\u{caa}\x03\x02\x02\x02\u{caa}\u{cac}\x03\x02\x02\x02\
	\u{cab}\u{c7e}\x03\x02\x02\x02\u{cab}\u{c7f}\x03\x02\x02\x02\u{cab}\u{c96}\
	\x03\x02\x02\x02\u{cac}\u{9d}\x03\x02\x02\x02\u{cad}\u{caf}\x05\u{9c}\x4f\
	\x02\u{cae}\u{cb0}\x05\u{a0}\x51\x02\u{caf}\u{cae}\x03\x02\x02\x02\u{caf}\
	\u{cb0}\x03\x02\x02\x02\u{cb0}\u{9f}\x03\x02\x02\x02\u{cb1}\u{cb2}\x09\x1a\
	\x02\x02\u{cb2}\u{cb3}\x05\u{a2}\x52\x02\u{cb3}\u{a1}\x03\x02\x02\x02\u{cb4}\
	\u{cb6}\x09\x1b\x02\x02\u{cb5}\u{cb4}\x03\x02\x02\x02\u{cb5}\u{cb6}\x03\
	\x02\x02\x02\u{cb6}\u{cb7}\x03\x02\x02\x02\u{cb7}\u{cba}\x07\u{1bc}\x02\
	\x02\u{cb8}\u{cbb}\x05\u{a4}\x53\x02\u{cb9}\u{cbb}\x05\u{a6}\x54\x02\u{cba}\
	\u{cb8}\x03\x02\x02\x02\u{cba}\u{cb9}\x03\x02\x02\x02\u{cbb}\u{cbc}\x03\
	\x02\x02\x02\u{cbc}\u{cbe}\x07\u{1bd}\x02\x02\u{cbd}\u{cbf}\x05\u{a8}\x55\
	\x02\u{cbe}\u{cbd}\x03\x02\x02\x02\u{cbe}\u{cbf}\x03\x02\x02\x02\u{cbf}\
	\u{cc8}\x03\x02\x02\x02\u{cc0}\u{cc1}\x09\x1c\x02\x02\u{cc1}\u{cc2}\x07\
	\u{1bc}\x02\x02\u{cc2}\u{cc3}\x05\u{a4}\x53\x02\u{cc3}\u{cc5}\x07\u{1bd}\
	\x02\x02\u{cc4}\u{cc6}\x05\u{a8}\x55\x02\u{cc5}\u{cc4}\x03\x02\x02\x02\u{cc5}\
	\u{cc6}\x03\x02\x02\x02\u{cc6}\u{cc8}\x03\x02\x02\x02\u{cc7}\u{cb5}\x03\
	\x02\x02\x02\u{cc7}\u{cc0}\x03\x02\x02\x02\u{cc8}\u{a3}\x03\x02\x02\x02\
	\u{cc9}\u{cca}\x09\x1d\x02\x02\u{cca}\u{a5}\x03\x02\x02\x02\u{ccb}\u{ccc}\
	\x07\u{1d8}\x02\x02\u{ccc}\u{ccd}\x07\u{14d}\x02\x02\u{ccd}\u{a7}\x03\x02\
	\x02\x02\u{cce}\u{ccf}\x09\x1e\x02\x02\u{ccf}\u{cd0}\x07\u{1bc}\x02\x02\
	\u{cd0}\u{cd1}\x07\u{1d8}\x02\x02\u{cd1}\u{cd2}\x07\u{1bd}\x02\x02\u{cd2}\
	\u{a9}\x03\x02\x02\x02\u{cd3}\u{cd4}\x09\x1f\x02\x02\u{cd4}\u{ab}\x03\x02\
	\x02\x02\u{cd5}\u{cdc}\x07\x7b\x02\x02\u{cd6}\u{cd8}\x07\u{18b}\x02\x02\
	\u{cd7}\u{cd9}\x05\u{122}\u{92}\x02\u{cd8}\u{cd7}\x03\x02\x02\x02\u{cd8}\
	\u{cd9}\x03\x02\x02\x02\u{cd9}\u{cda}\x03\x02\x02\x02\u{cda}\u{cdc}\x05\
	\u{ae}\x58\x02\u{cdb}\u{cd5}\x03\x02\x02\x02\u{cdb}\u{cd6}\x03\x02\x02\x02\
	\u{cdc}\u{ad}\x03\x02\x02\x02\u{cdd}\u{cde}\x07\u{1b1}\x02\x02\u{cde}\u{ce2}\
	\x07\x4f\x02\x02\u{cdf}\u{ce0}\x07\u{1b3}\x02\x02\u{ce0}\u{ce2}\x07\x4f\
	\x02\x02\u{ce1}\u{cdd}\x03\x02\x02\x02\u{ce1}\u{cdf}\x03\x02\x02\x02\u{ce2}\
	\u{af}\x03\x02\x02\x02\u{ce3}\u{ce4}\x05\u{c4}\x63\x02\u{ce4}\u{b1}\x03\
	\x02\x02\x02\u{ce5}\u{d3f}\x05\u{b0}\x59\x02\u{ce6}\u{ce7}\x07\u{e7}\x02\
	\x02\u{ce7}\u{cf5}\x07\u{1bc}\x02\x02\u{ce8}\u{ce9}\x07\u{116}\x02\x02\u{ce9}\
	\u{cea}\x07\x2d\x02\x02\u{cea}\u{cef}\x05\u{f8}\x7d\x02\u{ceb}\u{cec}\x07\
	\x42\x02\x02\u{cec}\u{cee}\x05\u{f8}\x7d\x02\u{ced}\u{ceb}\x03\x02\x02\x02\
	\u{cee}\u{cf1}\x03\x02\x02\x02\u{cef}\u{ced}\x03\x02\x02\x02\u{cef}\u{cf0}\
	\x03\x02\x02\x02\u{cf0}\u{cf3}\x03\x02\x02\x02\u{cf1}\u{cef}\x03\x02\x02\
	\x02\u{cf2}\u{cf4}\x07\x42\x02\x02\u{cf3}\u{cf2}\x03\x02\x02\x02\u{cf3}\
	\u{cf4}\x03\x02\x02\x02\u{cf4}\u{cf6}\x03\x02\x02\x02\u{cf5}\u{ce8}\x03\
	\x02\x02\x02\u{cf5}\u{cf6}\x03\x02\x02\x02\u{cf6}\u{d04}\x03\x02\x02\x02\
	\u{cf7}\u{cf8}\x07\u{10e}\x02\x02\u{cf8}\u{cf9}\x07\x2d\x02\x02\u{cf9}\u{cfe}\
	\x05\x6c\x37\x02\u{cfa}\u{cfb}\x07\x42\x02\x02\u{cfb}\u{cfd}\x05\x6c\x37\
	\x02\u{cfc}\u{cfa}\x03\x02\x02\x02\u{cfd}\u{d00}\x03\x02\x02\x02\u{cfe}\
	\u{cfc}\x03\x02\x02\x02\u{cfe}\u{cff}\x03\x02\x02\x02\u{cff}\u{d02}\x03\
	\x02\x02\x02\u{d00}\u{cfe}\x03\x02\x02\x02\u{d01}\u{d03}\x07\x42\x02\x02\
	\u{d02}\u{d01}\x03\x02\x02\x02\u{d02}\u{d03}\x03\x02\x02\x02\u{d03}\u{d05}\
	\x03\x02\x02\x02\u{d04}\u{cf7}\x03\x02\x02\x02\u{d04}\u{d05}\x03\x02\x02\
	\x02\u{d05}\u{d12}\x03\x02\x02\x02\u{d06}\u{d07}\x07\u{ea}\x02\x02\u{d07}\
	\u{d0c}\x05\u{b4}\x5b\x02\u{d08}\u{d09}\x07\x42\x02\x02\u{d09}\u{d0b}\x05\
	\u{b4}\x5b\x02\u{d0a}\u{d08}\x03\x02\x02\x02\u{d0b}\u{d0e}\x03\x02\x02\x02\
	\u{d0c}\u{d0a}\x03\x02\x02\x02\u{d0c}\u{d0d}\x03\x02\x02\x02\u{d0d}\u{d10}\
	\x03\x02\x02\x02\u{d0e}\u{d0c}\x03\x02\x02\x02\u{d0f}\u{d11}\x07\x42\x02\
	\x02\u{d10}\u{d0f}\x03\x02\x02\x02\u{d10}\u{d11}\x03\x02\x02\x02\u{d11}\
	\u{d13}\x03\x02\x02\x02\u{d12}\u{d06}\x03\x02\x02\x02\u{d12}\u{d13}\x03\
	\x02\x02\x02\u{d13}\u{d15}\x03\x02\x02\x02\u{d14}\u{d16}\x05\u{b6}\x5c\x02\
	\u{d15}\u{d14}\x03\x02\x02\x02\u{d15}\u{d16}\x03\x02\x02\x02\u{d16}\u{d1a}\
	\x03\x02\x02\x02\u{d17}\u{d18}\x07\x13\x02\x02\u{d18}\u{d19}\x07\u{e3}\x02\
	\x02\u{d19}\u{d1b}\x05\u{ba}\x5e\x02\u{d1a}\u{d17}\x03\x02\x02\x02\u{d1a}\
	\u{d1b}\x03\x02\x02\x02\u{d1b}\u{d1d}\x03\x02\x02\x02\u{d1c}\u{d1e}\x09\
	\x20\x02\x02\u{d1d}\u{d1c}\x03\x02\x02\x02\u{d1d}\u{d1e}\x03\x02\x02\x02\
	\u{d1e}\u{d1f}\x03\x02\x02\x02\u{d1f}\u{d20}\x07\u{11c}\x02\x02\u{d20}\u{d21}\
	\x07\u{1bc}\x02\x02\u{d21}\u{d22}\x05\u{148}\u{a5}\x02\u{d22}\u{d2f}\x07\
	\u{1bd}\x02\x02\u{d23}\u{d24}\x07\u{171}\x02\x02\u{d24}\u{d29}\x05\u{bc}\
	\x5f\x02\u{d25}\u{d26}\x07\x42\x02\x02\u{d26}\u{d28}\x05\u{bc}\x5f\x02\u{d27}\
	\u{d25}\x03\x02\x02\x02\u{d28}\u{d2b}\x03\x02\x02\x02\u{d29}\u{d27}\x03\
	\x02\x02\x02\u{d29}\u{d2a}\x03\x02\x02\x02\u{d2a}\u{d2d}\x03\x02\x02\x02\
	\u{d2b}\u{d29}\x03\x02\x02\x02\u{d2c}\u{d2e}\x07\x42\x02\x02\u{d2d}\u{d2c}\
	\x03\x02\x02\x02\u{d2d}\u{d2e}\x03\x02\x02\x02\u{d2e}\u{d30}\x03\x02\x02\
	\x02\u{d2f}\u{d23}\x03\x02\x02\x02\u{d2f}\u{d30}\x03\x02\x02\x02\u{d30}\
	\u{d31}\x03\x02\x02\x02\u{d31}\u{d32}\x07\x5e\x02\x02\u{d32}\u{d37}\x05\
	\u{be}\x60\x02\u{d33}\u{d34}\x07\x42\x02\x02\u{d34}\u{d36}\x05\u{be}\x60\
	\x02\u{d35}\u{d33}\x03\x02\x02\x02\u{d36}\u{d39}\x03\x02\x02\x02\u{d37}\
	\u{d35}\x03\x02\x02\x02\u{d37}\u{d38}\x03\x02\x02\x02\u{d38}\u{d3b}\x03\
	\x02\x02\x02\u{d39}\u{d37}\x03\x02\x02\x02\u{d3a}\u{d3c}\x07\x42\x02\x02\
	\u{d3b}\u{d3a}\x03\x02\x02\x02\u{d3b}\u{d3c}\x03\x02\x02\x02\u{d3c}\u{d3d}\
	\x03\x02\x02\x02\u{d3d}\u{d3e}\x07\u{1bd}\x02\x02\u{d3e}\u{d40}\x03\x02\
	\x02\x02\u{d3f}\u{ce6}\x03\x02\x02\x02\u{d3f}\u{d40}\x03\x02\x02\x02\u{d40}\
	\u{b3}\x03\x02\x02\x02\u{d41}\u{d42}\x05\u{f8}\x7d\x02\u{d42}\u{d43}\x07\
	\x1e\x02\x02\u{d43}\u{d44}\x05\u{164}\u{b3}\x02\u{d44}\u{b5}\x03\x02\x02\
	\x02\u{d45}\u{d46}\x07\u{109}\x02\x02\u{d46}\u{d47}\x07\u{14c}\x02\x02\u{d47}\
	\u{d48}\x07\u{11d}\x02\x02\u{d48}\u{d51}\x07\u{e3}\x02\x02\u{d49}\u{d4a}\
	\x07\x14\x02\x02\u{d4a}\u{d4b}\x07\u{14d}\x02\x02\u{d4b}\u{d4c}\x07\u{11d}\
	\x02\x02\u{d4c}\u{d4e}\x07\u{e3}\x02\x02\u{d4d}\u{d4f}\x05\u{b8}\x5d\x02\
	\u{d4e}\u{d4d}\x03\x02\x02\x02\u{d4e}\u{d4f}\x03\x02\x02\x02\u{d4f}\u{d51}\
	\x03\x02\x02\x02\u{d50}\u{d45}\x03\x02\x02\x02\u{d50}\u{d49}\x03\x02\x02\
	\x02\u{d51}\u{b7}\x03\x02\x02\x02\u{d52}\u{d53}\x07\u{162}\x02\x02\u{d53}\
	\u{d54}\x07\x75\x02\x02\u{d54}\u{d5c}\x07\u{e5}\x02\x02\u{d55}\u{d56}\x07\
	\u{107}\x02\x02\u{d56}\u{d57}\x07\x75\x02\x02\u{d57}\u{d5c}\x07\u{e5}\x02\
	\x02\u{d58}\u{d59}\x07\u{1b1}\x02\x02\u{d59}\u{d5a}\x07\u{197}\x02\x02\u{d5a}\
	\u{d5c}\x07\u{14d}\x02\x02\u{d5b}\u{d52}\x03\x02\x02\x02\u{d5b}\u{d55}\x03\
	\x02\x02\x02\u{d5b}\u{d58}\x03\x02\x02\x02\u{d5c}\u{b9}\x03\x02\x02\x02\
	\u{d5d}\u{d5e}\x07\u{164}\x02\x02\u{d5e}\u{d5f}\x07\u{183}\x02\x02\u{d5f}\
	\u{d60}\x07\u{f6}\x02\x02\u{d60}\u{d71}\x07\u{14c}\x02\x02\u{d61}\u{d62}\
	\x07\u{164}\x02\x02\u{d62}\u{d63}\x07\u{11a}\x02\x02\u{d63}\u{d64}\x07\u{d2}\
	\x02\x02\u{d64}\u{d71}\x07\u{14c}\x02\x02\u{d65}\u{d66}\x07\u{164}\x02\x02\
	\u{d66}\u{d67}\x07\u{183}\x02\x02\u{d67}\u{d68}\x07\u{8e}\x02\x02\u{d68}\
	\u{d71}\x05\u{164}\u{b3}\x02\u{d69}\u{d6a}\x07\u{164}\x02\x02\u{d6a}\u{d6b}\
	\x07\u{183}\x02\x02\u{d6b}\u{d6c}\x07\u{d2}\x02\x02\u{d6c}\u{d71}\x05\u{164}\
	\u{b3}\x02\u{d6d}\u{d6e}\x07\u{164}\x02\x02\u{d6e}\u{d6f}\x07\u{183}\x02\
	\x02\u{d6f}\u{d71}\x05\u{164}\u{b3}\x02\u{d70}\u{d5d}\x03\x02\x02\x02\u{d70}\
	\u{d61}\x03\x02\x02\x02\u{d70}\u{d65}\x03\x02\x02\x02\u{d70}\u{d69}\x03\
	\x02\x02\x02\u{d70}\u{d6d}\x03\x02\x02\x02\u{d71}\u{bb}\x03\x02\x02\x02\
	\u{d72}\u{d73}\x05\u{164}\u{b3}\x02\u{d73}\u{d74}\x07\u{1c1}\x02\x02\u{d74}\
	\u{d75}\x07\u{1bc}\x02\x02\u{d75}\u{d7a}\x05\u{164}\u{b3}\x02\u{d76}\u{d77}\
	\x07\x42\x02\x02\u{d77}\u{d79}\x05\u{164}\u{b3}\x02\u{d78}\u{d76}\x03\x02\
	\x02\x02\u{d79}\u{d7c}\x03\x02\x02\x02\u{d7a}\u{d78}\x03\x02\x02\x02\u{d7a}\
	\u{d7b}\x03\x02\x02\x02\u{d7b}\u{d7e}\x03\x02\x02\x02\u{d7c}\u{d7a}\x03\
	\x02\x02\x02\u{d7d}\u{d7f}\x07\x42\x02\x02\u{d7e}\u{d7d}\x03\x02\x02\x02\
	\u{d7e}\u{d7f}\x03\x02\x02\x02\u{d7f}\u{d80}\x03\x02\x02\x02\u{d80}\u{d81}\
	\x07\u{1bd}\x02\x02\u{d81}\u{bd}\x03\x02\x02\x02\u{d82}\u{d83}\x05\u{164}\
	\u{b3}\x02\u{d83}\u{d84}\x07\x1e\x02\x02\u{d84}\u{d85}\x05\u{f8}\x7d\x02\
	\u{d85}\u{bf}\x03\x02\x02\x02\u{d86}\u{d87}\x07\x21\x02\x02\u{d87}\u{d94}\
	\x07\u{1bc}\x02\x02\u{d88}\u{d89}\x07\u{182}\x02\x02\u{d89}\u{d8a}\x07\x03\
	\x02\x02\u{d8a}\u{d95}\x05\u{f8}\x7d\x02\u{d8b}\u{d8c}\x07\u{106}\x02\x02\
	\u{d8c}\u{d8d}\x07\x03\x02\x02\u{d8d}\u{d95}\x05\u{f8}\x7d\x02\u{d8e}\u{d8f}\
	\x07\u{16b}\x02\x02\u{d8f}\u{d90}\x07\x03\x02\x02\u{d90}\u{d95}\x05\u{f8}\
	\x7d\x02\u{d91}\u{d92}\x07\u{16e}\x02\x02\u{d92}\u{d93}\x07\x03\x02\x02\
	\u{d93}\u{d95}\x05\u{122}\u{92}\x02\u{d94}\u{d88}\x03\x02\x02\x02\u{d94}\
	\u{d8b}\x03\x02\x02\x02\u{d94}\u{d8e}\x03\x02\x02\x02\u{d94}\u{d91}\x03\
	\x02\x02\x02\u{d95}\u{d96}\x03\x02\x02\x02\u{d96}\u{d97}\x07\u{1bd}\x02\
	\x02\u{d97}\u{da0}\x03\x02\x02\x02\u{d98}\u{d99}\x07\x27\x02\x02\u{d99}\
	\u{d9a}\x07\u{1bc}\x02\x02\u{d9a}\u{d9b}\x07\u{16b}\x02\x02\u{d9b}\u{d9c}\
	\x07\x03\x02\x02\u{d9c}\u{d9d}\x05\u{f8}\x7d\x02\u{d9d}\u{d9e}\x07\u{1bd}\
	\x02\x02\u{d9e}\u{da0}\x03\x02\x02\x02\u{d9f}\u{d86}\x03\x02\x02\x02\u{d9f}\
	\u{d98}\x03\x02\x02\x02\u{da0}\u{c1}\x03\x02\x02\x02\u{da1}\u{da7}\x05\u{e0}\
	\x71\x02\u{da2}\u{da3}\x07\x69\x02\x02\u{da3}\u{da4}\x07\u{1bc}\x02\x02\
	\u{da4}\u{da5}\x07\u{1de}\x02\x02\u{da5}\u{da7}\x07\u{1bd}\x02\x02\u{da6}\
	\u{da1}\x03\x02\x02\x02\u{da6}\u{da2}\x03\x02\x02\x02\u{da7}\u{c3}\x03\x02\
	\x02\x02\u{da8}\u{daa}\x05\u{c2}\x62\x02\u{da9}\u{dab}\x05\u{c0}\x61\x02\
	\u{daa}\u{da9}\x03\x02\x02\x02\u{daa}\u{dab}\x03\x02\x02\x02\u{dab}\u{dc4}\
	\x03\x02\x02\x02\u{dac}\u{dad}\x07\x39\x02\x02\u{dad}\u{dae}\x07\u{1bc}\
	\x02\x02\u{dae}\u{daf}\x07\u{b3}\x02\x02\u{daf}\u{db0}\x07\x03\x02\x02\u{db0}\
	\u{db1}\x09\x21\x02\x02\u{db1}\u{db2}\x07\u{1bd}\x02\x02\u{db2}\u{dc2}\x05\
	\u{c0}\x61\x02\u{db3}\u{db4}\x07\x79\x02\x02\u{db4}\u{dbe}\x07\u{1bc}\x02\
	\x02\u{db5}\u{db6}\x07\u{182}\x02\x02\u{db6}\u{db7}\x07\x03\x02\x02\u{db7}\
	\u{dbf}\x05\u{f8}\x7d\x02\u{db8}\u{db9}\x07\u{106}\x02\x02\u{db9}\u{dba}\
	\x07\x03\x02\x02\u{dba}\u{dbf}\x05\u{f8}\x7d\x02\u{dbb}\u{dbc}\x07\u{16b}\
	\x02\x02\u{dbc}\u{dbd}\x07\x03\x02\x02\u{dbd}\u{dbf}\x05\u{f8}\x7d\x02\u{dbe}\
	\u{db5}\x03\x02\x02\x02\u{dbe}\u{db8}\x03\x02\x02\x02\u{dbe}\u{dbb}\x03\
	\x02\x02\x02\u{dbf}\u{dc0}\x03\x02\x02\x02\u{dc0}\u{dc1}\x07\u{1bd}\x02\
	\x02\u{dc1}\u{dc3}\x03\x02\x02\x02\u{dc2}\u{db3}\x03\x02\x02\x02\u{dc2}\
	\u{dc3}\x03\x02\x02\x02\u{dc3}\u{dc5}\x03\x02\x02\x02\u{dc4}\u{dac}\x03\
	\x02\x02\x02\u{dc4}\u{dc5}\x03\x02\x02\x02\u{dc5}\u{c5}\x03\x02\x02\x02\
	\u{dc6}\u{dcd}\x05\u{b2}\x5a\x02\u{dc7}\u{dc8}\x07\u{175}\x02\x02\u{dc8}\
	\u{dc9}\x07\u{1bc}\x02\x02\u{dc9}\u{dca}\x05\u{e6}\x74\x02\u{dca}\u{dcb}\
	\x07\u{1bd}\x02\x02\u{dcb}\u{dcd}\x03\x02\x02\x02\u{dcc}\u{dc6}\x03\x02\
	\x02\x02\u{dcc}\u{dc7}\x03\x02\x02\x02\u{dcd}\u{c7}\x03\x02\x02\x02\u{dce}\
	\u{dd2}\x05\u{c6}\x64\x02\u{dcf}\u{dd1}\x05\u{dc}\x6f\x02\u{dd0}\u{dcf}\
	\x03\x02\x02\x02\u{dd1}\u{dd4}\x03\x02\x02\x02\u{dd2}\u{dd0}\x03\x02\x02\
	\x02\u{dd2}\u{dd3}\x03\x02\x02\x02\u{dd3}\u{c9}\x03\x02\x02\x02\u{dd4}\u{dd2}\
	\x03\x02\x02\x02\u{dd5}\u{dde}\x05\u{c8}\x65\x02\u{dd6}\u{dd7}\x07\x1e\x02\
	\x02\u{dd7}\u{dda}\x05\u{164}\u{b3}\x02\u{dd8}\u{dda}\x05\u{166}\u{b4}\x02\
	\u{dd9}\u{dd6}\x03\x02\x02\x02\u{dd9}\u{dd8}\x03\x02\x02\x02\u{dda}\u{ddc}\
	\x03\x02\x02\x02\u{ddb}\u{ddd}\x05\u{e2}\x72\x02\u{ddc}\u{ddb}\x03\x02\x02\
	\x02\u{ddc}\u{ddd}\x03\x02\x02\x02\u{ddd}\u{ddf}\x03\x02\x02\x02\u{dde}\
	\u{dd9}\x03\x02\x02\x02\u{dde}\u{ddf}\x03\x02\x02\x02\u{ddf}\u{cb}\x03\x02\
	\x02\x02\u{de0}\u{de1}\x05\u{f8}\x7d\x02\u{de1}\u{cd}\x03\x02\x02\x02\u{de2}\
	\u{de3}\x05\u{164}\u{b3}\x02\u{de3}\u{cf}\x03\x02\x02\x02\u{de4}\u{de5}\
	\x05\u{f8}\x7d\x02\u{de5}\u{d1}\x03\x02\x02\x02\u{de6}\u{de7}\x07\x1e\x02\
	\x02\u{de7}\u{dea}\x05\u{164}\u{b3}\x02\u{de8}\u{dea}\x05\u{166}\u{b4}\x02\
	\u{de9}\u{de6}\x03\x02\x02\x02\u{de9}\u{de8}\x03\x02\x02\x02\u{dea}\u{dec}\
	\x03\x02\x02\x02\u{deb}\u{ded}\x05\u{e2}\x72\x02\u{dec}\u{deb}\x03\x02\x02\
	\x02\u{dec}\u{ded}\x03\x02\x02\x02\u{ded}\u{def}\x03\x02\x02\x02\u{dee}\
	\u{de9}\x03\x02\x02\x02\u{dee}\u{def}\x03\x02\x02\x02\u{def}\u{d3}\x03\x02\
	\x02\x02\u{df0}\u{df1}\x05\u{164}\u{b3}\x02\u{df1}\u{df2}\x07\u{92}\x02\
	\x02\u{df2}\u{df3}\x05\u{164}\u{b3}\x02\u{df3}\u{df4}\x07\u{af}\x02\x02\
	\u{df4}\u{df5}\x07\u{1bc}\x02\x02\u{df5}\u{df6}\x05\u{d6}\x6c\x02\u{df6}\
	\u{df7}\x07\u{1bd}\x02\x02\u{df7}\u{d5}\x03\x02\x02\x02\u{df8}\u{dfd}\x05\
	\u{164}\u{b3}\x02\u{df9}\u{dfa}\x07\x42\x02\x02\u{dfa}\u{dfc}\x05\u{164}\
	\u{b3}\x02\u{dfb}\u{df9}\x03\x02\x02\x02\u{dfc}\u{dff}\x03\x02\x02\x02\u{dfd}\
	\u{dfb}\x03\x02\x02\x02\u{dfd}\u{dfe}\x03\x02\x02\x02\u{dfe}\u{e01}\x03\
	\x02\x02\x02\u{dff}\u{dfd}\x03\x02\x02\x02\u{e00}\u{e02}\x07\x42\x02\x02\
	\u{e01}\u{e00}\x03\x02\x02\x02\u{e01}\u{e02}\x03\x02\x02\x02\u{e02}\u{d7}\
	\x03\x02\x02\x02\u{e03}\u{e04}\x05\u{d4}\x6b\x02\u{e04}\u{d9}\x03\x02\x02\
	\x02\u{e05}\u{e0a}\x05\u{d0}\x69\x02\u{e06}\u{e07}\x07\x42\x02\x02\u{e07}\
	\u{e09}\x05\u{d0}\x69\x02\u{e08}\u{e06}\x03\x02\x02\x02\u{e09}\u{e0c}\x03\
	\x02\x02\x02\u{e0a}\u{e08}\x03\x02\x02\x02\u{e0a}\u{e0b}\x03\x02\x02\x02\
	\u{e0b}\u{e0e}\x03\x02\x02\x02\u{e0c}\u{e0a}\x03\x02\x02\x02\u{e0d}\u{e0f}\
	\x07\x42\x02\x02\u{e0e}\u{e0d}\x03\x02\x02\x02\u{e0e}\u{e0f}\x03\x02\x02\
	\x02\u{e0f}\u{e16}\x03\x02\x02\x02\u{e10}\u{e12}\x07\x19\x02\x02\u{e11}\
	\u{e13}\x05\u{86}\x44\x02\u{e12}\u{e11}\x03\x02\x02\x02\u{e12}\u{e13}\x03\
	\x02\x02\x02\u{e13}\u{e16}\x03\x02\x02\x02\u{e14}\u{e16}\x05\x2a\x16\x02\
	\u{e15}\u{e05}\x03\x02\x02\x02\u{e15}\u{e10}\x03\x02\x02\x02\u{e15}\u{e14}\
	\x03\x02\x02\x02\u{e16}\u{db}\x03\x02\x02\x02\u{e17}\u{e18}\x07\u{122}\x02\
	\x02\u{e18}\u{e19}\x07\u{1bc}\x02\x02\u{e19}\u{e1a}\x05\u{cc}\x67\x02\u{e1a}\
	\u{e1b}\x07\u{92}\x02\x02\u{e1b}\u{e1c}\x05\u{ce}\x68\x02\u{e1c}\u{e1d}\
	\x07\u{af}\x02\x02\u{e1d}\u{e1e}\x07\u{1bc}\x02\x02\u{e1e}\u{e1f}\x05\u{da}\
	\x6e\x02\u{e1f}\u{e20}\x07\u{1bd}\x02\x02\u{e20}\u{e21}\x07\u{1bd}\x02\x02\
	\u{e21}\u{e22}\x05\u{d2}\x6a\x02\u{e22}\u{e2d}\x03\x02\x02\x02\u{e23}\u{e25}\
	\x07\u{199}\x02\x02\u{e24}\u{e26}\x05\x10\x09\x02\u{e25}\u{e24}\x03\x02\
	\x02\x02\u{e25}\u{e26}\x03\x02\x02\x02\u{e26}\u{e27}\x03\x02\x02\x02\u{e27}\
	\u{e28}\x07\u{1bc}\x02\x02\u{e28}\u{e29}\x05\u{d8}\x6d\x02\u{e29}\u{e2a}\
	\x07\u{1bd}\x02\x02\u{e2a}\u{e2b}\x05\u{d2}\x6a\x02\u{e2b}\u{e2d}\x03\x02\
	\x02\x02\u{e2c}\u{e17}\x03\x02\x02\x02\u{e2c}\u{e23}\x03\x02\x02\x02\u{e2d}\
	\u{dd}\x03\x02\x02\x02\u{e2e}\u{e2f}\x05\u{e4}\x73\x02\u{e2f}\u{df}\x03\
	\x02\x02\x02\u{e30}\u{e39}\x05\u{de}\x70\x02\u{e31}\u{e32}\x07\x1e\x02\x02\
	\u{e32}\u{e35}\x05\u{164}\u{b3}\x02\u{e33}\u{e35}\x05\u{166}\u{b4}\x02\u{e34}\
	\u{e31}\x03\x02\x02\x02\u{e34}\u{e33}\x03\x02\x02\x02\u{e35}\u{e37}\x03\
	\x02\x02\x02\u{e36}\u{e38}\x05\u{e2}\x72\x02\u{e37}\u{e36}\x03\x02\x02\x02\
	\u{e37}\u{e38}\x03\x02\x02\x02\u{e38}\u{e3a}\x03\x02\x02\x02\u{e39}\u{e34}\
	\x03\x02\x02\x02\u{e39}\u{e3a}\x03\x02\x02\x02\u{e3a}\u{e1}\x03\x02\x02\
	\x02\u{e3b}\u{e3c}\x07\u{1bc}\x02\x02\u{e3c}\u{e3e}\x05\u{170}\u{b9}\x02\
	\u{e3d}\u{e3f}\x07\x42\x02\x02\u{e3e}\u{e3d}\x03\x02\x02\x02\u{e3e}\u{e3f}\
	\x03\x02\x02\x02\u{e3f}\u{e40}\x03\x02\x02\x02\u{e40}\u{e41}\x07\u{1bd}\
	\x02\x02\u{e41}\u{e3}\x03\x02\x02\x02\u{e42}\u{e48}\x07\u{d4}\x02\x02\u{e43}\
	\u{e44}\x07\u{1bc}\x02\x02\u{e44}\u{e45}\x05\x2a\x16\x02\u{e45}\u{e46}\x07\
	\u{1bd}\x02\x02\u{e46}\u{e49}\x03\x02\x02\x02\u{e47}\u{e49}\x05\u{e6}\x74\
	\x02\u{e48}\u{e43}\x03\x02\x02\x02\u{e48}\u{e47}\x03\x02\x02\x02\u{e49}\
	\u{e7a}\x03\x02\x02\x02\u{e4a}\u{e7a}\x05\u{156}\u{ac}\x02\u{e4b}\u{e4c}\
	\x07\u{175}\x02\x02\u{e4c}\u{e4d}\x07\u{1bc}\x02\x02\u{e4d}\u{e4e}\x07\u{1df}\
	\x02\x02\u{e4e}\u{e7a}\x07\u{1bd}\x02\x02\u{e4f}\u{e5e}\x07\u{1de}\x02\x02\
	\u{e50}\u{e51}\x07\u{1bc}\x02\x02\u{e51}\u{e56}\x05\u{11a}\u{8e}\x02\u{e52}\
	\u{e53}\x07\x42\x02\x02\u{e53}\u{e55}\x05\u{11a}\u{8e}\x02\u{e54}\u{e52}\
	\x03\x02\x02\x02\u{e55}\u{e58}\x03\x02\x02\x02\u{e56}\u{e54}\x03\x02\x02\
	\x02\u{e56}\u{e57}\x03\x02\x02\x02\u{e57}\u{e5a}\x03\x02\x02\x02\u{e58}\
	\u{e56}\x03\x02\x02\x02\u{e59}\u{e5b}\x07\x42\x02\x02\u{e5a}\u{e59}\x03\
	\x02\x02\x02\u{e5a}\u{e5b}\x03\x02\x02\x02\u{e5b}\u{e5c}\x03\x02\x02\x02\
	\u{e5c}\u{e5d}\x07\u{1bd}\x02\x02\u{e5d}\u{e5f}\x03\x02\x02\x02\u{e5e}\u{e50}\
	\x03\x02\x02\x02\u{e5e}\u{e5f}\x03\x02\x02\x02\u{e5f}\u{e7a}\x03\x02\x02\
	\x02\u{e60}\u{e6f}\x07\u{1d4}\x02\x02\u{e61}\u{e62}\x07\u{1bc}\x02\x02\u{e62}\
	\u{e67}\x05\u{11a}\u{8e}\x02\u{e63}\u{e64}\x07\x42\x02\x02\u{e64}\u{e66}\
	\x05\u{11a}\u{8e}\x02\u{e65}\u{e63}\x03\x02\x02\x02\u{e66}\u{e69}\x03\x02\
	\x02\x02\u{e67}\u{e65}\x03\x02\x02\x02\u{e67}\u{e68}\x03\x02\x02\x02\u{e68}\
	\u{e6b}\x03\x02\x02\x02\u{e69}\u{e67}\x03\x02\x02\x02\u{e6a}\u{e6c}\x07\
	\x42\x02\x02\u{e6b}\u{e6a}\x03\x02\x02\x02\u{e6b}\u{e6c}\x03\x02\x02\x02\
	\u{e6c}\u{e6d}\x03\x02\x02\x02\u{e6d}\u{e6e}\x07\u{1bd}\x02\x02\u{e6e}\u{e70}\
	\x03\x02\x02\x02\u{e6f}\u{e61}\x03\x02\x02\x02\u{e6f}\u{e70}\x03\x02\x02\
	\x02\u{e70}\u{e7a}\x03\x02\x02\x02\u{e71}\u{e72}\x07\u{1bc}\x02\x02\u{e72}\
	\u{e73}\x05\x2a\x16\x02\u{e73}\u{e74}\x07\u{1bd}\x02\x02\u{e74}\u{e7a}\x03\
	\x02\x02\x02\u{e75}\u{e76}\x07\u{1bc}\x02\x02\u{e76}\u{e77}\x05\u{92}\x4a\
	\x02\u{e77}\u{e78}\x07\u{1bd}\x02\x02\u{e78}\u{e7a}\x03\x02\x02\x02\u{e79}\
	\u{e42}\x03\x02\x02\x02\u{e79}\u{e4a}\x03\x02\x02\x02\u{e79}\u{e4b}\x03\
	\x02\x02\x02\u{e79}\u{e4f}\x03\x02\x02\x02\u{e79}\u{e60}\x03\x02\x02\x02\
	\u{e79}\u{e71}\x03\x02\x02\x02\u{e79}\u{e75}\x03\x02\x02\x02\u{e7a}\u{e5}\
	\x03\x02\x02\x02\u{e7b}\u{e7c}\x07\u{1a4}\x02\x02\u{e7c}\u{e7d}\x07\u{1bc}\
	\x02\x02\u{e7d}\u{e7e}\x05\u{154}\u{ab}\x02\u{e7e}\u{e7f}\x07\x42\x02\x02\
	\u{e7f}\u{e80}\x05\u{10a}\u{86}\x02\u{e80}\u{e81}\x07\u{1bd}\x02\x02\u{e81}\
	\u{ea6}\x03\x02\x02\x02\u{e82}\u{e83}\x05\u{116}\u{8c}\x02\u{e83}\u{e8f}\
	\x07\u{1bc}\x02\x02\u{e84}\u{e89}\x05\u{ec}\x77\x02\u{e85}\u{e86}\x07\x42\
	\x02\x02\u{e86}\u{e88}\x05\u{ec}\x77\x02\u{e87}\u{e85}\x03\x02\x02\x02\u{e88}\
	\u{e8b}\x03\x02\x02\x02\u{e89}\u{e87}\x03\x02\x02\x02\u{e89}\u{e8a}\x03\
	\x02\x02\x02\u{e8a}\u{e8d}\x03\x02\x02\x02\u{e8b}\u{e89}\x03\x02\x02\x02\
	\u{e8c}\u{e8e}\x07\x42\x02\x02\u{e8d}\u{e8c}\x03\x02\x02\x02\u{e8d}\u{e8e}\
	\x03\x02\x02\x02\u{e8e}\u{e90}\x03\x02\x02\x02\u{e8f}\u{e84}\x03\x02\x02\
	\x02\u{e8f}\u{e90}\x03\x02\x02\x02\u{e90}\u{e92}\x03\x02\x02\x02\u{e91}\
	\u{e93}\x05\u{e8}\x75\x02\u{e92}\u{e91}\x03\x02\x02\x02\u{e92}\u{e93}\x03\
	\x02\x02\x02\u{e93}\u{e94}\x03\x02\x02\x02\u{e94}\u{e96}\x07\u{1bd}\x02\
	\x02\u{e95}\u{e97}\x05\u{140}\u{a1}\x02\u{e96}\u{e95}\x03\x02\x02\x02\u{e96}\
	\u{e97}\x03\x02\x02\x02\u{e97}\u{ea6}\x03\x02\x02\x02\u{e98}\u{e99}\x05\
	\u{116}\u{8c}\x02\u{e99}\u{e9d}\x07\u{1bc}\x02\x02\u{e9a}\u{e9b}\x05\u{ea}\
	\x76\x02\u{e9b}\u{e9c}\x07\x03\x02\x02\u{e9c}\u{e9e}\x03\x02\x02\x02\u{e9d}\
	\u{e9a}\x03\x02\x02\x02\u{e9d}\u{e9e}\x03\x02\x02\x02\u{e9e}\u{e9f}\x03\
	\x02\x02\x02\u{e9f}\u{ea1}\x05\x50\x29\x02\u{ea0}\u{ea2}\x07\x42\x02\x02\
	\u{ea1}\u{ea0}\x03\x02\x02\x02\u{ea1}\u{ea2}\x03\x02\x02\x02\u{ea2}\u{ea3}\
	\x03\x02\x02\x02\u{ea3}\u{ea4}\x07\u{1bd}\x02\x02\u{ea4}\u{ea6}\x03\x02\
	\x02\x02\u{ea5}\u{e7b}\x03\x02\x02\x02\u{ea5}\u{e82}\x03\x02\x02\x02\u{ea5}\
	\u{e98}\x03\x02\x02\x02\u{ea6}\u{e7}\x03\x02\x02\x02\u{ea7}\u{ea8}\x07\x4d\
	\x02\x02\u{ea8}\u{ead}\x05\u{f6}\x7c\x02\u{ea9}\u{eaa}\x07\x42\x02\x02\u{eaa}\
	\u{eac}\x05\u{f6}\x7c\x02\u{eab}\u{ea9}\x03\x02\x02\x02\u{eac}\u{eaf}\x03\
	\x02\x02\x02\u{ead}\u{eab}\x03\x02\x02\x02\u{ead}\u{eae}\x03\x02\x02\x02\
	\u{eae}\u{eb1}\x03\x02\x02\x02\u{eaf}\u{ead}\x03\x02\x02\x02\u{eb0}\u{eb2}\
	\x07\x42\x02\x02\u{eb1}\u{eb0}\x03\x02\x02\x02\u{eb1}\u{eb2}\x03\x02\x02\
	\x02\u{eb2}\u{e9}\x03\x02\x02\x02\u{eb3}\u{eb7}\x05\u{164}\u{b3}\x02\u{eb4}\
	\u{eb7}\x07\u{110}\x02\x02\u{eb5}\u{eb7}\x07\u{134}\x02\x02\u{eb6}\u{eb3}\
	\x03\x02\x02\x02\u{eb6}\u{eb4}\x03\x02\x02\x02\u{eb6}\u{eb5}\x03\x02\x02\
	\x02\u{eb7}\u{eb}\x03\x02\x02\x02\u{eb8}\u{eb9}\x05\u{ea}\x76\x02\u{eb9}\
	\u{eba}\x07\x03\x02\x02\u{eba}\u{ebc}\x03\x02\x02\x02\u{ebb}\u{eb8}\x03\
	\x02\x02\x02\u{ebb}\u{ebc}\x03\x02\x02\x02\u{ebc}\u{ec0}\x03\x02\x02\x02\
	\u{ebd}\u{ec1}\x05\u{ee}\x78\x02\u{ebe}\u{ec1}\x05\u{f2}\x7a\x02\u{ebf}\
	\u{ec1}\x05\u{f8}\x7d\x02\u{ec0}\u{ebd}\x03\x02\x02\x02\u{ec0}\u{ebe}\x03\
	\x02\x02\x02\u{ec0}\u{ebf}\x03\x02\x02\x02\u{ec1}\u{ed}\x03\x02\x02\x02\
	\u{ec2}\u{ed7}\x05\u{f0}\x79\x02\u{ec3}\u{ec4}\x07\u{116}\x02\x02\u{ec4}\
	\u{ed5}\x07\x2d\x02\x02\u{ec5}\u{ed1}\x07\u{1bc}\x02\x02\u{ec6}\u{ecb}\x05\
	\u{f8}\x7d\x02\u{ec7}\u{ec8}\x07\x42\x02\x02\u{ec8}\u{eca}\x05\u{f8}\x7d\
	\x02\u{ec9}\u{ec7}\x03\x02\x02\x02\u{eca}\u{ecd}\x03\x02\x02\x02\u{ecb}\
	\u{ec9}\x03\x02\x02\x02\u{ecb}\u{ecc}\x03\x02\x02\x02\u{ecc}\u{ecf}\x03\
	\x02\x02\x02\u{ecd}\u{ecb}\x03\x02\x02\x02\u{ece}\u{ed0}\x07\x42\x02\x02\
	\u{ecf}\u{ece}\x03\x02\x02\x02\u{ecf}\u{ed0}\x03\x02\x02\x02\u{ed0}\u{ed2}\
	\x03\x02\x02\x02\u{ed1}\u{ec6}\x03\x02\x02\x02\u{ed1}\u{ed2}\x03\x02\x02\
	\x02\u{ed2}\u{ed3}\x03\x02\x02\x02\u{ed3}\u{ed6}\x07\u{1bd}\x02\x02\u{ed4}\
	\u{ed6}\x05\u{f8}\x7d\x02\u{ed5}\u{ec5}\x03\x02\x02\x02\u{ed5}\u{ed4}\x03\
	\x02\x02\x02\u{ed6}\u{ed8}\x03\x02\x02\x02\u{ed7}\u{ec3}\x03\x02\x02\x02\
	\u{ed7}\u{ed8}\x03\x02\x02\x02\u{ed8}\u{edf}\x03\x02\x02\x02\u{ed9}\u{eda}\
	\x07\u{12e}\x02\x02\u{eda}\u{edb}\x07\u{1ae}\x02\x02\u{edb}\u{ee0}\x07\x75\
	\x02\x02\u{edc}\u{edd}\x07\u{cc}\x02\x02\u{edd}\u{ede}\x07\u{1ae}\x02\x02\
	\u{ede}\u{ee0}\x07\x75\x02\x02\u{edf}\u{ed9}\x03\x02\x02\x02\u{edf}\u{edc}\
	\x03\x02\x02\x02\u{edf}\u{ee0}\x03\x02\x02\x02\u{ee0}\u{ef4}\x03\x02\x02\
	\x02\u{ee1}\u{ee2}\x07\u{10e}\x02\x02\u{ee2}\u{ef2}\x07\x2d\x02\x02\u{ee3}\
	\u{ee4}\x07\u{1bc}\x02\x02\u{ee4}\u{ee9}\x05\x6c\x37\x02\u{ee5}\u{ee6}\x07\
	\x42\x02\x02\u{ee6}\u{ee8}\x05\x6c\x37\x02\u{ee7}\u{ee5}\x03\x02\x02\x02\
	\u{ee8}\u{eeb}\x03\x02\x02\x02\u{ee9}\u{ee7}\x03\x02\x02\x02\u{ee9}\u{eea}\
	\x03\x02\x02\x02\u{eea}\u{eed}\x03\x02\x02\x02\u{eeb}\u{ee9}\x03\x02\x02\
	\x02\u{eec}\u{eee}\x07\x42\x02\x02\u{eed}\u{eec}\x03\x02\x02\x02\u{eed}\
	\u{eee}\x03\x02\x02\x02\u{eee}\u{eef}\x03\x02\x02\x02\u{eef}\u{ef0}\x07\
	\u{1bd}\x02\x02\u{ef0}\u{ef3}\x03\x02\x02\x02\u{ef1}\u{ef3}\x05\x6c\x37\
	\x02\u{ef2}\u{ee3}\x03\x02\x02\x02\u{ef2}\u{ef1}\x03\x02\x02\x02\u{ef3}\
	\u{ef5}\x03\x02\x02\x02\u{ef4}\u{ee1}\x03\x02\x02\x02\u{ef4}\u{ef5}\x03\
	\x02\x02\x02\u{ef5}\u{ef}\x03\x02\x02\x02\u{ef6}\u{ef7}\x07\u{175}\x02\x02\
	\u{ef7}\u{ef8}\x07\u{1bc}\x02\x02\u{ef8}\u{ef9}\x05\u{154}\u{ab}\x02\u{ef9}\
	\u{f01}\x07\u{1bd}\x02\x02\u{efa}\u{efc}\x07\x1e\x02\x02\u{efb}\u{efa}\x03\
	\x02\x02\x02\u{efb}\u{efc}\x03\x02\x02\x02\u{efc}\u{efd}\x03\x02\x02\x02\
	\u{efd}\u{eff}\x05\u{164}\u{b3}\x02\u{efe}\u{f00}\x05\u{e2}\x72\x02\u{eff}\
	\u{efe}\x03\x02\x02\x02\u{eff}\u{f00}\x03\x02\x02\x02\u{f00}\u{f02}\x03\
	\x02\x02\x02\u{f01}\u{efb}\x03\x02\x02\x02\u{f01}\u{f02}\x03\x02\x02\x02\
	\u{f02}\u{f11}\x03\x02\x02\x02\u{f03}\u{f04}\x07\u{175}\x02\x02\u{f04}\u{f05}\
	\x07\u{1bc}\x02\x02\u{f05}\u{f06}\x05\x2a\x16\x02\u{f06}\u{f0e}\x07\u{1bd}\
	\x02\x02\u{f07}\u{f09}\x07\x1e\x02\x02\u{f08}\u{f07}\x03\x02\x02\x02\u{f08}\
	\u{f09}\x03\x02\x02\x02\u{f09}\u{f0a}\x03\x02\x02\x02\u{f0a}\u{f0c}\x05\
	\u{164}\u{b3}\x02\u{f0b}\u{f0d}\x05\u{e2}\x72\x02\u{f0c}\u{f0b}\x03\x02\
	\x02\x02\u{f0c}\u{f0d}\x03\x02\x02\x02\u{f0d}\u{f0f}\x03\x02\x02\x02\u{f0e}\
	\u{f08}\x03\x02\x02\x02\u{f0e}\u{f0f}\x03\x02\x02\x02\u{f0f}\u{f11}\x03\
	\x02\x02\x02\u{f10}\u{ef6}\x03\x02\x02\x02\u{f10}\u{f03}\x03\x02\x02\x02\
	\u{f11}\u{f1}\x03\x02\x02\x02\u{f12}\u{f13}\x07\x68\x02\x02\u{f13}\u{f14}\
	\x07\u{1bc}\x02\x02\u{f14}\u{f19}\x05\u{f4}\x7b\x02\u{f15}\u{f16}\x07\x42\
	\x02\x02\u{f16}\u{f18}\x05\u{f4}\x7b\x02\u{f17}\u{f15}\x03\x02\x02\x02\u{f18}\
	\u{f1b}\x03\x02\x02\x02\u{f19}\u{f17}\x03\x02\x02\x02\u{f19}\u{f1a}\x03\
	\x02\x02\x02\u{f1a}\u{f1d}\x03\x02\x02\x02\u{f1b}\u{f19}\x03\x02\x02\x02\
	\u{f1c}\u{f1e}\x07\x42\x02\x02\u{f1d}\u{f1c}\x03\x02\x02\x02\u{f1d}\u{f1e}\
	\x03\x02\x02\x02\u{f1e}\u{f1f}\x03\x02\x02\x02\u{f1f}\u{f20}\x07\u{1bd}\
	\x02\x02\u{f20}\u{f28}\x03\x02\x02\x02\u{f21}\u{f22}\x07\x37\x02\x02\u{f22}\
	\u{f23}\x07\u{1bc}\x02\x02\u{f23}\u{f24}\x07\u{102}\x02\x02\u{f24}\u{f25}\
	\x07\x1e\x02\x02\u{f25}\u{f26}\x07\x68\x02\x02\u{f26}\u{f28}\x07\u{1bd}\
	\x02\x02\u{f27}\u{f12}\x03\x02\x02\x02\u{f27}\u{f21}\x03\x02\x02\x02\u{f28}\
	\u{f3}\x03\x02\x02\x02\u{f29}\u{f2b}\x05\u{164}\u{b3}\x02\u{f2a}\u{f2c}\
	\x05\u{134}\u{9b}\x02\u{f2b}\u{f2a}\x03\x02\x02\x02\u{f2b}\u{f2c}\x03\x02\
	\x02\x02\u{f2c}\u{f5}\x03\x02\x02\x02\u{f2d}\u{f2e}\x07\u{1bc}\x02\x02\u{f2e}\
	\u{f2f}\x05\u{154}\u{ab}\x02\u{f2f}\u{f30}\x07\x42\x02\x02\u{f30}\u{f35}\
	\x05\u{154}\u{ab}\x02\u{f31}\u{f32}\x07\x42\x02\x02\u{f32}\u{f34}\x05\u{154}\
	\u{ab}\x02\u{f33}\u{f31}\x03\x02\x02\x02\u{f34}\u{f37}\x03\x02\x02\x02\u{f35}\
	\u{f33}\x03\x02\x02\x02\u{f35}\u{f36}\x03\x02\x02\x02\u{f36}\u{f39}\x03\
	\x02\x02\x02\u{f37}\u{f35}\x03\x02\x02\x02\u{f38}\u{f3a}\x07\x42\x02\x02\
	\u{f39}\u{f38}\x03\x02\x02\x02\u{f39}\u{f3a}\x03\x02\x02\x02\u{f3a}\u{f3b}\
	\x03\x02\x02\x02\u{f3b}\u{f3c}\x07\u{1bd}\x02\x02\u{f3c}\u{f7}\x03\x02\x02\
	\x02\u{f3d}\u{f3e}\x05\u{fa}\x7e\x02\u{f3e}\u{f9}\x03\x02\x02\x02\u{f3f}\
	\u{f40}\x08\x7e\x01\x02\u{f40}\u{f44}\x05\u{fe}\u{80}\x02\u{f41}\u{f42}\
	\x07\u{100}\x02\x02\u{f42}\u{f44}\x05\u{fa}\x7e\x05\u{f43}\u{f3f}\x03\x02\
	\x02\x02\u{f43}\u{f41}\x03\x02\x02\x02\u{f44}\u{f4f}\x03\x02\x02\x02\u{f45}\
	\u{f46}\x0c\x04\x02\x02\u{f46}\u{f47}\x07\x17\x02\x02\u{f47}\u{f4e}\x05\
	\u{fa}\x7e\x05\u{f48}\u{f49}\x0c\x03\x02\x02\u{f49}\u{f4a}\x07\u{10d}\x02\
	\x02\u{f4a}\u{f4e}\x05\u{fa}\x7e\x04\u{f4b}\u{f4c}\x0c\x07\x02\x02\u{f4c}\
	\u{f4e}\x05\u{fc}\x7f\x02\u{f4d}\u{f45}\x03\x02\x02\x02\u{f4d}\u{f48}\x03\
	\x02\x02\x02\u{f4d}\u{f4b}\x03\x02\x02\x02\u{f4e}\u{f51}\x03\x02\x02\x02\
	\u{f4f}\u{f4d}\x03\x02\x02\x02\u{f4f}\u{f50}\x03\x02\x02\x02\u{f50}\u{fb}\
	\x03\x02\x02\x02\u{f51}\u{f4f}\x03\x02\x02\x02\u{f52}\u{f53}\x05\u{126}\
	\u{94}\x02\u{f53}\u{f56}\x05\u{102}\u{82}\x02\u{f54}\u{f55}\x07\x3f\x02\
	\x02\u{f55}\u{f57}\x05\u{122}\u{92}\x02\u{f56}\u{f54}\x03\x02\x02\x02\u{f56}\
	\u{f57}\x03\x02\x02\x02\u{f57}\u{f5f}\x03\x02\x02\x02\u{f58}\u{f59}\x05\
	\u{126}\u{94}\x02\u{f59}\u{f5a}\x05\u{128}\u{95}\x02\u{f5a}\u{f5b}\x07\u{1bc}\
	\x02\x02\u{f5b}\u{f5c}\x05\x2a\x16\x02\u{f5c}\u{f5d}\x07\u{1bd}\x02\x02\
	\u{f5d}\u{f5f}\x03\x02\x02\x02\u{f5e}\u{f52}\x03\x02\x02\x02\u{f5e}\u{f58}\
	\x03\x02\x02\x02\u{f5f}\u{fd}\x03\x02\x02\x02\u{f60}\u{f62}\x05\u{102}\u{82}\
	\x02\u{f61}\u{f63}\x05\u{100}\u{81}\x02\u{f62}\u{f61}\x03\x02\x02\x02\u{f62}\
	\u{f63}\x03\x02\x02\x02\u{f63}\u{ff}\x03\x02\x02\x02\u{f64}\u{f66}\x07\u{100}\
	\x02\x02\u{f65}\u{f64}\x03\x02\x02\x02\u{f65}\u{f66}\x03\x02\x02\x02\u{f66}\
	\u{f67}\x03\x02\x02\x02\u{f67}\u{f68}\x07\x2a\x02\x02\u{f68}\u{f69}\x05\
	\u{102}\u{82}\x02\u{f69}\u{f6a}\x07\x17\x02\x02\u{f6a}\u{f6b}\x05\u{102}\
	\u{82}\x02\u{f6b}\u{fbe}\x03\x02\x02\x02\u{f6c}\u{f6e}\x07\u{100}\x02\x02\
	\u{f6d}\u{f6c}\x03\x02\x02\x02\u{f6d}\u{f6e}\x03\x02\x02\x02\u{f6e}\u{f6f}\
	\x03\x02\x02\x02\u{f6f}\u{f70}\x07\u{af}\x02\x02\u{f70}\u{f71}\x07\u{1bc}\
	\x02\x02\u{f71}\u{f76}\x05\u{f8}\x7d\x02\u{f72}\u{f73}\x07\x42\x02\x02\u{f73}\
	\u{f75}\x05\u{f8}\x7d\x02\u{f74}\u{f72}\x03\x02\x02\x02\u{f75}\u{f78}\x03\
	\x02\x02\x02\u{f76}\u{f74}\x03\x02\x02\x02\u{f76}\u{f77}\x03\x02\x02\x02\
	\u{f77}\u{f7a}\x03\x02\x02\x02\u{f78}\u{f76}\x03\x02\x02\x02\u{f79}\u{f7b}\
	\x07\x42\x02\x02\u{f7a}\u{f79}\x03\x02\x02\x02\u{f7a}\u{f7b}\x03\x02\x02\
	\x02\u{f7b}\u{f7c}\x03\x02\x02\x02\u{f7c}\u{f7d}\x07\u{1bd}\x02\x02\u{f7d}\
	\u{fbe}\x03\x02\x02\x02\u{f7e}\u{f80}\x07\u{100}\x02\x02\u{f7f}\u{f7e}\x03\
	\x02\x02\x02\u{f7f}\u{f80}\x03\x02\x02\x02\u{f80}\u{f81}\x03\x02\x02\x02\
	\u{f81}\u{f82}\x07\u{af}\x02\x02\u{f82}\u{f83}\x07\u{1bc}\x02\x02\u{f83}\
	\u{f84}\x05\x2a\x16\x02\u{f84}\u{f85}\x07\u{1bd}\x02\x02\u{f85}\u{fbe}\x03\
	\x02\x02\x02\u{f86}\u{f87}\x09\x22\x02\x02\u{f87}\u{f88}\x09\x23\x02\x02\
	\u{f88}\u{f8b}\x05\u{102}\u{82}\x02\u{f89}\u{f8a}\x07\x7c\x02\x02\u{f8a}\
	\u{f8c}\x05\u{102}\u{82}\x02\u{f8b}\u{f89}\x03\x02\x02\x02\u{f8b}\u{f8c}\
	\x03\x02\x02\x02\u{f8c}\u{fbe}\x03\x02\x02\x02\u{f8d}\u{f8e}\x07\x3f\x02\
	\x02\u{f8e}\u{fbe}\x05\u{122}\u{92}\x02\u{f8f}\u{f91}\x07\u{100}\x02\x02\
	\u{f90}\u{f8f}\x03\x02\x02\x02\u{f90}\u{f91}\x03\x02\x02\x02\u{f91}\u{f92}\
	\x03\x02\x02\x02\u{f92}\u{f93}\x07\u{135}\x02\x02\u{f93}\u{fbe}\x05\u{102}\
	\u{82}\x02\u{f94}\u{f96}\x07\u{100}\x02\x02\u{f95}\u{f94}\x03\x02\x02\x02\
	\u{f95}\u{f96}\x03\x02\x02\x02\u{f96}\u{f97}\x03\x02\x02\x02\u{f97}\u{f98}\
	\x07\u{146}\x02\x02\u{f98}\u{fbe}\x05\u{122}\u{92}\x02\u{f99}\u{f9b}\x07\
	\u{100}\x02\x02\u{f9a}\u{f99}\x03\x02\x02\x02\u{f9a}\u{f9b}\x03\x02\x02\
	\x02\u{f9b}\u{f9c}\x03\x02\x02\x02\u{f9c}\u{f9d}\x09\x22\x02\x02\u{f9d}\
	\u{fa0}\x05\u{102}\u{82}\x02\u{f9e}\u{f9f}\x07\x7c\x02\x02\u{f9f}\u{fa1}\
	\x05\u{102}\u{82}\x02\u{fa0}\u{f9e}\x03\x02\x02\x02\u{fa0}\u{fa1}\x03\x02\
	\x02\x02\u{fa1}\u{fbe}\x03\x02\x02\x02\u{fa2}\u{fa4}\x07\u{100}\x02\x02\
	\u{fa3}\u{fa2}\x03\x02\x02\x02\u{fa3}\u{fa4}\x03\x02\x02\x02\u{fa4}\u{fa5}\
	\x03\x02\x02\x02\u{fa5}\u{fa6}\x07\u{163}\x02\x02\u{fa6}\u{fa7}\x07\u{183}\
	\x02\x02\u{fa7}\u{faa}\x05\u{102}\u{82}\x02\u{fa8}\u{fa9}\x07\x7c\x02\x02\
	\u{fa9}\u{fab}\x05\u{102}\u{82}\x02\u{faa}\u{fa8}\x03\x02\x02\x02\u{faa}\
	\u{fab}\x03\x02\x02\x02\u{fab}\u{fbe}\x03\x02\x02\x02\u{fac}\u{fae}\x07\
	\u{c0}\x02\x02\u{fad}\u{faf}\x07\u{100}\x02\x02\u{fae}\u{fad}\x03\x02\x02\
	\x02\u{fae}\u{faf}\x03\x02\x02\x02\u{faf}\u{fb0}\x03\x02\x02\x02\u{fb0}\
	\u{fbe}\x07\u{102}\x02\x02\u{fb1}\u{fb3}\x07\u{c0}\x02\x02\u{fb2}\u{fb4}\
	\x07\u{100}\x02\x02\u{fb3}\u{fb2}\x03\x02\x02\x02\u{fb3}\u{fb4}\x03\x02\
	\x02\x02\u{fb4}\u{fb5}\x03\x02\x02\x02\u{fb5}\u{fb6}\x07\x6b\x02\x02\u{fb6}\
	\u{fb7}\x07\u{96}\x02\x02\u{fb7}\u{fbe}\x05\u{102}\u{82}\x02\u{fb8}\u{fba}\
	\x07\u{c0}\x02\x02\u{fb9}\u{fbb}\x07\u{100}\x02\x02\u{fba}\u{fb9}\x03\x02\
	\x02\x02\u{fba}\u{fbb}\x03\x02\x02\x02\u{fbb}\u{fbc}\x03\x02\x02\x02\u{fbc}\
	\u{fbe}\x07\u{195}\x02\x02\u{fbd}\u{f65}\x03\x02\x02\x02\u{fbd}\u{f6d}\x03\
	\x02\x02\x02\u{fbd}\u{f7f}\x03\x02\x02\x02\u{fbd}\u{f86}\x03\x02\x02\x02\
	\u{fbd}\u{f8d}\x03\x02\x02\x02\u{fbd}\u{f90}\x03\x02\x02\x02\u{fbd}\u{f95}\
	\x03\x02\x02\x02\u{fbd}\u{f9a}\x03\x02\x02\x02\u{fbd}\u{fa3}\x03\x02\x02\
	\x02\u{fbd}\u{fac}\x03\x02\x02\x02\u{fbd}\u{fb1}\x03\x02\x02\x02\u{fbd}\
	\u{fb8}\x03\x02\x02\x02\u{fbe}\u{101}\x03\x02\x02\x02\u{fbf}\u{fc0}\x08\
	\u{82}\x01\x02\u{fc0}\u{fc2}\x05\u{104}\u{83}\x02\u{fc1}\u{fc3}\x07\x04\
	\x02\x02\u{fc2}\u{fc1}\x03\x02\x02\x02\u{fc2}\u{fc3}\x03\x02\x02\x02\u{fc3}\
	\u{fc7}\x03\x02\x02\x02\u{fc4}\u{fc5}\x09\x24\x02\x02\u{fc5}\u{fc7}\x05\
	\u{102}\u{82}\x07\u{fc6}\u{fbf}\x03\x02\x02\x02\u{fc6}\u{fc4}\x03\x02\x02\
	\x02\u{fc7}\u{fd9}\x03\x02\x02\x02\u{fc8}\u{fc9}\x0c\x06\x02\x02\u{fc9}\
	\u{fca}\x09\x25\x02\x02\u{fca}\u{fd8}\x05\u{102}\u{82}\x07\u{fcb}\u{fcc}\
	\x0c\x05\x02\x02\u{fcc}\u{fcd}\x09\x26\x02\x02\u{fcd}\u{fd8}\x05\u{102}\
	\u{82}\x06\u{fce}\u{fcf}\x0c\x04\x02\x02\u{fcf}\u{fd0}\x07\u{1cc}\x02\x02\
	\u{fd0}\u{fd8}\x05\u{102}\u{82}\x05\u{fd1}\u{fd2}\x0c\x03\x02\x02\u{fd2}\
	\u{fd3}\x07\u{1d1}\x02\x02\u{fd3}\u{fd8}\x05\u{102}\u{82}\x04\u{fd4}\u{fd5}\
	\x0c\x08\x02\x02\u{fd5}\u{fd6}\x07\x21\x02\x02\u{fd6}\u{fd8}\x05\u{124}\
	\u{93}\x02\u{fd7}\u{fc8}\x03\x02\x02\x02\u{fd7}\u{fcb}\x03\x02\x02\x02\u{fd7}\
	\u{fce}\x03\x02\x02\x02\u{fd7}\u{fd1}\x03\x02\x02\x02\u{fd7}\u{fd4}\x03\
	\x02\x02\x02\u{fd8}\u{fdb}\x03\x02\x02\x02\u{fd9}\u{fd7}\x03\x02\x02\x02\
	\u{fd9}\u{fda}\x03\x02\x02\x02\u{fda}\u{103}\x03\x02\x02\x02\u{fdb}\u{fd9}\
	\x03\x02\x02\x02\u{fdc}\u{fdd}\x08\u{83}\x01\x02\u{fdd}\u{1190}\x05\u{10e}\
	\u{88}\x02\u{fde}\u{fec}\x07\x05\x02\x02\u{fdf}\u{fe0}\x05\u{122}\u{92}\
	\x02\u{fe0}\u{fe1}\x07\u{1cf}\x02\x02\u{fe1}\u{fe9}\x05\u{f8}\x7d\x02\u{fe2}\
	\u{fe3}\x07\x42\x02\x02\u{fe3}\u{fe4}\x05\u{122}\u{92}\x02\u{fe4}\u{fe5}\
	\x07\u{1cf}\x02\x02\u{fe5}\u{fe6}\x05\u{f8}\x7d\x02\u{fe6}\u{fe8}\x03\x02\
	\x02\x02\u{fe7}\u{fe2}\x03\x02\x02\x02\u{fe8}\u{feb}\x03\x02\x02\x02\u{fe9}\
	\u{fe7}\x03\x02\x02\x02\u{fe9}\u{fea}\x03\x02\x02\x02\u{fea}\u{fed}\x03\
	\x02\x02\x02\u{feb}\u{fe9}\x03\x02\x02\x02\u{fec}\u{fdf}\x03\x02\x02\x02\
	\u{fec}\u{fed}\x03\x02\x02\x02\u{fed}\u{fee}\x03\x02\x02\x02\u{fee}\u{1190}\
	\x07\x06\x02\x02\u{fef}\u{ff0}\x07\u{1bc}\x02\x02\u{ff0}\u{ff3}\x05\u{f8}\
	\x7d\x02\u{ff1}\u{ff2}\x07\x42\x02\x02\u{ff2}\u{ff4}\x05\u{f8}\x7d\x02\u{ff3}\
	\u{ff1}\x03\x02\x02\x02\u{ff4}\u{ff5}\x03\x02\x02\x02\u{ff5}\u{ff3}\x03\
	\x02\x02\x02\u{ff5}\u{ff6}\x03\x02\x02\x02\u{ff6}\u{ff8}\x03\x02\x02\x02\
	\u{ff7}\u{ff9}\x07\x42\x02\x02\u{ff8}\u{ff7}\x03\x02\x02\x02\u{ff8}\u{ff9}\
	\x03\x02\x02\x02\u{ff9}\u{ffa}\x03\x02\x02\x02\u{ffa}\u{ffb}\x07\u{1bd}\
	\x02\x02\u{ffb}\u{1190}\x03\x02\x02\x02\u{ffc}\u{ffd}\x07\u{14c}\x02\x02\
	\u{ffd}\u{ffe}\x07\u{1bc}\x02\x02\u{ffe}\u{1003}\x05\u{f8}\x7d\x02\u{fff}\
	\u{1000}\x07\x42\x02\x02\u{1000}\u{1002}\x05\u{f8}\x7d\x02\u{1001}\u{fff}\
	\x03\x02\x02\x02\u{1002}\u{1005}\x03\x02\x02\x02\u{1003}\u{1001}\x03\x02\
	\x02\x02\u{1003}\u{1004}\x03\x02\x02\x02\u{1004}\u{1006}\x03\x02\x02\x02\
	\u{1005}\u{1003}\x03\x02\x02\x02\u{1006}\u{1007}\x07\u{1bd}\x02\x02\u{1007}\
	\u{1190}\x03\x02\x02\x02\u{1008}\u{1009}\x07\u{125}\x02\x02\u{1009}\u{100a}\
	\x07\u{1bc}\x02\x02\u{100a}\u{100b}\x05\u{102}\u{82}\x02\u{100b}\u{100c}\
	\x07\u{af}\x02\x02\u{100c}\u{100d}\x05\u{102}\u{82}\x02\u{100d}\u{100e}\
	\x07\u{1bd}\x02\x02\u{100e}\u{1190}\x03\x02\x02\x02\u{100f}\u{1010}\x07\
	\u{dc}\x02\x02\u{1010}\u{1012}\x07\u{1bc}\x02\x02\u{1011}\u{1013}\x05\x66\
	\x34\x02\u{1012}\u{1011}\x03\x02\x02\x02\u{1012}\u{1013}\x03\x02\x02\x02\
	\u{1013}\u{1014}\x03\x02\x02\x02\u{1014}\u{1017}\x05\u{f8}\x7d\x02\u{1015}\
	\u{1016}\x07\x42\x02\x02\u{1016}\u{1018}\x05\u{f8}\x7d\x02\u{1017}\u{1015}\
	\x03\x02\x02\x02\u{1017}\u{1018}\x03\x02\x02\x02\u{1018}\u{101a}\x03\x02\
	\x02\x02\u{1019}\u{101b}\x07\x42\x02\x02\u{101a}\u{1019}\x03\x02\x02\x02\
	\u{101a}\u{101b}\x03\x02\x02\x02\u{101b}\u{101c}\x03\x02\x02\x02\u{101c}\
	\u{102f}\x07\u{1bd}\x02\x02\u{101d}\u{101e}\x07\u{1b2}\x02\x02\u{101e}\u{101f}\
	\x07\u{a1}\x02\x02\u{101f}\u{1020}\x07\u{1bc}\x02\x02\u{1020}\u{1021}\x07\
	\u{10e}\x02\x02\u{1021}\u{1022}\x07\x2d\x02\x02\u{1022}\u{1027}\x05\x6c\
	\x37\x02\u{1023}\u{1024}\x07\x42\x02\x02\u{1024}\u{1026}\x05\x6c\x37\x02\
	\u{1025}\u{1023}\x03\x02\x02\x02\u{1026}\u{1029}\x03\x02\x02\x02\u{1027}\
	\u{1025}\x03\x02\x02\x02\u{1027}\u{1028}\x03\x02\x02\x02\u{1028}\u{102b}\
	\x03\x02\x02\x02\u{1029}\u{1027}\x03\x02\x02\x02\u{102a}\u{102c}\x07\x42\
	\x02\x02\u{102b}\u{102a}\x03\x02\x02\x02\u{102b}\u{102c}\x03\x02\x02\x02\
	\u{102c}\u{102d}\x03\x02\x02\x02\u{102d}\u{102e}\x07\u{1bd}\x02\x02\u{102e}\
	\u{1030}\x03\x02\x02\x02\u{102f}\u{101d}\x03\x02\x02\x02\u{102f}\u{1030}\
	\x03\x02\x02\x02\u{1030}\u{1040}\x03\x02\x02\x02\u{1031}\u{1032}\x07\u{113}\
	\x02\x02\u{1032}\u{103d}\x07\u{1bc}\x02\x02\u{1033}\u{1034}\x07\u{116}\x02\
	\x02\u{1034}\u{1035}\x07\x2d\x02\x02\u{1035}\u{103a}\x05\u{f8}\x7d\x02\u{1036}\
	\u{1037}\x07\x42\x02\x02\u{1037}\u{1039}\x05\u{f8}\x7d\x02\u{1038}\u{1036}\
	\x03\x02\x02\x02\u{1039}\u{103c}\x03\x02\x02\x02\u{103a}\u{1038}\x03\x02\
	\x02\x02\u{103a}\u{103b}\x03\x02\x02\x02\u{103b}\u{103e}\x03\x02\x02\x02\
	\u{103c}\u{103a}\x03\x02\x02\x02\u{103d}\u{1033}\x03\x02\x02\x02\u{103d}\
	\u{103e}\x03\x02\x02\x02\u{103e}\u{103f}\x03\x02\x02\x02\u{103f}\u{1041}\
	\x07\u{1bd}\x02\x02\u{1040}\u{1031}\x03\x02\x02\x02\u{1040}\u{1041}\x03\
	\x02\x02\x02\u{1041}\u{1190}\x03\x02\x02\x02\u{1042}\u{1043}\x07\u{83}\x02\
	\x02\u{1043}\u{1044}\x07\u{1bc}\x02\x02\u{1044}\u{1045}\x05\x2a\x16\x02\
	\u{1045}\u{1046}\x07\u{1bd}\x02\x02\u{1046}\u{1190}\x03\x02\x02\x02\u{1047}\
	\u{1048}\x07\x34\x02\x02\u{1048}\u{104a}\x05\u{f8}\x7d\x02\u{1049}\u{104b}\
	\x05\u{13c}\u{9f}\x02\u{104a}\u{1049}\x03\x02\x02\x02\u{104b}\u{104c}\x03\
	\x02\x02\x02\u{104c}\u{104a}\x03\x02\x02\x02\u{104c}\u{104d}\x03\x02\x02\
	\x02\u{104d}\u{1050}\x03\x02\x02\x02\u{104e}\u{104f}\x07\x74\x02\x02\u{104f}\
	\u{1051}\x05\u{f8}\x7d\x02\u{1050}\u{104e}\x03\x02\x02\x02\u{1050}\u{1051}\
	\x03\x02\x02\x02\u{1051}\u{1052}\x03\x02\x02\x02\u{1052}\u{1053}\x07\x79\
	\x02\x02\u{1053}\u{1190}\x03\x02\x02\x02\u{1054}\u{1056}\x07\x34\x02\x02\
	\u{1055}\u{1057}\x05\u{13c}\u{9f}\x02\u{1056}\u{1055}\x03\x02\x02\x02\u{1057}\
	\u{1058}\x03\x02\x02\x02\u{1058}\u{1056}\x03\x02\x02\x02\u{1058}\u{1059}\
	\x03\x02\x02\x02\u{1059}\u{105c}\x03\x02\x02\x02\u{105a}\u{105b}\x07\x74\
	\x02\x02\u{105b}\u{105d}\x05\u{f8}\x7d\x02\u{105c}\u{105a}\x03\x02\x02\x02\
	\u{105c}\u{105d}\x03\x02\x02\x02\u{105d}\u{105e}\x03\x02\x02\x02\u{105e}\
	\u{105f}\x07\x79\x02\x02\u{105f}\u{1190}\x03\x02\x02\x02\u{1060}\u{1061}\
	\x07\x37\x02\x02\u{1061}\u{1062}\x07\u{1bc}\x02\x02\u{1062}\u{1063}\x05\
	\u{f8}\x7d\x02\u{1063}\u{1064}\x07\x1e\x02\x02\u{1064}\u{1065}\x05\u{134}\
	\u{9b}\x02\u{1065}\u{1066}\x07\u{1bd}\x02\x02\u{1066}\u{1190}\x03\x02\x02\
	\x02\u{1067}\u{1068}\x07\u{18c}\x02\x02\u{1068}\u{1069}\x07\u{1bc}\x02\x02\
	\u{1069}\u{106a}\x05\u{f8}\x7d\x02\u{106a}\u{106b}\x07\x1e\x02\x02\u{106b}\
	\u{106c}\x05\u{134}\u{9b}\x02\u{106c}\u{106d}\x07\u{1bd}\x02\x02\u{106d}\
	\u{1190}\x03\x02\x02\x02\u{106e}\u{106f}\x07\u{189}\x02\x02\u{106f}\u{1071}\
	\x07\u{1bc}\x02\x02\u{1070}\u{1072}\x05\u{aa}\x56\x02\u{1071}\u{1070}\x03\
	\x02\x02\x02\u{1071}\u{1072}\x03\x02\x02\x02\u{1072}\u{1074}\x03\x02\x02\
	\x02\u{1073}\u{1075}\x05\u{102}\u{82}\x02\u{1074}\u{1073}\x03\x02\x02\x02\
	\u{1074}\u{1075}\x03\x02\x02\x02\u{1075}\u{1076}\x03\x02\x02\x02\u{1076}\
	\u{1077}\x07\u{96}\x02\x02\u{1077}\u{1078}\x03\x02\x02\x02\u{1078}\u{1079}\
	\x05\u{102}\u{82}\x02\u{1079}\u{107a}\x07\u{1bd}\x02\x02\u{107a}\u{1190}\
	\x03\x02\x02\x02\u{107b}\u{107c}\x07\u{189}\x02\x02\u{107c}\u{1084}\x07\
	\u{1bc}\x02\x02\u{107d}\u{107f}\x05\u{aa}\x56\x02\u{107e}\u{1080}\x05\u{102}\
	\u{82}\x02\u{107f}\u{107e}\x03\x02\x02\x02\u{107f}\u{1080}\x03\x02\x02\x02\
	\u{1080}\u{1082}\x03\x02\x02\x02\u{1081}\u{1083}\x07\u{96}\x02\x02\u{1082}\
	\u{1081}\x03\x02\x02\x02\u{1082}\u{1083}\x03\x02\x02\x02\u{1083}\u{1085}\
	\x03\x02\x02\x02\u{1084}\u{107d}\x03\x02\x02\x02\u{1084}\u{1085}\x03\x02\
	\x02\x02\u{1085}\u{1086}\x03\x02\x02\x02\u{1086}\u{1087}\x05\u{102}\u{82}\
	\x02\u{1087}\u{1088}\x07\u{1bd}\x02\x02\u{1088}\u{1190}\x03\x02\x02\x02\
	\u{1089}\u{108a}\x07\u{189}\x02\x02\u{108a}\u{108b}\x07\u{1bc}\x02\x02\u{108b}\
	\u{108c}\x05\u{102}\u{82}\x02\u{108c}\u{108d}\x07\x42\x02\x02\u{108d}\u{108f}\
	\x05\u{102}\u{82}\x02\u{108e}\u{1090}\x07\x42\x02\x02\u{108f}\u{108e}\x03\
	\x02\x02\x02\u{108f}\u{1090}\x03\x02\x02\x02\u{1090}\u{1091}\x03\x02\x02\
	\x02\u{1091}\u{1092}\x07\u{1bd}\x02\x02\u{1092}\u{1190}\x03\x02\x02\x02\
	\u{1093}\u{1094}\x07\u{ff}\x02\x02\u{1094}\u{1095}\x07\u{1bc}\x02\x02\u{1095}\
	\u{1098}\x05\u{102}\u{82}\x02\u{1096}\u{1097}\x07\x42\x02\x02\u{1097}\u{1099}\
	\x05\u{130}\u{99}\x02\u{1098}\u{1096}\x03\x02\x02\x02\u{1098}\u{1099}\x03\
	\x02\x02\x02\u{1099}\u{109b}\x03\x02\x02\x02\u{109a}\u{109c}\x07\x42\x02\
	\x02\u{109b}\u{109a}\x03\x02\x02\x02\u{109b}\u{109c}\x03\x02\x02\x02\u{109c}\
	\u{109d}\x03\x02\x02\x02\u{109d}\u{109e}\x07\u{1bd}\x02\x02\u{109e}\u{1190}\
	\x03\x02\x02\x02\u{109f}\u{10a0}\x07\u{86}\x02\x02\u{10a0}\u{10a1}\x07\u{1bc}\
	\x02\x02\u{10a1}\u{10a2}\x05\u{164}\u{b3}\x02\u{10a2}\u{10a3}\x07\u{96}\
	\x02\x02\u{10a3}\u{10a4}\x05\u{102}\u{82}\x02\u{10a4}\u{10a5}\x07\u{1bd}\
	\x02\x02\u{10a5}\u{1190}\x03\x02\x02\x02\u{10a6}\u{10a7}\x07\u{ed}\x02\x02\
	\u{10a7}\u{10a8}\x07\u{1bc}\x02\x02\u{10a8}\u{10a9}\x05\u{172}\u{ba}\x02\
	\u{10a9}\u{10aa}\x07\x42\x02\x02\u{10aa}\u{10ab}\x07\u{1c9}\x02\x02\u{10ab}\
	\u{10ac}\x07\u{1bd}\x02\x02\u{10ac}\u{1190}\x03\x02\x02\x02\u{10ad}\u{10ae}\
	\x07\u{a9}\x02\x02\u{10ae}\u{10af}\x07\u{1bc}\x02\x02\u{10af}\u{10b0}\x05\
	\u{122}\u{92}\x02\u{10b0}\u{10b1}\x07\u{1bd}\x02\x02\u{10b1}\u{1190}\x03\
	\x02\x02\x02\u{10b2}\u{10b3}\x07\u{f0}\x02\x02\u{10b3}\u{10b4}\x07\u{1bc}\
	\x02\x02\u{10b4}\u{10b5}\x05\u{f8}\x7d\x02\u{10b5}\u{10b6}\x07\x42\x02\x02\
	\u{10b6}\u{10b7}\x05\u{f8}\x7d\x02\u{10b7}\u{10b8}\x07\u{1bd}\x02\x02\u{10b8}\
	\u{1190}\x03\x02\x02\x02\u{10b9}\u{10ba}\x07\x5b\x02\x02\u{10ba}\u{10c3}\
	\x07\u{1bc}\x02\x02\u{10bb}\u{10c0}\x05\u{10a}\u{86}\x02\u{10bc}\u{10bd}\
	\x07\x42\x02\x02\u{10bd}\u{10bf}\x05\u{10a}\u{86}\x02\u{10be}\u{10bc}\x03\
	\x02\x02\x02\u{10bf}\u{10c2}\x03\x02\x02\x02\u{10c0}\u{10be}\x03\x02\x02\
	\x02\u{10c0}\u{10c1}\x03\x02\x02\x02\u{10c1}\u{10c4}\x03\x02\x02\x02\u{10c2}\
	\u{10c0}\x03\x02\x02\x02\u{10c3}\u{10bb}\x03\x02\x02\x02\u{10c3}\u{10c4}\
	\x03\x02\x02\x02\u{10c4}\u{10c5}\x03\x02\x02\x02\u{10c5}\u{1190}\x07\u{1bd}\
	\x02\x02\u{10c6}\u{10c7}\x07\x4f\x02\x02\u{10c7}\u{10c8}\x07\u{1bc}\x02\
	\x02\u{10c8}\u{10c9}\x07\u{1c9}\x02\x02\u{10c9}\u{10ca}\x07\u{1bd}\x02\x02\
	\u{10ca}\u{1190}\x05\u{108}\u{85}\x02\u{10cb}\u{10cc}\x05\u{106}\u{84}\x02\
	\u{10cc}\u{10cd}\x05\u{116}\u{8c}\x02\u{10cd}\u{10dd}\x07\u{1bc}\x02\x02\
	\u{10ce}\u{10d0}\x05\x66\x34\x02\u{10cf}\u{10ce}\x03\x02\x02\x02\u{10cf}\
	\u{10d0}\x03\x02\x02\x02\u{10d0}\u{10d1}\x03\x02\x02\x02\u{10d1}\u{10d6}\
	\x05\u{10a}\u{86}\x02\u{10d2}\u{10d3}\x07\x42\x02\x02\u{10d3}\u{10d5}\x05\
	\u{10a}\u{86}\x02\u{10d4}\u{10d2}\x03\x02\x02\x02\u{10d5}\u{10d8}\x03\x02\
	\x02\x02\u{10d6}\u{10d4}\x03\x02\x02\x02\u{10d6}\u{10d7}\x03\x02\x02\x02\
	\u{10d7}\u{10da}\x03\x02\x02\x02\u{10d8}\u{10d6}\x03\x02\x02\x02\u{10d9}\
	\u{10cf}\x03\x02\x02\x02\u{10d9}\u{10da}\x03\x02\x02\x02\u{10da}\u{10db}\
	\x03\x02\x02\x02\u{10db}\u{10de}\x05\u{10c}\u{87}\x02\u{10dc}\u{10de}\x05\
	\x50\x29\x02\u{10dd}\u{10d9}\x03\x02\x02\x02\u{10dd}\u{10dc}\x03\x02\x02\
	\x02\u{10de}\u{10e0}\x03\x02\x02\x02\u{10df}\u{10e1}\x07\x42\x02\x02\u{10e0}\
	\u{10df}\x03\x02\x02\x02\u{10e0}\u{10e1}\x03\x02\x02\x02\u{10e1}\u{10e2}\
	\x03\x02\x02\x02\u{10e2}\u{10e3}\x07\u{1bd}\x02\x02\u{10e3}\u{10e4}\x05\
	\u{108}\u{85}\x02\u{10e4}\u{1190}\x03\x02\x02\x02\u{10e5}\u{10e6}\x05\u{164}\
	\u{b3}\x02\u{10e6}\u{10e7}\x05\u{140}\u{a1}\x02\u{10e7}\u{1190}\x03\x02\
	\x02\x02\u{10e8}\u{10ea}\x05\u{164}\u{b3}\x02\u{10e9}\u{10eb}\x05\u{134}\
	\u{9b}\x02\u{10ea}\u{10e9}\x03\x02\x02\x02\u{10ea}\u{10eb}\x03\x02\x02\x02\
	\u{10eb}\u{10ec}\x03\x02\x02\x02\u{10ec}\u{10ed}\x07\x07\x02\x02\u{10ed}\
	\u{10ee}\x05\u{f8}\x7d\x02\u{10ee}\u{1190}\x03\x02\x02\x02\u{10ef}\u{10fe}\
	\x07\u{1bc}\x02\x02\u{10f0}\u{10f2}\x05\u{164}\u{b3}\x02\u{10f1}\u{10f3}\
	\x05\u{134}\u{9b}\x02\u{10f2}\u{10f1}\x03\x02\x02\x02\u{10f2}\u{10f3}\x03\
	\x02\x02\x02\u{10f3}\u{10fb}\x03\x02\x02\x02\u{10f4}\u{10f5}\x07\x42\x02\
	\x02\u{10f5}\u{10f7}\x05\u{164}\u{b3}\x02\u{10f6}\u{10f8}\x05\u{134}\u{9b}\
	\x02\u{10f7}\u{10f6}\x03\x02\x02\x02\u{10f7}\u{10f8}\x03\x02\x02\x02\u{10f8}\
	\u{10fa}\x03\x02\x02\x02\u{10f9}\u{10f4}\x03\x02\x02\x02\u{10fa}\u{10fd}\
	\x03\x02\x02\x02\u{10fb}\u{10f9}\x03\x02\x02\x02\u{10fb}\u{10fc}\x03\x02\
	\x02\x02\u{10fc}\u{10ff}\x03\x02\x02\x02\u{10fd}\u{10fb}\x03\x02\x02\x02\
	\u{10fe}\u{10f0}\x03\x02\x02\x02\u{10fe}\u{10ff}\x03\x02\x02\x02\u{10ff}\
	\u{1101}\x03\x02\x02\x02\u{1100}\u{1102}\x07\x42\x02\x02\u{1101}\u{1100}\
	\x03\x02\x02\x02\u{1101}\u{1102}\x03\x02\x02\x02\u{1102}\u{1103}\x03\x02\
	\x02\x02\u{1103}\u{1104}\x07\u{1bd}\x02\x02\u{1104}\u{1105}\x07\x07\x02\
	\x02\u{1105}\u{1190}\x05\u{f8}\x7d\x02\u{1106}\u{1107}\x07\u{1bc}\x02\x02\
	\u{1107}\u{1108}\x05\x2a\x16\x02\u{1108}\u{1109}\x07\u{1bd}\x02\x02\u{1109}\
	\u{1190}\x03\x02\x02\x02\u{110a}\u{110b}\x07\u{129}\x02\x02\u{110b}\u{110c}\
	\x05\u{104}\u{83}\x02\u{110c}\u{110d}\x07\u{1c0}\x02\x02\u{110d}\u{110e}\
	\x05\x3c\x1f\x02\u{110e}\u{1190}\x03\x02\x02\x02\u{110f}\u{1190}\x05\x3a\
	\x1e\x02\u{1110}\u{1111}\x07\u{129}\x02\x02\u{1111}\u{1190}\x05\x3a\x1e\
	\x02\u{1112}\u{1113}\x07\u{1d0}\x02\x02\u{1113}\u{1190}\x07\u{1d8}\x02\x02\
	\u{1114}\u{1115}\x07\u{1bc}\x02\x02\u{1115}\u{1116}\x05\u{f8}\x7d\x02\u{1116}\
	\u{1117}\x07\u{1bd}\x02\x02\u{1117}\u{1190}\x03\x02\x02\x02\u{1118}\u{1124}\
	\x07\u{1be}\x02\x02\u{1119}\u{111e}\x05\u{f8}\x7d\x02\u{111a}\u{111b}\x07\
	\x42\x02\x02\u{111b}\u{111d}\x05\u{f8}\x7d\x02\u{111c}\u{111a}\x03\x02\x02\
	\x02\u{111d}\u{1120}\x03\x02\x02\x02\u{111e}\u{111c}\x03\x02\x02\x02\u{111e}\
	\u{111f}\x03\x02\x02\x02\u{111f}\u{1122}\x03\x02\x02\x02\u{1120}\u{111e}\
	\x03\x02\x02\x02\u{1121}\u{1123}\x07\x42\x02\x02\u{1122}\u{1121}\x03\x02\
	\x02\x02\u{1122}\u{1123}\x03\x02\x02\x02\u{1123}\u{1125}\x03\x02\x02\x02\
	\u{1124}\u{1119}\x03\x02\x02\x02\u{1124}\u{1125}\x03\x02\x02\x02\u{1125}\
	\u{1126}\x03\x02\x02\x02\u{1126}\u{1190}\x07\u{1bf}\x02\x02\u{1127}\u{1190}\
	\x07\u{1df}\x02\x02\u{1128}\u{1129}\x09\x27\x02\x02\u{1129}\u{112b}\x07\
	\u{1bc}\x02\x02\u{112a}\u{112c}\x05\x66\x34\x02\u{112b}\u{112a}\x03\x02\
	\x02\x02\u{112b}\u{112c}\x03\x02\x02\x02\u{112c}\u{112d}\x03\x02\x02\x02\
	\u{112d}\u{112e}\x05\u{f8}\x7d\x02\u{112e}\u{1142}\x07\u{1bd}\x02\x02\u{112f}\
	\u{1130}\x07\u{1b2}\x02\x02\u{1130}\u{1131}\x07\u{a1}\x02\x02\u{1131}\u{113c}\
	\x07\u{1bc}\x02\x02\u{1132}\u{1133}\x07\u{10e}\x02\x02\u{1133}\u{1134}\x07\
	\x2d\x02\x02\u{1134}\u{1139}\x05\x6c\x37\x02\u{1135}\u{1136}\x07\x42\x02\
	\x02\u{1136}\u{1138}\x05\x6c\x37\x02\u{1137}\u{1135}\x03\x02\x02\x02\u{1138}\
	\u{113b}\x03\x02\x02\x02\u{1139}\u{1137}\x03\x02\x02\x02\u{1139}\u{113a}\
	\x03\x02\x02\x02\u{113a}\u{113d}\x03\x02\x02\x02\u{113b}\u{1139}\x03\x02\
	\x02\x02\u{113c}\u{1132}\x03\x02\x02\x02\u{113c}\u{113d}\x03\x02\x02\x02\
	\u{113d}\u{113f}\x03\x02\x02\x02\u{113e}\u{1140}\x07\x42\x02\x02\u{113f}\
	\u{113e}\x03\x02\x02\x02\u{113f}\u{1140}\x03\x02\x02\x02\u{1140}\u{1141}\
	\x03\x02\x02\x02\u{1141}\u{1143}\x07\u{1bd}\x02\x02\u{1142}\u{112f}\x03\
	\x02\x02\x02\u{1142}\u{1143}\x03\x02\x02\x02\u{1143}\u{1145}\x03\x02\x02\
	\x02\u{1144}\u{1146}\x05\u{140}\u{a1}\x02\u{1145}\u{1144}\x03\x02\x02\x02\
	\u{1145}\u{1146}\x03\x02\x02\x02\u{1146}\u{1190}\x03\x02\x02\x02\u{1147}\
	\u{1148}\x07\u{11e}\x02\x02\u{1148}\u{1149}\x07\u{1bc}\x02\x02\u{1149}\u{114a}\
	\x05\u{172}\u{ba}\x02\u{114a}\u{114b}\x07\u{1bd}\x02\x02\u{114b}\u{114c}\
	\x07\u{1b2}\x02\x02\u{114c}\u{114d}\x07\u{a1}\x02\x02\u{114d}\u{114e}\x07\
	\u{1bc}\x02\x02\u{114e}\u{114f}\x07\u{10e}\x02\x02\u{114f}\u{1150}\x07\x2d\
	\x02\x02\u{1150}\u{1152}\x05\u{f8}\x7d\x02\u{1151}\u{1153}\x09\x18\x02\x02\
	\u{1152}\u{1151}\x03\x02\x02\x02\u{1152}\u{1153}\x03\x02\x02\x02\u{1153}\
	\u{1154}\x03\x02\x02\x02\u{1154}\u{1164}\x07\u{1bd}\x02\x02\u{1155}\u{1156}\
	\x07\u{113}\x02\x02\u{1156}\u{1161}\x07\u{1bc}\x02\x02\u{1157}\u{1158}\x07\
	\u{116}\x02\x02\u{1158}\u{1159}\x07\x2d\x02\x02\u{1159}\u{115e}\x05\u{f8}\
	\x7d\x02\u{115a}\u{115b}\x07\x42\x02\x02\u{115b}\u{115d}\x05\u{f8}\x7d\x02\
	\u{115c}\u{115a}\x03\x02\x02\x02\u{115d}\u{1160}\x03\x02\x02\x02\u{115e}\
	\u{115c}\x03\x02\x02\x02\u{115e}\u{115f}\x03\x02\x02\x02\u{115f}\u{1162}\
	\x03\x02\x02\x02\u{1160}\u{115e}\x03\x02\x02\x02\u{1161}\u{1157}\x03\x02\
	\x02\x02\u{1161}\u{1162}\x03\x02\x02\x02\u{1162}\u{1163}\x03\x02\x02\x02\
	\u{1163}\u{1165}\x07\u{1bd}\x02\x02\u{1164}\u{1155}\x03\x02\x02\x02\u{1164}\
	\u{1165}\x03\x02\x02\x02\u{1165}\u{1190}\x03\x02\x02\x02\u{1166}\u{1167}\
	\x07\u{11f}\x02\x02\u{1167}\u{1168}\x07\u{1bc}\x02\x02\u{1168}\u{1169}\x05\
	\u{172}\u{ba}\x02\u{1169}\u{116a}\x07\u{1bd}\x02\x02\u{116a}\u{116b}\x07\
	\u{1b2}\x02\x02\u{116b}\u{116c}\x07\u{a1}\x02\x02\u{116c}\u{116d}\x07\u{1bc}\
	\x02\x02\u{116d}\u{116e}\x07\u{10e}\x02\x02\u{116e}\u{116f}\x07\x2d\x02\
	\x02\u{116f}\u{1171}\x05\u{f8}\x7d\x02\u{1170}\u{1172}\x09\x18\x02\x02\u{1171}\
	\u{1170}\x03\x02\x02\x02\u{1171}\u{1172}\x03\x02\x02\x02\u{1172}\u{1173}\
	\x03\x02\x02\x02\u{1173}\u{1183}\x07\u{1bd}\x02\x02\u{1174}\u{1175}\x07\
	\u{113}\x02\x02\u{1175}\u{1180}\x07\u{1bc}\x02\x02\u{1176}\u{1177}\x07\u{116}\
	\x02\x02\u{1177}\u{1178}\x07\x2d\x02\x02\u{1178}\u{117d}\x05\u{f8}\x7d\x02\
	\u{1179}\u{117a}\x07\x42\x02\x02\u{117a}\u{117c}\x05\u{f8}\x7d\x02\u{117b}\
	\u{1179}\x03\x02\x02\x02\u{117c}\u{117f}\x03\x02\x02\x02\u{117d}\u{117b}\
	\x03\x02\x02\x02\u{117d}\u{117e}\x03\x02\x02\x02\u{117e}\u{1181}\x03\x02\
	\x02\x02\u{117f}\u{117d}\x03\x02\x02\x02\u{1180}\u{1176}\x03\x02\x02\x02\
	\u{1180}\u{1181}\x03\x02\x02\x02\u{1181}\u{1182}\x03\x02\x02\x02\u{1182}\
	\u{1184}\x07\u{1bd}\x02\x02\u{1183}\u{1174}\x03\x02\x02\x02\u{1183}\u{1184}\
	\x03\x02\x02\x02\u{1184}\u{1190}\x03\x02\x02\x02\u{1185}\u{1186}\x09\x28\
	\x02\x02\u{1186}\u{1187}\x07\u{1bc}\x02\x02\u{1187}\u{118a}\x05\u{f8}\x7d\
	\x02\u{1188}\u{1189}\x09\x29\x02\x02\u{1189}\u{118b}\x07\u{103}\x02\x02\
	\u{118a}\u{1188}\x03\x02\x02\x02\u{118a}\u{118b}\x03\x02\x02\x02\u{118b}\
	\u{118c}\x03\x02\x02\x02\u{118c}\u{118d}\x07\u{1bd}\x02\x02\u{118d}\u{118e}\
	\x05\u{140}\u{a1}\x02\u{118e}\u{1190}\x03\x02\x02\x02\u{118f}\u{fdc}\x03\
	\x02\x02\x02\u{118f}\u{fde}\x03\x02\x02\x02\u{118f}\u{fef}\x03\x02\x02\x02\
	\u{118f}\u{ffc}\x03\x02\x02\x02\u{118f}\u{1008}\x03\x02\x02\x02\u{118f}\
	\u{100f}\x03\x02\x02\x02\u{118f}\u{1042}\x03\x02\x02\x02\u{118f}\u{1047}\
	\x03\x02\x02\x02\u{118f}\u{1054}\x03\x02\x02\x02\u{118f}\u{1060}\x03\x02\
	\x02\x02\u{118f}\u{1067}\x03\x02\x02\x02\u{118f}\u{106e}\x03\x02\x02\x02\
	\u{118f}\u{107b}\x03\x02\x02\x02\u{118f}\u{1089}\x03\x02\x02\x02\u{118f}\
	\u{1093}\x03\x02\x02\x02\u{118f}\u{109f}\x03\x02\x02\x02\u{118f}\u{10a6}\
	\x03\x02\x02\x02\u{118f}\u{10ad}\x03\x02\x02\x02\u{118f}\u{10b2}\x03\x02\
	\x02\x02\u{118f}\u{10b9}\x03\x02\x02\x02\u{118f}\u{10c6}\x03\x02\x02\x02\
	\u{118f}\u{10cb}\x03\x02\x02\x02\u{118f}\u{10e5}\x03\x02\x02\x02\u{118f}\
	\u{10e8}\x03\x02\x02\x02\u{118f}\u{10ef}\x03\x02\x02\x02\u{118f}\u{1106}\
	\x03\x02\x02\x02\u{118f}\u{110a}\x03\x02\x02\x02\u{118f}\u{110f}\x03\x02\
	\x02\x02\u{118f}\u{1110}\x03\x02\x02\x02\u{118f}\u{1112}\x03\x02\x02\x02\
	\u{118f}\u{1114}\x03\x02\x02\x02\u{118f}\u{1118}\x03\x02\x02\x02\u{118f}\
	\u{1127}\x03\x02\x02\x02\u{118f}\u{1128}\x03\x02\x02\x02\u{118f}\u{1147}\
	\x03\x02\x02\x02\u{118f}\u{1166}\x03\x02\x02\x02\u{118f}\u{1185}\x03\x02\
	\x02\x02\u{1190}\u{119f}\x03\x02\x02\x02\u{1191}\u{1192}\x0c\x11\x02\x02\
	\u{1192}\u{1193}\x07\x08\x02\x02\u{1193}\u{119e}\x05\u{134}\u{9b}\x02\u{1194}\
	\u{1195}\x0c\x10\x02\x02\u{1195}\u{119e}\x05\u{110}\u{89}\x02\u{1196}\u{1197}\
	\x0c\x0f\x02\x02\u{1197}\u{1198}\x07\u{1c0}\x02\x02\u{1198}\u{119e}\x05\
	\x3c\x1f\x02\u{1199}\u{119a}\x0c\x0d\x02\x02\u{119a}\u{119b}\x07\u{1c0}\
	\x02\x02\u{119b}\u{119c}\x07\u{1d0}\x02\x02\u{119c}\u{119e}\x07\u{1d8}\x02\
	\x02\u{119d}\u{1191}\x03\x02\x02\x02\u{119d}\u{1194}\x03\x02\x02\x02\u{119d}\
	\u{1196}\x03\x02\x02\x02\u{119d}\u{1199}\x03\x02\x02\x02\u{119e}\u{11a1}\
	\x03\x02\x02\x02\u{119f}\u{119d}\x03\x02\x02\x02\u{119f}\u{11a0}\x03\x02\
	\x02\x02\u{11a0}\u{105}\x03\x02\x02\x02\u{11a1}\u{119f}\x03\x02\x02\x02\
	\u{11a2}\u{11a4}\x05\u{11e}\u{90}\x02\u{11a3}\u{11a2}\x03\x02\x02\x02\u{11a3}\
	\u{11a4}\x03\x02\x02\x02\u{11a4}\u{107}\x03\x02\x02\x02\u{11a5}\u{11a7}\
	\x05\u{13e}\u{a0}\x02\u{11a6}\u{11a5}\x03\x02\x02\x02\u{11a6}\u{11a7}\x03\
	\x02\x02\x02\u{11a7}\u{11ac}\x03\x02\x02\x02\u{11a8}\u{11aa}\x05\u{120}\
	\u{91}\x02\u{11a9}\u{11a8}\x03\x02\x02\x02\u{11a9}\u{11aa}\x03\x02\x02\x02\
	\u{11aa}\u{11ab}\x03\x02\x02\x02\u{11ab}\u{11ad}\x05\u{140}\u{a1}\x02\u{11ac}\
	\u{11a9}\x03\x02\x02\x02\u{11ac}\u{11ad}\x03\x02\x02\x02\u{11ad}\u{109}\
	\x03\x02\x02\x02\u{11ae}\u{11bf}\x05\u{f8}\x7d\x02\u{11af}\u{11b0}\x05\u{164}\
	\u{b3}\x02\u{11b0}\u{11b1}\x07\x03\x02\x02\u{11b1}\u{11b2}\x05\u{f8}\x7d\
	\x02\u{11b2}\u{11bf}\x03\x02\x02\x02\u{11b3}\u{11b4}\x07\u{8b}\x02\x02\u{11b4}\
	\u{11b5}\x07\x03\x02\x02\u{11b5}\u{11ba}\x05\u{122}\u{92}\x02\u{11b6}\u{11b7}\
	\x07\x42\x02\x02\u{11b7}\u{11b9}\x05\u{122}\u{92}\x02\u{11b8}\u{11b6}\x03\
	\x02\x02\x02\u{11b9}\u{11bc}\x03\x02\x02\x02\u{11ba}\u{11b8}\x03\x02\x02\
	\x02\u{11ba}\u{11bb}\x03\x02\x02\x02\u{11bb}\u{11bf}\x03\x02\x02\x02\u{11bc}\
	\u{11ba}\x03\x02\x02\x02\u{11bd}\u{11bf}\x05\u{8e}\x48\x02\u{11be}\u{11ae}\
	\x03\x02\x02\x02\u{11be}\u{11af}\x03\x02\x02\x02\u{11be}\u{11b3}\x03\x02\
	\x02\x02\u{11be}\u{11bd}\x03\x02\x02\x02\u{11bf}\u{10b}\x03\x02\x02\x02\
	\u{11c0}\u{11c1}\x07\u{10e}\x02\x02\u{11c1}\u{11c2}\x07\x2d\x02\x02\u{11c2}\
	\u{11c7}\x05\x6c\x37\x02\u{11c3}\u{11c4}\x07\x42\x02\x02\u{11c4}\u{11c6}\
	\x05\x6c\x37\x02\u{11c5}\u{11c3}\x03\x02\x02\x02\u{11c6}\u{11c9}\x03\x02\
	\x02\x02\u{11c7}\u{11c5}\x03\x02\x02\x02\u{11c7}\u{11c8}\x03\x02\x02\x02\
	\u{11c8}\u{11cb}\x03\x02\x02\x02\u{11c9}\u{11c7}\x03\x02\x02\x02\u{11ca}\
	\u{11c0}\x03\x02\x02\x02\u{11ca}\u{11cb}\x03\x02\x02\x02\u{11cb}\u{10d}\
	\x03\x02\x02\x02\u{11cc}\u{11d9}\x07\u{102}\x02\x02\u{11cd}\u{11d9}\x05\
	\u{12c}\u{97}\x02\u{11ce}\u{11d9}\x05\u{172}\u{ba}\x02\u{11cf}\u{11d9}\x05\
	\u{12a}\u{96}\x02\u{11d0}\u{11d9}\x05\u{122}\u{92}\x02\u{11d1}\u{11d9}\x07\
	\u{1d7}\x02\x02\u{11d2}\u{11d3}\x05\u{164}\u{b3}\x02\u{11d3}\u{11d4}\x05\
	\u{122}\u{92}\x02\u{11d4}\u{11d9}\x03\x02\x02\x02\u{11d5}\u{11d6}\x07\x71\
	\x02\x02\u{11d6}\u{11d7}\x07\u{127}\x02\x02\u{11d7}\u{11d9}\x05\u{122}\u{92}\
	\x02\u{11d8}\u{11cc}\x03\x02\x02\x02\u{11d8}\u{11cd}\x03\x02\x02\x02\u{11d8}\
	\u{11ce}\x03\x02\x02\x02\u{11d8}\u{11cf}\x03\x02\x02\x02\u{11d8}\u{11d0}\
	\x03\x02\x02\x02\u{11d8}\u{11d1}\x03\x02\x02\x02\u{11d8}\u{11d2}\x03\x02\
	\x02\x02\u{11d8}\u{11d5}\x03\x02\x02\x02\u{11d9}\u{10f}\x03\x02\x02\x02\
	\u{11da}\u{11db}\x07\u{1cf}\x02\x02\u{11db}\u{11df}\x05\u{114}\u{8b}\x02\
	\u{11dc}\u{11de}\x05\u{112}\u{8a}\x02\u{11dd}\u{11dc}\x03\x02\x02\x02\u{11de}\
	\u{11e1}\x03\x02\x02\x02\u{11df}\u{11dd}\x03\x02\x02\x02\u{11df}\u{11e0}\
	\x03\x02\x02\x02\u{11e0}\u{11ec}\x03\x02\x02\x02\u{11e1}\u{11df}\x03\x02\
	\x02\x02\u{11e2}\u{11e3}\x07\u{1be}\x02\x02\u{11e3}\u{11e4}\x05\u{102}\u{82}\
	\x02\u{11e4}\u{11e8}\x07\u{1bf}\x02\x02\u{11e5}\u{11e7}\x05\u{112}\u{8a}\
	\x02\u{11e6}\u{11e5}\x03\x02\x02\x02\u{11e7}\u{11ea}\x03\x02\x02\x02\u{11e8}\
	\u{11e6}\x03\x02\x02\x02\u{11e8}\u{11e9}\x03\x02\x02\x02\u{11e9}\u{11ec}\
	\x03\x02\x02\x02\u{11ea}\u{11e8}\x03\x02\x02\x02\u{11eb}\u{11da}\x03\x02\
	\x02\x02\u{11eb}\u{11e2}\x03\x02\x02\x02\u{11ec}\u{111}\x03\x02\x02\x02\
	\u{11ed}\u{11ee}\x07\u{1c0}\x02\x02\u{11ee}\u{11f4}\x05\u{114}\u{8b}\x02\
	\u{11ef}\u{11f0}\x07\u{1be}\x02\x02\u{11f0}\u{11f1}\x05\u{102}\u{82}\x02\
	\u{11f1}\u{11f2}\x07\u{1bf}\x02\x02\u{11f2}\u{11f4}\x03\x02\x02\x02\u{11f3}\
	\u{11ed}\x03\x02\x02\x02\u{11f3}\u{11ef}\x03\x02\x02\x02\u{11f4}\u{113}\
	\x03\x02\x02\x02\u{11f5}\u{1380}\x05\u{168}\u{b5}\x02\u{11f6}\u{1380}\x07\
	\u{1db}\x02\x02\u{11f7}\u{1380}\x07\u{1dd}\x02\x02\u{11f8}\u{1380}\x05\u{17c}\
	\u{bf}\x02\u{11f9}\u{1380}\x07\x0e\x02\x02\u{11fa}\u{1380}\x07\x0f\x02\x02\
	\u{11fb}\u{1380}\x07\x10\x02\x02\u{11fc}\u{1380}\x07\x11\x02\x02\u{11fd}\
	\u{1380}\x07\x12\x02\x02\u{11fe}\u{1380}\x07\x13\x02\x02\u{11ff}\u{1380}\
	\x07\x14\x02\x02\u{1200}\u{1380}\x07\x15\x02\x02\u{1201}\u{1380}\x07\x16\
	\x02\x02\u{1202}\u{1380}\x07\x17\x02\x02\u{1203}\u{1380}\x07\x18\x02\x02\
	\u{1204}\u{1380}\x07\x19\x02\x02\u{1205}\u{1380}\x07\x1b\x02\x02\u{1206}\
	\u{1380}\x07\x1e\x02\x02\u{1207}\u{1380}\x07\x1f\x02\x02\u{1208}\u{1380}\
	\x07\x20\x02\x02\u{1209}\u{1380}\x07\x21\x02\x02\u{120a}\u{1380}\x07\x22\
	\x02\x02\u{120b}\u{1380}\x07\x23\x02\x02\u{120c}\u{1380}\x07\x24\x02\x02\
	\u{120d}\u{1380}\x07\x25\x02\x02\u{120e}\u{1380}\x07\x26\x02\x02\u{120f}\
	\u{1380}\x07\x27\x02\x02\u{1210}\u{1380}\x07\x28\x02\x02\u{1211}\u{1380}\
	\x07\x29\x02\x02\u{1212}\u{1380}\x07\x2a\x02\x02\u{1213}\u{1380}\x07\x2b\
	\x02\x02\u{1214}\u{1380}\x07\x2c\x02\x02\u{1215}\u{1380}\x07\x2d\x02\x02\
	\u{1216}\u{1380}\x07\x2f\x02\x02\u{1217}\u{1380}\x07\x30\x02\x02\u{1218}\
	\u{1380}\x07\x32\x02\x02\u{1219}\u{1380}\x07\x33\x02\x02\u{121a}\u{1380}\
	\x07\x34\x02\x02\u{121b}\u{1380}\x07\x37\x02\x02\u{121c}\u{1380}\x07\x38\
	\x02\x02\u{121d}\u{1380}\x07\x39\x02\x02\u{121e}\u{1380}\x07\x3a\x02\x02\
	\u{121f}\u{1380}\x07\x3b\x02\x02\u{1220}\u{1380}\x07\x3c\x02\x02\u{1221}\
	\u{1380}\x07\x3d\x02\x02\u{1222}\u{1380}\x07\x3e\x02\x02\u{1223}\u{1380}\
	\x07\x3f\x02\x02\u{1224}\u{1380}\x07\x40\x02\x02\u{1225}\u{1380}\x07\x41\
	\x02\x02\u{1226}\u{1380}\x07\x43\x02\x02\u{1227}\u{1380}\x07\x44\x02\x02\
	\u{1228}\u{1380}\x07\x45\x02\x02\u{1229}\u{1380}\x07\x46\x02\x02\u{122a}\
	\u{1380}\x07\x47\x02\x02\u{122b}\u{1380}\x07\x48\x02\x02\u{122c}\u{1380}\
	\x07\x49\x02\x02\u{122d}\u{1380}\x07\x4a\x02\x02\u{122e}\u{1380}\x07\x4c\
	\x02\x02\u{122f}\u{1380}\x07\x4d\x02\x02\u{1230}\u{1380}\x07\x4e\x02\x02\
	\u{1231}\u{1380}\x07\x4f\x02\x02\u{1232}\u{1380}\x07\x50\x02\x02\u{1233}\
	\u{1380}\x07\x51\x02\x02\u{1234}\u{1380}\x07\x52\x02\x02\u{1235}\u{1380}\
	\x07\x53\x02\x02\u{1236}\u{1380}\x07\x55\x02\x02\u{1237}\u{1380}\x07\x56\
	\x02\x02\u{1238}\u{1380}\x07\x57\x02\x02\u{1239}\u{1380}\x07\x58\x02\x02\
	\u{123a}\u{1380}\x07\x59\x02\x02\u{123b}\u{1380}\x07\x5a\x02\x02\u{123c}\
	\u{1380}\x07\x5b\x02\x02\u{123d}\u{1380}\x07\x5c\x02\x02\u{123e}\u{1380}\
	\x07\x5d\x02\x02\u{123f}\u{1380}\x07\x5e\x02\x02\u{1240}\u{1380}\x07\x5f\
	\x02\x02\u{1241}\u{1380}\x07\x60\x02\x02\u{1242}\u{1380}\x07\x61\x02\x02\
	\u{1243}\u{1380}\x07\x62\x02\x02\u{1244}\u{1380}\x07\x63\x02\x02\u{1245}\
	\u{1380}\x07\x64\x02\x02\u{1246}\u{1380}\x07\x65\x02\x02\u{1247}\u{1380}\
	\x07\x66\x02\x02\u{1248}\u{1380}\x07\x67\x02\x02\u{1249}\u{1380}\x07\x68\
	\x02\x02\u{124a}\u{1380}\x07\x69\x02\x02\u{124b}\u{1380}\x07\x6a\x02\x02\
	\u{124c}\u{1380}\x07\x6b\x02\x02\u{124d}\u{1380}\x07\x6c\x02\x02\u{124e}\
	\u{1380}\x07\x6d\x02\x02\u{124f}\u{1380}\x07\x6e\x02\x02\u{1250}\u{1380}\
	\x07\x6f\x02\x02\u{1251}\u{1380}\x07\x70\x02\x02\u{1252}\u{1380}\x07\x71\
	\x02\x02\u{1253}\u{1380}\x07\x72\x02\x02\u{1254}\u{1380}\x07\x73\x02\x02\
	\u{1255}\u{1380}\x07\x74\x02\x02\u{1256}\u{1380}\x07\x75\x02\x02\u{1257}\
	\u{1380}\x07\x76\x02\x02\u{1258}\u{1380}\x07\x77\x02\x02\u{1259}\u{1380}\
	\x07\x78\x02\x02\u{125a}\u{1380}\x07\x79\x02\x02\u{125b}\u{1380}\x07\x7a\
	\x02\x02\u{125c}\u{1380}\x07\x7b\x02\x02\u{125d}\u{1380}\x07\x7c\x02\x02\
	\u{125e}\u{1380}\x07\x7d\x02\x02\u{125f}\u{1380}\x07\x7e\x02\x02\u{1260}\
	\u{1380}\x07\x7f\x02\x02\u{1261}\u{1380}\x07\u{80}\x02\x02\u{1262}\u{1380}\
	\x07\u{81}\x02\x02\u{1263}\u{1380}\x07\u{82}\x02\x02\u{1264}\u{1380}\x07\
	\u{83}\x02\x02\u{1265}\u{1380}\x07\u{84}\x02\x02\u{1266}\u{1380}\x07\u{85}\
	\x02\x02\u{1267}\u{1380}\x07\u{86}\x02\x02\u{1268}\u{1380}\x07\u{87}\x02\
	\x02\u{1269}\u{1380}\x07\u{88}\x02\x02\u{126a}\u{1380}\x07\u{89}\x02\x02\
	\u{126b}\u{1380}\x07\u{8b}\x02\x02\u{126c}\u{1380}\x07\u{8c}\x02\x02\u{126d}\
	\u{1380}\x07\u{8d}\x02\x02\u{126e}\u{1380}\x07\u{8e}\x02\x02\u{126f}\u{1380}\
	\x07\u{90}\x02\x02\u{1270}\u{1380}\x07\u{91}\x02\x02\u{1271}\u{1380}\x07\
	\u{92}\x02\x02\u{1272}\u{1380}\x07\u{93}\x02\x02\u{1273}\u{1380}\x07\u{94}\
	\x02\x02\u{1274}\u{1380}\x07\u{96}\x02\x02\u{1275}\u{1380}\x07\u{97}\x02\
	\x02\u{1276}\u{1380}\x07\u{98}\x02\x02\u{1277}\u{1380}\x07\u{99}\x02\x02\
	\u{1278}\u{1380}\x07\u{9a}\x02\x02\u{1279}\u{1380}\x07\u{9b}\x02\x02\u{127a}\
	\u{1380}\x07\u{9c}\x02\x02\u{127b}\u{1380}\x07\u{9d}\x02\x02\u{127c}\u{1380}\
	\x07\u{9e}\x02\x02\u{127d}\u{1380}\x07\u{9f}\x02\x02\u{127e}\u{1380}\x07\
	\u{a0}\x02\x02\u{127f}\u{1380}\x07\u{a1}\x02\x02\u{1280}\u{1380}\x07\u{a2}\
	\x02\x02\u{1281}\u{1380}\x07\u{a3}\x02\x02\u{1282}\u{1380}\x07\u{a4}\x02\
	\x02\u{1283}\u{1380}\x07\u{a5}\x02\x02\u{1284}\u{1380}\x07\u{a6}\x02\x02\
	\u{1285}\u{1380}\x07\u{a7}\x02\x02\u{1286}\u{1380}\x07\u{a8}\x02\x02\u{1287}\
	\u{1380}\x07\u{aa}\x02\x02\u{1288}\u{1380}\x07\u{ab}\x02\x02\u{1289}\u{1380}\
	\x07\u{ac}\x02\x02\u{128a}\u{1380}\x07\u{ad}\x02\x02\u{128b}\u{1380}\x07\
	\u{ae}\x02\x02\u{128c}\u{1380}\x07\u{af}\x02\x02\u{128d}\u{1380}\x07\u{b0}\
	\x02\x02\u{128e}\u{1380}\x07\u{b1}\x02\x02\u{128f}\u{1380}\x07\u{b2}\x02\
	\x02\u{1290}\u{1380}\x07\u{b3}\x02\x02\u{1291}\u{1380}\x07\u{b4}\x02\x02\
	\u{1292}\u{1380}\x07\u{b5}\x02\x02\u{1293}\u{1380}\x07\u{b6}\x02\x02\u{1294}\
	\u{1380}\x07\u{b7}\x02\x02\u{1295}\u{1380}\x07\u{b8}\x02\x02\u{1296}\u{1380}\
	\x07\u{b9}\x02\x02\u{1297}\u{1380}\x07\u{ba}\x02\x02\u{1298}\u{1380}\x07\
	\u{bb}\x02\x02\u{1299}\u{1380}\x07\u{bc}\x02\x02\u{129a}\u{1380}\x07\u{bd}\
	\x02\x02\u{129b}\u{1380}\x07\u{be}\x02\x02\u{129c}\u{1380}\x07\u{bf}\x02\
	\x02\u{129d}\u{1380}\x07\u{c0}\x02\x02\u{129e}\u{1380}\x07\u{c1}\x02\x02\
	\u{129f}\u{1380}\x07\u{c2}\x02\x02\u{12a0}\u{1380}\x07\u{c3}\x02\x02\u{12a1}\
	\u{1380}\x07\u{c4}\x02\x02\u{12a2}\u{1380}\x07\u{c5}\x02\x02\u{12a3}\u{1380}\
	\x07\u{c6}\x02\x02\u{12a4}\u{1380}\x07\u{cc}\x02\x02\u{12a5}\u{1380}\x07\
	\u{cd}\x02\x02\u{12a6}\u{1380}\x07\u{ce}\x02\x02\u{12a7}\u{1380}\x07\u{d0}\
	\x02\x02\u{12a8}\u{1380}\x07\u{d1}\x02\x02\u{12a9}\u{1380}\x07\u{d2}\x02\
	\x02\u{12aa}\u{1380}\x07\u{d4}\x02\x02\u{12ab}\u{1380}\x07\u{d5}\x02\x02\
	\u{12ac}\u{1380}\x07\u{d6}\x02\x02\u{12ad}\u{1380}\x07\u{d7}\x02\x02\u{12ae}\
	\u{1380}\x07\u{d8}\x02\x02\u{12af}\u{1380}\x07\u{d9}\x02\x02\u{12b0}\u{1380}\
	\x07\u{da}\x02\x02\u{12b1}\u{1380}\x07\u{db}\x02\x02\u{12b2}\u{1380}\x07\
	\u{dc}\x02\x02\u{12b3}\u{1380}\x07\u{dd}\x02\x02\u{12b4}\u{1380}\x07\u{de}\
	\x02\x02\u{12b5}\u{1380}\x07\u{df}\x02\x02\u{12b6}\u{1380}\x07\u{e0}\x02\
	\x02\u{12b7}\u{1380}\x07\u{e1}\x02\x02\u{12b8}\u{1380}\x07\u{e2}\x02\x02\
	\u{12b9}\u{1380}\x07\u{e3}\x02\x02\u{12ba}\u{1380}\x07\u{e4}\x02\x02\u{12bb}\
	\u{1380}\x07\u{e5}\x02\x02\u{12bc}\u{1380}\x07\u{e6}\x02\x02\u{12bd}\u{1380}\
	\x07\u{e8}\x02\x02\u{12be}\u{1380}\x07\u{e9}\x02\x02\u{12bf}\u{1380}\x07\
	\u{ea}\x02\x02\u{12c0}\u{1380}\x07\u{eb}\x02\x02\u{12c1}\u{1380}\x07\u{ec}\
	\x02\x02\u{12c2}\u{1380}\x07\u{ed}\x02\x02\u{12c3}\u{1380}\x07\u{ee}\x02\
	\x02\u{12c4}\u{1380}\x07\u{ef}\x02\x02\u{12c5}\u{1380}\x07\u{f1}\x02\x02\
	\u{12c6}\u{1380}\x07\u{f2}\x02\x02\u{12c7}\u{1380}\x07\u{f4}\x02\x02\u{12c8}\
	\u{1380}\x07\u{f5}\x02\x02\u{12c9}\u{1380}\x07\u{f6}\x02\x02\u{12ca}\u{1380}\
	\x07\u{fb}\x02\x02\u{12cb}\u{1380}\x07\u{fc}\x02\x02\u{12cc}\u{1380}\x07\
	\u{fd}\x02\x02\u{12cd}\u{1380}\x07\u{fe}\x02\x02\u{12ce}\u{1380}\x07\u{ff}\
	\x02\x02\u{12cf}\u{1380}\x07\u{100}\x02\x02\u{12d0}\u{1380}\x07\u{101}\x02\
	\x02\u{12d1}\u{1380}\x07\u{102}\x02\x02\u{12d2}\u{1380}\x07\u{103}\x02\x02\
	\u{12d3}\u{1380}\x07\u{104}\x02\x02\u{12d4}\u{1380}\x07\u{105}\x02\x02\u{12d5}\
	\u{1380}\x07\u{106}\x02\x02\u{12d6}\u{1380}\x07\u{107}\x02\x02\u{12d7}\u{1380}\
	\x07\u{108}\x02\x02\u{12d8}\u{1380}\x07\u{109}\x02\x02\u{12d9}\u{1380}\x07\
	\u{10a}\x02\x02\u{12da}\u{1380}\x07\u{10b}\x02\x02\u{12db}\u{1380}\x07\u{10c}\
	\x02\x02\u{12dc}\u{1380}\x07\u{10d}\x02\x02\u{12dd}\u{1380}\x07\u{10e}\x02\
	\x02\u{12de}\u{1380}\x07\u{10f}\x02\x02\u{12df}\u{1380}\x07\u{110}\x02\x02\
	\u{12e0}\u{1380}\x07\u{111}\x02\x02\u{12e1}\u{1380}\x07\u{112}\x02\x02\u{12e2}\
	\u{1380}\x07\u{113}\x02\x02\u{12e3}\u{1380}\x07\u{114}\x02\x02\u{12e4}\u{1380}\
	\x07\u{116}\x02\x02\u{12e5}\u{1380}\x07\u{117}\x02\x02\u{12e6}\u{1380}\x07\
	\u{118}\x02\x02\u{12e7}\u{1380}\x07\u{119}\x02\x02\u{12e8}\u{1380}\x07\u{11a}\
	\x02\x02\u{12e9}\u{1380}\x07\u{11b}\x02\x02\u{12ea}\u{1380}\x07\u{11c}\x02\
	\x02\u{12eb}\u{1380}\x07\u{11d}\x02\x02\u{12ec}\u{1380}\x07\u{120}\x02\x02\
	\u{12ed}\u{1380}\x07\u{121}\x02\x02\u{12ee}\u{1380}\x07\u{122}\x02\x02\u{12ef}\
	\u{1380}\x07\u{123}\x02\x02\u{12f0}\u{1380}\x07\u{124}\x02\x02\u{12f1}\u{1380}\
	\x07\u{125}\x02\x02\u{12f2}\u{1380}\x07\u{126}\x02\x02\u{12f3}\u{1380}\x07\
	\u{127}\x02\x02\u{12f4}\u{1380}\x07\u{128}\x02\x02\u{12f5}\u{1380}\x07\u{129}\
	\x02\x02\u{12f6}\u{1380}\x07\u{12a}\x02\x02\u{12f7}\u{1380}\x07\u{12b}\x02\
	\x02\u{12f8}\u{1380}\x07\u{12c}\x02\x02\u{12f9}\u{1380}\x07\u{12d}\x02\x02\
	\u{12fa}\u{1380}\x07\u{12e}\x02\x02\u{12fb}\u{1380}\x07\u{12f}\x02\x02\u{12fc}\
	\u{1380}\x07\u{130}\x02\x02\u{12fd}\u{1380}\x07\u{131}\x02\x02\u{12fe}\u{1380}\
	\x07\u{132}\x02\x02\u{12ff}\u{1380}\x07\u{133}\x02\x02\u{1300}\u{1380}\x07\
	\u{134}\x02\x02\u{1301}\u{1380}\x07\u{135}\x02\x02\u{1302}\u{1380}\x07\u{136}\
	\x02\x02\u{1303}\u{1380}\x07\u{137}\x02\x02\u{1304}\u{1380}\x07\u{138}\x02\
	\x02\u{1305}\u{1380}\x07\u{139}\x02\x02\u{1306}\u{1380}\x07\u{13a}\x02\x02\
	\u{1307}\u{1380}\x07\u{13b}\x02\x02\u{1308}\u{1380}\x07\u{13c}\x02\x02\u{1309}\
	\u{1380}\x07\u{13d}\x02\x02\u{130a}\u{1380}\x07\u{13e}\x02\x02\u{130b}\u{1380}\
	\x07\u{13f}\x02\x02\u{130c}\u{1380}\x07\u{141}\x02\x02\u{130d}\u{1380}\x07\
	\u{142}\x02\x02\u{130e}\u{1380}\x07\u{143}\x02\x02\u{130f}\u{1380}\x07\u{144}\
	\x02\x02\u{1310}\u{1380}\x07\u{145}\x02\x02\u{1311}\u{1380}\x07\u{146}\x02\
	\x02\u{1312}\u{1380}\x07\u{147}\x02\x02\u{1313}\u{1380}\x07\u{148}\x02\x02\
	\u{1314}\u{1380}\x07\u{149}\x02\x02\u{1315}\u{1380}\x07\u{14a}\x02\x02\u{1316}\
	\u{1380}\x07\u{14b}\x02\x02\u{1317}\u{1380}\x07\u{14c}\x02\x02\u{1318}\u{1380}\
	\x07\u{14d}\x02\x02\u{1319}\u{1380}\x07\u{14e}\x02\x02\u{131a}\u{1380}\x07\
	\u{14f}\x02\x02\u{131b}\u{1380}\x07\u{150}\x02\x02\u{131c}\u{1380}\x07\u{151}\
	\x02\x02\u{131d}\u{1380}\x07\u{152}\x02\x02\u{131e}\u{1380}\x07\u{153}\x02\
	\x02\u{131f}\u{1380}\x07\u{154}\x02\x02\u{1320}\u{1380}\x07\u{155}\x02\x02\
	\u{1321}\u{1380}\x07\u{156}\x02\x02\u{1322}\u{1380}\x07\u{157}\x02\x02\u{1323}\
	\u{1380}\x07\u{158}\x02\x02\u{1324}\u{1380}\x07\u{159}\x02\x02\u{1325}\u{1380}\
	\x07\u{15a}\x02\x02\u{1326}\u{1380}\x07\u{15b}\x02\x02\u{1327}\u{1380}\x07\
	\u{15c}\x02\x02\u{1328}\u{1380}\x07\u{15d}\x02\x02\u{1329}\u{1380}\x07\u{15e}\
	\x02\x02\u{132a}\u{1380}\x07\u{15f}\x02\x02\u{132b}\u{1380}\x07\u{160}\x02\
	\x02\u{132c}\u{1380}\x07\u{161}\x02\x02\u{132d}\u{1380}\x07\u{162}\x02\x02\
	\u{132e}\u{1380}\x07\u{163}\x02\x02\u{132f}\u{1380}\x07\u{165}\x02\x02\u{1330}\
	\u{1380}\x07\u{166}\x02\x02\u{1331}\u{1380}\x07\u{167}\x02\x02\u{1332}\u{1380}\
	\x07\u{168}\x02\x02\u{1333}\u{1380}\x07\u{169}\x02\x02\u{1334}\u{1380}\x07\
	\u{16a}\x02\x02\u{1335}\u{1380}\x07\u{16b}\x02\x02\u{1336}\u{1380}\x07\u{16c}\
	\x02\x02\u{1337}\u{1380}\x07\u{16d}\x02\x02\u{1338}\u{1380}\x07\u{16e}\x02\
	\x02\u{1339}\u{1380}\x07\u{16f}\x02\x02\u{133a}\u{1380}\x07\u{170}\x02\x02\
	\u{133b}\u{1380}\x07\u{171}\x02\x02\u{133c}\u{1380}\x07\u{172}\x02\x02\u{133d}\
	\u{1380}\x07\u{173}\x02\x02\u{133e}\u{1380}\x07\u{175}\x02\x02\u{133f}\u{1380}\
	\x07\u{176}\x02\x02\u{1340}\u{1380}\x07\u{177}\x02\x02\u{1341}\u{1380}\x07\
	\u{178}\x02\x02\u{1342}\u{1380}\x07\u{179}\x02\x02\u{1343}\u{1380}\x07\u{17a}\
	\x02\x02\u{1344}\u{1380}\x07\u{17b}\x02\x02\u{1345}\u{1380}\x07\u{17c}\x02\
	\x02\u{1346}\u{1380}\x07\u{17d}\x02\x02\u{1347}\u{1380}\x07\u{17f}\x02\x02\
	\u{1348}\u{1380}\x07\u{180}\x02\x02\u{1349}\u{1380}\x07\u{181}\x02\x02\u{134a}\
	\u{1380}\x07\u{182}\x02\x02\u{134b}\u{1380}\x07\u{183}\x02\x02\u{134c}\u{1380}\
	\x07\u{184}\x02\x02\u{134d}\u{1380}\x07\u{185}\x02\x02\u{134e}\u{1380}\x07\
	\u{187}\x02\x02\u{134f}\u{1380}\x07\u{188}\x02\x02\u{1350}\u{1380}\x07\u{189}\
	\x02\x02\u{1351}\u{1380}\x07\u{18a}\x02\x02\u{1352}\u{1380}\x07\u{18b}\x02\
	\x02\u{1353}\u{1380}\x07\u{18d}\x02\x02\u{1354}\u{1380}\x07\u{18e}\x02\x02\
	\u{1355}\u{1380}\x07\u{18f}\x02\x02\u{1356}\u{1380}\x07\u{190}\x02\x02\u{1357}\
	\u{1380}\x07\u{191}\x02\x02\u{1358}\u{1380}\x07\u{192}\x02\x02\u{1359}\u{1380}\
	\x07\u{193}\x02\x02\u{135a}\u{1380}\x07\u{194}\x02\x02\u{135b}\u{1380}\x07\
	\u{195}\x02\x02\u{135c}\u{1380}\x07\u{196}\x02\x02\u{135d}\u{1380}\x07\u{197}\
	\x02\x02\u{135e}\u{1380}\x07\u{198}\x02\x02\u{135f}\u{1380}\x07\u{199}\x02\
	\x02\u{1360}\u{1380}\x07\u{19a}\x02\x02\u{1361}\u{1380}\x07\u{19b}\x02\x02\
	\u{1362}\u{1380}\x07\u{19c}\x02\x02\u{1363}\u{1380}\x07\u{19d}\x02\x02\u{1364}\
	\u{1380}\x07\u{19e}\x02\x02\u{1365}\u{1380}\x07\u{19f}\x02\x02\u{1366}\u{1380}\
	\x07\u{1a3}\x02\x02\u{1367}\u{1380}\x07\u{1a4}\x02\x02\u{1368}\u{1380}\x07\
	\u{1a5}\x02\x02\u{1369}\u{1380}\x07\u{1a6}\x02\x02\u{136a}\u{1380}\x07\u{1a7}\
	\x02\x02\u{136b}\u{1380}\x07\u{1a8}\x02\x02\u{136c}\u{1380}\x07\u{1a9}\x02\
	\x02\u{136d}\u{1380}\x07\u{1aa}\x02\x02\u{136e}\u{1380}\x07\u{1ab}\x02\x02\
	\u{136f}\u{1380}\x07\u{1ac}\x02\x02\u{1370}\u{1380}\x07\u{1ad}\x02\x02\u{1371}\
	\u{1380}\x07\u{1ae}\x02\x02\u{1372}\u{1380}\x07\u{1af}\x02\x02\u{1373}\u{1380}\
	\x07\u{1b0}\x02\x02\u{1374}\u{1380}\x07\u{1b1}\x02\x02\u{1375}\u{1380}\x07\
	\u{1b2}\x02\x02\u{1376}\u{1380}\x07\u{1b3}\x02\x02\u{1377}\u{1380}\x07\u{1b4}\
	\x02\x02\u{1378}\u{1380}\x07\u{1b5}\x02\x02\u{1379}\u{1380}\x07\u{1b6}\x02\
	\x02\u{137a}\u{1380}\x07\u{1b7}\x02\x02\u{137b}\u{1380}\x07\u{1b8}\x02\x02\
	\u{137c}\u{1380}\x07\u{1b9}\x02\x02\u{137d}\u{1380}\x07\u{1ba}\x02\x02\u{137e}\
	\u{1380}\x07\u{1bb}\x02\x02\u{137f}\u{11f5}\x03\x02\x02\x02\u{137f}\u{11f6}\
	\x03\x02\x02\x02\u{137f}\u{11f7}\x03\x02\x02\x02\u{137f}\u{11f8}\x03\x02\
	\x02\x02\u{137f}\u{11f9}\x03\x02\x02\x02\u{137f}\u{11fa}\x03\x02\x02\x02\
	\u{137f}\u{11fb}\x03\x02\x02\x02\u{137f}\u{11fc}\x03\x02\x02\x02\u{137f}\
	\u{11fd}\x03\x02\x02\x02\u{137f}\u{11fe}\x03\x02\x02\x02\u{137f}\u{11ff}\
	\x03\x02\x02\x02\u{137f}\u{1200}\x03\x02\x02\x02\u{137f}\u{1201}\x03\x02\
	\x02\x02\u{137f}\u{1202}\x03\x02\x02\x02\u{137f}\u{1203}\x03\x02\x02\x02\
	\u{137f}\u{1204}\x03\x02\x02\x02\u{137f}\u{1205}\x03\x02\x02\x02\u{137f}\
	\u{1206}\x03\x02\x02\x02\u{137f}\u{1207}\x03\x02\x02\x02\u{137f}\u{1208}\
	\x03\x02\x02\x02\u{137f}\u{1209}\x03\x02\x02\x02\u{137f}\u{120a}\x03\x02\
	\x02\x02\u{137f}\u{120b}\x03\x02\x02\x02\u{137f}\u{120c}\x03\x02\x02\x02\
	\u{137f}\u{120d}\x03\x02\x02\x02\u{137f}\u{120e}\x03\x02\x02\x02\u{137f}\
	\u{120f}\x03\x02\x02\x02\u{137f}\u{1210}\x03\x02\x02\x02\u{137f}\u{1211}\
	\x03\x02\x02\x02\u{137f}\u{1212}\x03\x02\x02\x02\u{137f}\u{1213}\x03\x02\
	\x02\x02\u{137f}\u{1214}\x03\x02\x02\x02\u{137f}\u{1215}\x03\x02\x02\x02\
	\u{137f}\u{1216}\x03\x02\x02\x02\u{137f}\u{1217}\x03\x02\x02\x02\u{137f}\
	\u{1218}\x03\x02\x02\x02\u{137f}\u{1219}\x03\x02\x02\x02\u{137f}\u{121a}\
	\x03\x02\x02\x02\u{137f}\u{121b}\x03\x02\x02\x02\u{137f}\u{121c}\x03\x02\
	\x02\x02\u{137f}\u{121d}\x03\x02\x02\x02\u{137f}\u{121e}\x03\x02\x02\x02\
	\u{137f}\u{121f}\x03\x02\x02\x02\u{137f}\u{1220}\x03\x02\x02\x02\u{137f}\
	\u{1221}\x03\x02\x02\x02\u{137f}\u{1222}\x03\x02\x02\x02\u{137f}\u{1223}\
	\x03\x02\x02\x02\u{137f}\u{1224}\x03\x02\x02\x02\u{137f}\u{1225}\x03\x02\
	\x02\x02\u{137f}\u{1226}\x03\x02\x02\x02\u{137f}\u{1227}\x03\x02\x02\x02\
	\u{137f}\u{1228}\x03\x02\x02\x02\u{137f}\u{1229}\x03\x02\x02\x02\u{137f}\
	\u{122a}\x03\x02\x02\x02\u{137f}\u{122b}\x03\x02\x02\x02\u{137f}\u{122c}\
	\x03\x02\x02\x02\u{137f}\u{122d}\x03\x02\x02\x02\u{137f}\u{122e}\x03\x02\
	\x02\x02\u{137f}\u{122f}\x03\x02\x02\x02\u{137f}\u{1230}\x03\x02\x02\x02\
	\u{137f}\u{1231}\x03\x02\x02\x02\u{137f}\u{1232}\x03\x02\x02\x02\u{137f}\
	\u{1233}\x03\x02\x02\x02\u{137f}\u{1234}\x03\x02\x02\x02\u{137f}\u{1235}\
	\x03\x02\x02\x02\u{137f}\u{1236}\x03\x02\x02\x02\u{137f}\u{1237}\x03\x02\
	\x02\x02\u{137f}\u{1238}\x03\x02\x02\x02\u{137f}\u{1239}\x03\x02\x02\x02\
	\u{137f}\u{123a}\x03\x02\x02\x02\u{137f}\u{123b}\x03\x02\x02\x02\u{137f}\
	\u{123c}\x03\x02\x02\x02\u{137f}\u{123d}\x03\x02\x02\x02\u{137f}\u{123e}\
	\x03\x02\x02\x02\u{137f}\u{123f}\x03\x02\x02\x02\u{137f}\u{1240}\x03\x02\
	\x02\x02\u{137f}\u{1241}\x03\x02\x02\x02\u{137f}\u{1242}\x03\x02\x02\x02\
	\u{137f}\u{1243}\x03\x02\x02\x02\u{137f}\u{1244}\x03\x02\x02\x02\u{137f}\
	\u{1245}\x03\x02\x02\x02\u{137f}\u{1246}\x03\x02\x02\x02\u{137f}\u{1247}\
	\x03\x02\x02\x02\u{137f}\u{1248}\x03\x02\x02\x02\u{137f}\u{1249}\x03\x02\
	\x02\x02\u{137f}\u{124a}\x03\x02\x02\x02\u{137f}\u{124b}\x03\x02\x02\x02\
	\u{137f}\u{124c}\x03\x02\x02\x02\u{137f}\u{124d}\x03\x02\x02\x02\u{137f}\
	\u{124e}\x03\x02\x02\x02\u{137f}\u{124f}\x03\x02\x02\x02\u{137f}\u{1250}\
	\x03\x02\x02\x02\u{137f}\u{1251}\x03\x02\x02\x02\u{137f}\u{1252}\x03\x02\
	\x02\x02\u{137f}\u{1253}\x03\x02\x02\x02\u{137f}\u{1254}\x03\x02\x02\x02\
	\u{137f}\u{1255}\x03\x02\x02\x02\u{137f}\u{1256}\x03\x02\x02\x02\u{137f}\
	\u{1257}\x03\x02\x02\x02\u{137f}\u{1258}\x03\x02\x02\x02\u{137f}\u{1259}\
	\x03\x02\x02\x02\u{137f}\u{125a}\x03\x02\x02\x02\u{137f}\u{125b}\x03\x02\
	\x02\x02\u{137f}\u{125c}\x03\x02\x02\x02\u{137f}\u{125d}\x03\x02\x02\x02\
	\u{137f}\u{125e}\x03\x02\x02\x02\u{137f}\u{125f}\x03\x02\x02\x02\u{137f}\
	\u{1260}\x03\x02\x02\x02\u{137f}\u{1261}\x03\x02\x02\x02\u{137f}\u{1262}\
	\x03\x02\x02\x02\u{137f}\u{1263}\x03\x02\x02\x02\u{137f}\u{1264}\x03\x02\
	\x02\x02\u{137f}\u{1265}\x03\x02\x02\x02\u{137f}\u{1266}\x03\x02\x02\x02\
	\u{137f}\u{1267}\x03\x02\x02\x02\u{137f}\u{1268}\x03\x02\x02\x02\u{137f}\
	\u{1269}\x03\x02\x02\x02\u{137f}\u{126a}\x03\x02\x02\x02\u{137f}\u{126b}\
	\x03\x02\x02\x02\u{137f}\u{126c}\x03\x02\x02\x02\u{137f}\u{126d}\x03\x02\
	\x02\x02\u{137f}\u{126e}\x03\x02\x02\x02\u{137f}\u{126f}\x03\x02\x02\x02\
	\u{137f}\u{1270}\x03\x02\x02\x02\u{137f}\u{1271}\x03\x02\x02\x02\u{137f}\
	\u{1272}\x03\x02\x02\x02\u{137f}\u{1273}\x03\x02\x02\x02\u{137f}\u{1274}\
	\x03\x02\x02\x02\u{137f}\u{1275}\x03\x02\x02\x02\u{137f}\u{1276}\x03\x02\
	\x02\x02\u{137f}\u{1277}\x03\x02\x02\x02\u{137f}\u{1278}\x03\x02\x02\x02\
	\u{137f}\u{1279}\x03\x02\x02\x02\u{137f}\u{127a}\x03\x02\x02\x02\u{137f}\
	\u{127b}\x03\x02\x02\x02\u{137f}\u{127c}\x03\x02\x02\x02\u{137f}\u{127d}\
	\x03\x02\x02\x02\u{137f}\u{127e}\x03\x02\x02\x02\u{137f}\u{127f}\x03\x02\
	\x02\x02\u{137f}\u{1280}\x03\x02\x02\x02\u{137f}\u{1281}\x03\x02\x02\x02\
	\u{137f}\u{1282}\x03\x02\x02\x02\u{137f}\u{1283}\x03\x02\x02\x02\u{137f}\
	\u{1284}\x03\x02\x02\x02\u{137f}\u{1285}\x03\x02\x02\x02\u{137f}\u{1286}\
	\x03\x02\x02\x02\u{137f}\u{1287}\x03\x02\x02\x02\u{137f}\u{1288}\x03\x02\
	\x02\x02\u{137f}\u{1289}\x03\x02\x02\x02\u{137f}\u{128a}\x03\x02\x02\x02\
	\u{137f}\u{128b}\x03\x02\x02\x02\u{137f}\u{128c}\x03\x02\x02\x02\u{137f}\
	\u{128d}\x03\x02\x02\x02\u{137f}\u{128e}\x03\x02\x02\x02\u{137f}\u{128f}\
	\x03\x02\x02\x02\u{137f}\u{1290}\x03\x02\x02\x02\u{137f}\u{1291}\x03\x02\
	\x02\x02\u{137f}\u{1292}\x03\x02\x02\x02\u{137f}\u{1293}\x03\x02\x02\x02\
	\u{137f}\u{1294}\x03\x02\x02\x02\u{137f}\u{1295}\x03\x02\x02\x02\u{137f}\
	\u{1296}\x03\x02\x02\x02\u{137f}\u{1297}\x03\x02\x02\x02\u{137f}\u{1298}\
	\x03\x02\x02\x02\u{137f}\u{1299}\x03\x02\x02\x02\u{137f}\u{129a}\x03\x02\
	\x02\x02\u{137f}\u{129b}\x03\x02\x02\x02\u{137f}\u{129c}\x03\x02\x02\x02\
	\u{137f}\u{129d}\x03\x02\x02\x02\u{137f}\u{129e}\x03\x02\x02\x02\u{137f}\
	\u{129f}\x03\x02\x02\x02\u{137f}\u{12a0}\x03\x02\x02\x02\u{137f}\u{12a1}\
	\x03\x02\x02\x02\u{137f}\u{12a2}\x03\x02\x02\x02\u{137f}\u{12a3}\x03\x02\
	\x02\x02\u{137f}\u{12a4}\x03\x02\x02\x02\u{137f}\u{12a5}\x03\x02\x02\x02\
	\u{137f}\u{12a6}\x03\x02\x02\x02\u{137f}\u{12a7}\x03\x02\x02\x02\u{137f}\
	\u{12a8}\x03\x02\x02\x02\u{137f}\u{12a9}\x03\x02\x02\x02\u{137f}\u{12aa}\
	\x03\x02\x02\x02\u{137f}\u{12ab}\x03\x02\x02\x02\u{137f}\u{12ac}\x03\x02\
	\x02\x02\u{137f}\u{12ad}\x03\x02\x02\x02\u{137f}\u{12ae}\x03\x02\x02\x02\
	\u{137f}\u{12af}\x03\x02\x02\x02\u{137f}\u{12b0}\x03\x02\x02\x02\u{137f}\
	\u{12b1}\x03\x02\x02\x02\u{137f}\u{12b2}\x03\x02\x02\x02\u{137f}\u{12b3}\
	\x03\x02\x02\x02\u{137f}\u{12b4}\x03\x02\x02\x02\u{137f}\u{12b5}\x03\x02\
	\x02\x02\u{137f}\u{12b6}\x03\x02\x02\x02\u{137f}\u{12b7}\x03\x02\x02\x02\
	\u{137f}\u{12b8}\x03\x02\x02\x02\u{137f}\u{12b9}\x03\x02\x02\x02\u{137f}\
	\u{12ba}\x03\x02\x02\x02\u{137f}\u{12bb}\x03\x02\x02\x02\u{137f}\u{12bc}\
	\x03\x02\x02\x02\u{137f}\u{12bd}\x03\x02\x02\x02\u{137f}\u{12be}\x03\x02\
	\x02\x02\u{137f}\u{12bf}\x03\x02\x02\x02\u{137f}\u{12c0}\x03\x02\x02\x02\
	\u{137f}\u{12c1}\x03\x02\x02\x02\u{137f}\u{12c2}\x03\x02\x02\x02\u{137f}\
	\u{12c3}\x03\x02\x02\x02\u{137f}\u{12c4}\x03\x02\x02\x02\u{137f}\u{12c5}\
	\x03\x02\x02\x02\u{137f}\u{12c6}\x03\x02\x02\x02\u{137f}\u{12c7}\x03\x02\
	\x02\x02\u{137f}\u{12c8}\x03\x02\x02\x02\u{137f}\u{12c9}\x03\x02\x02\x02\
	\u{137f}\u{12ca}\x03\x02\x02\x02\u{137f}\u{12cb}\x03\x02\x02\x02\u{137f}\
	\u{12cc}\x03\x02\x02\x02\u{137f}\u{12cd}\x03\x02\x02\x02\u{137f}\u{12ce}\
	\x03\x02\x02\x02\u{137f}\u{12cf}\x03\x02\x02\x02\u{137f}\u{12d0}\x03\x02\
	\x02\x02\u{137f}\u{12d1}\x03\x02\x02\x02\u{137f}\u{12d2}\x03\x02\x02\x02\
	\u{137f}\u{12d3}\x03\x02\x02\x02\u{137f}\u{12d4}\x03\x02\x02\x02\u{137f}\
	\u{12d5}\x03\x02\x02\x02\u{137f}\u{12d6}\x03\x02\x02\x02\u{137f}\u{12d7}\
	\x03\x02\x02\x02\u{137f}\u{12d8}\x03\x02\x02\x02\u{137f}\u{12d9}\x03\x02\
	\x02\x02\u{137f}\u{12da}\x03\x02\x02\x02\u{137f}\u{12db}\x03\x02\x02\x02\
	\u{137f}\u{12dc}\x03\x02\x02\x02\u{137f}\u{12dd}\x03\x02\x02\x02\u{137f}\
	\u{12de}\x03\x02\x02\x02\u{137f}\u{12df}\x03\x02\x02\x02\u{137f}\u{12e0}\
	\x03\x02\x02\x02\u{137f}\u{12e1}\x03\x02\x02\x02\u{137f}\u{12e2}\x03\x02\
	\x02\x02\u{137f}\u{12e3}\x03\x02\x02\x02\u{137f}\u{12e4}\x03\x02\x02\x02\
	\u{137f}\u{12e5}\x03\x02\x02\x02\u{137f}\u{12e6}\x03\x02\x02\x02\u{137f}\
	\u{12e7}\x03\x02\x02\x02\u{137f}\u{12e8}\x03\x02\x02\x02\u{137f}\u{12e9}\
	\x03\x02\x02\x02\u{137f}\u{12ea}\x03\x02\x02\x02\u{137f}\u{12eb}\x03\x02\
	\x02\x02\u{137f}\u{12ec}\x03\x02\x02\x02\u{137f}\u{12ed}\x03\x02\x02\x02\
	\u{137f}\u{12ee}\x03\x02\x02\x02\u{137f}\u{12ef}\x03\x02\x02\x02\u{137f}\
	\u{12f0}\x03\x02\x02\x02\u{137f}\u{12f1}\x03\x02\x02\x02\u{137f}\u{12f2}\
	\x03\x02\x02\x02\u{137f}\u{12f3}\x03\x02\x02\x02\u{137f}\u{12f4}\x03\x02\
	\x02\x02\u{137f}\u{12f5}\x03\x02\x02\x02\u{137f}\u{12f6}\x03\x02\x02\x02\
	\u{137f}\u{12f7}\x03\x02\x02\x02\u{137f}\u{12f8}\x03\x02\x02\x02\u{137f}\
	\u{12f9}\x03\x02\x02\x02\u{137f}\u{12fa}\x03\x02\x02\x02\u{137f}\u{12fb}\
	\x03\x02\x02\x02\u{137f}\u{12fc}\x03\x02\x02\x02\u{137f}\u{12fd}\x03\x02\
	\x02\x02\u{137f}\u{12fe}\x03\x02\x02\x02\u{137f}\u{12ff}\x03\x02\x02\x02\
	\u{137f}\u{1300}\x03\x02\x02\x02\u{137f}\u{1301}\x03\x02\x02\x02\u{137f}\
	\u{1302}\x03\x02\x02\x02\u{137f}\u{1303}\x03\x02\x02\x02\u{137f}\u{1304}\
	\x03\x02\x02\x02\u{137f}\u{1305}\x03\x02\x02\x02\u{137f}\u{1306}\x03\x02\
	\x02\x02\u{137f}\u{1307}\x03\x02\x02\x02\u{137f}\u{1308}\x03\x02\x02\x02\
	\u{137f}\u{1309}\x03\x02\x02\x02\u{137f}\u{130a}\x03\x02\x02\x02\u{137f}\
	\u{130b}\x03\x02\x02\x02\u{137f}\u{130c}\x03\x02\x02\x02\u{137f}\u{130d}\
	\x03\x02\x02\x02\u{137f}\u{130e}\x03\x02\x02\x02\u{137f}\u{130f}\x03\x02\
	\x02\x02\u{137f}\u{1310}\x03\x02\x02\x02\u{137f}\u{1311}\x03\x02\x02\x02\
	\u{137f}\u{1312}\x03\x02\x02\x02\u{137f}\u{1313}\x03\x02\x02\x02\u{137f}\
	\u{1314}\x03\x02\x02\x02\u{137f}\u{1315}\x03\x02\x02\x02\u{137f}\u{1316}\
	\x03\x02\x02\x02\u{137f}\u{1317}\x03\x02\x02\x02\u{137f}\u{1318}\x03\x02\
	\x02\x02\u{137f}\u{1319}\x03\x02\x02\x02\u{137f}\u{131a}\x03\x02\x02\x02\
	\u{137f}\u{131b}\x03\x02\x02\x02\u{137f}\u{131c}\x03\x02\x02\x02\u{137f}\
	\u{131d}\x03\x02\x02\x02\u{137f}\u{131e}\x03\x02\x02\x02\u{137f}\u{131f}\
	\x03\x02\x02\x02\u{137f}\u{1320}\x03\x02\x02\x02\u{137f}\u{1321}\x03\x02\
	\x02\x02\u{137f}\u{1322}\x03\x02\x02\x02\u{137f}\u{1323}\x03\x02\x02\x02\
	\u{137f}\u{1324}\x03\x02\x02\x02\u{137f}\u{1325}\x03\x02\x02\x02\u{137f}\
	\u{1326}\x03\x02\x02\x02\u{137f}\u{1327}\x03\x02\x02\x02\u{137f}\u{1328}\
	\x03\x02\x02\x02\u{137f}\u{1329}\x03\x02\x02\x02\u{137f}\u{132a}\x03\x02\
	\x02\x02\u{137f}\u{132b}\x03\x02\x02\x02\u{137f}\u{132c}\x03\x02\x02\x02\
	\u{137f}\u{132d}\x03\x02\x02\x02\u{137f}\u{132e}\x03\x02\x02\x02\u{137f}\
	\u{132f}\x03\x02\x02\x02\u{137f}\u{1330}\x03\x02\x02\x02\u{137f}\u{1331}\
	\x03\x02\x02\x02\u{137f}\u{1332}\x03\x02\x02\x02\u{137f}\u{1333}\x03\x02\
	\x02\x02\u{137f}\u{1334}\x03\x02\x02\x02\u{137f}\u{1335}\x03\x02\x02\x02\
	\u{137f}\u{1336}\x03\x02\x02\x02\u{137f}\u{1337}\x03\x02\x02\x02\u{137f}\
	\u{1338}\x03\x02\x02\x02\u{137f}\u{1339}\x03\x02\x02\x02\u{137f}\u{133a}\
	\x03\x02\x02\x02\u{137f}\u{133b}\x03\x02\x02\x02\u{137f}\u{133c}\x03\x02\
	\x02\x02\u{137f}\u{133d}\x03\x02\x02\x02\u{137f}\u{133e}\x03\x02\x02\x02\
	\u{137f}\u{133f}\x03\x02\x02\x02\u{137f}\u{1340}\x03\x02\x02\x02\u{137f}\
	\u{1341}\x03\x02\x02\x02\u{137f}\u{1342}\x03\x02\x02\x02\u{137f}\u{1343}\
	\x03\x02\x02\x02\u{137f}\u{1344}\x03\x02\x02\x02\u{137f}\u{1345}\x03\x02\
	\x02\x02\u{137f}\u{1346}\x03\x02\x02\x02\u{137f}\u{1347}\x03\x02\x02\x02\
	\u{137f}\u{1348}\x03\x02\x02\x02\u{137f}\u{1349}\x03\x02\x02\x02\u{137f}\
	\u{134a}\x03\x02\x02\x02\u{137f}\u{134b}\x03\x02\x02\x02\u{137f}\u{134c}\
	\x03\x02\x02\x02\u{137f}\u{134d}\x03\x02\x02\x02\u{137f}\u{134e}\x03\x02\
	\x02\x02\u{137f}\u{134f}\x03\x02\x02\x02\u{137f}\u{1350}\x03\x02\x02\x02\
	\u{137f}\u{1351}\x03\x02\x02\x02\u{137f}\u{1352}\x03\x02\x02\x02\u{137f}\
	\u{1353}\x03\x02\x02\x02\u{137f}\u{1354}\x03\x02\x02\x02\u{137f}\u{1355}\
	\x03\x02\x02\x02\u{137f}\u{1356}\x03\x02\x02\x02\u{137f}\u{1357}\x03\x02\
	\x02\x02\u{137f}\u{1358}\x03\x02\x02\x02\u{137f}\u{1359}\x03\x02\x02\x02\
	\u{137f}\u{135a}\x03\x02\x02\x02\u{137f}\u{135b}\x03\x02\x02\x02\u{137f}\
	\u{135c}\x03\x02\x02\x02\u{137f}\u{135d}\x03\x02\x02\x02\u{137f}\u{135e}\
	\x03\x02\x02\x02\u{137f}\u{135f}\x03\x02\x02\x02\u{137f}\u{1360}\x03\x02\
	\x02\x02\u{137f}\u{1361}\x03\x02\x02\x02\u{137f}\u{1362}\x03\x02\x02\x02\
	\u{137f}\u{1363}\x03\x02\x02\x02\u{137f}\u{1364}\x03\x02\x02\x02\u{137f}\
	\u{1365}\x03\x02\x02\x02\u{137f}\u{1366}\x03\x02\x02\x02\u{137f}\u{1367}\
	\x03\x02\x02\x02\u{137f}\u{1368}\x03\x02\x02\x02\u{137f}\u{1369}\x03\x02\
	\x02\x02\u{137f}\u{136a}\x03\x02\x02\x02\u{137f}\u{136b}\x03\x02\x02\x02\
	\u{137f}\u{136c}\x03\x02\x02\x02\u{137f}\u{136d}\x03\x02\x02\x02\u{137f}\
	\u{136e}\x03\x02\x02\x02\u{137f}\u{136f}\x03\x02\x02\x02\u{137f}\u{1370}\
	\x03\x02\x02\x02\u{137f}\u{1371}\x03\x02\x02\x02\u{137f}\u{1372}\x03\x02\
	\x02\x02\u{137f}\u{1373}\x03\x02\x02\x02\u{137f}\u{1374}\x03\x02\x02\x02\
	\u{137f}\u{1375}\x03\x02\x02\x02\u{137f}\u{1376}\x03\x02\x02\x02\u{137f}\
	\u{1377}\x03\x02\x02\x02\u{137f}\u{1378}\x03\x02\x02\x02\u{137f}\u{1379}\
	\x03\x02\x02\x02\u{137f}\u{137a}\x03\x02\x02\x02\u{137f}\u{137b}\x03\x02\
	\x02\x02\u{137f}\u{137c}\x03\x02\x02\x02\u{137f}\u{137d}\x03\x02\x02\x02\
	\u{137f}\u{137e}\x03\x02\x02\x02\u{1380}\u{115}\x03\x02\x02\x02\u{1381}\
	\u{1393}\x05\u{154}\u{ab}\x02\u{1382}\u{1393}\x07\u{d6}\x02\x02\u{1383}\
	\u{1393}\x07\u{145}\x02\x02\u{1384}\u{1393}\x07\u{ab}\x02\x02\u{1385}\u{1393}\
	\x07\u{13c}\x02\x02\u{1386}\u{1393}\x07\u{c2}\x02\x02\u{1387}\u{1393}\x07\
	\u{ba}\x02\x02\u{1388}\u{1393}\x07\u{d9}\x02\x02\u{1389}\u{1393}\x07\u{dc}\
	\x02\x02\u{138a}\u{1393}\x07\u{ff}\x02\x02\u{138b}\u{1393}\x07\u{189}\x02\
	\x02\u{138c}\u{1393}\x07\x3f\x02\x02\u{138d}\u{1393}\x07\u{11e}\x02\x02\
	\u{138e}\u{1393}\x07\u{11f}\x02\x02\u{138f}\u{1393}\x07\u{135}\x02\x02\u{1390}\
	\u{1393}\x07\u{146}\x02\x02\u{1391}\u{1393}\x07\u{a2}\x02\x02\u{1392}\u{1381}\
	\x03\x02\x02\x02\u{1392}\u{1382}\x03\x02\x02\x02\u{1392}\u{1383}\x03\x02\
	\x02\x02\u{1392}\u{1384}\x03\x02\x02\x02\u{1392}\u{1385}\x03\x02\x02\x02\
	\u{1392}\u{1386}\x03\x02\x02\x02\u{1392}\u{1387}\x03\x02\x02\x02\u{1392}\
	\u{1388}\x03\x02\x02\x02\u{1392}\u{1389}\x03\x02\x02\x02\u{1392}\u{138a}\
	\x03\x02\x02\x02\u{1392}\u{138b}\x03\x02\x02\x02\u{1392}\u{138c}\x03\x02\
	\x02\x02\u{1392}\u{138d}\x03\x02\x02\x02\u{1392}\u{138e}\x03\x02\x02\x02\
	\u{1392}\u{138f}\x03\x02\x02\x02\u{1392}\u{1390}\x03\x02\x02\x02\u{1392}\
	\u{1391}\x03\x02\x02\x02\u{1393}\u{117}\x03\x02\x02\x02\u{1394}\u{1395}\
	\x05\u{164}\u{b3}\x02\u{1395}\u{1398}\x05\u{134}\u{9b}\x02\u{1396}\u{1397}\
	\x07\x5c\x02\x02\u{1397}\u{1399}\x05\u{f8}\x7d\x02\u{1398}\u{1396}\x03\x02\
	\x02\x02\u{1398}\u{1399}\x03\x02\x02\x02\u{1399}\u{119}\x03\x02\x02\x02\
	\u{139a}\u{139b}\x07\u{8a}\x02\x02\u{139b}\u{139e}\x07\x03\x02\x02\u{139c}\
	\u{139f}\x05\u{122}\u{92}\x02\u{139d}\u{139f}\x05\u{154}\u{ab}\x02\u{139e}\
	\u{139c}\x03\x02\x02\x02\u{139e}\u{139d}\x03\x02\x02\x02\u{139f}\u{13a4}\
	\x03\x02\x02\x02\u{13a0}\u{13a1}\x07\u{11c}\x02\x02\u{13a1}\u{13a2}\x07\
	\x03\x02\x02\u{13a2}\u{13a4}\x05\u{122}\u{92}\x02\u{13a3}\u{139a}\x03\x02\
	\x02\x02\u{13a3}\u{13a0}\x03\x02\x02\x02\u{13a4}\u{11b}\x03\x02\x02\x02\
	\u{13a5}\u{13a8}\x05\u{f8}\x7d\x02\u{13a6}\u{13a7}\x07\x1e\x02\x02\u{13a7}\
	\u{13a9}\x05\u{164}\u{b3}\x02\u{13a8}\u{13a6}\x03\x02\x02\x02\u{13a8}\u{13a9}\
	\x03\x02\x02\x02\u{13a9}\u{11d}\x03\x02\x02\x02\u{13aa}\u{13ab}\x09\x2a\
	\x02\x02\u{13ab}\u{11f}\x03\x02\x02\x02\u{13ac}\u{13ad}\x07\u{ac}\x02\x02\
	\u{13ad}\u{13b1}\x07\u{103}\x02\x02\u{13ae}\u{13af}\x07\u{13e}\x02\x02\u{13af}\
	\u{13b1}\x07\u{103}\x02\x02\u{13b0}\u{13ac}\x03\x02\x02\x02\u{13b0}\u{13ae}\
	\x03\x02\x02\x02\u{13b1}\u{121}\x03\x02\x02\x02\u{13b2}\u{13ba}\x07\u{1d4}\
	\x02\x02\u{13b3}\u{13b6}\x07\u{1d5}\x02\x02\u{13b4}\u{13b5}\x07\u{18f}\x02\
	\x02\u{13b5}\u{13b7}\x07\u{1d4}\x02\x02\u{13b6}\u{13b4}\x03\x02\x02\x02\
	\u{13b6}\u{13b7}\x03\x02\x02\x02\u{13b7}\u{13ba}\x03\x02\x02\x02\u{13b8}\
	\u{13ba}\x07\u{1d6}\x02\x02\u{13b9}\u{13b2}\x03\x02\x02\x02\u{13b9}\u{13b3}\
	\x03\x02\x02\x02\u{13b9}\u{13b8}\x03\x02\x02\x02\u{13ba}\u{123}\x03\x02\
	\x02\x02\u{13bb}\u{13bc}\x07\u{181}\x02\x02\u{13bc}\u{13bd}\x07\u{1ba}\x02\
	\x02\u{13bd}\u{13c2}\x05\u{12c}\u{97}\x02\u{13be}\u{13bf}\x07\u{181}\x02\
	\x02\u{13bf}\u{13c0}\x07\u{1ba}\x02\x02\u{13c0}\u{13c2}\x05\u{122}\u{92}\
	\x02\u{13c1}\u{13bb}\x03\x02\x02\x02\u{13c1}\u{13be}\x03\x02\x02\x02\u{13c2}\
	\u{125}\x03\x02\x02\x02\u{13c3}\u{13c4}\x09\x2b\x02\x02\u{13c4}\u{127}\x03\
	\x02\x02\x02\u{13c5}\u{13c6}\x09\x2c\x02\x02\u{13c6}\u{129}\x03\x02\x02\
	\x02\u{13c7}\u{13c8}\x09\x2d\x02\x02\u{13c8}\u{12b}\x03\x02\x02\x02\u{13c9}\
	\u{13ca}\x07\u{bc}\x02\x02\u{13ca}\u{13cc}\x05\u{122}\u{92}\x02\u{13cb}\
	\u{13cd}\x05\u{12e}\u{98}\x02\u{13cc}\u{13cb}\x03\x02\x02\x02\u{13cc}\u{13cd}\
	\x03\x02\x02\x02\u{13cd}\u{12d}\x03\x02\x02\x02\u{13ce}\u{13cf}\x09\x2e\
	\x02\x02\u{13cf}\u{12f}\x03\x02\x02\x02\u{13d0}\u{13d1}\x09\x2f\x02\x02\
	\u{13d1}\u{131}\x03\x02\x02\x02\u{13d2}\u{13d3}\x05\u{164}\u{b3}\x02\u{13d3}\
	\u{133}\x03\x02\x02\x02\u{13d4}\u{13d7}\x05\u{136}\u{9c}\x02\u{13d5}\u{13d6}\
	\x07\u{100}\x02\x02\u{13d6}\u{13d8}\x07\u{102}\x02\x02\u{13d7}\u{13d5}\x03\
	\x02\x02\x02\u{13d7}\u{13d8}\x03\x02\x02\x02\u{13d8}\u{13db}\x03\x02\x02\
	\x02\u{13d9}\u{13db}\x07\u{102}\x02\x02\u{13da}\u{13d4}\x03\x02\x02\x02\
	\u{13da}\u{13d9}\x03\x02\x02\x02\u{13db}\u{135}\x03\x02\x02\x02\u{13dc}\
	\u{13dd}\x07\u{1d0}\x02\x02\u{13dd}\u{1446}\x07\u{1d8}\x02\x02\u{13de}\u{13df}\
	\x07\x71\x02\x02\u{13df}\u{1446}\x07\u{127}\x02\x02\u{13e0}\u{13e1}\x09\
	\x30\x02\x02\u{13e1}\u{13e5}\x07\u{1a7}\x02\x02\u{13e2}\u{13e3}\x07\u{1bc}\
	\x02\x02\u{13e3}\u{13e4}\x07\u{1d8}\x02\x02\u{13e4}\u{13e6}\x07\u{1bd}\x02\
	\x02\u{13e5}\u{13e2}\x03\x02\x02\x02\u{13e5}\u{13e6}\x03\x02\x02\x02\u{13e6}\
	\u{1446}\x03\x02\x02\x02\u{13e7}\u{13f1}\x07\u{182}\x02\x02\u{13e8}\u{13ee}\
	\x07\u{1b3}\x02\x02\u{13e9}\u{13eb}\x07\u{1b1}\x02\x02\u{13ea}\u{13ec}\x07\
	\u{dd}\x02\x02\u{13eb}\u{13ea}\x03\x02\x02\x02\u{13eb}\u{13ec}\x03\x02\x02\
	\x02\u{13ec}\u{13ee}\x03\x02\x02\x02\u{13ed}\u{13e8}\x03\x02\x02\x02\u{13ed}\
	\u{13e9}\x03\x02\x02\x02\u{13ee}\u{13ef}\x03\x02\x02\x02\u{13ef}\u{13f0}\
	\x07\u{181}\x02\x02\u{13f0}\u{13f2}\x07\u{1ba}\x02\x02\u{13f1}\u{13ed}\x03\
	\x02\x02\x02\u{13f1}\u{13f2}\x03\x02\x02\x02\u{13f2}\u{13f7}\x03\x02\x02\
	\x02\u{13f3}\u{13f4}\x07\u{1bc}\x02\x02\u{13f4}\u{13f5}\x05\u{13a}\u{9e}\
	\x02\u{13f5}\u{13f6}\x07\u{1bd}\x02\x02\u{13f6}\u{13f8}\x03\x02\x02\x02\
	\u{13f7}\u{13f3}\x03\x02\x02\x02\u{13f7}\u{13f8}\x03\x02\x02\x02\u{13f8}\
	\u{1446}\x03\x02\x02\x02\u{13f9}\u{13fe}\x07\u{181}\x02\x02\u{13fa}\u{13fb}\
	\x07\u{1bc}\x02\x02\u{13fb}\u{13fc}\x05\u{13a}\u{9e}\x02\u{13fc}\u{13fd}\
	\x07\u{1bd}\x02\x02\u{13fd}\u{13ff}\x03\x02\x02\x02\u{13fe}\u{13fa}\x03\
	\x02\x02\x02\u{13fe}\u{13ff}\x03\x02\x02\x02\u{13ff}\u{1446}\x03\x02\x02\
	\x02\u{1400}\u{1401}\x07\u{98}\x02\x02\u{1401}\u{1402}\x07\u{1bc}\x02\x02\
	\u{1402}\u{1407}\x05\u{134}\u{9b}\x02\u{1403}\u{1404}\x07\x42\x02\x02\u{1404}\
	\u{1406}\x05\u{134}\u{9b}\x02\u{1405}\u{1403}\x03\x02\x02\x02\u{1406}\u{1409}\
	\x03\x02\x02\x02\u{1407}\u{1405}\x03\x02\x02\x02\u{1407}\u{1408}\x03\x02\
	\x02\x02\u{1408}\u{140a}\x03\x02\x02\x02\u{1409}\u{1407}\x03\x02\x02\x02\
	\u{140a}\u{140b}\x07\u{1bd}\x02\x02\u{140b}\u{1446}\x03\x02\x02\x02\u{140c}\
	\u{140d}\x07\u{170}\x02\x02\u{140d}\u{140e}\x07\u{1c3}\x02\x02\u{140e}\u{1413}\
	\x05\u{138}\u{9d}\x02\u{140f}\u{1410}\x07\x42\x02\x02\u{1410}\u{1412}\x05\
	\u{138}\u{9d}\x02\u{1411}\u{140f}\x03\x02\x02\x02\u{1412}\u{1415}\x03\x02\
	\x02\x02\u{1413}\u{1411}\x03\x02\x02\x02\u{1413}\u{1414}\x03\x02\x02\x02\
	\u{1414}\u{1417}\x03\x02\x02\x02\u{1415}\u{1413}\x03\x02\x02\x02\u{1416}\
	\u{1418}\x07\x42\x02\x02\u{1417}\u{1416}\x03\x02\x02\x02\u{1417}\u{1418}\
	\x03\x02\x02\x02\u{1418}\u{1419}\x03\x02\x02\x02\u{1419}\u{141a}\x07\u{1c5}\
	\x02\x02\u{141a}\u{1446}\x03\x02\x02\x02\u{141b}\u{141c}\x07\u{104}\x02\
	\x02\u{141c}\u{141d}\x07\u{1bc}\x02\x02\u{141d}\u{1422}\x05\u{138}\u{9d}\
	\x02\u{141e}\u{141f}\x07\x42\x02\x02\u{141f}\u{1421}\x05\u{138}\u{9d}\x02\
	\u{1420}\u{141e}\x03\x02\x02\x02\u{1421}\u{1424}\x03\x02\x02\x02\u{1422}\
	\u{1420}\x03\x02\x02\x02\u{1422}\u{1423}\x03\x02\x02\x02\u{1423}\u{1426}\
	\x03\x02\x02\x02\u{1424}\u{1422}\x03\x02\x02\x02\u{1425}\u{1427}\x07\x42\
	\x02\x02\u{1426}\u{1425}\x03\x02\x02\x02\u{1426}\u{1427}\x03\x02\x02\x02\
	\u{1427}\u{1428}\x03\x02\x02\x02\u{1428}\u{1429}\x07\u{1bd}\x02\x02\u{1429}\
	\u{1446}\x03\x02\x02\x02\u{142a}\u{142b}\x07\u{e1}\x02\x02\u{142b}\u{142c}\
	\x07\u{1bc}\x02\x02\u{142c}\u{142d}\x05\u{134}\u{9b}\x02\u{142d}\u{142e}\
	\x07\x42\x02\x02\u{142e}\u{1430}\x05\u{134}\u{9b}\x02\u{142f}\u{1431}\x07\
	\x42\x02\x02\u{1430}\u{142f}\x03\x02\x02\x02\u{1430}\u{1431}\x03\x02\x02\
	\x02\u{1431}\u{1432}\x03\x02\x02\x02\u{1432}\u{1433}\x07\u{1bd}\x02\x02\
	\u{1433}\u{1446}\x03\x02\x02\x02\u{1434}\u{1443}\x05\u{132}\u{9a}\x02\u{1435}\
	\u{1436}\x07\u{1bc}\x02\x02\u{1436}\u{143b}\x05\u{13a}\u{9e}\x02\u{1437}\
	\u{1438}\x07\x42\x02\x02\u{1438}\u{143a}\x05\u{13a}\u{9e}\x02\u{1439}\u{1437}\
	\x03\x02\x02\x02\u{143a}\u{143d}\x03\x02\x02\x02\u{143b}\u{1439}\x03\x02\
	\x02\x02\u{143b}\u{143c}\x03\x02\x02\x02\u{143c}\u{143f}\x03\x02\x02\x02\
	\u{143d}\u{143b}\x03\x02\x02\x02\u{143e}\u{1440}\x07\x42\x02\x02\u{143f}\
	\u{143e}\x03\x02\x02\x02\u{143f}\u{1440}\x03\x02\x02\x02\u{1440}\u{1441}\
	\x03\x02\x02\x02\u{1441}\u{1442}\x07\u{1bd}\x02\x02\u{1442}\u{1444}\x03\
	\x02\x02\x02\u{1443}\u{1435}\x03\x02\x02\x02\u{1443}\u{1444}\x03\x02\x02\
	\x02\u{1444}\u{1446}\x03\x02\x02\x02\u{1445}\u{13dc}\x03\x02\x02\x02\u{1445}\
	\u{13de}\x03\x02\x02\x02\u{1445}\u{13e0}\x03\x02\x02\x02\u{1445}\u{13e7}\
	\x03\x02\x02\x02\u{1445}\u{13f9}\x03\x02\x02\x02\u{1445}\u{1400}\x03\x02\
	\x02\x02\u{1445}\u{140c}\x03\x02\x02\x02\u{1445}\u{141b}\x03\x02\x02\x02\
	\u{1445}\u{142a}\x03\x02\x02\x02\u{1445}\u{1434}\x03\x02\x02\x02\u{1446}\
	\u{137}\x03\x02\x02\x02\u{1447}\u{1448}\x05\u{164}\u{b3}\x02\u{1448}\u{1449}\
	\x05\u{134}\u{9b}\x02\u{1449}\u{139}\x03\x02\x02\x02\u{144a}\u{144d}\x07\
	\u{1d8}\x02\x02\u{144b}\u{144d}\x05\u{134}\u{9b}\x02\u{144c}\u{144a}\x03\
	\x02\x02\x02\u{144c}\u{144b}\x03\x02\x02\x02\u{144d}\u{13b}\x03\x02\x02\
	\x02\u{144e}\u{144f}\x07\u{1ae}\x02\x02\u{144f}\u{1450}\x05\u{f8}\x7d\x02\
	\u{1450}\u{1451}\x07\u{17f}\x02\x02\u{1451}\u{1452}\x05\u{f8}\x7d\x02\u{1452}\
	\u{13d}\x03\x02\x02\x02\u{1453}\u{1454}\x07\u{8c}\x02\x02\u{1454}\u{1455}\
	\x07\u{1bc}\x02\x02\u{1455}\u{1456}\x07\u{1af}\x02\x02\u{1456}\u{1457}\x05\
	\u{fa}\x7e\x02\u{1457}\u{1458}\x07\u{1bd}\x02\x02\u{1458}\u{13f}\x03\x02\
	\x02\x02\u{1459}\u{145f}\x07\u{113}\x02\x02\u{145a}\u{1460}\x05\u{164}\u{b3}\
	\x02\u{145b}\u{145c}\x07\u{1bc}\x02\x02\u{145c}\u{145d}\x05\u{82}\x42\x02\
	\u{145d}\u{145e}\x07\u{1bd}\x02\x02\u{145e}\u{1460}\x03\x02\x02\x02\u{145f}\
	\u{145a}\x03\x02\x02\x02\u{145f}\u{145b}\x03\x02\x02\x02\u{1460}\u{141}\
	\x03\x02\x02\x02\u{1461}\u{1462}\x07\u{ea}\x02\x02\u{1462}\u{1467}\x05\u{b4}\
	\x5b\x02\u{1463}\u{1464}\x07\x42\x02\x02\u{1464}\u{1466}\x05\u{b4}\x5b\x02\
	\u{1465}\u{1463}\x03\x02\x02\x02\u{1466}\u{1469}\x03\x02\x02\x02\u{1467}\
	\u{1465}\x03\x02\x02\x02\u{1467}\u{1468}\x03\x02\x02\x02\u{1468}\u{146b}\
	\x03\x02\x02\x02\u{1469}\u{1467}\x03\x02\x02\x02\u{146a}\u{146c}\x07\x42\
	\x02\x02\u{146b}\u{146a}\x03\x02\x02\x02\u{146b}\u{146c}\x03\x02\x02\x02\
	\u{146c}\u{146e}\x03\x02\x02\x02\u{146d}\u{1461}\x03\x02\x02\x02\u{146d}\
	\u{146e}\x03\x02\x02\x02\u{146e}\u{146f}\x03\x02\x02\x02\u{146f}\u{1473}\
	\x05\u{144}\u{a3}\x02\u{1470}\u{1471}\x07\x13\x02\x02\u{1471}\u{1472}\x07\
	\u{e3}\x02\x02\u{1472}\u{1474}\x05\u{ba}\x5e\x02\u{1473}\u{1470}\x03\x02\
	\x02\x02\u{1473}\u{1474}\x03\x02\x02\x02\u{1474}\u{1476}\x03\x02\x02\x02\
	\u{1475}\u{1477}\x09\x20\x02\x02\u{1476}\u{1475}\x03\x02\x02\x02\u{1476}\
	\u{1477}\x03\x02\x02\x02\u{1477}\u{147d}\x03\x02\x02\x02\u{1478}\u{1479}\
	\x07\u{11c}\x02\x02\u{1479}\u{147a}\x07\u{1bc}\x02\x02\u{147a}\u{147b}\x05\
	\u{148}\u{a5}\x02\u{147b}\u{147c}\x07\u{1bd}\x02\x02\u{147c}\u{147e}\x03\
	\x02\x02\x02\u{147d}\u{1478}\x03\x02\x02\x02\u{147d}\u{147e}\x03\x02\x02\
	\x02\u{147e}\u{148b}\x03\x02\x02\x02\u{147f}\u{1480}\x07\u{171}\x02\x02\
	\u{1480}\u{1485}\x05\u{bc}\x5f\x02\u{1481}\u{1482}\x07\x42\x02\x02\u{1482}\
	\u{1484}\x05\u{bc}\x5f\x02\u{1483}\u{1481}\x03\x02\x02\x02\u{1484}\u{1487}\
	\x03\x02\x02\x02\u{1485}\u{1483}\x03\x02\x02\x02\u{1485}\u{1486}\x03\x02\
	\x02\x02\u{1486}\u{1489}\x03\x02\x02\x02\u{1487}\u{1485}\x03\x02\x02\x02\
	\u{1488}\u{148a}\x07\x42\x02\x02\u{1489}\u{1488}\x03\x02\x02\x02\u{1489}\
	\u{148a}\x03\x02\x02\x02\u{148a}\u{148c}\x03\x02\x02\x02\u{148b}\u{147f}\
	\x03\x02\x02\x02\u{148b}\u{148c}\x03\x02\x02\x02\u{148c}\u{1499}\x03\x02\
	\x02\x02\u{148d}\u{148e}\x07\x5e\x02\x02\u{148e}\u{1493}\x05\u{be}\x60\x02\
	\u{148f}\u{1490}\x07\x42\x02\x02\u{1490}\u{1492}\x05\u{be}\x60\x02\u{1491}\
	\u{148f}\x03\x02\x02\x02\u{1492}\u{1495}\x03\x02\x02\x02\u{1493}\u{1491}\
	\x03\x02\x02\x02\u{1493}\u{1494}\x03\x02\x02\x02\u{1494}\u{1497}\x03\x02\
	\x02\x02\u{1495}\u{1493}\x03\x02\x02\x02\u{1496}\u{1498}\x07\x42\x02\x02\
	\u{1497}\u{1496}\x03\x02\x02\x02\u{1497}\u{1498}\x03\x02\x02\x02\u{1498}\
	\u{149a}\x03\x02\x02\x02\u{1499}\u{148d}\x03\x02\x02\x02\u{1499}\u{149a}\
	\x03\x02\x02\x02\u{149a}\u{143}\x03\x02\x02\x02\u{149b}\u{149c}\x07\u{132}\
	\x02\x02\u{149c}\u{14b4}\x05\u{146}\u{a4}\x02\u{149d}\u{149e}\x07\u{14d}\
	\x02\x02\u{149e}\u{14b4}\x05\u{146}\u{a4}\x02\u{149f}\u{14a0}\x07\u{a3}\
	\x02\x02\u{14a0}\u{14b4}\x05\u{146}\u{a4}\x02\u{14a1}\u{14a2}\x07\u{132}\
	\x02\x02\u{14a2}\u{14a3}\x07\x2a\x02\x02\u{14a3}\u{14a4}\x05\u{146}\u{a4}\
	\x02\u{14a4}\u{14a5}\x07\x17\x02\x02\u{14a5}\u{14a6}\x05\u{146}\u{a4}\x02\
	\u{14a6}\u{14b4}\x03\x02\x02\x02\u{14a7}\u{14a8}\x07\u{14d}\x02\x02\u{14a8}\
	\u{14a9}\x07\x2a\x02\x02\u{14a9}\u{14aa}\x05\u{146}\u{a4}\x02\u{14aa}\u{14ab}\
	\x07\x17\x02\x02\u{14ab}\u{14ac}\x05\u{146}\u{a4}\x02\u{14ac}\u{14b4}\x03\
	\x02\x02\x02\u{14ad}\u{14ae}\x07\u{a3}\x02\x02\u{14ae}\u{14af}\x07\x2a\x02\
	\x02\u{14af}\u{14b0}\x05\u{146}\u{a4}\x02\u{14b0}\u{14b1}\x07\x17\x02\x02\
	\u{14b1}\u{14b2}\x05\u{146}\u{a4}\x02\u{14b2}\u{14b4}\x03\x02\x02\x02\u{14b3}\
	\u{149b}\x03\x02\x02\x02\u{14b3}\u{149d}\x03\x02\x02\x02\u{14b3}\u{149f}\
	\x03\x02\x02\x02\u{14b3}\u{14a1}\x03\x02\x02\x02\u{14b3}\u{14a7}\x03\x02\
	\x02\x02\u{14b3}\u{14ad}\x03\x02\x02\x02\u{14b4}\u{145}\x03\x02\x02\x02\
	\u{14b5}\u{14b6}\x07\u{190}\x02\x02\u{14b6}\u{14bf}\x07\u{126}\x02\x02\u{14b7}\
	\u{14b8}\x07\u{190}\x02\x02\u{14b8}\u{14bf}\x07\u{91}\x02\x02\u{14b9}\u{14ba}\
	\x07\x53\x02\x02\u{14ba}\u{14bf}\x07\u{14c}\x02\x02\u{14bb}\u{14bc}\x05\
	\u{f8}\x7d\x02\u{14bc}\u{14bd}\x09\x31\x02\x02\u{14bd}\u{14bf}\x03\x02\x02\
	\x02\u{14be}\u{14b5}\x03\x02\x02\x02\u{14be}\u{14b7}\x03\x02\x02\x02\u{14be}\
	\u{14b9}\x03\x02\x02\x02\u{14be}\u{14bb}\x03\x02\x02\x02\u{14bf}\u{147}\
	\x03\x02\x02\x02\u{14c0}\u{14c1}\x08\u{a5}\x01\x02\u{14c1}\u{14c3}\x05\u{14a}\
	\u{a6}\x02\u{14c2}\u{14c4}\x05\u{14c}\u{a7}\x02\u{14c3}\u{14c2}\x03\x02\
	\x02\x02\u{14c3}\u{14c4}\x03\x02\x02\x02\u{14c4}\u{14cc}\x03\x02\x02\x02\
	\u{14c5}\u{14c6}\x0c\x04\x02\x02\u{14c6}\u{14cb}\x05\u{148}\u{a5}\x05\u{14c7}\
	\u{14c8}\x0c\x03\x02\x02\u{14c8}\u{14c9}\x07\x09\x02\x02\u{14c9}\u{14cb}\
	\x05\u{148}\u{a5}\x04\u{14ca}\u{14c5}\x03\x02\x02\x02\u{14ca}\u{14c7}\x03\
	\x02\x02\x02\u{14cb}\u{14ce}\x03\x02\x02\x02\u{14cc}\u{14ca}\x03\x02\x02\
	\x02\u{14cc}\u{14cd}\x03\x02\x02\x02\u{14cd}\u{149}\x03\x02\x02\x02\u{14ce}\
	\u{14cc}\x03\x02\x02\x02\u{14cf}\u{14ec}\x05\u{164}\u{b3}\x02\u{14d0}\u{14d1}\
	\x07\u{1bc}\x02\x02\u{14d1}\u{14ec}\x07\u{1bd}\x02\x02\u{14d2}\u{14d3}\x07\
	\u{121}\x02\x02\u{14d3}\u{14d4}\x07\u{1bc}\x02\x02\u{14d4}\u{14d9}\x05\u{148}\
	\u{a5}\x02\u{14d5}\u{14d6}\x07\x42\x02\x02\u{14d6}\u{14d8}\x05\u{148}\u{a5}\
	\x02\u{14d7}\u{14d5}\x03\x02\x02\x02\u{14d8}\u{14db}\x03\x02\x02\x02\u{14d9}\
	\u{14d7}\x03\x02\x02\x02\u{14d9}\u{14da}\x03\x02\x02\x02\u{14da}\u{14dd}\
	\x03\x02\x02\x02\u{14db}\u{14d9}\x03\x02\x02\x02\u{14dc}\u{14de}\x07\x42\
	\x02\x02\u{14dd}\u{14dc}\x03\x02\x02\x02\u{14dd}\u{14de}\x03\x02\x02\x02\
	\u{14de}\u{14df}\x03\x02\x02\x02\u{14df}\u{14e0}\x07\u{1bd}\x02\x02\u{14e0}\
	\u{14ec}\x03\x02\x02\x02\u{14e1}\u{14e2}\x07\u{1bc}\x02\x02\u{14e2}\u{14e3}\
	\x05\u{148}\u{a5}\x02\u{14e3}\u{14e4}\x07\u{1bd}\x02\x02\u{14e4}\u{14ec}\
	\x03\x02\x02\x02\u{14e5}\u{14ec}\x07\x0a\x02\x02\u{14e6}\u{14ec}\x07\u{1d0}\
	\x02\x02\u{14e7}\u{14e8}\x07\x0b\x02\x02\u{14e8}\u{14e9}\x05\u{148}\u{a5}\
	\x02\u{14e9}\u{14ea}\x07\x0c\x02\x02\u{14ea}\u{14ec}\x03\x02\x02\x02\u{14eb}\
	\u{14cf}\x03\x02\x02\x02\u{14eb}\u{14d0}\x03\x02\x02\x02\u{14eb}\u{14d2}\
	\x03\x02\x02\x02\u{14eb}\u{14e1}\x03\x02\x02\x02\u{14eb}\u{14e5}\x03\x02\
	\x02\x02\u{14eb}\u{14e6}\x03\x02\x02\x02\u{14eb}\u{14e7}\x03\x02\x02\x02\
	\u{14ec}\u{14b}\x03\x02\x02\x02\u{14ed}\u{14ef}\x07\u{1c9}\x02\x02\u{14ee}\
	\u{14f0}\x07\u{1cd}\x02\x02\u{14ef}\u{14ee}\x03\x02\x02\x02\u{14ef}\u{14f0}\
	\x03\x02\x02\x02\u{14f0}\u{150f}\x03\x02\x02\x02\u{14f1}\u{14f3}\x07\u{1c7}\
	\x02\x02\u{14f2}\u{14f4}\x07\u{1cd}\x02\x02\u{14f3}\u{14f2}\x03\x02\x02\
	\x02\u{14f3}\u{14f4}\x03\x02\x02\x02\u{14f4}\u{150f}\x03\x02\x02\x02\u{14f5}\
	\u{14f7}\x07\u{1cd}\x02\x02\u{14f6}\u{14f8}\x07\u{1cd}\x02\x02\u{14f7}\u{14f6}\
	\x03\x02\x02\x02\u{14f7}\u{14f8}\x03\x02\x02\x02\u{14f8}\u{150f}\x03\x02\
	\x02\x02\u{14f9}\u{14fa}\x07\x05\x02\x02\u{14fa}\u{14fb}\x07\u{1d8}\x02\
	\x02\u{14fb}\u{14fd}\x07\x06\x02\x02\u{14fc}\u{14fe}\x07\u{1cd}\x02\x02\
	\u{14fd}\u{14fc}\x03\x02\x02\x02\u{14fd}\u{14fe}\x03\x02\x02\x02\u{14fe}\
	\u{150f}\x03\x02\x02\x02\u{14ff}\u{1501}\x07\x05\x02\x02\u{1500}\u{1502}\
	\x07\u{1d8}\x02\x02\u{1501}\u{1500}\x03\x02\x02\x02\u{1501}\u{1502}\x03\
	\x02\x02\x02\u{1502}\u{1503}\x03\x02\x02\x02\u{1503}\u{1505}\x07\x42\x02\
	\x02\u{1504}\u{1506}\x07\u{1d8}\x02\x02\u{1505}\u{1504}\x03\x02\x02\x02\
	\u{1505}\u{1506}\x03\x02\x02\x02\u{1506}\u{1508}\x03\x02\x02\x02\u{1507}\
	\u{1509}\x07\x42\x02\x02\u{1508}\u{1507}\x03\x02\x02\x02\u{1508}\u{1509}\
	\x03\x02\x02\x02\u{1509}\u{150a}\x03\x02\x02\x02\u{150a}\u{150c}\x07\x06\
	\x02\x02\u{150b}\u{150d}\x07\u{1cd}\x02\x02\u{150c}\u{150b}\x03\x02\x02\
	\x02\u{150c}\u{150d}\x03\x02\x02\x02\u{150d}\u{150f}\x03\x02\x02\x02\u{150e}\
	\u{14ed}\x03\x02\x02\x02\u{150e}\u{14f1}\x03\x02\x02\x02\u{150e}\u{14f5}\
	\x03\x02\x02\x02\u{150e}\u{14f9}\x03\x02\x02\x02\u{150e}\u{14ff}\x03\x02\
	\x02\x02\u{150f}\u{14d}\x03\x02\x02\x02\u{1510}\u{1511}\x07\u{c1}\x02\x02\
	\u{1511}\u{1512}\x07\u{d7}\x02\x02\u{1512}\u{1516}\x05\u{150}\u{a9}\x02\
	\u{1513}\u{1514}\x07\u{133}\x02\x02\u{1514}\u{1516}\x09\x32\x02\x02\u{1515}\
	\u{1510}\x03\x02\x02\x02\u{1515}\u{1513}\x03\x02\x02\x02\u{1516}\u{14f}\
	\x03\x02\x02\x02\u{1517}\u{1518}\x07\u{133}\x02\x02\u{1518}\u{151f}\x07\
	\u{191}\x02\x02\u{1519}\u{151a}\x07\u{133}\x02\x02\u{151a}\u{151f}\x07\x45\
	\x02\x02\u{151b}\u{151c}\x07\u{13b}\x02\x02\u{151c}\u{151f}\x07\u{133}\x02\
	\x02\u{151d}\u{151f}\x07\u{15e}\x02\x02\u{151e}\u{1517}\x03\x02\x02\x02\
	\u{151e}\u{1519}\x03\x02\x02\x02\u{151e}\u{151b}\x03\x02\x02\x02\u{151e}\
	\u{151d}\x03\x02\x02\x02\u{151f}\u{151}\x03\x02\x02\x02\u{1520}\u{1521}\
	\x09\x33\x02\x02\u{1521}\u{153}\x03\x02\x02\x02\u{1522}\u{1527}\x05\u{164}\
	\u{b3}\x02\u{1523}\u{1524}\x07\u{1c0}\x02\x02\u{1524}\u{1526}\x05\u{16a}\
	\u{b6}\x02\u{1525}\u{1523}\x03\x02\x02\x02\u{1526}\u{1529}\x03\x02\x02\x02\
	\u{1527}\u{1525}\x03\x02\x02\x02\u{1527}\u{1528}\x03\x02\x02\x02\u{1528}\
	\u{1530}\x03\x02\x02\x02\u{1529}\u{1527}\x03\x02\x02\x02\u{152a}\u{152b}\
	\x07\u{a9}\x02\x02\u{152b}\u{152c}\x07\u{1bc}\x02\x02\u{152c}\u{152d}\x05\
	\u{122}\u{92}\x02\u{152d}\u{152e}\x07\u{1bd}\x02\x02\u{152e}\u{1530}\x03\
	\x02\x02\x02\u{152f}\u{1522}\x03\x02\x02\x02\u{152f}\u{152a}\x03\x02\x02\
	\x02\u{1530}\u{155}\x03\x02\x02\x02\u{1531}\u{1532}\x05\u{154}\u{ab}\x02\
	\u{1532}\u{157}\x03\x02\x02\x02\u{1533}\u{1536}\x07\u{1db}\x02\x02\u{1534}\
	\u{1536}\x05\u{17c}\u{bf}\x02\u{1535}\u{1533}\x03\x02\x02\x02\u{1535}\u{1534}\
	\x03\x02\x02\x02\u{1536}\u{159}\x03\x02\x02\x02\u{1537}\u{1538}\x08\u{ae}\
	\x01\x02\u{1538}\u{1539}\x05\u{158}\u{ad}\x02\u{1539}\u{153a}\x07\u{1c8}\
	\x02\x02\u{153a}\u{153b}\x05\u{158}\u{ad}\x02\u{153b}\u{1546}\x03\x02\x02\
	\x02\u{153c}\u{153d}\x05\u{158}\u{ad}\x02\u{153d}\u{153e}\x07\u{1c8}\x02\
	\x02\u{153e}\u{153f}\x07\u{1d8}\x02\x02\u{153f}\u{1546}\x03\x02\x02\x02\
	\u{1540}\u{1541}\x05\u{158}\u{ad}\x02\u{1541}\u{1542}\x07\u{1c8}\x02\x02\
	\u{1542}\u{1543}\x07\u{1d9}\x02\x02\u{1543}\u{1544}\x05\u{158}\u{ad}\x02\
	\u{1544}\u{1546}\x03\x02\x02\x02\u{1545}\u{1537}\x03\x02\x02\x02\u{1545}\
	\u{153c}\x03\x02\x02\x02\u{1545}\u{1540}\x03\x02\x02\x02\u{1546}\u{1553}\
	\x03\x02\x02\x02\u{1547}\u{1548}\x0c\x07\x02\x02\u{1548}\u{1549}\x07\u{1c8}\
	\x02\x02\u{1549}\u{1552}\x05\u{158}\u{ad}\x02\u{154a}\u{154b}\x0c\x05\x02\
	\x02\u{154b}\u{154c}\x07\u{1c8}\x02\x02\u{154c}\u{1552}\x07\u{1d8}\x02\x02\
	\u{154d}\u{154e}\x0c\x03\x02\x02\u{154e}\u{154f}\x07\u{1c8}\x02\x02\u{154f}\
	\u{1550}\x07\u{1d9}\x02\x02\u{1550}\u{1552}\x05\u{158}\u{ad}\x02\u{1551}\
	\u{1547}\x03\x02\x02\x02\u{1551}\u{154a}\x03\x02\x02\x02\u{1551}\u{154d}\
	\x03\x02\x02\x02\u{1552}\u{1555}\x03\x02\x02\x02\u{1553}\u{1551}\x03\x02\
	\x02\x02\u{1553}\u{1554}\x03\x02\x02\x02\u{1554}\u{15b}\x03\x02\x02\x02\
	\u{1555}\u{1553}\x03\x02\x02\x02\u{1556}\u{1559}\x05\u{158}\u{ad}\x02\u{1557}\
	\u{1559}\x05\u{15a}\u{ae}\x02\u{1558}\u{1556}\x03\x02\x02\x02\u{1558}\u{1557}\
	\x03\x02\x02\x02\u{1559}\u{15d}\x03\x02\x02\x02\u{155a}\u{155b}\x07\u{92}\
	\x02\x02\u{155b}\u{155c}\x05\u{160}\u{b1}\x02\u{155c}\u{155d}\x07\x1e\x02\
	\x02\u{155d}\u{155e}\x07\u{105}\x02\x02\u{155e}\u{155f}\x05\u{102}\u{82}\
	\x02\u{155f}\u{15f}\x03\x02\x02\x02\u{1560}\u{1561}\x09\x34\x02\x02\u{1561}\
	\u{161}\x03\x02\x02\x02\u{1562}\u{1568}\x05\u{164}\u{b3}\x02\u{1563}\u{1564}\
	\x07\u{19e}\x02\x02\u{1564}\u{1568}\x05\u{164}\u{b3}\x02\u{1565}\u{1566}\
	\x07\u{148}\x02\x02\u{1566}\u{1568}\x05\u{164}\u{b3}\x02\u{1567}\u{1562}\
	\x03\x02\x02\x02\u{1567}\u{1563}\x03\x02\x02\x02\u{1567}\u{1565}\x03\x02\
	\x02\x02\u{1568}\u{163}\x03\x02\x02\x02\u{1569}\u{156c}\x05\u{166}\u{b4}\
	\x02\u{156a}\u{156c}\x05\u{17a}\u{be}\x02\u{156b}\u{1569}\x03\x02\x02\x02\
	\u{156b}\u{156a}\x03\x02\x02\x02\u{156c}\u{165}\x03\x02\x02\x02\u{156d}\
	\u{1572}\x07\u{1db}\x02\x02\u{156e}\u{1572}\x05\u{168}\u{b5}\x02\u{156f}\
	\u{1572}\x05\u{17c}\u{bf}\x02\u{1570}\u{1572}\x07\u{1dd}\x02\x02\u{1571}\
	\u{156d}\x03\x02\x02\x02\u{1571}\u{156e}\x03\x02\x02\x02\u{1571}\u{156f}\
	\x03\x02\x02\x02\u{1571}\u{1570}\x03\x02\x02\x02\u{1572}\u{167}\x03\x02\
	\x02\x02\u{1573}\u{1574}\x07\u{1dc}\x02\x02\u{1574}\u{169}\x03\x02\x02\x02\
	\u{1575}\u{1576}\x05\u{164}\u{b3}\x02\u{1576}\u{16b}\x03\x02\x02\x02\u{1577}\
	\u{1578}\x05\u{164}\u{b3}\x02\u{1578}\u{1579}\x07\x02\x02\x03\u{1579}\u{16d}\
	\x03\x02\x02\x02\u{157a}\u{157b}\x07\u{1bc}\x02\x02\u{157b}\u{157c}\x05\
	\u{170}\u{b9}\x02\u{157c}\u{157d}\x07\u{1bd}\x02\x02\u{157d}\u{16f}\x03\
	\x02\x02\x02\u{157e}\u{1583}\x05\u{164}\u{b3}\x02\u{157f}\u{1580}\x07\x42\
	\x02\x02\u{1580}\u{1582}\x05\u{164}\u{b3}\x02\u{1581}\u{157f}\x03\x02\x02\
	\x02\u{1582}\u{1585}\x03\x02\x02\x02\u{1583}\u{1581}\x03\x02\x02\x02\u{1583}\
	\u{1584}\x03\x02\x02\x02\u{1584}\u{171}\x03\x02\x02\x02\u{1585}\u{1583}\
	\x03\x02\x02\x02\u{1586}\u{1588}\x07\u{1c8}\x02\x02\u{1587}\u{1586}\x03\
	\x02\x02\x02\u{1587}\u{1588}\x03\x02\x02\x02\u{1588}\u{1589}\x03\x02\x02\
	\x02\u{1589}\u{1593}\x07\u{1d9}\x02\x02\u{158a}\u{158c}\x07\u{1c8}\x02\x02\
	\u{158b}\u{158a}\x03\x02\x02\x02\u{158b}\u{158c}\x03\x02\x02\x02\u{158c}\
	\u{158d}\x03\x02\x02\x02\u{158d}\u{1593}\x07\u{1da}\x02\x02\u{158e}\u{1590}\
	\x07\u{1c8}\x02\x02\u{158f}\u{158e}\x03\x02\x02\x02\u{158f}\u{1590}\x03\
	\x02\x02\x02\u{1590}\u{1591}\x03\x02\x02\x02\u{1591}\u{1593}\x07\u{1d8}\
	\x02\x02\u{1592}\u{1587}\x03\x02\x02\x02\u{1592}\u{158b}\x03\x02\x02\x02\
	\u{1592}\u{158f}\x03\x02\x02\x02\u{1593}\u{173}\x03\x02\x02\x02\u{1594}\
	\u{15b1}\x07\x19\x02\x02\u{1595}\u{1596}\x07\u{14c}\x02\x02\u{1596}\u{1597}\
	\x07\u{1bc}\x02\x02\u{1597}\u{1598}\x05\u{174}\u{bb}\x02\u{1598}\u{1599}\
	\x07\u{1bd}\x02\x02\u{1599}\u{15b1}\x03\x02\x02\x02\u{159a}\u{159b}\x07\
	\u{104}\x02\x02\u{159b}\u{159c}\x07\u{1bc}\x02\x02\u{159c}\u{159d}\x05\u{164}\
	\u{b3}\x02\u{159d}\u{159e}\x05\u{174}\u{bb}\x02\u{159e}\u{159f}\x07\u{1bd}\
	\x02\x02\u{159f}\u{15b1}\x03\x02\x02\x02\u{15a0}\u{15a1}\x07\u{e1}\x02\x02\
	\u{15a1}\u{15a2}\x07\u{1bc}\x02\x02\u{15a2}\u{15a3}\x05\u{174}\u{bb}\x02\
	\u{15a3}\u{15a4}\x07\x42\x02\x02\u{15a4}\u{15a5}\x05\u{174}\u{bb}\x02\u{15a5}\
	\u{15a6}\x07\u{1bd}\x02\x02\u{15a6}\u{15b1}\x03\x02\x02\x02\u{15a7}\u{15a8}\
	\x07\u{1a8}\x02\x02\u{15a8}\u{15a9}\x07\u{1bc}\x02\x02\u{15a9}\u{15aa}\x05\
	\u{174}\u{bb}\x02\u{15aa}\u{15ab}\x07\x42\x02\x02\u{15ab}\u{15ac}\x05\u{172}\
	\u{ba}\x02\u{15ac}\u{15ad}\x07\u{1bd}\x02\x02\u{15ad}\u{15b1}\x03\x02\x02\
	\x02\u{15ae}\u{15b1}\x07\u{90}\x02\x02\u{15af}\u{15b1}\x05\u{134}\u{9b}\
	\x02\u{15b0}\u{1594}\x03\x02\x02\x02\u{15b0}\u{1595}\x03\x02\x02\x02\u{15b0}\
	\u{159a}\x03\x02\x02\x02\u{15b0}\u{15a0}\x03\x02\x02\x02\u{15b0}\u{15a7}\
	\x03\x02\x02\x02\u{15b0}\u{15ae}\x03\x02\x02\x02\u{15b0}\u{15af}\x03\x02\
	\x02\x02\u{15b1}\u{175}\x03\x02\x02\x02\u{15b2}\u{15b3}\x05\u{116}\u{8c}\
	\x02\u{15b3}\u{15b9}\x07\u{1bc}\x02\x02\u{15b4}\u{15ba}\x05\u{174}\u{bb}\
	\x02\u{15b5}\u{15b6}\x07\u{1be}\x02\x02\u{15b6}\u{15b7}\x05\u{174}\u{bb}\
	\x02\u{15b7}\u{15b8}\x07\u{1bf}\x02\x02\u{15b8}\u{15ba}\x03\x02\x02\x02\
	\u{15b9}\u{15b4}\x03\x02\x02\x02\u{15b9}\u{15b5}\x03\x02\x02\x02\u{15b9}\
	\u{15ba}\x03\x02\x02\x02\u{15ba}\u{15c3}\x03\x02\x02\x02\u{15bb}\u{15bc}\
	\x07\x42\x02\x02\u{15bc}\u{15c2}\x05\u{174}\u{bb}\x02\u{15bd}\u{15be}\x07\
	\x0d\x02\x02\u{15be}\u{15bf}\x05\u{174}\u{bb}\x02\u{15bf}\u{15c0}\x07\u{1bf}\
	\x02\x02\u{15c0}\u{15c2}\x03\x02\x02\x02\u{15c1}\u{15bb}\x03\x02\x02\x02\
	\u{15c1}\u{15bd}\x03\x02\x02\x02\u{15c2}\u{15c5}\x03\x02\x02\x02\u{15c3}\
	\u{15c1}\x03\x02\x02\x02\u{15c3}\u{15c4}\x03\x02\x02\x02\u{15c4}\u{15c6}\
	\x03\x02\x02\x02\u{15c5}\u{15c3}\x03\x02\x02\x02\u{15c6}\u{15c7}\x07\u{1bd}\
	\x02\x02\u{15c7}\u{15c8}\x07\u{141}\x02\x02\u{15c8}\u{15c9}\x05\u{174}\u{bb}\
	\x02\u{15c9}\u{177}\x03\x02\x02\x02\u{15ca}\u{15cf}\x05\u{176}\u{bc}\x02\
	\u{15cb}\u{15cc}\x07\x42\x02\x02\u{15cc}\u{15ce}\x05\u{176}\u{bc}\x02\u{15cd}\
	\u{15cb}\x03\x02\x02\x02\u{15ce}\u{15d1}\x03\x02\x02\x02\u{15cf}\u{15cd}\
	\x03\x02\x02\x02\u{15cf}\u{15d0}\x03\x02\x02\x02\u{15d0}\u{179}\x03\x02\
	\x02\x02\u{15d1}\u{15cf}\x03\x02\x02\x02\u{15d2}\u{15d3}\x09\x35\x02\x02\
	\u{15d3}\u{17b}\x03\x02\x02\x02\u{15d4}\u{15d5}\x09\x36\x02\x02\u{15d5}\
	\u{17d}\x03\x02\x02\x02\u{306}\u{17f}\u{183}\u{187}\u{18d}\u{190}\u{1a9}\
	\u{1af}\u{1c9}\u{1d0}\u{1d6}\u{1de}\u{1e2}\u{1e6}\u{1e9}\u{1f0}\u{1f3}\u{1f6}\
	\u{1fc}\u{202}\u{206}\u{20f}\u{212}\u{218}\u{228}\u{22c}\u{230}\u{235}\u{23c}\
	\u{24c}\u{250}\u{256}\u{25b}\u{260}\u{267}\u{277}\u{27b}\u{280}\u{287}\u{297}\
	\u{29b}\u{29f}\u{2a7}\u{2ab}\u{2af}\u{2b3}\u{2bb}\u{2c0}\u{2c3}\u{2c6}\u{2cc}\
	\u{2d2}\u{2dd}\u{2eb}\u{2f4}\u{2f8}\u{2fa}\u{2ff}\u{302}\u{309}\u{30f}\u{313}\
	\u{31b}\u{31f}\u{323}\u{328}\u{32b}\u{338}\u{33d}\u{340}\u{344}\u{34e}\u{353}\
	\u{35d}\u{360}\u{363}\u{366}\u{369}\u{36f}\u{375}\u{37d}\u{381}\u{385}\u{388}\
	\u{395}\u{39a}\u{39d}\u{3a1}\u{3a5}\u{3aa}\u{3b2}\u{3bd}\u{3c8}\u{3d3}\u{3d6}\
	\u{3dc}\u{3e2}\u{3e7}\u{3eb}\u{3ef}\u{3f4}\u{3f7}\u{3fa}\u{400}\u{406}\u{40e}\
	\u{412}\u{414}\u{419}\u{427}\u{42b}\u{42f}\u{432}\u{435}\u{443}\u{446}\u{44b}\
	\u{454}\u{457}\u{45a}\u{460}\u{466}\u{46e}\u{472}\u{474}\u{479}\u{487}\u{48b}\
	\u{48f}\u{492}\u{495}\u{4a3}\u{4a6}\u{4ab}\u{4b1}\u{4b4}\u{4b7}\u{4bd}\u{4c3}\
	\u{4cb}\u{4cf}\u{4d1}\u{4d6}\u{4e4}\u{4e8}\u{4ec}\u{4ef}\u{4f2}\u{500}\u{503}\
	\u{508}\u{511}\u{514}\u{517}\u{51d}\u{523}\u{52b}\u{52f}\u{531}\u{536}\u{544}\
	\u{548}\u{54c}\u{54f}\u{552}\u{560}\u{563}\u{568}\u{571}\u{574}\u{577}\u{57d}\
	\u{583}\u{58b}\u{58f}\u{591}\u{596}\u{5a4}\u{5a8}\u{5ac}\u{5af}\u{5b2}\u{5c0}\
	\u{5c3}\u{5c8}\u{5ce}\u{5d1}\u{5d4}\u{5da}\u{5e0}\u{5e8}\u{5ec}\u{5ee}\u{5f3}\
	\u{5f8}\u{5fb}\u{609}\u{60c}\u{611}\u{61a}\u{61d}\u{620}\u{626}\u{62c}\u{634}\
	\u{638}\u{63a}\u{63f}\u{644}\u{647}\u{655}\u{658}\u{65d}\u{663}\u{666}\u{669}\
	\u{673}\u{677}\u{679}\u{67e}\u{68c}\u{690}\u{694}\u{697}\u{69a}\u{69e}\u{6a1}\
	\u{6a4}\u{6a9}\u{6b2}\u{6b5}\u{6b8}\u{6c2}\u{6c6}\u{6c8}\u{6cd}\u{6db}\u{6df}\
	\u{6e3}\u{6e6}\u{6e9}\u{6f0}\u{6f5}\u{701}\u{705}\u{707}\u{716}\u{71a}\u{71e}\
	\u{721}\u{724}\u{72b}\u{734}\u{736}\u{742}\u{745}\u{748}\u{74b}\u{750}\u{758}\
	\u{75f}\u{766}\u{76d}\u{773}\u{779}\u{77f}\u{785}\u{78b}\u{792}\u{798}\u{79e}\
	\u{7a5}\u{7ac}\u{7b3}\u{7ba}\u{7c1}\u{7cc}\u{7d4}\u{7dc}\u{7e3}\u{7ed}\u{7f4}\
	\u{7fc}\u{820}\u{823}\u{826}\u{829}\u{82d}\u{833}\u{83f}\u{860}\u{868}\u{86f}\
	\u{876}\u{87f}\u{883}\u{887}\u{88b}\u{894}\u{89b}\u{8a2}\u{8ac}\u{8b0}\u{8b2}\
	\u{8b8}\u{8bf}\u{8c6}\u{8cd}\u{8d4}\u{8e1}\u{8e4}\u{8eb}\u{8f9}\u{902}\u{90f}\
	\u{915}\u{919}\u{91b}\u{920}\u{924}\u{929}\u{92d}\u{930}\u{935}\u{937}\u{93c}\
	\u{93f}\u{942}\u{945}\u{949}\u{94c}\u{94f}\u{952}\u{95a}\u{95e}\u{964}\u{96c}\
	\u{978}\u{97c}\u{97e}\u{982}\u{99c}\u{9a2}\u{9a9}\u{9ae}\u{9b2}\u{9b6}\u{9ba}\
	\u{9c8}\u{9cb}\u{9cd}\u{9cf}\u{9d2}\u{9de}\u{9e3}\u{9e5}\u{9e8}\u{9ec}\u{9f0}\
	\u{9f4}\u{9fb}\u{a03}\u{a05}\u{a0b}\u{a0f}\u{a13}\u{a21}\u{a24}\u{a26}\u{a28}\
	\u{a2b}\u{a37}\u{a3c}\u{a3e}\u{a41}\u{a45}\u{a49}\u{a4f}\u{a5a}\u{a5d}\u{a64}\
	\u{a68}\u{a72}\u{a7b}\u{a7f}\u{a87}\u{a90}\u{a97}\u{aa0}\u{aa5}\u{aa7}\u{aab}\
	\u{aaf}\u{ab2}\u{ab4}\u{ab8}\u{abf}\u{acb}\u{ad0}\u{ad4}\u{ad8}\u{ada}\u{ae2}\
	\u{ae7}\u{af1}\u{af5}\u{afe}\u{b02}\u{b06}\u{b0d}\u{b10}\u{b19}\u{b1d}\u{b1f}\
	\u{b23}\u{b26}\u{b29}\u{b2d}\u{b31}\u{b36}\u{b3f}\u{b44}\u{b4d}\u{b51}\u{b59}\
	\u{b60}\u{b64}\u{b66}\u{b6f}\u{b73}\u{b75}\u{b7f}\u{b83}\u{b85}\u{b90}\u{b94}\
	\u{b99}\u{ba1}\u{ba4}\u{ba7}\u{bab}\u{bb4}\u{bb7}\u{bba}\u{bbd}\u{bc6}\u{bca}\
	\u{bd3}\u{bd7}\u{bdb}\u{be5}\u{bea}\u{bed}\u{bf0}\u{bf5}\u{bfa}\u{bfc}\u{c05}\
	\u{c0a}\u{c1c}\u{c21}\u{c23}\u{c2a}\u{c39}\u{c3f}\u{c46}\u{c51}\u{c53}\u{c55}\
	\u{c59}\u{c5d}\u{c61}\u{c65}\u{c67}\u{c72}\u{c76}\u{c7a}\u{c86}\u{c8a}\u{c8e}\
	\u{c92}\u{c94}\u{c9c}\u{ca0}\u{ca3}\u{ca7}\u{ca9}\u{cab}\u{caf}\u{cb5}\u{cba}\
	\u{cbe}\u{cc5}\u{cc7}\u{cd8}\u{cdb}\u{ce1}\u{cef}\u{cf3}\u{cf5}\u{cfe}\u{d02}\
	\u{d04}\u{d0c}\u{d10}\u{d12}\u{d15}\u{d1a}\u{d1d}\u{d29}\u{d2d}\u{d2f}\u{d37}\
	\u{d3b}\u{d3f}\u{d4e}\u{d50}\u{d5b}\u{d70}\u{d7a}\u{d7e}\u{d94}\u{d9f}\u{da6}\
	\u{daa}\u{dbe}\u{dc2}\u{dc4}\u{dcc}\u{dd2}\u{dd9}\u{ddc}\u{dde}\u{de9}\u{dec}\
	\u{dee}\u{dfd}\u{e01}\u{e0a}\u{e0e}\u{e12}\u{e15}\u{e25}\u{e2c}\u{e34}\u{e37}\
	\u{e39}\u{e3e}\u{e48}\u{e56}\u{e5a}\u{e5e}\u{e67}\u{e6b}\u{e6f}\u{e79}\u{e89}\
	\u{e8d}\u{e8f}\u{e92}\u{e96}\u{e9d}\u{ea1}\u{ea5}\u{ead}\u{eb1}\u{eb6}\u{ebb}\
	\u{ec0}\u{ecb}\u{ecf}\u{ed1}\u{ed5}\u{ed7}\u{edf}\u{ee9}\u{eed}\u{ef2}\u{ef4}\
	\u{efb}\u{eff}\u{f01}\u{f08}\u{f0c}\u{f0e}\u{f10}\u{f19}\u{f1d}\u{f27}\u{f2b}\
	\u{f35}\u{f39}\u{f43}\u{f4d}\u{f4f}\u{f56}\u{f5e}\u{f62}\u{f65}\u{f6d}\u{f76}\
	\u{f7a}\u{f7f}\u{f8b}\u{f90}\u{f95}\u{f9a}\u{fa0}\u{fa3}\u{faa}\u{fae}\u{fb3}\
	\u{fba}\u{fbd}\u{fc2}\u{fc6}\u{fd7}\u{fd9}\u{fe9}\u{fec}\u{ff5}\u{ff8}\u{1003}\
	\u{1012}\u{1017}\u{101a}\u{1027}\u{102b}\u{102f}\u{103a}\u{103d}\u{1040}\
	\u{104c}\u{1050}\u{1058}\u{105c}\u{1071}\u{1074}\u{107f}\u{1082}\u{1084}\
	\u{108f}\u{1098}\u{109b}\u{10c0}\u{10c3}\u{10cf}\u{10d6}\u{10d9}\u{10dd}\
	\u{10e0}\u{10ea}\u{10f2}\u{10f7}\u{10fb}\u{10fe}\u{1101}\u{111e}\u{1122}\
	\u{1124}\u{112b}\u{1139}\u{113c}\u{113f}\u{1142}\u{1145}\u{1152}\u{115e}\
	\u{1161}\u{1164}\u{1171}\u{117d}\u{1180}\u{1183}\u{118a}\u{118f}\u{119d}\
	\u{119f}\u{11a3}\u{11a6}\u{11a9}\u{11ac}\u{11ba}\u{11be}\u{11c7}\u{11ca}\
	\u{11d8}\u{11df}\u{11e8}\u{11eb}\u{11f3}\u{137f}\u{1392}\u{1398}\u{139e}\
	\u{13a3}\u{13a8}\u{13b0}\u{13b6}\u{13b9}\u{13c1}\u{13cc}\u{13d7}\u{13da}\
	\u{13e5}\u{13eb}\u{13ed}\u{13f1}\u{13f7}\u{13fe}\u{1407}\u{1413}\u{1417}\
	\u{1422}\u{1426}\u{1430}\u{143b}\u{143f}\u{1443}\u{1445}\u{144c}\u{145f}\
	\u{1467}\u{146b}\u{146d}\u{1473}\u{1476}\u{147d}\u{1485}\u{1489}\u{148b}\
	\u{1493}\u{1497}\u{1499}\u{14b3}\u{14be}\u{14c3}\u{14ca}\u{14cc}\u{14d9}\
	\u{14dd}\u{14eb}\u{14ef}\u{14f3}\u{14f7}\u{14fd}\u{1501}\u{1505}\u{1508}\
	\u{150c}\u{150e}\u{1515}\u{151e}\u{1527}\u{152f}\u{1535}\u{1545}\u{1551}\
	\u{1553}\u{1558}\u{1567}\u{156b}\u{1571}\u{1583}\u{1587}\u{158b}\u{158f}\
	\u{1592}\u{15b0}\u{15b9}\u{15c1}\u{15c3}\u{15cf}";

